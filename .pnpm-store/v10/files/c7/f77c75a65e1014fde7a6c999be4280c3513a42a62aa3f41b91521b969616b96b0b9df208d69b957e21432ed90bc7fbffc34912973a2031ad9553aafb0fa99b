var Wr = Object.defineProperty;
var Ur = (t) => {
  throw TypeError(t);
};
var Vr = (t, e, n) => e in t ? Wr(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var qr = (t, e, n) => Vr(t, typeof e != "symbol" ? e + "" : e, n), jr = (t, e, n) => e.has(t) || Ur("Cannot " + n);
var tr = (t, e, n) => (jr(t, e, "read from private field"), n ? n.call(t) : e.get(t)), ir = (t, e, n) => e.has(t) ? Ur("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, n), Br = (t, e, n, a) => (jr(t, e, "write to private field"), a ? a.call(t, n) : e.set(t, n), n), Dr = (t, e, n) => (jr(t, e, "access private method"), n);
import { canSerialize, serialize, deserialize } from "@nhtio/web-serialization";
import { R as RuntimeException, y, E as E_MISSING_APP_KEY, a as E_INSECURE_APP_KEY } from "./errors-gBU8_uEB.mjs";
import { e as rt } from "./errors-gBU8_uEB.mjs";
var buffer$1 = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i)
  lookup[i] = code[i], revLookup[code.charCodeAt(i)] = i;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(t) {
  var e = t.length;
  if (e % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n = t.indexOf("=");
  n === -1 && (n = e);
  var a = n === e ? 0 : 4 - n % 4;
  return [n, a];
}
function byteLength(t) {
  var e = getLens(t), n = e[0], a = e[1];
  return (n + a) * 3 / 4 - a;
}
function _byteLength(t, e, n) {
  return (e + n) * 3 / 4 - n;
}
function toByteArray(t) {
  var e, n = getLens(t), a = n[0], u = n[1], o = new Arr(_byteLength(t, a, u)), d = 0, l = u > 0 ? a - 4 : a, _;
  for (_ = 0; _ < l; _ += 4)
    e = revLookup[t.charCodeAt(_)] << 18 | revLookup[t.charCodeAt(_ + 1)] << 12 | revLookup[t.charCodeAt(_ + 2)] << 6 | revLookup[t.charCodeAt(_ + 3)], o[d++] = e >> 16 & 255, o[d++] = e >> 8 & 255, o[d++] = e & 255;
  return u === 2 && (e = revLookup[t.charCodeAt(_)] << 2 | revLookup[t.charCodeAt(_ + 1)] >> 4, o[d++] = e & 255), u === 1 && (e = revLookup[t.charCodeAt(_)] << 10 | revLookup[t.charCodeAt(_ + 1)] << 4 | revLookup[t.charCodeAt(_ + 2)] >> 2, o[d++] = e >> 8 & 255, o[d++] = e & 255), o;
}
function tripletToBase64(t) {
  return lookup[t >> 18 & 63] + lookup[t >> 12 & 63] + lookup[t >> 6 & 63] + lookup[t & 63];
}
function encodeChunk(t, e, n) {
  for (var a, u = [], o = e; o < n; o += 3)
    a = (t[o] << 16 & 16711680) + (t[o + 1] << 8 & 65280) + (t[o + 2] & 255), u.push(tripletToBase64(a));
  return u.join("");
}
function fromByteArray(t) {
  for (var e, n = t.length, a = n % 3, u = [], o = 16383, d = 0, l = n - a; d < l; d += o)
    u.push(encodeChunk(t, d, d + o > l ? l : d + o));
  return a === 1 ? (e = t[n - 1], u.push(
    lookup[e >> 2] + lookup[e << 4 & 63] + "=="
  )) : a === 2 && (e = (t[n - 2] << 8) + t[n - 1], u.push(
    lookup[e >> 10] + lookup[e >> 4 & 63] + lookup[e << 2 & 63] + "="
  )), u.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(t, e, n, a, u) {
  var o, d, l = u * 8 - a - 1, _ = (1 << l) - 1, P = _ >> 1, h = -7, x = n ? u - 1 : 0, C = n ? -1 : 1, D = t[e + x];
  for (x += C, o = D & (1 << -h) - 1, D >>= -h, h += l; h > 0; o = o * 256 + t[e + x], x += C, h -= 8)
    ;
  for (d = o & (1 << -h) - 1, o >>= -h, h += a; h > 0; d = d * 256 + t[e + x], x += C, h -= 8)
    ;
  if (o === 0)
    o = 1 - P;
  else {
    if (o === _)
      return d ? NaN : (D ? -1 : 1) * (1 / 0);
    d = d + Math.pow(2, a), o = o - P;
  }
  return (D ? -1 : 1) * d * Math.pow(2, o - a);
};
ieee754.write = function(t, e, n, a, u, o) {
  var d, l, _, P = o * 8 - u - 1, h = (1 << P) - 1, x = h >> 1, C = u === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, D = a ? 0 : o - 1, q = a ? 1 : -1, H = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (l = isNaN(e) ? 1 : 0, d = h) : (d = Math.floor(Math.log(e) / Math.LN2), e * (_ = Math.pow(2, -d)) < 1 && (d--, _ *= 2), d + x >= 1 ? e += C / _ : e += C * Math.pow(2, 1 - x), e * _ >= 2 && (d++, _ /= 2), d + x >= h ? (l = 0, d = h) : d + x >= 1 ? (l = (e * _ - 1) * Math.pow(2, u), d = d + x) : (l = e * Math.pow(2, x - 1) * Math.pow(2, u), d = 0)); u >= 8; t[n + D] = l & 255, D += q, l /= 256, u -= 8)
    ;
  for (d = d << u | l, P += u; P > 0; t[n + D] = d & 255, D += q, d /= 256, P -= 8)
    ;
  t[n + D - q] |= H * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(t) {
  const e = base64Js, n = ieee754, a = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  t.Buffer = h, t.SlowBuffer = se, t.INSPECT_MAX_BYTES = 50;
  const u = 2147483647;
  t.kMaxLength = u;
  const { Uint8Array: o, ArrayBuffer: d, SharedArrayBuffer: l } = globalThis;
  h.TYPED_ARRAY_SUPPORT = _(), !h.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function _() {
    try {
      const N = new o(1), E = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(E, o.prototype), Object.setPrototypeOf(N, E), N.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(h.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (h.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(h.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (h.isBuffer(this))
        return this.byteOffset;
    }
  });
  function P(N) {
    if (N > u)
      throw new RangeError('The value "' + N + '" is invalid for option "size"');
    const E = new o(N);
    return Object.setPrototypeOf(E, h.prototype), E;
  }
  function h(N, E, I) {
    if (typeof N == "number") {
      if (typeof E == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return q(N);
    }
    return x(N, E, I);
  }
  h.poolSize = 8192;
  function x(N, E, I) {
    if (typeof N == "string")
      return H(N, E);
    if (d.isView(N))
      return z(N);
    if (N == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof N
      );
    if (Me(N, d) || N && Me(N.buffer, d) || typeof l < "u" && (Me(N, l) || N && Me(N.buffer, l)))
      return F(N, E, I);
    if (typeof N == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const U = N.valueOf && N.valueOf();
    if (U != null && U !== N)
      return h.from(U, E, I);
    const re = X(N);
    if (re) return re;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof N[Symbol.toPrimitive] == "function")
      return h.from(N[Symbol.toPrimitive]("string"), E, I);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof N
    );
  }
  h.from = function(N, E, I) {
    return x(N, E, I);
  }, Object.setPrototypeOf(h.prototype, o.prototype), Object.setPrototypeOf(h, o);
  function C(N) {
    if (typeof N != "number")
      throw new TypeError('"size" argument must be of type number');
    if (N < 0)
      throw new RangeError('The value "' + N + '" is invalid for option "size"');
  }
  function D(N, E, I) {
    return C(N), N <= 0 ? P(N) : E !== void 0 ? typeof I == "string" ? P(N).fill(E, I) : P(N).fill(E) : P(N);
  }
  h.alloc = function(N, E, I) {
    return D(N, E, I);
  };
  function q(N) {
    return C(N), P(N < 0 ? 0 : ee(N) | 0);
  }
  h.allocUnsafe = function(N) {
    return q(N);
  }, h.allocUnsafeSlow = function(N) {
    return q(N);
  };
  function H(N, E) {
    if ((typeof E != "string" || E === "") && (E = "utf8"), !h.isEncoding(E))
      throw new TypeError("Unknown encoding: " + E);
    const I = ce(N, E) | 0;
    let U = P(I);
    const re = U.write(N, E);
    return re !== I && (U = U.slice(0, re)), U;
  }
  function Y(N) {
    const E = N.length < 0 ? 0 : ee(N.length) | 0, I = P(E);
    for (let U = 0; U < E; U += 1)
      I[U] = N[U] & 255;
    return I;
  }
  function z(N) {
    if (Me(N, o)) {
      const E = new o(N);
      return F(E.buffer, E.byteOffset, E.byteLength);
    }
    return Y(N);
  }
  function F(N, E, I) {
    if (E < 0 || N.byteLength < E)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (N.byteLength < E + (I || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let U;
    return E === void 0 && I === void 0 ? U = new o(N) : I === void 0 ? U = new o(N, E) : U = new o(N, E, I), Object.setPrototypeOf(U, h.prototype), U;
  }
  function X(N) {
    if (h.isBuffer(N)) {
      const E = ee(N.length) | 0, I = P(E);
      return I.length === 0 || N.copy(I, 0, 0, E), I;
    }
    if (N.length !== void 0)
      return typeof N.length != "number" || qe(N.length) ? P(0) : Y(N);
    if (N.type === "Buffer" && Array.isArray(N.data))
      return Y(N.data);
  }
  function ee(N) {
    if (N >= u)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + u.toString(16) + " bytes");
    return N | 0;
  }
  function se(N) {
    return +N != N && (N = 0), h.alloc(+N);
  }
  h.isBuffer = function(E) {
    return E != null && E._isBuffer === !0 && E !== h.prototype;
  }, h.compare = function(E, I) {
    if (Me(E, o) && (E = h.from(E, E.offset, E.byteLength)), Me(I, o) && (I = h.from(I, I.offset, I.byteLength)), !h.isBuffer(E) || !h.isBuffer(I))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (E === I) return 0;
    let U = E.length, re = I.length;
    for (let ae = 0, fe = Math.min(U, re); ae < fe; ++ae)
      if (E[ae] !== I[ae]) {
        U = E[ae], re = I[ae];
        break;
      }
    return U < re ? -1 : re < U ? 1 : 0;
  }, h.isEncoding = function(E) {
    switch (String(E).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, h.concat = function(E, I) {
    if (!Array.isArray(E))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (E.length === 0)
      return h.alloc(0);
    let U;
    if (I === void 0)
      for (I = 0, U = 0; U < E.length; ++U)
        I += E[U].length;
    const re = h.allocUnsafe(I);
    let ae = 0;
    for (U = 0; U < E.length; ++U) {
      let fe = E[U];
      if (Me(fe, o))
        ae + fe.length > re.length ? (h.isBuffer(fe) || (fe = h.from(fe)), fe.copy(re, ae)) : o.prototype.set.call(
          re,
          fe,
          ae
        );
      else if (h.isBuffer(fe))
        fe.copy(re, ae);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      ae += fe.length;
    }
    return re;
  };
  function ce(N, E) {
    if (h.isBuffer(N))
      return N.length;
    if (d.isView(N) || Me(N, d))
      return N.byteLength;
    if (typeof N != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof N
      );
    const I = N.length, U = arguments.length > 2 && arguments[2] === !0;
    if (!U && I === 0) return 0;
    let re = !1;
    for (; ; )
      switch (E) {
        case "ascii":
        case "latin1":
        case "binary":
          return I;
        case "utf8":
        case "utf-8":
          return Oe(N).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return I * 2;
        case "hex":
          return I >>> 1;
        case "base64":
          return Ne(N).length;
        default:
          if (re)
            return U ? -1 : Oe(N).length;
          E = ("" + E).toLowerCase(), re = !0;
      }
  }
  h.byteLength = ce;
  function le(N, E, I) {
    let U = !1;
    if ((E === void 0 || E < 0) && (E = 0), E > this.length || ((I === void 0 || I > this.length) && (I = this.length), I <= 0) || (I >>>= 0, E >>>= 0, I <= E))
      return "";
    for (N || (N = "utf8"); ; )
      switch (N) {
        case "hex":
          return b(this, E, I);
        case "utf8":
        case "utf-8":
          return S(this, E, I);
        case "ascii":
          return p(this, E, I);
        case "latin1":
        case "binary":
          return B(this, E, I);
        case "base64":
          return $(this, E, I);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return k(this, E, I);
        default:
          if (U) throw new TypeError("Unknown encoding: " + N);
          N = (N + "").toLowerCase(), U = !0;
      }
  }
  h.prototype._isBuffer = !0;
  function he(N, E, I) {
    const U = N[E];
    N[E] = N[I], N[I] = U;
  }
  h.prototype.swap16 = function() {
    const E = this.length;
    if (E % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let I = 0; I < E; I += 2)
      he(this, I, I + 1);
    return this;
  }, h.prototype.swap32 = function() {
    const E = this.length;
    if (E % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let I = 0; I < E; I += 4)
      he(this, I, I + 3), he(this, I + 1, I + 2);
    return this;
  }, h.prototype.swap64 = function() {
    const E = this.length;
    if (E % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let I = 0; I < E; I += 8)
      he(this, I, I + 7), he(this, I + 1, I + 6), he(this, I + 2, I + 5), he(this, I + 3, I + 4);
    return this;
  }, h.prototype.toString = function() {
    const E = this.length;
    return E === 0 ? "" : arguments.length === 0 ? S(this, 0, E) : le.apply(this, arguments);
  }, h.prototype.toLocaleString = h.prototype.toString, h.prototype.equals = function(E) {
    if (!h.isBuffer(E)) throw new TypeError("Argument must be a Buffer");
    return this === E ? !0 : h.compare(this, E) === 0;
  }, h.prototype.inspect = function() {
    let E = "";
    const I = t.INSPECT_MAX_BYTES;
    return E = this.toString("hex", 0, I).replace(/(.{2})/g, "$1 ").trim(), this.length > I && (E += " ... "), "<Buffer " + E + ">";
  }, a && (h.prototype[a] = h.prototype.inspect), h.prototype.compare = function(E, I, U, re, ae) {
    if (Me(E, o) && (E = h.from(E, E.offset, E.byteLength)), !h.isBuffer(E))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof E
      );
    if (I === void 0 && (I = 0), U === void 0 && (U = E ? E.length : 0), re === void 0 && (re = 0), ae === void 0 && (ae = this.length), I < 0 || U > E.length || re < 0 || ae > this.length)
      throw new RangeError("out of range index");
    if (re >= ae && I >= U)
      return 0;
    if (re >= ae)
      return -1;
    if (I >= U)
      return 1;
    if (I >>>= 0, U >>>= 0, re >>>= 0, ae >>>= 0, this === E) return 0;
    let fe = ae - re, ye = U - I;
    const Ee = Math.min(fe, ye), ve = this.slice(re, ae), Be = E.slice(I, U);
    for (let $e = 0; $e < Ee; ++$e)
      if (ve[$e] !== Be[$e]) {
        fe = ve[$e], ye = Be[$e];
        break;
      }
    return fe < ye ? -1 : ye < fe ? 1 : 0;
  };
  function oe(N, E, I, U, re) {
    if (N.length === 0) return -1;
    if (typeof I == "string" ? (U = I, I = 0) : I > 2147483647 ? I = 2147483647 : I < -2147483648 && (I = -2147483648), I = +I, qe(I) && (I = re ? 0 : N.length - 1), I < 0 && (I = N.length + I), I >= N.length) {
      if (re) return -1;
      I = N.length - 1;
    } else if (I < 0)
      if (re) I = 0;
      else return -1;
    if (typeof E == "string" && (E = h.from(E, U)), h.isBuffer(E))
      return E.length === 0 ? -1 : _e(N, E, I, U, re);
    if (typeof E == "number")
      return E = E & 255, typeof o.prototype.indexOf == "function" ? re ? o.prototype.indexOf.call(N, E, I) : o.prototype.lastIndexOf.call(N, E, I) : _e(N, [E], I, U, re);
    throw new TypeError("val must be string, number or Buffer");
  }
  function _e(N, E, I, U, re) {
    let ae = 1, fe = N.length, ye = E.length;
    if (U !== void 0 && (U = String(U).toLowerCase(), U === "ucs2" || U === "ucs-2" || U === "utf16le" || U === "utf-16le")) {
      if (N.length < 2 || E.length < 2)
        return -1;
      ae = 2, fe /= 2, ye /= 2, I /= 2;
    }
    function Ee(Be, $e) {
      return ae === 1 ? Be[$e] : Be.readUInt16BE($e * ae);
    }
    let ve;
    if (re) {
      let Be = -1;
      for (ve = I; ve < fe; ve++)
        if (Ee(N, ve) === Ee(E, Be === -1 ? 0 : ve - Be)) {
          if (Be === -1 && (Be = ve), ve - Be + 1 === ye) return Be * ae;
        } else
          Be !== -1 && (ve -= ve - Be), Be = -1;
    } else
      for (I + ye > fe && (I = fe - ye), ve = I; ve >= 0; ve--) {
        let Be = !0;
        for (let $e = 0; $e < ye; $e++)
          if (Ee(N, ve + $e) !== Ee(E, $e)) {
            Be = !1;
            break;
          }
        if (Be) return ve;
      }
    return -1;
  }
  h.prototype.includes = function(E, I, U) {
    return this.indexOf(E, I, U) !== -1;
  }, h.prototype.indexOf = function(E, I, U) {
    return oe(this, E, I, U, !0);
  }, h.prototype.lastIndexOf = function(E, I, U) {
    return oe(this, E, I, U, !1);
  };
  function J(N, E, I, U) {
    I = Number(I) || 0;
    const re = N.length - I;
    U ? (U = Number(U), U > re && (U = re)) : U = re;
    const ae = E.length;
    U > ae / 2 && (U = ae / 2);
    let fe;
    for (fe = 0; fe < U; ++fe) {
      const ye = parseInt(E.substr(fe * 2, 2), 16);
      if (qe(ye)) return fe;
      N[I + fe] = ye;
    }
    return fe;
  }
  function w(N, E, I, U) {
    return ge(Oe(E, N.length - I), N, I, U);
  }
  function m(N, E, I, U) {
    return ge(xe(E), N, I, U);
  }
  function c(N, E, I, U) {
    return ge(Ne(E), N, I, U);
  }
  function v(N, E, I, U) {
    return ge(je(E, N.length - I), N, I, U);
  }
  h.prototype.write = function(E, I, U, re) {
    if (I === void 0)
      re = "utf8", U = this.length, I = 0;
    else if (U === void 0 && typeof I == "string")
      re = I, U = this.length, I = 0;
    else if (isFinite(I))
      I = I >>> 0, isFinite(U) ? (U = U >>> 0, re === void 0 && (re = "utf8")) : (re = U, U = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const ae = this.length - I;
    if ((U === void 0 || U > ae) && (U = ae), E.length > 0 && (U < 0 || I < 0) || I > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    re || (re = "utf8");
    let fe = !1;
    for (; ; )
      switch (re) {
        case "hex":
          return J(this, E, I, U);
        case "utf8":
        case "utf-8":
          return w(this, E, I, U);
        case "ascii":
        case "latin1":
        case "binary":
          return m(this, E, I, U);
        case "base64":
          return c(this, E, I, U);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return v(this, E, I, U);
        default:
          if (fe) throw new TypeError("Unknown encoding: " + re);
          re = ("" + re).toLowerCase(), fe = !0;
      }
  }, h.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function $(N, E, I) {
    return E === 0 && I === N.length ? e.fromByteArray(N) : e.fromByteArray(N.slice(E, I));
  }
  function S(N, E, I) {
    I = Math.min(N.length, I);
    const U = [];
    let re = E;
    for (; re < I; ) {
      const ae = N[re];
      let fe = null, ye = ae > 239 ? 4 : ae > 223 ? 3 : ae > 191 ? 2 : 1;
      if (re + ye <= I) {
        let Ee, ve, Be, $e;
        switch (ye) {
          case 1:
            ae < 128 && (fe = ae);
            break;
          case 2:
            Ee = N[re + 1], (Ee & 192) === 128 && ($e = (ae & 31) << 6 | Ee & 63, $e > 127 && (fe = $e));
            break;
          case 3:
            Ee = N[re + 1], ve = N[re + 2], (Ee & 192) === 128 && (ve & 192) === 128 && ($e = (ae & 15) << 12 | (Ee & 63) << 6 | ve & 63, $e > 2047 && ($e < 55296 || $e > 57343) && (fe = $e));
            break;
          case 4:
            Ee = N[re + 1], ve = N[re + 2], Be = N[re + 3], (Ee & 192) === 128 && (ve & 192) === 128 && (Be & 192) === 128 && ($e = (ae & 15) << 18 | (Ee & 63) << 12 | (ve & 63) << 6 | Be & 63, $e > 65535 && $e < 1114112 && (fe = $e));
        }
      }
      fe === null ? (fe = 65533, ye = 1) : fe > 65535 && (fe -= 65536, U.push(fe >>> 10 & 1023 | 55296), fe = 56320 | fe & 1023), U.push(fe), re += ye;
    }
    return M(U);
  }
  const A = 4096;
  function M(N) {
    const E = N.length;
    if (E <= A)
      return String.fromCharCode.apply(String, N);
    let I = "", U = 0;
    for (; U < E; )
      I += String.fromCharCode.apply(
        String,
        N.slice(U, U += A)
      );
    return I;
  }
  function p(N, E, I) {
    let U = "";
    I = Math.min(N.length, I);
    for (let re = E; re < I; ++re)
      U += String.fromCharCode(N[re] & 127);
    return U;
  }
  function B(N, E, I) {
    let U = "";
    I = Math.min(N.length, I);
    for (let re = E; re < I; ++re)
      U += String.fromCharCode(N[re]);
    return U;
  }
  function b(N, E, I) {
    const U = N.length;
    (!E || E < 0) && (E = 0), (!I || I < 0 || I > U) && (I = U);
    let re = "";
    for (let ae = E; ae < I; ++ae)
      re += Se[N[ae]];
    return re;
  }
  function k(N, E, I) {
    const U = N.slice(E, I);
    let re = "";
    for (let ae = 0; ae < U.length - 1; ae += 2)
      re += String.fromCharCode(U[ae] + U[ae + 1] * 256);
    return re;
  }
  h.prototype.slice = function(E, I) {
    const U = this.length;
    E = ~~E, I = I === void 0 ? U : ~~I, E < 0 ? (E += U, E < 0 && (E = 0)) : E > U && (E = U), I < 0 ? (I += U, I < 0 && (I = 0)) : I > U && (I = U), I < E && (I = E);
    const re = this.subarray(E, I);
    return Object.setPrototypeOf(re, h.prototype), re;
  };
  function Z(N, E, I) {
    if (N % 1 !== 0 || N < 0) throw new RangeError("offset is not uint");
    if (N + E > I) throw new RangeError("Trying to access beyond buffer length");
  }
  h.prototype.readUintLE = h.prototype.readUIntLE = function(E, I, U) {
    E = E >>> 0, I = I >>> 0, U || Z(E, I, this.length);
    let re = this[E], ae = 1, fe = 0;
    for (; ++fe < I && (ae *= 256); )
      re += this[E + fe] * ae;
    return re;
  }, h.prototype.readUintBE = h.prototype.readUIntBE = function(E, I, U) {
    E = E >>> 0, I = I >>> 0, U || Z(E, I, this.length);
    let re = this[E + --I], ae = 1;
    for (; I > 0 && (ae *= 256); )
      re += this[E + --I] * ae;
    return re;
  }, h.prototype.readUint8 = h.prototype.readUInt8 = function(E, I) {
    return E = E >>> 0, I || Z(E, 1, this.length), this[E];
  }, h.prototype.readUint16LE = h.prototype.readUInt16LE = function(E, I) {
    return E = E >>> 0, I || Z(E, 2, this.length), this[E] | this[E + 1] << 8;
  }, h.prototype.readUint16BE = h.prototype.readUInt16BE = function(E, I) {
    return E = E >>> 0, I || Z(E, 2, this.length), this[E] << 8 | this[E + 1];
  }, h.prototype.readUint32LE = h.prototype.readUInt32LE = function(E, I) {
    return E = E >>> 0, I || Z(E, 4, this.length), (this[E] | this[E + 1] << 8 | this[E + 2] << 16) + this[E + 3] * 16777216;
  }, h.prototype.readUint32BE = h.prototype.readUInt32BE = function(E, I) {
    return E = E >>> 0, I || Z(E, 4, this.length), this[E] * 16777216 + (this[E + 1] << 16 | this[E + 2] << 8 | this[E + 3]);
  }, h.prototype.readBigUInt64LE = ke(function(E) {
    E = E >>> 0, be(E, "offset");
    const I = this[E], U = this[E + 7];
    (I === void 0 || U === void 0) && me(E, this.length - 8);
    const re = I + this[++E] * 2 ** 8 + this[++E] * 2 ** 16 + this[++E] * 2 ** 24, ae = this[++E] + this[++E] * 2 ** 8 + this[++E] * 2 ** 16 + U * 2 ** 24;
    return BigInt(re) + (BigInt(ae) << BigInt(32));
  }), h.prototype.readBigUInt64BE = ke(function(E) {
    E = E >>> 0, be(E, "offset");
    const I = this[E], U = this[E + 7];
    (I === void 0 || U === void 0) && me(E, this.length - 8);
    const re = I * 2 ** 24 + this[++E] * 2 ** 16 + this[++E] * 2 ** 8 + this[++E], ae = this[++E] * 2 ** 24 + this[++E] * 2 ** 16 + this[++E] * 2 ** 8 + U;
    return (BigInt(re) << BigInt(32)) + BigInt(ae);
  }), h.prototype.readIntLE = function(E, I, U) {
    E = E >>> 0, I = I >>> 0, U || Z(E, I, this.length);
    let re = this[E], ae = 1, fe = 0;
    for (; ++fe < I && (ae *= 256); )
      re += this[E + fe] * ae;
    return ae *= 128, re >= ae && (re -= Math.pow(2, 8 * I)), re;
  }, h.prototype.readIntBE = function(E, I, U) {
    E = E >>> 0, I = I >>> 0, U || Z(E, I, this.length);
    let re = I, ae = 1, fe = this[E + --re];
    for (; re > 0 && (ae *= 256); )
      fe += this[E + --re] * ae;
    return ae *= 128, fe >= ae && (fe -= Math.pow(2, 8 * I)), fe;
  }, h.prototype.readInt8 = function(E, I) {
    return E = E >>> 0, I || Z(E, 1, this.length), this[E] & 128 ? (255 - this[E] + 1) * -1 : this[E];
  }, h.prototype.readInt16LE = function(E, I) {
    E = E >>> 0, I || Z(E, 2, this.length);
    const U = this[E] | this[E + 1] << 8;
    return U & 32768 ? U | 4294901760 : U;
  }, h.prototype.readInt16BE = function(E, I) {
    E = E >>> 0, I || Z(E, 2, this.length);
    const U = this[E + 1] | this[E] << 8;
    return U & 32768 ? U | 4294901760 : U;
  }, h.prototype.readInt32LE = function(E, I) {
    return E = E >>> 0, I || Z(E, 4, this.length), this[E] | this[E + 1] << 8 | this[E + 2] << 16 | this[E + 3] << 24;
  }, h.prototype.readInt32BE = function(E, I) {
    return E = E >>> 0, I || Z(E, 4, this.length), this[E] << 24 | this[E + 1] << 16 | this[E + 2] << 8 | this[E + 3];
  }, h.prototype.readBigInt64LE = ke(function(E) {
    E = E >>> 0, be(E, "offset");
    const I = this[E], U = this[E + 7];
    (I === void 0 || U === void 0) && me(E, this.length - 8);
    const re = this[E + 4] + this[E + 5] * 2 ** 8 + this[E + 6] * 2 ** 16 + (U << 24);
    return (BigInt(re) << BigInt(32)) + BigInt(I + this[++E] * 2 ** 8 + this[++E] * 2 ** 16 + this[++E] * 2 ** 24);
  }), h.prototype.readBigInt64BE = ke(function(E) {
    E = E >>> 0, be(E, "offset");
    const I = this[E], U = this[E + 7];
    (I === void 0 || U === void 0) && me(E, this.length - 8);
    const re = (I << 24) + // Overflow
    this[++E] * 2 ** 16 + this[++E] * 2 ** 8 + this[++E];
    return (BigInt(re) << BigInt(32)) + BigInt(this[++E] * 2 ** 24 + this[++E] * 2 ** 16 + this[++E] * 2 ** 8 + U);
  }), h.prototype.readFloatLE = function(E, I) {
    return E = E >>> 0, I || Z(E, 4, this.length), n.read(this, E, !0, 23, 4);
  }, h.prototype.readFloatBE = function(E, I) {
    return E = E >>> 0, I || Z(E, 4, this.length), n.read(this, E, !1, 23, 4);
  }, h.prototype.readDoubleLE = function(E, I) {
    return E = E >>> 0, I || Z(E, 8, this.length), n.read(this, E, !0, 52, 8);
  }, h.prototype.readDoubleBE = function(E, I) {
    return E = E >>> 0, I || Z(E, 8, this.length), n.read(this, E, !1, 52, 8);
  };
  function te(N, E, I, U, re, ae) {
    if (!h.isBuffer(N)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (E > re || E < ae) throw new RangeError('"value" argument is out of bounds');
    if (I + U > N.length) throw new RangeError("Index out of range");
  }
  h.prototype.writeUintLE = h.prototype.writeUIntLE = function(E, I, U, re) {
    if (E = +E, I = I >>> 0, U = U >>> 0, !re) {
      const ye = Math.pow(2, 8 * U) - 1;
      te(this, E, I, U, ye, 0);
    }
    let ae = 1, fe = 0;
    for (this[I] = E & 255; ++fe < U && (ae *= 256); )
      this[I + fe] = E / ae & 255;
    return I + U;
  }, h.prototype.writeUintBE = h.prototype.writeUIntBE = function(E, I, U, re) {
    if (E = +E, I = I >>> 0, U = U >>> 0, !re) {
      const ye = Math.pow(2, 8 * U) - 1;
      te(this, E, I, U, ye, 0);
    }
    let ae = U - 1, fe = 1;
    for (this[I + ae] = E & 255; --ae >= 0 && (fe *= 256); )
      this[I + ae] = E / fe & 255;
    return I + U;
  }, h.prototype.writeUint8 = h.prototype.writeUInt8 = function(E, I, U) {
    return E = +E, I = I >>> 0, U || te(this, E, I, 1, 255, 0), this[I] = E & 255, I + 1;
  }, h.prototype.writeUint16LE = h.prototype.writeUInt16LE = function(E, I, U) {
    return E = +E, I = I >>> 0, U || te(this, E, I, 2, 65535, 0), this[I] = E & 255, this[I + 1] = E >>> 8, I + 2;
  }, h.prototype.writeUint16BE = h.prototype.writeUInt16BE = function(E, I, U) {
    return E = +E, I = I >>> 0, U || te(this, E, I, 2, 65535, 0), this[I] = E >>> 8, this[I + 1] = E & 255, I + 2;
  }, h.prototype.writeUint32LE = h.prototype.writeUInt32LE = function(E, I, U) {
    return E = +E, I = I >>> 0, U || te(this, E, I, 4, 4294967295, 0), this[I + 3] = E >>> 24, this[I + 2] = E >>> 16, this[I + 1] = E >>> 8, this[I] = E & 255, I + 4;
  }, h.prototype.writeUint32BE = h.prototype.writeUInt32BE = function(E, I, U) {
    return E = +E, I = I >>> 0, U || te(this, E, I, 4, 4294967295, 0), this[I] = E >>> 24, this[I + 1] = E >>> 16, this[I + 2] = E >>> 8, this[I + 3] = E & 255, I + 4;
  };
  function V(N, E, I, U, re) {
    pe(E, U, re, N, I, 7);
    let ae = Number(E & BigInt(4294967295));
    N[I++] = ae, ae = ae >> 8, N[I++] = ae, ae = ae >> 8, N[I++] = ae, ae = ae >> 8, N[I++] = ae;
    let fe = Number(E >> BigInt(32) & BigInt(4294967295));
    return N[I++] = fe, fe = fe >> 8, N[I++] = fe, fe = fe >> 8, N[I++] = fe, fe = fe >> 8, N[I++] = fe, I;
  }
  function T(N, E, I, U, re) {
    pe(E, U, re, N, I, 7);
    let ae = Number(E & BigInt(4294967295));
    N[I + 7] = ae, ae = ae >> 8, N[I + 6] = ae, ae = ae >> 8, N[I + 5] = ae, ae = ae >> 8, N[I + 4] = ae;
    let fe = Number(E >> BigInt(32) & BigInt(4294967295));
    return N[I + 3] = fe, fe = fe >> 8, N[I + 2] = fe, fe = fe >> 8, N[I + 1] = fe, fe = fe >> 8, N[I] = fe, I + 8;
  }
  h.prototype.writeBigUInt64LE = ke(function(E, I = 0) {
    return V(this, E, I, BigInt(0), BigInt("0xffffffffffffffff"));
  }), h.prototype.writeBigUInt64BE = ke(function(E, I = 0) {
    return T(this, E, I, BigInt(0), BigInt("0xffffffffffffffff"));
  }), h.prototype.writeIntLE = function(E, I, U, re) {
    if (E = +E, I = I >>> 0, !re) {
      const Ee = Math.pow(2, 8 * U - 1);
      te(this, E, I, U, Ee - 1, -Ee);
    }
    let ae = 0, fe = 1, ye = 0;
    for (this[I] = E & 255; ++ae < U && (fe *= 256); )
      E < 0 && ye === 0 && this[I + ae - 1] !== 0 && (ye = 1), this[I + ae] = (E / fe >> 0) - ye & 255;
    return I + U;
  }, h.prototype.writeIntBE = function(E, I, U, re) {
    if (E = +E, I = I >>> 0, !re) {
      const Ee = Math.pow(2, 8 * U - 1);
      te(this, E, I, U, Ee - 1, -Ee);
    }
    let ae = U - 1, fe = 1, ye = 0;
    for (this[I + ae] = E & 255; --ae >= 0 && (fe *= 256); )
      E < 0 && ye === 0 && this[I + ae + 1] !== 0 && (ye = 1), this[I + ae] = (E / fe >> 0) - ye & 255;
    return I + U;
  }, h.prototype.writeInt8 = function(E, I, U) {
    return E = +E, I = I >>> 0, U || te(this, E, I, 1, 127, -128), E < 0 && (E = 255 + E + 1), this[I] = E & 255, I + 1;
  }, h.prototype.writeInt16LE = function(E, I, U) {
    return E = +E, I = I >>> 0, U || te(this, E, I, 2, 32767, -32768), this[I] = E & 255, this[I + 1] = E >>> 8, I + 2;
  }, h.prototype.writeInt16BE = function(E, I, U) {
    return E = +E, I = I >>> 0, U || te(this, E, I, 2, 32767, -32768), this[I] = E >>> 8, this[I + 1] = E & 255, I + 2;
  }, h.prototype.writeInt32LE = function(E, I, U) {
    return E = +E, I = I >>> 0, U || te(this, E, I, 4, 2147483647, -2147483648), this[I] = E & 255, this[I + 1] = E >>> 8, this[I + 2] = E >>> 16, this[I + 3] = E >>> 24, I + 4;
  }, h.prototype.writeInt32BE = function(E, I, U) {
    return E = +E, I = I >>> 0, U || te(this, E, I, 4, 2147483647, -2147483648), E < 0 && (E = 4294967295 + E + 1), this[I] = E >>> 24, this[I + 1] = E >>> 16, this[I + 2] = E >>> 8, this[I + 3] = E & 255, I + 4;
  }, h.prototype.writeBigInt64LE = ke(function(E, I = 0) {
    return V(this, E, I, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), h.prototype.writeBigInt64BE = ke(function(E, I = 0) {
    return T(this, E, I, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function O(N, E, I, U, re, ae) {
    if (I + U > N.length) throw new RangeError("Index out of range");
    if (I < 0) throw new RangeError("Index out of range");
  }
  function Q(N, E, I, U, re) {
    return E = +E, I = I >>> 0, re || O(N, E, I, 4), n.write(N, E, I, U, 23, 4), I + 4;
  }
  h.prototype.writeFloatLE = function(E, I, U) {
    return Q(this, E, I, !0, U);
  }, h.prototype.writeFloatBE = function(E, I, U) {
    return Q(this, E, I, !1, U);
  };
  function ie(N, E, I, U, re) {
    return E = +E, I = I >>> 0, re || O(N, E, I, 8), n.write(N, E, I, U, 52, 8), I + 8;
  }
  h.prototype.writeDoubleLE = function(E, I, U) {
    return ie(this, E, I, !0, U);
  }, h.prototype.writeDoubleBE = function(E, I, U) {
    return ie(this, E, I, !1, U);
  }, h.prototype.copy = function(E, I, U, re) {
    if (!h.isBuffer(E)) throw new TypeError("argument should be a Buffer");
    if (U || (U = 0), !re && re !== 0 && (re = this.length), I >= E.length && (I = E.length), I || (I = 0), re > 0 && re < U && (re = U), re === U || E.length === 0 || this.length === 0) return 0;
    if (I < 0)
      throw new RangeError("targetStart out of bounds");
    if (U < 0 || U >= this.length) throw new RangeError("Index out of range");
    if (re < 0) throw new RangeError("sourceEnd out of bounds");
    re > this.length && (re = this.length), E.length - I < re - U && (re = E.length - I + U);
    const ae = re - U;
    return this === E && typeof o.prototype.copyWithin == "function" ? this.copyWithin(I, U, re) : o.prototype.set.call(
      E,
      this.subarray(U, re),
      I
    ), ae;
  }, h.prototype.fill = function(E, I, U, re) {
    if (typeof E == "string") {
      if (typeof I == "string" ? (re = I, I = 0, U = this.length) : typeof U == "string" && (re = U, U = this.length), re !== void 0 && typeof re != "string")
        throw new TypeError("encoding must be a string");
      if (typeof re == "string" && !h.isEncoding(re))
        throw new TypeError("Unknown encoding: " + re);
      if (E.length === 1) {
        const fe = E.charCodeAt(0);
        (re === "utf8" && fe < 128 || re === "latin1") && (E = fe);
      }
    } else typeof E == "number" ? E = E & 255 : typeof E == "boolean" && (E = Number(E));
    if (I < 0 || this.length < I || this.length < U)
      throw new RangeError("Out of range index");
    if (U <= I)
      return this;
    I = I >>> 0, U = U === void 0 ? this.length : U >>> 0, E || (E = 0);
    let ae;
    if (typeof E == "number")
      for (ae = I; ae < U; ++ae)
        this[ae] = E;
    else {
      const fe = h.isBuffer(E) ? E : h.from(E, re), ye = fe.length;
      if (ye === 0)
        throw new TypeError('The value "' + E + '" is invalid for argument "value"');
      for (ae = 0; ae < U - I; ++ae)
        this[ae + I] = fe[ae % ye];
    }
    return this;
  };
  const L = {};
  function j(N, E, I) {
    L[N] = class extends I {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: E.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${N}]`, this.stack, delete this.name;
      }
      get code() {
        return N;
      }
      set code(re) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: re,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${N}]: ${this.message}`;
      }
    };
  }
  j(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(N) {
      return N ? `${N} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), j(
    "ERR_INVALID_ARG_TYPE",
    function(N, E) {
      return `The "${N}" argument must be of type number. Received type ${typeof E}`;
    },
    TypeError
  ), j(
    "ERR_OUT_OF_RANGE",
    function(N, E, I) {
      let U = `The value of "${N}" is out of range.`, re = I;
      return Number.isInteger(I) && Math.abs(I) > 2 ** 32 ? re = ne(String(I)) : typeof I == "bigint" && (re = String(I), (I > BigInt(2) ** BigInt(32) || I < -(BigInt(2) ** BigInt(32))) && (re = ne(re)), re += "n"), U += ` It must be ${E}. Received ${re}`, U;
    },
    RangeError
  );
  function ne(N) {
    let E = "", I = N.length;
    const U = N[0] === "-" ? 1 : 0;
    for (; I >= U + 4; I -= 3)
      E = `_${N.slice(I - 3, I)}${E}`;
    return `${N.slice(0, I)}${E}`;
  }
  function de(N, E, I) {
    be(E, "offset"), (N[E] === void 0 || N[E + I] === void 0) && me(E, N.length - (I + 1));
  }
  function pe(N, E, I, U, re, ae) {
    if (N > I || N < E) {
      const fe = typeof E == "bigint" ? "n" : "";
      let ye;
      throw E === 0 || E === BigInt(0) ? ye = `>= 0${fe} and < 2${fe} ** ${(ae + 1) * 8}${fe}` : ye = `>= -(2${fe} ** ${(ae + 1) * 8 - 1}${fe}) and < 2 ** ${(ae + 1) * 8 - 1}${fe}`, new L.ERR_OUT_OF_RANGE("value", ye, N);
    }
    de(U, re, ae);
  }
  function be(N, E) {
    if (typeof N != "number")
      throw new L.ERR_INVALID_ARG_TYPE(E, "number", N);
  }
  function me(N, E, I) {
    throw Math.floor(N) !== N ? (be(N, I), new L.ERR_OUT_OF_RANGE("offset", "an integer", N)) : E < 0 ? new L.ERR_BUFFER_OUT_OF_BOUNDS() : new L.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${E}`,
      N
    );
  }
  const we = /[^+/0-9A-Za-z-_]/g;
  function ue(N) {
    if (N = N.split("=")[0], N = N.trim().replace(we, ""), N.length < 2) return "";
    for (; N.length % 4 !== 0; )
      N = N + "=";
    return N;
  }
  function Oe(N, E) {
    E = E || 1 / 0;
    let I;
    const U = N.length;
    let re = null;
    const ae = [];
    for (let fe = 0; fe < U; ++fe) {
      if (I = N.charCodeAt(fe), I > 55295 && I < 57344) {
        if (!re) {
          if (I > 56319) {
            (E -= 3) > -1 && ae.push(239, 191, 189);
            continue;
          } else if (fe + 1 === U) {
            (E -= 3) > -1 && ae.push(239, 191, 189);
            continue;
          }
          re = I;
          continue;
        }
        if (I < 56320) {
          (E -= 3) > -1 && ae.push(239, 191, 189), re = I;
          continue;
        }
        I = (re - 55296 << 10 | I - 56320) + 65536;
      } else re && (E -= 3) > -1 && ae.push(239, 191, 189);
      if (re = null, I < 128) {
        if ((E -= 1) < 0) break;
        ae.push(I);
      } else if (I < 2048) {
        if ((E -= 2) < 0) break;
        ae.push(
          I >> 6 | 192,
          I & 63 | 128
        );
      } else if (I < 65536) {
        if ((E -= 3) < 0) break;
        ae.push(
          I >> 12 | 224,
          I >> 6 & 63 | 128,
          I & 63 | 128
        );
      } else if (I < 1114112) {
        if ((E -= 4) < 0) break;
        ae.push(
          I >> 18 | 240,
          I >> 12 & 63 | 128,
          I >> 6 & 63 | 128,
          I & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return ae;
  }
  function xe(N) {
    const E = [];
    for (let I = 0; I < N.length; ++I)
      E.push(N.charCodeAt(I) & 255);
    return E;
  }
  function je(N, E) {
    let I, U, re;
    const ae = [];
    for (let fe = 0; fe < N.length && !((E -= 2) < 0); ++fe)
      I = N.charCodeAt(fe), U = I >> 8, re = I % 256, ae.push(re), ae.push(U);
    return ae;
  }
  function Ne(N) {
    return e.toByteArray(ue(N));
  }
  function ge(N, E, I, U) {
    let re;
    for (re = 0; re < U && !(re + I >= E.length || re >= N.length); ++re)
      E[re + I] = N[re];
    return re;
  }
  function Me(N, E) {
    return N instanceof E || N != null && N.constructor != null && N.constructor.name != null && N.constructor.name === E.name;
  }
  function qe(N) {
    return N !== N;
  }
  const Se = function() {
    const N = "0123456789abcdef", E = new Array(256);
    for (let I = 0; I < 16; ++I) {
      const U = I * 16;
      for (let re = 0; re < 16; ++re)
        E[U + re] = N[I] + N[re];
    }
    return E;
  }();
  function ke(N) {
    return typeof BigInt > "u" ? Le : N;
  }
  function Le() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer$C = buffer$1.Buffer, Blob = buffer$1.Blob, BlobOptions = buffer$1.BlobOptions, Buffer$1$1 = buffer$1.Buffer, File = buffer$1.File, FileOptions = buffer$1.FileOptions, INSPECT_MAX_BYTES = buffer$1.INSPECT_MAX_BYTES, SlowBuffer = buffer$1.SlowBuffer, TranscodeEncoding = buffer$1.TranscodeEncoding, atob = buffer$1.atob, btoa = buffer$1.btoa, constants$1 = buffer$1.constants, isAscii = buffer$1.isAscii, isUtf8 = buffer$1.isUtf8, kMaxLength = buffer$1.kMaxLength, kStringMaxLength = buffer$1.kStringMaxLength, resolveObjectURL = buffer$1.resolveObjectURL, transcode = buffer$1.transcode, dist = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob,
  BlobOptions,
  Buffer: Buffer$1$1,
  File,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  TranscodeEncoding,
  atob,
  btoa,
  constants: constants$1,
  default: Buffer$C,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs$1(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function getAugmentedNamespace(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function a() {
      return this instanceof a ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function(a) {
    var u = Object.getOwnPropertyDescriptor(t, a);
    Object.defineProperty(n, a, u.get ? u : {
      enumerable: !0,
      get: function() {
        return t[a];
      }
    });
  }), n;
}
var cryptoBrowserify = {};
function getDefaultExportFromCjs(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var browser$c = { exports: {} }, process = browser$c.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(t) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(t, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(t, 0);
  try {
    return cachedSetTimeout(t, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, t, 0);
    } catch {
      return cachedSetTimeout.call(this, t, 0);
    }
  }
}
function runClearTimeout(t) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(t);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(t);
  try {
    return cachedClearTimeout(t);
  } catch {
    try {
      return cachedClearTimeout.call(null, t);
    } catch {
      return cachedClearTimeout.call(this, t);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var t = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var e = queue.length; e; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < e; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, e = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(t);
  }
}
process.nextTick = function(t) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var n = 1; n < arguments.length; n++)
      e[n - 1] = arguments[n];
  queue.push(new Item(t, e)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(t, e) {
  this.fun = t, this.array = e;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(t) {
  return [];
};
process.binding = function(t) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(t) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports$1 = browser$c.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports$1);
var browser$b = { exports: {} }, safeBuffer$2 = { exports: {} };
const require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(dist);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
safeBuffer$2.exports;
(function(t, e) {
  var n = require$$1$2, a = n.Buffer;
  function u(d, l) {
    for (var _ in d)
      l[_] = d[_];
  }
  a.from && a.alloc && a.allocUnsafe && a.allocUnsafeSlow ? t.exports = n : (u(n, e), e.Buffer = o);
  function o(d, l, _) {
    return a(d, l, _);
  }
  o.prototype = Object.create(a.prototype), u(a, o), o.from = function(d, l, _) {
    if (typeof d == "number")
      throw new TypeError("Argument must not be a number");
    return a(d, l, _);
  }, o.alloc = function(d, l, _) {
    if (typeof d != "number")
      throw new TypeError("Argument must be a number");
    var P = a(d);
    return l !== void 0 ? typeof _ == "string" ? P.fill(l, _) : P.fill(l) : P.fill(0), P;
  }, o.allocUnsafe = function(d) {
    if (typeof d != "number")
      throw new TypeError("Argument must be a number");
    return a(d);
  }, o.allocUnsafeSlow = function(d) {
    if (typeof d != "number")
      throw new TypeError("Argument must be a number");
    return n.SlowBuffer(d);
  };
})(safeBuffer$2, safeBuffer$2.exports);
var safeBufferExports$1 = safeBuffer$2.exports;
browser$b.exports;
var MAX_BYTES = 65536, MAX_UINT32 = 4294967295;
function oldBrowser$1() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var Buffer$B = safeBufferExports$1.Buffer, crypto$1 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
crypto$1 && crypto$1.getRandomValues ? browser$b.exports = randomBytes$2 : browser$b.exports = oldBrowser$1;
function randomBytes$2(t, e) {
  if (t > MAX_UINT32) throw new RangeError("requested too many random bytes");
  var n = Buffer$B.allocUnsafe(t);
  if (t > 0)
    if (t > MAX_BYTES)
      for (var a = 0; a < t; a += MAX_BYTES)
        crypto$1.getRandomValues(n.slice(a, a + MAX_BYTES));
    else
      crypto$1.getRandomValues(n);
  return typeof e == "function" ? process$1.nextTick(function() {
    e(null, n);
  }) : n;
}
var browserExports = browser$b.exports, inherits_browser = { exports: {} };
inherits_browser.exports;
typeof Object.create == "function" ? inherits_browser.exports = function(e, n) {
  n && (e.super_ = n, e.prototype = Object.create(n.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser.exports = function(e, n) {
  if (n) {
    e.super_ = n;
    var a = function() {
    };
    a.prototype = n.prototype, e.prototype = new a(), e.prototype.constructor = e;
  }
};
var inherits_browserExports = inherits_browser.exports, events = { exports: {} };
events.exports;
var R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function(e, n, a) {
  return Function.prototype.apply.call(e, n, a);
}, ReflectOwnKeys;
R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : ReflectOwnKeys = function(e) {
  return Object.getOwnPropertyNames(e);
};
function ProcessEmitWarning(t) {
  console && console.warn && console.warn(t);
}
var NumberIsNaN = Number.isNaN || function(e) {
  return e !== e;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(t) {
  if (typeof t != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(t) {
    if (typeof t != "number" || t < 0 || NumberIsNaN(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    defaultMaxListeners = t;
  }
});
EventEmitter.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || NumberIsNaN(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function _getMaxListeners(t) {
  return t._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : t._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function(e) {
  for (var n = [], a = 1; a < arguments.length; a++) n.push(arguments[a]);
  var u = e === "error", o = this._events;
  if (o !== void 0)
    u = u && o.error === void 0;
  else if (!u)
    return !1;
  if (u) {
    var d;
    if (n.length > 0 && (d = n[0]), d instanceof Error)
      throw d;
    var l = new Error("Unhandled error." + (d ? " (" + d.message + ")" : ""));
    throw l.context = d, l;
  }
  var _ = o[e];
  if (_ === void 0)
    return !1;
  if (typeof _ == "function")
    ReflectApply(_, this, n);
  else
    for (var P = _.length, h = arrayClone(_, P), a = 0; a < P; ++a)
      ReflectApply(h[a], this, n);
  return !0;
};
function _addListener(t, e, n, a) {
  var u, o, d;
  if (checkListener(n), o = t._events, o === void 0 ? (o = t._events = /* @__PURE__ */ Object.create(null), t._eventsCount = 0) : (o.newListener !== void 0 && (t.emit(
    "newListener",
    e,
    n.listener ? n.listener : n
  ), o = t._events), d = o[e]), d === void 0)
    d = o[e] = n, ++t._eventsCount;
  else if (typeof d == "function" ? d = o[e] = a ? [n, d] : [d, n] : a ? d.unshift(n) : d.push(n), u = _getMaxListeners(t), u > 0 && d.length > u && !d.warned) {
    d.warned = !0;
    var l = new Error("Possible EventEmitter memory leak detected. " + d.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    l.name = "MaxListenersExceededWarning", l.emitter = t, l.type = e, l.count = d.length, ProcessEmitWarning(l);
  }
  return t;
}
EventEmitter.prototype.addListener = function(e, n) {
  return _addListener(this, e, n, !1);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function(e, n) {
  return _addListener(this, e, n, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(t, e, n) {
  var a = { fired: !1, wrapFn: void 0, target: t, type: e, listener: n }, u = onceWrapper.bind(a);
  return u.listener = n, a.wrapFn = u, u;
}
EventEmitter.prototype.once = function(e, n) {
  return checkListener(n), this.on(e, _onceWrap(this, e, n)), this;
};
EventEmitter.prototype.prependOnceListener = function(e, n) {
  return checkListener(n), this.prependListener(e, _onceWrap(this, e, n)), this;
};
EventEmitter.prototype.removeListener = function(e, n) {
  var a, u, o, d, l;
  if (checkListener(n), u = this._events, u === void 0)
    return this;
  if (a = u[e], a === void 0)
    return this;
  if (a === n || a.listener === n)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete u[e], u.removeListener && this.emit("removeListener", e, a.listener || n));
  else if (typeof a != "function") {
    for (o = -1, d = a.length - 1; d >= 0; d--)
      if (a[d] === n || a[d].listener === n) {
        l = a[d].listener, o = d;
        break;
      }
    if (o < 0)
      return this;
    o === 0 ? a.shift() : spliceOne(a, o), a.length === 1 && (u[e] = a[0]), u.removeListener !== void 0 && this.emit("removeListener", e, l || n);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function(e) {
  var n, a, u;
  if (a = this._events, a === void 0)
    return this;
  if (a.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : a[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete a[e]), this;
  if (arguments.length === 0) {
    var o = Object.keys(a), d;
    for (u = 0; u < o.length; ++u)
      d = o[u], d !== "removeListener" && this.removeAllListeners(d);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (n = a[e], typeof n == "function")
    this.removeListener(e, n);
  else if (n !== void 0)
    for (u = n.length - 1; u >= 0; u--)
      this.removeListener(e, n[u]);
  return this;
};
function _listeners(t, e, n) {
  var a = t._events;
  if (a === void 0)
    return [];
  var u = a[e];
  return u === void 0 ? [] : typeof u == "function" ? n ? [u.listener || u] : [u] : n ? unwrapListeners(u) : arrayClone(u, u.length);
}
EventEmitter.prototype.listeners = function(e) {
  return _listeners(this, e, !0);
};
EventEmitter.prototype.rawListeners = function(e) {
  return _listeners(this, e, !1);
};
EventEmitter.listenerCount = function(t, e) {
  return typeof t.listenerCount == "function" ? t.listenerCount(e) : listenerCount.call(t, e);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(t) {
  var e = this._events;
  if (e !== void 0) {
    var n = e[t];
    if (typeof n == "function")
      return 1;
    if (n !== void 0)
      return n.length;
  }
  return 0;
}
EventEmitter.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(t, e) {
  for (var n = new Array(e), a = 0; a < e; ++a)
    n[a] = t[a];
  return n;
}
function spliceOne(t, e) {
  for (; e + 1 < t.length; e++)
    t[e] = t[e + 1];
  t.pop();
}
function unwrapListeners(t) {
  for (var e = new Array(t.length), n = 0; n < e.length; ++n)
    e[n] = t[n].listener || t[n];
  return e;
}
function once(t, e) {
  return new Promise(function(n, a) {
    function u(d) {
      t.removeListener(e, o), a(d);
    }
    function o() {
      typeof t.removeListener == "function" && t.removeListener("error", u), n([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(t, e, o, { once: !0 }), e !== "error" && addErrorHandlerIfEventEmitter(t, u, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(t, e, n) {
  typeof t.on == "function" && eventTargetAgnosticAddListener(t, "error", e, n);
}
function eventTargetAgnosticAddListener(t, e, n, a) {
  if (typeof t.on == "function")
    a.once ? t.once(e, n) : t.on(e, n);
  else if (typeof t.addEventListener == "function")
    t.addEventListener(e, function u(o) {
      a.once && t.removeEventListener(e, u), n(o);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
}
var eventsExports = events.exports, streamBrowser$1, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser$1 = eventsExports.EventEmitter), streamBrowser$1;
}
var util$3 = {}, types = {}, shams$1 = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var e = {}, n = Symbol("test"), a = Object(n);
  if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(a) !== "[object Symbol]")
    return !1;
  var u = 42;
  e[n] = u;
  for (var o in e)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
    return !1;
  var d = Object.getOwnPropertySymbols(e);
  if (d.length !== 1 || d[0] !== n || !Object.prototype.propertyIsEnumerable.call(e, n))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var l = (
      /** @type {PropertyDescriptor} */
      Object.getOwnPropertyDescriptor(e, n)
    );
    if (l.value !== u || l.enumerable !== !0)
      return !1;
  }
  return !0;
}, hasSymbols$2 = shams$1, shams = function() {
  return hasSymbols$2() && !!Symbol.toStringTag;
}, esObjectAtoms = Object, esErrors = Error, _eval = EvalError, range = RangeError, ref = ReferenceError, syntax = SyntaxError, type = TypeError, uri = URIError, abs$1 = Math.abs, floor$1 = Math.floor, max$2 = Math.max, min$1 = Math.min, pow$1 = Math.pow, round$1 = Math.round, _isNaN = Number.isNaN || function(e) {
  return e !== e;
}, $isNaN = _isNaN, sign$2 = function(e) {
  return $isNaN(e) || e === 0 ? e : e < 0 ? -1 : 1;
}, gOPD$4 = Object.getOwnPropertyDescriptor, $gOPD$1 = gOPD$4;
if ($gOPD$1)
  try {
    $gOPD$1([], "length");
  } catch {
    $gOPD$1 = null;
  }
var gopd$1 = $gOPD$1, $defineProperty$3 = Object.defineProperty || !1;
if ($defineProperty$3)
  try {
    $defineProperty$3({}, "a", { value: 1 });
  } catch {
    $defineProperty$3 = !1;
  }
var esDefineProperty = $defineProperty$3, hasSymbols$1, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols$1;
  hasRequiredHasSymbols = 1;
  var t = typeof Symbol < "u" && Symbol, e = shams$1;
  return hasSymbols$1 = function() {
    return typeof t != "function" || typeof Symbol != "function" || typeof t("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : e();
  }, hasSymbols$1;
}
var Reflect_getPrototypeOf = typeof Reflect < "u" && Reflect.getPrototypeOf || null, $Object$2 = esObjectAtoms, Object_getPrototypeOf = $Object$2.getPrototypeOf || null, ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$3 = Object.prototype.toString, max$1 = Math.max, funcType = "[object Function]", concatty = function(e, n) {
  for (var a = [], u = 0; u < e.length; u += 1)
    a[u] = e[u];
  for (var o = 0; o < n.length; o += 1)
    a[o + e.length] = n[o];
  return a;
}, slicy = function(e, n) {
  for (var a = [], u = n || 0, o = 0; u < e.length; u += 1, o += 1)
    a[o] = e[u];
  return a;
}, joiny = function(t, e) {
  for (var n = "", a = 0; a < t.length; a += 1)
    n += t[a], a + 1 < t.length && (n += e);
  return n;
}, implementation$1 = function(e) {
  var n = this;
  if (typeof n != "function" || toStr$3.apply(n) !== funcType)
    throw new TypeError(ERROR_MESSAGE + n);
  for (var a = slicy(arguments, 1), u, o = function() {
    if (this instanceof u) {
      var h = n.apply(
        this,
        concatty(a, arguments)
      );
      return Object(h) === h ? h : this;
    }
    return n.apply(
      e,
      concatty(a, arguments)
    );
  }, d = max$1(0, n.length - a.length), l = [], _ = 0; _ < d; _++)
    l[_] = "$" + _;
  if (u = Function("binder", "return function (" + joiny(l, ",") + "){ return binder.apply(this,arguments); }")(o), n.prototype) {
    var P = function() {
    };
    P.prototype = n.prototype, u.prototype = new P(), P.prototype = null;
  }
  return u;
}, implementation = implementation$1, functionBind = Function.prototype.bind || implementation, functionCall = Function.prototype.call, functionApply = Function.prototype.apply, reflectApply$1 = typeof Reflect < "u" && Reflect && Reflect.apply, bind$4 = functionBind, $apply$2 = functionApply, $call$2 = functionCall, $reflectApply = reflectApply$1, actualApply$1 = $reflectApply || bind$4.call($call$2, $apply$2), bind$3 = functionBind, $TypeError$4 = type, $call$1 = functionCall, $actualApply = actualApply$1, callBindApplyHelpers = function(e) {
  if (e.length < 1 || typeof e[0] != "function")
    throw new $TypeError$4("a function is required");
  return $actualApply(bind$3, $call$1, e);
}, callBind$2 = callBindApplyHelpers, gOPD$3 = gopd$1, hasProtoAccessor;
try {
  hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
  [].__proto__ === Array.prototype;
} catch (t) {
  if (!t || typeof t != "object" || !("code" in t) || t.code !== "ERR_PROTO_ACCESS")
    throw t;
}
var desc = !!hasProtoAccessor && gOPD$3 && gOPD$3(
  Object.prototype,
  /** @type {keyof typeof Object.prototype} */
  "__proto__"
), $Object$1 = Object, $getPrototypeOf = $Object$1.getPrototypeOf, get = desc && typeof desc.get == "function" ? callBind$2([desc.get]) : typeof $getPrototypeOf == "function" ? (
  /** @type {import('./get')} */
  function(e) {
    return $getPrototypeOf(e == null ? e : $Object$1(e));
  }
) : !1, reflectGetProto = Reflect_getPrototypeOf, originalGetProto = Object_getPrototypeOf, getDunderProto = get, getProto$3 = reflectGetProto ? function(e) {
  return reflectGetProto(e);
} : originalGetProto ? function(e) {
  if (!e || typeof e != "object" && typeof e != "function")
    throw new TypeError("getProto: not an object");
  return originalGetProto(e);
} : getDunderProto ? function(e) {
  return getDunderProto(e);
} : null, call = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind$2 = functionBind, hasown = bind$2.call(call, $hasOwn), undefined$1, $Object = esObjectAtoms, $Error = esErrors, $EvalError = _eval, $RangeError = range, $ReferenceError = ref, $SyntaxError$1 = syntax, $TypeError$3 = type, $URIError = uri, abs = abs$1, floor = floor$1, max = max$2, min = min$1, pow = pow$1, round = round$1, sign$1 = sign$2, $Function = Function, getEvalledConstructor = function(t) {
  try {
    return $Function('"use strict"; return (' + t + ").constructor;")();
  } catch {
  }
}, $gOPD = gopd$1, $defineProperty$2 = esDefineProperty, throwTypeError = function() {
  throw new $TypeError$3();
}, ThrowTypeError = $gOPD ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols = requireHasSymbols()(), getProto$2 = getProto$3, $ObjectGPO = Object_getPrototypeOf, $ReflectGPO = Reflect_getPrototypeOf, $apply$1 = functionApply, $call = functionCall, needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto$2 ? undefined$1 : getProto$2(Uint8Array), INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto$2 ? getProto$2([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float16Array%": typeof Float16Array > "u" ? undefined$1 : Float16Array,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto$2 ? getProto$2(getProto$2([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto$2 ? undefined$1 : getProto$2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": $Object,
  "%Object.getOwnPropertyDescriptor%": $gOPD,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto$2 ? undefined$1 : getProto$2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto$2 ? getProto$2(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$3,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet,
  "%Function.prototype.call%": $call,
  "%Function.prototype.apply%": $apply$1,
  "%Object.defineProperty%": $defineProperty$2,
  "%Object.getPrototypeOf%": $ObjectGPO,
  "%Math.abs%": abs,
  "%Math.floor%": floor,
  "%Math.max%": max,
  "%Math.min%": min,
  "%Math.pow%": pow,
  "%Math.round%": round,
  "%Math.sign%": sign$1,
  "%Reflect.getPrototypeOf%": $ReflectGPO
};
if (getProto$2)
  try {
    null.error;
  } catch (t) {
    var errorProto = getProto$2(getProto$2(t));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function t(e) {
  var n;
  if (e === "%AsyncFunction%")
    n = getEvalledConstructor("async function () {}");
  else if (e === "%GeneratorFunction%")
    n = getEvalledConstructor("function* () {}");
  else if (e === "%AsyncGeneratorFunction%")
    n = getEvalledConstructor("async function* () {}");
  else if (e === "%AsyncGenerator%") {
    var a = t("%AsyncGeneratorFunction%");
    a && (n = a.prototype);
  } else if (e === "%AsyncIteratorPrototype%") {
    var u = t("%AsyncGenerator%");
    u && getProto$2 && (n = getProto$2(u.prototype));
  }
  return INTRINSICS[e] = n, n;
}, LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind$1 = functionBind, hasOwn$1 = hasown, $concat = bind$1.call($call, Array.prototype.concat), $spliceApply = bind$1.call($apply$1, Array.prototype.splice), $replace = bind$1.call($call, String.prototype.replace), $strSlice = bind$1.call($call, String.prototype.slice), $exec$2 = bind$1.call($call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function(e) {
  var n = $strSlice(e, 0, 1), a = $strSlice(e, -1);
  if (n === "%" && a !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if (a === "%" && n !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var u = [];
  return $replace(e, rePropName, function(o, d, l, _) {
    u[u.length] = l ? $replace(_, reEscapeChar, "$1") : d || o;
  }), u;
}, getBaseIntrinsic = function(e, n) {
  var a = e, u;
  if (hasOwn$1(LEGACY_ALIASES, a) && (u = LEGACY_ALIASES[a], a = "%" + u[0] + "%"), hasOwn$1(INTRINSICS, a)) {
    var o = INTRINSICS[a];
    if (o === needsEval && (o = doEval(a)), typeof o > "u" && !n)
      throw new $TypeError$3("intrinsic " + e + " exists, but is not available. Please file an issue!");
    return {
      alias: u,
      name: a,
      value: o
    };
  }
  throw new $SyntaxError$1("intrinsic " + e + " does not exist!");
}, getIntrinsic = function(e, n) {
  if (typeof e != "string" || e.length === 0)
    throw new $TypeError$3("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof n != "boolean")
    throw new $TypeError$3('"allowMissing" argument must be a boolean');
  if ($exec$2(/^%?[^%]*%?$/, e) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var a = stringToPath(e), u = a.length > 0 ? a[0] : "", o = getBaseIntrinsic("%" + u + "%", n), d = o.name, l = o.value, _ = !1, P = o.alias;
  P && (u = P[0], $spliceApply(a, $concat([0, 1], P)));
  for (var h = 1, x = !0; h < a.length; h += 1) {
    var C = a[h], D = $strSlice(C, 0, 1), q = $strSlice(C, -1);
    if ((D === '"' || D === "'" || D === "`" || q === '"' || q === "'" || q === "`") && D !== q)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((C === "constructor" || !x) && (_ = !0), u += "." + C, d = "%" + u + "%", hasOwn$1(INTRINSICS, d))
      l = INTRINSICS[d];
    else if (l != null) {
      if (!(C in l)) {
        if (!n)
          throw new $TypeError$3("base intrinsic for " + e + " exists, but the property is not available.");
        return;
      }
      if ($gOPD && h + 1 >= a.length) {
        var H = $gOPD(l, C);
        x = !!H, x && "get" in H && !("originalValue" in H.get) ? l = H.get : l = l[C];
      } else
        x = hasOwn$1(l, C), l = l[C];
      x && !_ && (INTRINSICS[d] = l);
    }
  }
  return l;
}, GetIntrinsic$1 = getIntrinsic, callBindBasic = callBindApplyHelpers, $indexOf$1 = callBindBasic([GetIntrinsic$1("%String.prototype.indexOf%")]), callBound$5 = function(e, n) {
  var a = (
    /** @type {(this: unknown, ...args: unknown[]) => unknown} */
    GetIntrinsic$1(e, !!n)
  );
  return typeof a == "function" && $indexOf$1(e, ".prototype.") > -1 ? callBindBasic(
    /** @type {const} */
    [a]
  ) : a;
}, hasToStringTag$4 = shams(), callBound$4 = callBound$5, $toString$2 = callBound$4("Object.prototype.toString"), isStandardArguments = function(e) {
  return hasToStringTag$4 && e && typeof e == "object" && Symbol.toStringTag in e ? !1 : $toString$2(e) === "[object Arguments]";
}, isLegacyArguments = function(e) {
  return isStandardArguments(e) ? !0 : e !== null && typeof e == "object" && "length" in e && typeof e.length == "number" && e.length >= 0 && $toString$2(e) !== "[object Array]" && "callee" in e && $toString$2(e.callee) === "[object Function]";
}, supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments, callBound$3 = callBound$5, hasToStringTag$3 = shams(), hasOwn = hasown, gOPD$2 = gopd$1, fn;
if (hasToStringTag$3) {
  var $exec$1 = callBound$3("RegExp.prototype.exec"), isRegexMarker = {}, throwRegexMarker = function() {
    throw isRegexMarker;
  }, badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };
  typeof Symbol.toPrimitive == "symbol" && (badStringifier[Symbol.toPrimitive] = throwRegexMarker), fn = function(e) {
    if (!e || typeof e != "object")
      return !1;
    var n = (
      /** @type {NonNullable<typeof gOPD>} */
      gOPD$2(
        /** @type {{ lastIndex?: unknown }} */
        e,
        "lastIndex"
      )
    ), a = n && hasOwn(n, "value");
    if (!a)
      return !1;
    try {
      $exec$1(
        e,
        /** @type {string} */
        /** @type {unknown} */
        badStringifier
      );
    } catch (u) {
      return u === isRegexMarker;
    }
  };
} else {
  var $toString$1 = callBound$3("Object.prototype.toString"), regexClass = "[object RegExp]";
  fn = function(e) {
    return !e || typeof e != "object" && typeof e != "function" ? !1 : $toString$1(e) === regexClass;
  };
}
var isRegex$1 = fn, callBound$2 = callBound$5, isRegex = isRegex$1, $exec = callBound$2("RegExp.prototype.exec"), $TypeError$2 = type, safeRegexTest$1 = function(e) {
  if (!isRegex(e))
    throw new $TypeError$2("`regex` must be a RegExp");
  return function(a) {
    return $exec(e, a) !== null;
  };
}, callBound$1 = callBound$5, safeRegexTest = safeRegexTest$1, isFnRegex = safeRegexTest(/^\s*(?:function)?\*/), hasToStringTag$2 = shams(), getProto$1 = getProto$3, toStr$2 = callBound$1("Object.prototype.toString"), fnToStr$1 = callBound$1("Function.prototype.toString"), getGeneratorFunc = function() {
  if (!hasToStringTag$2)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, GeneratorFunction, isGeneratorFunction = function(e) {
  if (typeof e != "function")
    return !1;
  if (isFnRegex(fnToStr$1(e)))
    return !0;
  if (!hasToStringTag$2) {
    var n = toStr$2(e);
    return n === "[object GeneratorFunction]";
  }
  if (!getProto$1)
    return !1;
  if (typeof GeneratorFunction > "u") {
    var a = getGeneratorFunc();
    GeneratorFunction = a ? (
      /** @type {GeneratorFunctionConstructor} */
      getProto$1(a)
    ) : !1;
  }
  return getProto$1(e) === GeneratorFunction;
}, fnToStr = Function.prototype.toString, reflectApply = typeof Reflect == "object" && Reflect !== null && Reflect.apply, badArrayLike, isCallableMarker;
if (typeof reflectApply == "function" && typeof Object.defineProperty == "function")
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    }), isCallableMarker = {}, reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (t) {
    t !== isCallableMarker && (reflectApply = null);
  }
else
  reflectApply = null;
var constructorRegex = /^\s*class\b/, isES6ClassFn = function(e) {
  try {
    var n = fnToStr.call(e);
    return constructorRegex.test(n);
  } catch {
    return !1;
  }
}, tryFunctionObject = function(e) {
  try {
    return isES6ClassFn(e) ? !1 : (fnToStr.call(e), !0);
  } catch {
    return !1;
  }
}, toStr$1 = Object.prototype.toString, objectClass = "[object Object]", fnClass = "[object Function]", genClass = "[object GeneratorFunction]", ddaClass = "[object HTMLAllCollection]", ddaClass2 = "[object HTML document.all class]", ddaClass3 = "[object HTMLCollection]", hasToStringTag$1 = typeof Symbol == "function" && !!Symbol.toStringTag, isIE68 = !(0 in [,]), isDDA = function() {
  return !1;
};
if (typeof document == "object") {
  var all = document.all;
  toStr$1.call(all) === toStr$1.call(document.all) && (isDDA = function(e) {
    if ((isIE68 || !e) && (typeof e > "u" || typeof e == "object"))
      try {
        var n = toStr$1.call(e);
        return (n === ddaClass || n === ddaClass2 || n === ddaClass3 || n === objectClass) && e("") == null;
      } catch {
      }
    return !1;
  });
}
var isCallable$1 = reflectApply ? function(e) {
  if (isDDA(e))
    return !0;
  if (!e || typeof e != "function" && typeof e != "object")
    return !1;
  try {
    reflectApply(e, null, badArrayLike);
  } catch (n) {
    if (n !== isCallableMarker)
      return !1;
  }
  return !isES6ClassFn(e) && tryFunctionObject(e);
} : function(e) {
  if (isDDA(e))
    return !0;
  if (!e || typeof e != "function" && typeof e != "object")
    return !1;
  if (hasToStringTag$1)
    return tryFunctionObject(e);
  if (isES6ClassFn(e))
    return !1;
  var n = toStr$1.call(e);
  return n !== fnClass && n !== genClass && !/^\[object HTML/.test(n) ? !1 : tryFunctionObject(e);
}, isCallable = isCallable$1, toStr = Object.prototype.toString, hasOwnProperty = Object.prototype.hasOwnProperty, forEachArray = function(e, n, a) {
  for (var u = 0, o = e.length; u < o; u++)
    hasOwnProperty.call(e, u) && (a == null ? n(e[u], u, e) : n.call(a, e[u], u, e));
}, forEachString = function(e, n, a) {
  for (var u = 0, o = e.length; u < o; u++)
    a == null ? n(e.charAt(u), u, e) : n.call(a, e.charAt(u), u, e);
}, forEachObject = function(e, n, a) {
  for (var u in e)
    hasOwnProperty.call(e, u) && (a == null ? n(e[u], u, e) : n.call(a, e[u], u, e));
};
function isArray$1(t) {
  return toStr.call(t) === "[object Array]";
}
var forEach$1 = function(e, n, a) {
  if (!isCallable(n))
    throw new TypeError("iterator must be a function");
  var u;
  arguments.length >= 3 && (u = a), isArray$1(e) ? forEachArray(e, n, u) : typeof e == "string" ? forEachString(e, n, u) : forEachObject(e, n, u);
}, possibleTypedArrayNames = [
  "Float16Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
], possibleNames = possibleTypedArrayNames, g$1 = typeof globalThis > "u" ? commonjsGlobal : globalThis, availableTypedArrays$1 = function() {
  for (var e = [], n = 0; n < possibleNames.length; n++)
    typeof g$1[possibleNames[n]] == "function" && (e[e.length] = possibleNames[n]);
  return e;
}, callBind$1 = { exports: {} }, $defineProperty$1 = esDefineProperty, $SyntaxError = syntax, $TypeError$1 = type, gopd = gopd$1, defineDataProperty = function(e, n, a) {
  if (!e || typeof e != "object" && typeof e != "function")
    throw new $TypeError$1("`obj` must be an object or a function`");
  if (typeof n != "string" && typeof n != "symbol")
    throw new $TypeError$1("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$1("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$1("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$1("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$1("`loose`, if provided, must be a boolean");
  var u = arguments.length > 3 ? arguments[3] : null, o = arguments.length > 4 ? arguments[4] : null, d = arguments.length > 5 ? arguments[5] : null, l = arguments.length > 6 ? arguments[6] : !1, _ = !!gopd && gopd(e, n);
  if ($defineProperty$1)
    $defineProperty$1(e, n, {
      configurable: d === null && _ ? _.configurable : !d,
      enumerable: u === null && _ ? _.enumerable : !u,
      value: a,
      writable: o === null && _ ? _.writable : !o
    });
  else if (l || !u && !o && !d)
    e[n] = a;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, $defineProperty = esDefineProperty, hasPropertyDescriptors = function() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function() {
  if (!$defineProperty)
    return null;
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors, GetIntrinsic = getIntrinsic, define = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD$1 = gopd$1, $TypeError = type, $floor = GetIntrinsic("%Math.floor%"), setFunctionLength = function(e, n) {
  if (typeof e != "function")
    throw new $TypeError("`fn` is not a function");
  if (typeof n != "number" || n < 0 || n > 4294967295 || $floor(n) !== n)
    throw new $TypeError("`length` must be a positive 32-bit integer");
  var a = arguments.length > 2 && !!arguments[2], u = !0, o = !0;
  if ("length" in e && gOPD$1) {
    var d = gOPD$1(e, "length");
    d && !d.configurable && (u = !1), d && !d.writable && (o = !1);
  }
  return (u || o || !a) && (hasDescriptors ? define(
    /** @type {Parameters<define>[0]} */
    e,
    "length",
    n,
    !0,
    !0
  ) : define(
    /** @type {Parameters<define>[0]} */
    e,
    "length",
    n
  )), e;
}, bind = functionBind, $apply = functionApply, actualApply = actualApply$1, applyBind = function() {
  return actualApply(bind, $apply, arguments);
};
callBind$1.exports;
(function(t) {
  var e = setFunctionLength, n = esDefineProperty, a = callBindApplyHelpers, u = applyBind;
  t.exports = function(d) {
    var l = a(arguments), _ = d.length - (arguments.length - 1);
    return e(
      l,
      1 + (_ > 0 ? _ : 0),
      !0
    );
  }, n ? n(t.exports, "apply", { value: u }) : t.exports.apply = u;
})(callBind$1);
var callBindExports = callBind$1.exports, forEach = forEach$1, availableTypedArrays = availableTypedArrays$1, callBind = callBindExports, callBound = callBound$5, gOPD = gopd$1, getProto = getProto$3, $toString = callBound("Object.prototype.toString"), hasToStringTag = shams(), g = typeof globalThis > "u" ? commonjsGlobal : globalThis, typedArrays = availableTypedArrays(), $slice = callBound("String.prototype.slice"), $indexOf = callBound("Array.prototype.indexOf", !0) || function(e, n) {
  for (var a = 0; a < e.length; a += 1)
    if (e[a] === n)
      return a;
  return -1;
}, cache = { __proto__: null };
hasToStringTag && gOPD && getProto ? forEach(typedArrays, function(t) {
  var e = new g[t]();
  if (Symbol.toStringTag in e && getProto) {
    var n = getProto(e), a = gOPD(n, Symbol.toStringTag);
    if (!a && n) {
      var u = getProto(n);
      a = gOPD(u, Symbol.toStringTag);
    }
    cache["$" + t] = callBind(a.get);
  }
}) : forEach(typedArrays, function(t) {
  var e = new g[t](), n = e.slice || e.set;
  n && (cache[
    /** @type {`$${import('.').TypedArrayName}`} */
    "$" + t
  ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
  // @ts-expect-error TODO FIXME
  callBind(n));
});
var tryTypedArrays = function(e) {
  var n = !1;
  return forEach(
    /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
    cache,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(a, u) {
      if (!n)
        try {
          "$" + a(e) === u && (n = /** @type {import('.').TypedArrayName} */
          $slice(u, 1));
        } catch {
        }
    }
  ), n;
}, trySlices = function(e) {
  var n = !1;
  return forEach(
    /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
    cache,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(a, u) {
      if (!n)
        try {
          a(e), n = /** @type {import('.').TypedArrayName} */
          $slice(u, 1);
        } catch {
        }
    }
  ), n;
}, whichTypedArray$1 = function(e) {
  if (!e || typeof e != "object")
    return !1;
  if (!hasToStringTag) {
    var n = $slice($toString(e), 8, -1);
    return $indexOf(typedArrays, n) > -1 ? n : n !== "Object" ? !1 : trySlices(e);
  }
  return gOPD ? tryTypedArrays(e) : null;
}, whichTypedArray = whichTypedArray$1, isTypedArray = function(e) {
  return !!whichTypedArray(e);
};
(function(t) {
  var e = isArguments, n = isGeneratorFunction, a = whichTypedArray$1, u = isTypedArray;
  function o(ue) {
    return ue.call.bind(ue);
  }
  var d = typeof BigInt < "u", l = typeof Symbol < "u", _ = o(Object.prototype.toString), P = o(Number.prototype.valueOf), h = o(String.prototype.valueOf), x = o(Boolean.prototype.valueOf);
  if (d)
    var C = o(BigInt.prototype.valueOf);
  if (l)
    var D = o(Symbol.prototype.valueOf);
  function q(ue, Oe) {
    if (typeof ue != "object")
      return !1;
    try {
      return Oe(ue), !0;
    } catch {
      return !1;
    }
  }
  t.isArgumentsObject = e, t.isGeneratorFunction = n, t.isTypedArray = u;
  function H(ue) {
    return typeof Promise < "u" && ue instanceof Promise || ue !== null && typeof ue == "object" && typeof ue.then == "function" && typeof ue.catch == "function";
  }
  t.isPromise = H;
  function Y(ue) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(ue) : u(ue) || k(ue);
  }
  t.isArrayBufferView = Y;
  function z(ue) {
    return a(ue) === "Uint8Array";
  }
  t.isUint8Array = z;
  function F(ue) {
    return a(ue) === "Uint8ClampedArray";
  }
  t.isUint8ClampedArray = F;
  function X(ue) {
    return a(ue) === "Uint16Array";
  }
  t.isUint16Array = X;
  function ee(ue) {
    return a(ue) === "Uint32Array";
  }
  t.isUint32Array = ee;
  function se(ue) {
    return a(ue) === "Int8Array";
  }
  t.isInt8Array = se;
  function ce(ue) {
    return a(ue) === "Int16Array";
  }
  t.isInt16Array = ce;
  function le(ue) {
    return a(ue) === "Int32Array";
  }
  t.isInt32Array = le;
  function he(ue) {
    return a(ue) === "Float32Array";
  }
  t.isFloat32Array = he;
  function oe(ue) {
    return a(ue) === "Float64Array";
  }
  t.isFloat64Array = oe;
  function _e(ue) {
    return a(ue) === "BigInt64Array";
  }
  t.isBigInt64Array = _e;
  function J(ue) {
    return a(ue) === "BigUint64Array";
  }
  t.isBigUint64Array = J;
  function w(ue) {
    return _(ue) === "[object Map]";
  }
  w.working = typeof Map < "u" && w(/* @__PURE__ */ new Map());
  function m(ue) {
    return typeof Map > "u" ? !1 : w.working ? w(ue) : ue instanceof Map;
  }
  t.isMap = m;
  function c(ue) {
    return _(ue) === "[object Set]";
  }
  c.working = typeof Set < "u" && c(/* @__PURE__ */ new Set());
  function v(ue) {
    return typeof Set > "u" ? !1 : c.working ? c(ue) : ue instanceof Set;
  }
  t.isSet = v;
  function $(ue) {
    return _(ue) === "[object WeakMap]";
  }
  $.working = typeof WeakMap < "u" && $(/* @__PURE__ */ new WeakMap());
  function S(ue) {
    return typeof WeakMap > "u" ? !1 : $.working ? $(ue) : ue instanceof WeakMap;
  }
  t.isWeakMap = S;
  function A(ue) {
    return _(ue) === "[object WeakSet]";
  }
  A.working = typeof WeakSet < "u" && A(/* @__PURE__ */ new WeakSet());
  function M(ue) {
    return A(ue);
  }
  t.isWeakSet = M;
  function p(ue) {
    return _(ue) === "[object ArrayBuffer]";
  }
  p.working = typeof ArrayBuffer < "u" && p(new ArrayBuffer());
  function B(ue) {
    return typeof ArrayBuffer > "u" ? !1 : p.working ? p(ue) : ue instanceof ArrayBuffer;
  }
  t.isArrayBuffer = B;
  function b(ue) {
    return _(ue) === "[object DataView]";
  }
  b.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && b(new DataView(new ArrayBuffer(1), 0, 1));
  function k(ue) {
    return typeof DataView > "u" ? !1 : b.working ? b(ue) : ue instanceof DataView;
  }
  t.isDataView = k;
  var Z = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function te(ue) {
    return _(ue) === "[object SharedArrayBuffer]";
  }
  function V(ue) {
    return typeof Z > "u" ? !1 : (typeof te.working > "u" && (te.working = te(new Z())), te.working ? te(ue) : ue instanceof Z);
  }
  t.isSharedArrayBuffer = V;
  function T(ue) {
    return _(ue) === "[object AsyncFunction]";
  }
  t.isAsyncFunction = T;
  function O(ue) {
    return _(ue) === "[object Map Iterator]";
  }
  t.isMapIterator = O;
  function Q(ue) {
    return _(ue) === "[object Set Iterator]";
  }
  t.isSetIterator = Q;
  function ie(ue) {
    return _(ue) === "[object Generator]";
  }
  t.isGeneratorObject = ie;
  function L(ue) {
    return _(ue) === "[object WebAssembly.Module]";
  }
  t.isWebAssemblyCompiledModule = L;
  function j(ue) {
    return q(ue, P);
  }
  t.isNumberObject = j;
  function ne(ue) {
    return q(ue, h);
  }
  t.isStringObject = ne;
  function de(ue) {
    return q(ue, x);
  }
  t.isBooleanObject = de;
  function pe(ue) {
    return d && q(ue, C);
  }
  t.isBigIntObject = pe;
  function be(ue) {
    return l && q(ue, D);
  }
  t.isSymbolObject = be;
  function me(ue) {
    return j(ue) || ne(ue) || de(ue) || pe(ue) || be(ue);
  }
  t.isBoxedPrimitive = me;
  function we(ue) {
    return typeof Uint8Array < "u" && (B(ue) || V(ue));
  }
  t.isAnyArrayBuffer = we, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(ue) {
    Object.defineProperty(t, ue, {
      enumerable: !1,
      value: function() {
        throw new Error(ue + " is not supported in userland");
      }
    });
  });
})(types);
var isBufferBrowser = function(e) {
  return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
};
(function(t) {
  var e = Object.getOwnPropertyDescriptors || function(k) {
    for (var Z = Object.keys(k), te = {}, V = 0; V < Z.length; V++)
      te[Z[V]] = Object.getOwnPropertyDescriptor(k, Z[V]);
    return te;
  }, n = /%[sdj%]/g;
  t.format = function(b) {
    if (!se(b)) {
      for (var k = [], Z = 0; Z < arguments.length; Z++)
        k.push(d(arguments[Z]));
      return k.join(" ");
    }
    for (var Z = 1, te = arguments, V = te.length, T = String(b).replace(n, function(Q) {
      if (Q === "%%") return "%";
      if (Z >= V) return Q;
      switch (Q) {
        case "%s":
          return String(te[Z++]);
        case "%d":
          return Number(te[Z++]);
        case "%j":
          try {
            return JSON.stringify(te[Z++]);
          } catch {
            return "[Circular]";
          }
        default:
          return Q;
      }
    }), O = te[Z]; Z < V; O = te[++Z])
      F(O) || !oe(O) ? T += " " + O : T += " " + d(O);
    return T;
  }, t.deprecate = function(b, k) {
    if (typeof process$1 < "u" && process$1.noDeprecation === !0)
      return b;
    if (typeof process$1 > "u")
      return function() {
        return t.deprecate(b, k).apply(this, arguments);
      };
    var Z = !1;
    function te() {
      if (!Z) {
        if (process$1.throwDeprecation)
          throw new Error(k);
        process$1.traceDeprecation ? console.trace(k) : console.error(k), Z = !0;
      }
      return b.apply(this, arguments);
    }
    return te;
  };
  var a = {}, u = /^$/;
  if (process$1.env.NODE_DEBUG) {
    var o = process$1.env.NODE_DEBUG;
    o = o.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), u = new RegExp("^" + o + "$", "i");
  }
  t.debuglog = function(b) {
    if (b = b.toUpperCase(), !a[b])
      if (u.test(b)) {
        var k = process$1.pid;
        a[b] = function() {
          var Z = t.format.apply(t, arguments);
          console.error("%s %d: %s", b, k, Z);
        };
      } else
        a[b] = function() {
        };
    return a[b];
  };
  function d(b, k) {
    var Z = {
      seen: [],
      stylize: _
    };
    return arguments.length >= 3 && (Z.depth = arguments[2]), arguments.length >= 4 && (Z.colors = arguments[3]), z(k) ? Z.showHidden = k : k && t._extend(Z, k), le(Z.showHidden) && (Z.showHidden = !1), le(Z.depth) && (Z.depth = 2), le(Z.colors) && (Z.colors = !1), le(Z.customInspect) && (Z.customInspect = !0), Z.colors && (Z.stylize = l), h(Z, b, Z.depth);
  }
  t.inspect = d, d.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, d.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function l(b, k) {
    var Z = d.styles[k];
    return Z ? "\x1B[" + d.colors[Z][0] + "m" + b + "\x1B[" + d.colors[Z][1] + "m" : b;
  }
  function _(b, k) {
    return b;
  }
  function P(b) {
    var k = {};
    return b.forEach(function(Z, te) {
      k[Z] = !0;
    }), k;
  }
  function h(b, k, Z) {
    if (b.customInspect && k && w(k.inspect) && // Filter out the util module, it's inspect function is special
    k.inspect !== t.inspect && // Also filter out any prototype objects using the circular check.
    !(k.constructor && k.constructor.prototype === k)) {
      var te = k.inspect(Z, b);
      return se(te) || (te = h(b, te, Z)), te;
    }
    var V = x(b, k);
    if (V)
      return V;
    var T = Object.keys(k), O = P(T);
    if (b.showHidden && (T = Object.getOwnPropertyNames(k)), J(k) && (T.indexOf("message") >= 0 || T.indexOf("description") >= 0))
      return C(k);
    if (T.length === 0) {
      if (w(k)) {
        var Q = k.name ? ": " + k.name : "";
        return b.stylize("[Function" + Q + "]", "special");
      }
      if (he(k))
        return b.stylize(RegExp.prototype.toString.call(k), "regexp");
      if (_e(k))
        return b.stylize(Date.prototype.toString.call(k), "date");
      if (J(k))
        return C(k);
    }
    var ie = "", L = !1, j = ["{", "}"];
    if (Y(k) && (L = !0, j = ["[", "]"]), w(k)) {
      var ne = k.name ? ": " + k.name : "";
      ie = " [Function" + ne + "]";
    }
    if (he(k) && (ie = " " + RegExp.prototype.toString.call(k)), _e(k) && (ie = " " + Date.prototype.toUTCString.call(k)), J(k) && (ie = " " + C(k)), T.length === 0 && (!L || k.length == 0))
      return j[0] + ie + j[1];
    if (Z < 0)
      return he(k) ? b.stylize(RegExp.prototype.toString.call(k), "regexp") : b.stylize("[Object]", "special");
    b.seen.push(k);
    var de;
    return L ? de = D(b, k, Z, O, T) : de = T.map(function(pe) {
      return q(b, k, Z, O, pe, L);
    }), b.seen.pop(), H(de, ie, j);
  }
  function x(b, k) {
    if (le(k))
      return b.stylize("undefined", "undefined");
    if (se(k)) {
      var Z = "'" + JSON.stringify(k).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return b.stylize(Z, "string");
    }
    if (ee(k))
      return b.stylize("" + k, "number");
    if (z(k))
      return b.stylize("" + k, "boolean");
    if (F(k))
      return b.stylize("null", "null");
  }
  function C(b) {
    return "[" + Error.prototype.toString.call(b) + "]";
  }
  function D(b, k, Z, te, V) {
    for (var T = [], O = 0, Q = k.length; O < Q; ++O)
      A(k, String(O)) ? T.push(q(
        b,
        k,
        Z,
        te,
        String(O),
        !0
      )) : T.push("");
    return V.forEach(function(ie) {
      ie.match(/^\d+$/) || T.push(q(
        b,
        k,
        Z,
        te,
        ie,
        !0
      ));
    }), T;
  }
  function q(b, k, Z, te, V, T) {
    var O, Q, ie;
    if (ie = Object.getOwnPropertyDescriptor(k, V) || { value: k[V] }, ie.get ? ie.set ? Q = b.stylize("[Getter/Setter]", "special") : Q = b.stylize("[Getter]", "special") : ie.set && (Q = b.stylize("[Setter]", "special")), A(te, V) || (O = "[" + V + "]"), Q || (b.seen.indexOf(ie.value) < 0 ? (F(Z) ? Q = h(b, ie.value, null) : Q = h(b, ie.value, Z - 1), Q.indexOf(`
`) > -1 && (T ? Q = Q.split(`
`).map(function(L) {
      return "  " + L;
    }).join(`
`).slice(2) : Q = `
` + Q.split(`
`).map(function(L) {
      return "   " + L;
    }).join(`
`))) : Q = b.stylize("[Circular]", "special")), le(O)) {
      if (T && V.match(/^\d+$/))
        return Q;
      O = JSON.stringify("" + V), O.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (O = O.slice(1, -1), O = b.stylize(O, "name")) : (O = O.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), O = b.stylize(O, "string"));
    }
    return O + ": " + Q;
  }
  function H(b, k, Z) {
    var te = b.reduce(function(V, T) {
      return T.indexOf(`
`) >= 0, V + T.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return te > 60 ? Z[0] + (k === "" ? "" : k + `
 `) + " " + b.join(`,
  `) + " " + Z[1] : Z[0] + k + " " + b.join(", ") + " " + Z[1];
  }
  t.types = types;
  function Y(b) {
    return Array.isArray(b);
  }
  t.isArray = Y;
  function z(b) {
    return typeof b == "boolean";
  }
  t.isBoolean = z;
  function F(b) {
    return b === null;
  }
  t.isNull = F;
  function X(b) {
    return b == null;
  }
  t.isNullOrUndefined = X;
  function ee(b) {
    return typeof b == "number";
  }
  t.isNumber = ee;
  function se(b) {
    return typeof b == "string";
  }
  t.isString = se;
  function ce(b) {
    return typeof b == "symbol";
  }
  t.isSymbol = ce;
  function le(b) {
    return b === void 0;
  }
  t.isUndefined = le;
  function he(b) {
    return oe(b) && c(b) === "[object RegExp]";
  }
  t.isRegExp = he, t.types.isRegExp = he;
  function oe(b) {
    return typeof b == "object" && b !== null;
  }
  t.isObject = oe;
  function _e(b) {
    return oe(b) && c(b) === "[object Date]";
  }
  t.isDate = _e, t.types.isDate = _e;
  function J(b) {
    return oe(b) && (c(b) === "[object Error]" || b instanceof Error);
  }
  t.isError = J, t.types.isNativeError = J;
  function w(b) {
    return typeof b == "function";
  }
  t.isFunction = w;
  function m(b) {
    return b === null || typeof b == "boolean" || typeof b == "number" || typeof b == "string" || typeof b == "symbol" || // ES6 symbol
    typeof b > "u";
  }
  t.isPrimitive = m, t.isBuffer = isBufferBrowser;
  function c(b) {
    return Object.prototype.toString.call(b);
  }
  function v(b) {
    return b < 10 ? "0" + b.toString(10) : b.toString(10);
  }
  var $ = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function S() {
    var b = /* @__PURE__ */ new Date(), k = [
      v(b.getHours()),
      v(b.getMinutes()),
      v(b.getSeconds())
    ].join(":");
    return [b.getDate(), $[b.getMonth()], k].join(" ");
  }
  t.log = function() {
    console.log("%s - %s", S(), t.format.apply(t, arguments));
  }, t.inherits = inherits_browserExports, t._extend = function(b, k) {
    if (!k || !oe(k)) return b;
    for (var Z = Object.keys(k), te = Z.length; te--; )
      b[Z[te]] = k[Z[te]];
    return b;
  };
  function A(b, k) {
    return Object.prototype.hasOwnProperty.call(b, k);
  }
  var M = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  t.promisify = function(k) {
    if (typeof k != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (M && k[M]) {
      var Z = k[M];
      if (typeof Z != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(Z, M, {
        value: Z,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Z;
    }
    function Z() {
      for (var te, V, T = new Promise(function(ie, L) {
        te = ie, V = L;
      }), O = [], Q = 0; Q < arguments.length; Q++)
        O.push(arguments[Q]);
      O.push(function(ie, L) {
        ie ? V(ie) : te(L);
      });
      try {
        k.apply(this, O);
      } catch (ie) {
        V(ie);
      }
      return T;
    }
    return Object.setPrototypeOf(Z, Object.getPrototypeOf(k)), M && Object.defineProperty(Z, M, {
      value: Z,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      Z,
      e(k)
    );
  }, t.promisify.custom = M;
  function p(b, k) {
    if (!b) {
      var Z = new Error("Promise was rejected with a falsy value");
      Z.reason = b, b = Z;
    }
    return k(b);
  }
  function B(b) {
    if (typeof b != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function k() {
      for (var Z = [], te = 0; te < arguments.length; te++)
        Z.push(arguments[te]);
      var V = Z.pop();
      if (typeof V != "function")
        throw new TypeError("The last argument must be of type Function");
      var T = this, O = function() {
        return V.apply(T, arguments);
      };
      b.apply(this, Z).then(
        function(Q) {
          process$1.nextTick(O.bind(null, null, Q));
        },
        function(Q) {
          process$1.nextTick(p.bind(null, Q, O));
        }
      );
    }
    return Object.setPrototypeOf(k, Object.getPrototypeOf(b)), Object.defineProperties(
      k,
      e(b)
    ), k;
  }
  t.callbackify = B;
})(util$3);
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function t(q, H) {
    var Y = Object.keys(q);
    if (Object.getOwnPropertySymbols) {
      var z = Object.getOwnPropertySymbols(q);
      H && (z = z.filter(function(F) {
        return Object.getOwnPropertyDescriptor(q, F).enumerable;
      })), Y.push.apply(Y, z);
    }
    return Y;
  }
  function e(q) {
    for (var H = 1; H < arguments.length; H++) {
      var Y = arguments[H] != null ? arguments[H] : {};
      H % 2 ? t(Object(Y), !0).forEach(function(z) {
        n(q, z, Y[z]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(q, Object.getOwnPropertyDescriptors(Y)) : t(Object(Y)).forEach(function(z) {
        Object.defineProperty(q, z, Object.getOwnPropertyDescriptor(Y, z));
      });
    }
    return q;
  }
  function n(q, H, Y) {
    return H = d(H), H in q ? Object.defineProperty(q, H, { value: Y, enumerable: !0, configurable: !0, writable: !0 }) : q[H] = Y, q;
  }
  function a(q, H) {
    if (!(q instanceof H))
      throw new TypeError("Cannot call a class as a function");
  }
  function u(q, H) {
    for (var Y = 0; Y < H.length; Y++) {
      var z = H[Y];
      z.enumerable = z.enumerable || !1, z.configurable = !0, "value" in z && (z.writable = !0), Object.defineProperty(q, d(z.key), z);
    }
  }
  function o(q, H, Y) {
    return H && u(q.prototype, H), Object.defineProperty(q, "prototype", { writable: !1 }), q;
  }
  function d(q) {
    var H = l(q, "string");
    return typeof H == "symbol" ? H : String(H);
  }
  function l(q, H) {
    if (typeof q != "object" || q === null) return q;
    var Y = q[Symbol.toPrimitive];
    if (Y !== void 0) {
      var z = Y.call(q, H);
      if (typeof z != "object") return z;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(q);
  }
  var _ = require$$1$2, P = _.Buffer, h = util$3, x = h.inspect, C = x && x.custom || "inspect";
  function D(q, H, Y) {
    P.prototype.copy.call(q, H, Y);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function q() {
      a(this, q), this.head = null, this.tail = null, this.length = 0;
    }
    return o(q, [{
      key: "push",
      value: function(Y) {
        var z = {
          data: Y,
          next: null
        };
        this.length > 0 ? this.tail.next = z : this.head = z, this.tail = z, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(Y) {
        var z = {
          data: Y,
          next: this.head
        };
        this.length === 0 && (this.tail = z), this.head = z, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var Y = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Y;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(Y) {
        if (this.length === 0) return "";
        for (var z = this.head, F = "" + z.data; z = z.next; ) F += Y + z.data;
        return F;
      }
    }, {
      key: "concat",
      value: function(Y) {
        if (this.length === 0) return P.alloc(0);
        for (var z = P.allocUnsafe(Y >>> 0), F = this.head, X = 0; F; )
          D(F.data, z, X), X += F.data.length, F = F.next;
        return z;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(Y, z) {
        var F;
        return Y < this.head.data.length ? (F = this.head.data.slice(0, Y), this.head.data = this.head.data.slice(Y)) : Y === this.head.data.length ? F = this.shift() : F = z ? this._getString(Y) : this._getBuffer(Y), F;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(Y) {
        var z = this.head, F = 1, X = z.data;
        for (Y -= X.length; z = z.next; ) {
          var ee = z.data, se = Y > ee.length ? ee.length : Y;
          if (se === ee.length ? X += ee : X += ee.slice(0, Y), Y -= se, Y === 0) {
            se === ee.length ? (++F, z.next ? this.head = z.next : this.head = this.tail = null) : (this.head = z, z.data = ee.slice(se));
            break;
          }
          ++F;
        }
        return this.length -= F, X;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(Y) {
        var z = P.allocUnsafe(Y), F = this.head, X = 1;
        for (F.data.copy(z), Y -= F.data.length; F = F.next; ) {
          var ee = F.data, se = Y > ee.length ? ee.length : Y;
          if (ee.copy(z, z.length - Y, 0, se), Y -= se, Y === 0) {
            se === ee.length ? (++X, F.next ? this.head = F.next : this.head = this.tail = null) : (this.head = F, F.data = ee.slice(se));
            break;
          }
          ++X;
        }
        return this.length -= X, z;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: C,
      value: function(Y, z) {
        return x(this, e(e({}, z), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), q;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1$1;
  hasRequiredDestroy = 1;
  function t(d, l) {
    var _ = this, P = this._readableState && this._readableState.destroyed, h = this._writableState && this._writableState.destroyed;
    return P || h ? (l ? l(d) : d && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(u, this, d)) : process$1.nextTick(u, this, d)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(d || null, function(x) {
      !l && x ? _._writableState ? _._writableState.errorEmitted ? process$1.nextTick(n, _) : (_._writableState.errorEmitted = !0, process$1.nextTick(e, _, x)) : process$1.nextTick(e, _, x) : l ? (process$1.nextTick(n, _), l(x)) : process$1.nextTick(n, _);
    }), this);
  }
  function e(d, l) {
    u(d, l), n(d);
  }
  function n(d) {
    d._writableState && !d._writableState.emitClose || d._readableState && !d._readableState.emitClose || d.emit("close");
  }
  function a() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function u(d, l) {
    d.emit("error", l);
  }
  function o(d, l) {
    var _ = d._readableState, P = d._writableState;
    _ && _.autoDestroy || P && P.autoDestroy ? d.destroy(l) : d.emit("error", l);
  }
  return destroy_1$1 = {
    destroy: t,
    undestroy: a,
    errorOrDestroy: o
  }, destroy_1$1;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function t(l, _) {
    l.prototype = Object.create(_.prototype), l.prototype.constructor = l, l.__proto__ = _;
  }
  var e = {};
  function n(l, _, P) {
    P || (P = Error);
    function h(C, D, q) {
      return typeof _ == "string" ? _ : _(C, D, q);
    }
    var x = /* @__PURE__ */ function(C) {
      t(D, C);
      function D(q, H, Y) {
        return C.call(this, h(q, H, Y)) || this;
      }
      return D;
    }(P);
    x.prototype.name = P.name, x.prototype.code = l, e[l] = x;
  }
  function a(l, _) {
    if (Array.isArray(l)) {
      var P = l.length;
      return l = l.map(function(h) {
        return String(h);
      }), P > 2 ? "one of ".concat(_, " ").concat(l.slice(0, P - 1).join(", "), ", or ") + l[P - 1] : P === 2 ? "one of ".concat(_, " ").concat(l[0], " or ").concat(l[1]) : "of ".concat(_, " ").concat(l[0]);
    } else
      return "of ".concat(_, " ").concat(String(l));
  }
  function u(l, _, P) {
    return l.substr(0, _.length) === _;
  }
  function o(l, _, P) {
    return (P === void 0 || P > l.length) && (P = l.length), l.substring(P - _.length, P) === _;
  }
  function d(l, _, P) {
    return typeof P != "number" && (P = 0), P + _.length > l.length ? !1 : l.indexOf(_, P) !== -1;
  }
  return n("ERR_INVALID_OPT_VALUE", function(l, _) {
    return 'The value "' + _ + '" is invalid for option "' + l + '"';
  }, TypeError), n("ERR_INVALID_ARG_TYPE", function(l, _, P) {
    var h;
    typeof _ == "string" && u(_, "not ") ? (h = "must not be", _ = _.replace(/^not /, "")) : h = "must be";
    var x;
    if (o(l, " argument"))
      x = "The ".concat(l, " ").concat(h, " ").concat(a(_, "type"));
    else {
      var C = d(l, ".") ? "property" : "argument";
      x = 'The "'.concat(l, '" ').concat(C, " ").concat(h, " ").concat(a(_, "type"));
    }
    return x += ". Received type ".concat(typeof P), x;
  }, TypeError), n("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), n("ERR_METHOD_NOT_IMPLEMENTED", function(l) {
    return "The " + l + " method is not implemented";
  }), n("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), n("ERR_STREAM_DESTROYED", function(l) {
    return "Cannot call " + l + " after a stream was destroyed";
  }), n("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), n("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), n("ERR_STREAM_WRITE_AFTER_END", "write after end"), n("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), n("ERR_UNKNOWN_ENCODING", function(l) {
    return "Unknown encoding: " + l;
  }, TypeError), n("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = e, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var t = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function e(a, u, o) {
    return a.highWaterMark != null ? a.highWaterMark : u ? a[o] : null;
  }
  function n(a, u, o, d) {
    var l = e(u, d, o);
    if (l != null) {
      if (!(isFinite(l) && Math.floor(l) === l) || l < 0) {
        var _ = d ? o : "highWaterMark";
        throw new t(_, l);
      }
      return Math.floor(l);
    }
    return a.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: n
  }, state;
}
var browser$a = deprecate;
function deprecate(t, e) {
  if (config("noDeprecation"))
    return t;
  var n = !1;
  function a() {
    if (!n) {
      if (config("throwDeprecation"))
        throw new Error(e);
      config("traceDeprecation") ? console.trace(e) : console.warn(e), n = !0;
    }
    return t.apply(this, arguments);
  }
  return a;
}
function config(t) {
  try {
    if (!commonjsGlobal.localStorage) return !1;
  } catch {
    return !1;
  }
  var e = commonjsGlobal.localStorage[t];
  return e == null ? !1 : String(e).toLowerCase() === "true";
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = he;
  function t(V) {
    var T = this;
    this.next = null, this.entry = null, this.finish = function() {
      te(T, V);
    };
  }
  var e;
  he.WritableState = ce;
  var n = {
    deprecate: browser$a
  }, a = requireStreamBrowser(), u = require$$1$2.Buffer, o = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function d(V) {
    return u.from(V);
  }
  function l(V) {
    return u.isBuffer(V) || V instanceof o;
  }
  var _ = requireDestroy(), P = requireState(), h = P.getHighWaterMark, x = requireErrorsBrowser().codes, C = x.ERR_INVALID_ARG_TYPE, D = x.ERR_METHOD_NOT_IMPLEMENTED, q = x.ERR_MULTIPLE_CALLBACK, H = x.ERR_STREAM_CANNOT_PIPE, Y = x.ERR_STREAM_DESTROYED, z = x.ERR_STREAM_NULL_VALUES, F = x.ERR_STREAM_WRITE_AFTER_END, X = x.ERR_UNKNOWN_ENCODING, ee = _.errorOrDestroy;
  inherits_browserExports(he, a);
  function se() {
  }
  function ce(V, T, O) {
    e = e || require_stream_duplex$1(), V = V || {}, typeof O != "boolean" && (O = T instanceof e), this.objectMode = !!V.objectMode, O && (this.objectMode = this.objectMode || !!V.writableObjectMode), this.highWaterMark = h(this, V, "writableHighWaterMark", O), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Q = V.decodeStrings === !1;
    this.decodeStrings = !Q, this.defaultEncoding = V.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ie) {
      $(T, ie);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = V.emitClose !== !1, this.autoDestroy = !!V.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  ce.prototype.getBuffer = function() {
    for (var T = this.bufferedRequest, O = []; T; )
      O.push(T), T = T.next;
    return O;
  }, function() {
    try {
      Object.defineProperty(ce.prototype, "buffer", {
        get: n.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var le;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (le = Function.prototype[Symbol.hasInstance], Object.defineProperty(he, Symbol.hasInstance, {
    value: function(T) {
      return le.call(this, T) ? !0 : this !== he ? !1 : T && T._writableState instanceof ce;
    }
  })) : le = function(T) {
    return T instanceof this;
  };
  function he(V) {
    e = e || require_stream_duplex$1();
    var T = this instanceof e;
    if (!T && !le.call(he, this)) return new he(V);
    this._writableState = new ce(V, this, T), this.writable = !0, V && (typeof V.write == "function" && (this._write = V.write), typeof V.writev == "function" && (this._writev = V.writev), typeof V.destroy == "function" && (this._destroy = V.destroy), typeof V.final == "function" && (this._final = V.final)), a.call(this);
  }
  he.prototype.pipe = function() {
    ee(this, new H());
  };
  function oe(V, T) {
    var O = new F();
    ee(V, O), process$1.nextTick(T, O);
  }
  function _e(V, T, O, Q) {
    var ie;
    return O === null ? ie = new z() : typeof O != "string" && !T.objectMode && (ie = new C("chunk", ["string", "Buffer"], O)), ie ? (ee(V, ie), process$1.nextTick(Q, ie), !1) : !0;
  }
  he.prototype.write = function(V, T, O) {
    var Q = this._writableState, ie = !1, L = !Q.objectMode && l(V);
    return L && !u.isBuffer(V) && (V = d(V)), typeof T == "function" && (O = T, T = null), L ? T = "buffer" : T || (T = Q.defaultEncoding), typeof O != "function" && (O = se), Q.ending ? oe(this, O) : (L || _e(this, Q, V, O)) && (Q.pendingcb++, ie = w(this, Q, L, V, T, O)), ie;
  }, he.prototype.cork = function() {
    this._writableState.corked++;
  }, he.prototype.uncork = function() {
    var V = this._writableState;
    V.corked && (V.corked--, !V.writing && !V.corked && !V.bufferProcessing && V.bufferedRequest && M(this, V));
  }, he.prototype.setDefaultEncoding = function(T) {
    if (typeof T == "string" && (T = T.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((T + "").toLowerCase()) > -1)) throw new X(T);
    return this._writableState.defaultEncoding = T, this;
  }, Object.defineProperty(he.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function J(V, T, O) {
    return !V.objectMode && V.decodeStrings !== !1 && typeof T == "string" && (T = u.from(T, O)), T;
  }
  Object.defineProperty(he.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function w(V, T, O, Q, ie, L) {
    if (!O) {
      var j = J(T, Q, ie);
      Q !== j && (O = !0, ie = "buffer", Q = j);
    }
    var ne = T.objectMode ? 1 : Q.length;
    T.length += ne;
    var de = T.length < T.highWaterMark;
    if (de || (T.needDrain = !0), T.writing || T.corked) {
      var pe = T.lastBufferedRequest;
      T.lastBufferedRequest = {
        chunk: Q,
        encoding: ie,
        isBuf: O,
        callback: L,
        next: null
      }, pe ? pe.next = T.lastBufferedRequest : T.bufferedRequest = T.lastBufferedRequest, T.bufferedRequestCount += 1;
    } else
      m(V, T, !1, ne, Q, ie, L);
    return de;
  }
  function m(V, T, O, Q, ie, L, j) {
    T.writelen = Q, T.writecb = j, T.writing = !0, T.sync = !0, T.destroyed ? T.onwrite(new Y("write")) : O ? V._writev(ie, T.onwrite) : V._write(ie, L, T.onwrite), T.sync = !1;
  }
  function c(V, T, O, Q, ie) {
    --T.pendingcb, O ? (process$1.nextTick(ie, Q), process$1.nextTick(k, V, T), V._writableState.errorEmitted = !0, ee(V, Q)) : (ie(Q), V._writableState.errorEmitted = !0, ee(V, Q), k(V, T));
  }
  function v(V) {
    V.writing = !1, V.writecb = null, V.length -= V.writelen, V.writelen = 0;
  }
  function $(V, T) {
    var O = V._writableState, Q = O.sync, ie = O.writecb;
    if (typeof ie != "function") throw new q();
    if (v(O), T) c(V, O, Q, T, ie);
    else {
      var L = p(O) || V.destroyed;
      !L && !O.corked && !O.bufferProcessing && O.bufferedRequest && M(V, O), Q ? process$1.nextTick(S, V, O, L, ie) : S(V, O, L, ie);
    }
  }
  function S(V, T, O, Q) {
    O || A(V, T), T.pendingcb--, Q(), k(V, T);
  }
  function A(V, T) {
    T.length === 0 && T.needDrain && (T.needDrain = !1, V.emit("drain"));
  }
  function M(V, T) {
    T.bufferProcessing = !0;
    var O = T.bufferedRequest;
    if (V._writev && O && O.next) {
      var Q = T.bufferedRequestCount, ie = new Array(Q), L = T.corkedRequestsFree;
      L.entry = O;
      for (var j = 0, ne = !0; O; )
        ie[j] = O, O.isBuf || (ne = !1), O = O.next, j += 1;
      ie.allBuffers = ne, m(V, T, !0, T.length, ie, "", L.finish), T.pendingcb++, T.lastBufferedRequest = null, L.next ? (T.corkedRequestsFree = L.next, L.next = null) : T.corkedRequestsFree = new t(T), T.bufferedRequestCount = 0;
    } else {
      for (; O; ) {
        var de = O.chunk, pe = O.encoding, be = O.callback, me = T.objectMode ? 1 : de.length;
        if (m(V, T, !1, me, de, pe, be), O = O.next, T.bufferedRequestCount--, T.writing)
          break;
      }
      O === null && (T.lastBufferedRequest = null);
    }
    T.bufferedRequest = O, T.bufferProcessing = !1;
  }
  he.prototype._write = function(V, T, O) {
    O(new D("_write()"));
  }, he.prototype._writev = null, he.prototype.end = function(V, T, O) {
    var Q = this._writableState;
    return typeof V == "function" ? (O = V, V = null, T = null) : typeof T == "function" && (O = T, T = null), V != null && this.write(V, T), Q.corked && (Q.corked = 1, this.uncork()), Q.ending || Z(this, Q, O), this;
  }, Object.defineProperty(he.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function p(V) {
    return V.ending && V.length === 0 && V.bufferedRequest === null && !V.finished && !V.writing;
  }
  function B(V, T) {
    V._final(function(O) {
      T.pendingcb--, O && ee(V, O), T.prefinished = !0, V.emit("prefinish"), k(V, T);
    });
  }
  function b(V, T) {
    !T.prefinished && !T.finalCalled && (typeof V._final == "function" && !T.destroyed ? (T.pendingcb++, T.finalCalled = !0, process$1.nextTick(B, V, T)) : (T.prefinished = !0, V.emit("prefinish")));
  }
  function k(V, T) {
    var O = p(T);
    if (O && (b(V, T), T.pendingcb === 0 && (T.finished = !0, V.emit("finish"), T.autoDestroy))) {
      var Q = V._readableState;
      (!Q || Q.autoDestroy && Q.endEmitted) && V.destroy();
    }
    return O;
  }
  function Z(V, T, O) {
    T.ending = !0, k(V, T), O && (T.finished ? process$1.nextTick(O) : V.once("finish", O)), T.ended = !0, V.writable = !1;
  }
  function te(V, T, O) {
    var Q = V.entry;
    for (V.entry = null; Q; ) {
      var ie = Q.callback;
      T.pendingcb--, ie(O), Q = Q.next;
    }
    T.corkedRequestsFree.next = V;
  }
  return Object.defineProperty(he.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(T) {
      this._writableState && (this._writableState.destroyed = T);
    }
  }), he.prototype.destroy = _.destroy, he.prototype._undestroy = _.undestroy, he.prototype._destroy = function(V, T) {
    T(V);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var t = Object.keys || function(P) {
    var h = [];
    for (var x in P) h.push(x);
    return h;
  };
  _stream_duplex$1 = d;
  var e = require_stream_readable$1(), n = require_stream_writable$1();
  inherits_browserExports(d, e);
  for (var a = t(n.prototype), u = 0; u < a.length; u++) {
    var o = a[u];
    d.prototype[o] || (d.prototype[o] = n.prototype[o]);
  }
  function d(P) {
    if (!(this instanceof d)) return new d(P);
    e.call(this, P), n.call(this, P), this.allowHalfOpen = !0, P && (P.readable === !1 && (this.readable = !1), P.writable === !1 && (this.writable = !1), P.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", l)));
  }
  Object.defineProperty(d.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(d.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(d.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function l() {
    this._writableState.ended || process$1.nextTick(_, this);
  }
  function _(P) {
    P.end();
  }
  return Object.defineProperty(d.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(h) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = h, this._writableState.destroyed = h);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, safeBuffer$1 = { exports: {} };
safeBuffer$1.exports;
(function(t, e) {
  var n = require$$1$2, a = n.Buffer;
  function u(d, l) {
    for (var _ in d)
      l[_] = d[_];
  }
  a.from && a.alloc && a.allocUnsafe && a.allocUnsafeSlow ? t.exports = n : (u(n, e), e.Buffer = o);
  function o(d, l, _) {
    return a(d, l, _);
  }
  u(a, o), o.from = function(d, l, _) {
    if (typeof d == "number")
      throw new TypeError("Argument must not be a number");
    return a(d, l, _);
  }, o.alloc = function(d, l, _) {
    if (typeof d != "number")
      throw new TypeError("Argument must be a number");
    var P = a(d);
    return l !== void 0 ? typeof _ == "string" ? P.fill(l, _) : P.fill(l) : P.fill(0), P;
  }, o.allocUnsafe = function(d) {
    if (typeof d != "number")
      throw new TypeError("Argument must be a number");
    return a(d);
  }, o.allocUnsafeSlow = function(d) {
    if (typeof d != "number")
      throw new TypeError("Argument must be a number");
    return n.SlowBuffer(d);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, Buffer$A = safeBufferExports.Buffer, isEncoding = Buffer$A.isEncoding || function(t) {
  switch (t = "" + t, t && t.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function _normalizeEncoding(t) {
  if (!t) return "utf8";
  for (var e; ; )
    switch (t) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return t;
      default:
        if (e) return;
        t = ("" + t).toLowerCase(), e = !0;
    }
}
function normalizeEncoding(t) {
  var e = _normalizeEncoding(t);
  if (typeof e != "string" && (Buffer$A.isEncoding === isEncoding || !isEncoding(t))) throw new Error("Unknown encoding: " + t);
  return e || t;
}
string_decoder.StringDecoder = StringDecoder$1;
function StringDecoder$1(t) {
  this.encoding = normalizeEncoding(t);
  var e;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text, this.end = utf16End, e = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast, e = 4;
      break;
    case "base64":
      this.text = base64Text, this.end = base64End, e = 3;
      break;
    default:
      this.write = simpleWrite, this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer$A.allocUnsafe(e);
}
StringDecoder$1.prototype.write = function(t) {
  if (t.length === 0) return "";
  var e, n;
  if (this.lastNeed) {
    if (e = this.fillLast(t), e === void 0) return "";
    n = this.lastNeed, this.lastNeed = 0;
  } else
    n = 0;
  return n < t.length ? e ? e + this.text(t, n) : this.text(t, n) : e || "";
};
StringDecoder$1.prototype.end = utf8End;
StringDecoder$1.prototype.text = utf8Text;
StringDecoder$1.prototype.fillLast = function(t) {
  if (this.lastNeed <= t.length)
    return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
};
function utf8CheckByte(t) {
  return t <= 127 ? 0 : t >> 5 === 6 ? 2 : t >> 4 === 14 ? 3 : t >> 3 === 30 ? 4 : t >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(t, e, n) {
  var a = e.length - 1;
  if (a < n) return 0;
  var u = utf8CheckByte(e[a]);
  return u >= 0 ? (u > 0 && (t.lastNeed = u - 1), u) : --a < n || u === -2 ? 0 : (u = utf8CheckByte(e[a]), u >= 0 ? (u > 0 && (t.lastNeed = u - 2), u) : --a < n || u === -2 ? 0 : (u = utf8CheckByte(e[a]), u >= 0 ? (u > 0 && (u === 2 ? u = 0 : t.lastNeed = u - 3), u) : 0));
}
function utf8CheckExtraBytes(t, e, n) {
  if ((e[0] & 192) !== 128)
    return t.lastNeed = 0, "�";
  if (t.lastNeed > 1 && e.length > 1) {
    if ((e[1] & 192) !== 128)
      return t.lastNeed = 1, "�";
    if (t.lastNeed > 2 && e.length > 2 && (e[2] & 192) !== 128)
      return t.lastNeed = 2, "�";
  }
}
function utf8FillLast(t) {
  var e = this.lastTotal - this.lastNeed, n = utf8CheckExtraBytes(this, t);
  if (n !== void 0) return n;
  if (this.lastNeed <= t.length)
    return t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  t.copy(this.lastChar, e, 0, t.length), this.lastNeed -= t.length;
}
function utf8Text(t, e) {
  var n = utf8CheckIncomplete(this, t, e);
  if (!this.lastNeed) return t.toString("utf8", e);
  this.lastTotal = n;
  var a = t.length - (n - this.lastNeed);
  return t.copy(this.lastChar, 0, a), t.toString("utf8", e, a);
}
function utf8End(t) {
  var e = t && t.length ? this.write(t) : "";
  return this.lastNeed ? e + "�" : e;
}
function utf16Text(t, e) {
  if ((t.length - e) % 2 === 0) {
    var n = t.toString("utf16le", e);
    if (n) {
      var a = n.charCodeAt(n.length - 1);
      if (a >= 55296 && a <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], n.slice(0, -1);
    }
    return n;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1);
}
function utf16End(t) {
  var e = t && t.length ? this.write(t) : "";
  if (this.lastNeed) {
    var n = this.lastTotal - this.lastNeed;
    return e + this.lastChar.toString("utf16le", 0, n);
  }
  return e;
}
function base64Text(t, e) {
  var n = (t.length - e) % 3;
  return n === 0 ? t.toString("base64", e) : (this.lastNeed = 3 - n, this.lastTotal = 3, n === 1 ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - n));
}
function base64End(t) {
  var e = t && t.length ? this.write(t) : "";
  return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
}
function simpleWrite(t) {
  return t.toString(this.encoding);
}
function simpleEnd(t) {
  return t && t.length ? this.write(t) : "";
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var t = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function e(o) {
    var d = !1;
    return function() {
      if (!d) {
        d = !0;
        for (var l = arguments.length, _ = new Array(l), P = 0; P < l; P++)
          _[P] = arguments[P];
        o.apply(this, _);
      }
    };
  }
  function n() {
  }
  function a(o) {
    return o.setHeader && typeof o.abort == "function";
  }
  function u(o, d, l) {
    if (typeof d == "function") return u(o, null, d);
    d || (d = {}), l = e(l || n);
    var _ = d.readable || d.readable !== !1 && o.readable, P = d.writable || d.writable !== !1 && o.writable, h = function() {
      o.writable || C();
    }, x = o._writableState && o._writableState.finished, C = function() {
      P = !1, x = !0, _ || l.call(o);
    }, D = o._readableState && o._readableState.endEmitted, q = function() {
      _ = !1, D = !0, P || l.call(o);
    }, H = function(X) {
      l.call(o, X);
    }, Y = function() {
      var X;
      if (_ && !D)
        return (!o._readableState || !o._readableState.ended) && (X = new t()), l.call(o, X);
      if (P && !x)
        return (!o._writableState || !o._writableState.ended) && (X = new t()), l.call(o, X);
    }, z = function() {
      o.req.on("finish", C);
    };
    return a(o) ? (o.on("complete", C), o.on("abort", Y), o.req ? z() : o.on("request", z)) : P && !o._writableState && (o.on("end", h), o.on("close", h)), o.on("end", q), o.on("finish", C), d.error !== !1 && o.on("error", H), o.on("close", Y), function() {
      o.removeListener("complete", C), o.removeListener("abort", Y), o.removeListener("request", z), o.req && o.req.removeListener("finish", C), o.removeListener("end", h), o.removeListener("close", h), o.removeListener("finish", C), o.removeListener("end", q), o.removeListener("error", H), o.removeListener("close", Y);
    };
  }
  return endOfStream = u, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var t;
  function e(X, ee, se) {
    return ee = n(ee), ee in X ? Object.defineProperty(X, ee, { value: se, enumerable: !0, configurable: !0, writable: !0 }) : X[ee] = se, X;
  }
  function n(X) {
    var ee = a(X, "string");
    return typeof ee == "symbol" ? ee : String(ee);
  }
  function a(X, ee) {
    if (typeof X != "object" || X === null) return X;
    var se = X[Symbol.toPrimitive];
    if (se !== void 0) {
      var ce = se.call(X, ee);
      if (typeof ce != "object") return ce;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(X);
  }
  var u = requireEndOfStream(), o = Symbol("lastResolve"), d = Symbol("lastReject"), l = Symbol("error"), _ = Symbol("ended"), P = Symbol("lastPromise"), h = Symbol("handlePromise"), x = Symbol("stream");
  function C(X, ee) {
    return {
      value: X,
      done: ee
    };
  }
  function D(X) {
    var ee = X[o];
    if (ee !== null) {
      var se = X[x].read();
      se !== null && (X[P] = null, X[o] = null, X[d] = null, ee(C(se, !1)));
    }
  }
  function q(X) {
    process$1.nextTick(D, X);
  }
  function H(X, ee) {
    return function(se, ce) {
      X.then(function() {
        if (ee[_]) {
          se(C(void 0, !0));
          return;
        }
        ee[h](se, ce);
      }, ce);
    };
  }
  var Y = Object.getPrototypeOf(function() {
  }), z = Object.setPrototypeOf((t = {
    get stream() {
      return this[x];
    },
    next: function() {
      var ee = this, se = this[l];
      if (se !== null)
        return Promise.reject(se);
      if (this[_])
        return Promise.resolve(C(void 0, !0));
      if (this[x].destroyed)
        return new Promise(function(oe, _e) {
          process$1.nextTick(function() {
            ee[l] ? _e(ee[l]) : oe(C(void 0, !0));
          });
        });
      var ce = this[P], le;
      if (ce)
        le = new Promise(H(ce, this));
      else {
        var he = this[x].read();
        if (he !== null)
          return Promise.resolve(C(he, !1));
        le = new Promise(this[h]);
      }
      return this[P] = le, le;
    }
  }, e(t, Symbol.asyncIterator, function() {
    return this;
  }), e(t, "return", function() {
    var ee = this;
    return new Promise(function(se, ce) {
      ee[x].destroy(null, function(le) {
        if (le) {
          ce(le);
          return;
        }
        se(C(void 0, !0));
      });
    });
  }), t), Y), F = function(ee) {
    var se, ce = Object.create(z, (se = {}, e(se, x, {
      value: ee,
      writable: !0
    }), e(se, o, {
      value: null,
      writable: !0
    }), e(se, d, {
      value: null,
      writable: !0
    }), e(se, l, {
      value: null,
      writable: !0
    }), e(se, _, {
      value: ee._readableState.endEmitted,
      writable: !0
    }), e(se, h, {
      value: function(he, oe) {
        var _e = ce[x].read();
        _e ? (ce[P] = null, ce[o] = null, ce[d] = null, he(C(_e, !1))) : (ce[o] = he, ce[d] = oe);
      },
      writable: !0
    }), se));
    return ce[P] = null, u(ee, function(le) {
      if (le && le.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var he = ce[d];
        he !== null && (ce[P] = null, ce[o] = null, ce[d] = null, he(le)), ce[l] = le;
        return;
      }
      var oe = ce[o];
      oe !== null && (ce[P] = null, ce[o] = null, ce[d] = null, oe(C(void 0, !0))), ce[_] = !0;
    }), ee.on("readable", q.bind(null, ce)), ce;
  };
  return async_iterator = F, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = oe;
  var t;
  oe.ReadableState = he, eventsExports.EventEmitter;
  var e = function(j, ne) {
    return j.listeners(ne).length;
  }, n = requireStreamBrowser(), a = require$$1$2.Buffer, u = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function o(L) {
    return a.from(L);
  }
  function d(L) {
    return a.isBuffer(L) || L instanceof u;
  }
  var l = util$3, _;
  l && l.debuglog ? _ = l.debuglog("stream") : _ = function() {
  };
  var P = requireBuffer_list(), h = requireDestroy(), x = requireState(), C = x.getHighWaterMark, D = requireErrorsBrowser().codes, q = D.ERR_INVALID_ARG_TYPE, H = D.ERR_STREAM_PUSH_AFTER_EOF, Y = D.ERR_METHOD_NOT_IMPLEMENTED, z = D.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, F, X, ee;
  inherits_browserExports(oe, n);
  var se = h.errorOrDestroy, ce = ["error", "close", "destroy", "pause", "resume"];
  function le(L, j, ne) {
    if (typeof L.prependListener == "function") return L.prependListener(j, ne);
    !L._events || !L._events[j] ? L.on(j, ne) : Array.isArray(L._events[j]) ? L._events[j].unshift(ne) : L._events[j] = [ne, L._events[j]];
  }
  function he(L, j, ne) {
    t = t || require_stream_duplex$1(), L = L || {}, typeof ne != "boolean" && (ne = j instanceof t), this.objectMode = !!L.objectMode, ne && (this.objectMode = this.objectMode || !!L.readableObjectMode), this.highWaterMark = C(this, L, "readableHighWaterMark", ne), this.buffer = new P(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = L.emitClose !== !1, this.autoDestroy = !!L.autoDestroy, this.destroyed = !1, this.defaultEncoding = L.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, L.encoding && (F || (F = string_decoder.StringDecoder), this.decoder = new F(L.encoding), this.encoding = L.encoding);
  }
  function oe(L) {
    if (t = t || require_stream_duplex$1(), !(this instanceof oe)) return new oe(L);
    var j = this instanceof t;
    this._readableState = new he(L, this, j), this.readable = !0, L && (typeof L.read == "function" && (this._read = L.read), typeof L.destroy == "function" && (this._destroy = L.destroy)), n.call(this);
  }
  Object.defineProperty(oe.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(j) {
      this._readableState && (this._readableState.destroyed = j);
    }
  }), oe.prototype.destroy = h.destroy, oe.prototype._undestroy = h.undestroy, oe.prototype._destroy = function(L, j) {
    j(L);
  }, oe.prototype.push = function(L, j) {
    var ne = this._readableState, de;
    return ne.objectMode ? de = !0 : typeof L == "string" && (j = j || ne.defaultEncoding, j !== ne.encoding && (L = a.from(L, j), j = ""), de = !0), _e(this, L, j, !1, de);
  }, oe.prototype.unshift = function(L) {
    return _e(this, L, null, !0, !1);
  };
  function _e(L, j, ne, de, pe) {
    _("readableAddChunk", j);
    var be = L._readableState;
    if (j === null)
      be.reading = !1, $(L, be);
    else {
      var me;
      if (pe || (me = w(be, j)), me)
        se(L, me);
      else if (be.objectMode || j && j.length > 0)
        if (typeof j != "string" && !be.objectMode && Object.getPrototypeOf(j) !== a.prototype && (j = o(j)), de)
          be.endEmitted ? se(L, new z()) : J(L, be, j, !0);
        else if (be.ended)
          se(L, new H());
        else {
          if (be.destroyed)
            return !1;
          be.reading = !1, be.decoder && !ne ? (j = be.decoder.write(j), be.objectMode || j.length !== 0 ? J(L, be, j, !1) : M(L, be)) : J(L, be, j, !1);
        }
      else de || (be.reading = !1, M(L, be));
    }
    return !be.ended && (be.length < be.highWaterMark || be.length === 0);
  }
  function J(L, j, ne, de) {
    j.flowing && j.length === 0 && !j.sync ? (j.awaitDrain = 0, L.emit("data", ne)) : (j.length += j.objectMode ? 1 : ne.length, de ? j.buffer.unshift(ne) : j.buffer.push(ne), j.needReadable && S(L)), M(L, j);
  }
  function w(L, j) {
    var ne;
    return !d(j) && typeof j != "string" && j !== void 0 && !L.objectMode && (ne = new q("chunk", ["string", "Buffer", "Uint8Array"], j)), ne;
  }
  oe.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, oe.prototype.setEncoding = function(L) {
    F || (F = string_decoder.StringDecoder);
    var j = new F(L);
    this._readableState.decoder = j, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var ne = this._readableState.buffer.head, de = ""; ne !== null; )
      de += j.write(ne.data), ne = ne.next;
    return this._readableState.buffer.clear(), de !== "" && this._readableState.buffer.push(de), this._readableState.length = de.length, this;
  };
  var m = 1073741824;
  function c(L) {
    return L >= m ? L = m : (L--, L |= L >>> 1, L |= L >>> 2, L |= L >>> 4, L |= L >>> 8, L |= L >>> 16, L++), L;
  }
  function v(L, j) {
    return L <= 0 || j.length === 0 && j.ended ? 0 : j.objectMode ? 1 : L !== L ? j.flowing && j.length ? j.buffer.head.data.length : j.length : (L > j.highWaterMark && (j.highWaterMark = c(L)), L <= j.length ? L : j.ended ? j.length : (j.needReadable = !0, 0));
  }
  oe.prototype.read = function(L) {
    _("read", L), L = parseInt(L, 10);
    var j = this._readableState, ne = L;
    if (L !== 0 && (j.emittedReadable = !1), L === 0 && j.needReadable && ((j.highWaterMark !== 0 ? j.length >= j.highWaterMark : j.length > 0) || j.ended))
      return _("read: emitReadable", j.length, j.ended), j.length === 0 && j.ended ? O(this) : S(this), null;
    if (L = v(L, j), L === 0 && j.ended)
      return j.length === 0 && O(this), null;
    var de = j.needReadable;
    _("need readable", de), (j.length === 0 || j.length - L < j.highWaterMark) && (de = !0, _("length less than watermark", de)), j.ended || j.reading ? (de = !1, _("reading or ended", de)) : de && (_("do read"), j.reading = !0, j.sync = !0, j.length === 0 && (j.needReadable = !0), this._read(j.highWaterMark), j.sync = !1, j.reading || (L = v(ne, j)));
    var pe;
    return L > 0 ? pe = T(L, j) : pe = null, pe === null ? (j.needReadable = j.length <= j.highWaterMark, L = 0) : (j.length -= L, j.awaitDrain = 0), j.length === 0 && (j.ended || (j.needReadable = !0), ne !== L && j.ended && O(this)), pe !== null && this.emit("data", pe), pe;
  };
  function $(L, j) {
    if (_("onEofChunk"), !j.ended) {
      if (j.decoder) {
        var ne = j.decoder.end();
        ne && ne.length && (j.buffer.push(ne), j.length += j.objectMode ? 1 : ne.length);
      }
      j.ended = !0, j.sync ? S(L) : (j.needReadable = !1, j.emittedReadable || (j.emittedReadable = !0, A(L)));
    }
  }
  function S(L) {
    var j = L._readableState;
    _("emitReadable", j.needReadable, j.emittedReadable), j.needReadable = !1, j.emittedReadable || (_("emitReadable", j.flowing), j.emittedReadable = !0, process$1.nextTick(A, L));
  }
  function A(L) {
    var j = L._readableState;
    _("emitReadable_", j.destroyed, j.length, j.ended), !j.destroyed && (j.length || j.ended) && (L.emit("readable"), j.emittedReadable = !1), j.needReadable = !j.flowing && !j.ended && j.length <= j.highWaterMark, V(L);
  }
  function M(L, j) {
    j.readingMore || (j.readingMore = !0, process$1.nextTick(p, L, j));
  }
  function p(L, j) {
    for (; !j.reading && !j.ended && (j.length < j.highWaterMark || j.flowing && j.length === 0); ) {
      var ne = j.length;
      if (_("maybeReadMore read 0"), L.read(0), ne === j.length)
        break;
    }
    j.readingMore = !1;
  }
  oe.prototype._read = function(L) {
    se(this, new Y("_read()"));
  }, oe.prototype.pipe = function(L, j) {
    var ne = this, de = this._readableState;
    switch (de.pipesCount) {
      case 0:
        de.pipes = L;
        break;
      case 1:
        de.pipes = [de.pipes, L];
        break;
      default:
        de.pipes.push(L);
        break;
    }
    de.pipesCount += 1, _("pipe count=%d opts=%j", de.pipesCount, j);
    var pe = (!j || j.end !== !1) && L !== process$1.stdout && L !== process$1.stderr, be = pe ? we : qe;
    de.endEmitted ? process$1.nextTick(be) : ne.once("end", be), L.on("unpipe", me);
    function me(Se, ke) {
      _("onunpipe"), Se === ne && ke && ke.hasUnpiped === !1 && (ke.hasUnpiped = !0, xe());
    }
    function we() {
      _("onend"), L.end();
    }
    var ue = B(ne);
    L.on("drain", ue);
    var Oe = !1;
    function xe() {
      _("cleanup"), L.removeListener("close", ge), L.removeListener("finish", Me), L.removeListener("drain", ue), L.removeListener("error", Ne), L.removeListener("unpipe", me), ne.removeListener("end", we), ne.removeListener("end", qe), ne.removeListener("data", je), Oe = !0, de.awaitDrain && (!L._writableState || L._writableState.needDrain) && ue();
    }
    ne.on("data", je);
    function je(Se) {
      _("ondata");
      var ke = L.write(Se);
      _("dest.write", ke), ke === !1 && ((de.pipesCount === 1 && de.pipes === L || de.pipesCount > 1 && ie(de.pipes, L) !== -1) && !Oe && (_("false write response, pause", de.awaitDrain), de.awaitDrain++), ne.pause());
    }
    function Ne(Se) {
      _("onerror", Se), qe(), L.removeListener("error", Ne), e(L, "error") === 0 && se(L, Se);
    }
    le(L, "error", Ne);
    function ge() {
      L.removeListener("finish", Me), qe();
    }
    L.once("close", ge);
    function Me() {
      _("onfinish"), L.removeListener("close", ge), qe();
    }
    L.once("finish", Me);
    function qe() {
      _("unpipe"), ne.unpipe(L);
    }
    return L.emit("pipe", ne), de.flowing || (_("pipe resume"), ne.resume()), L;
  };
  function B(L) {
    return function() {
      var ne = L._readableState;
      _("pipeOnDrain", ne.awaitDrain), ne.awaitDrain && ne.awaitDrain--, ne.awaitDrain === 0 && e(L, "data") && (ne.flowing = !0, V(L));
    };
  }
  oe.prototype.unpipe = function(L) {
    var j = this._readableState, ne = {
      hasUnpiped: !1
    };
    if (j.pipesCount === 0) return this;
    if (j.pipesCount === 1)
      return L && L !== j.pipes ? this : (L || (L = j.pipes), j.pipes = null, j.pipesCount = 0, j.flowing = !1, L && L.emit("unpipe", this, ne), this);
    if (!L) {
      var de = j.pipes, pe = j.pipesCount;
      j.pipes = null, j.pipesCount = 0, j.flowing = !1;
      for (var be = 0; be < pe; be++) de[be].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var me = ie(j.pipes, L);
    return me === -1 ? this : (j.pipes.splice(me, 1), j.pipesCount -= 1, j.pipesCount === 1 && (j.pipes = j.pipes[0]), L.emit("unpipe", this, ne), this);
  }, oe.prototype.on = function(L, j) {
    var ne = n.prototype.on.call(this, L, j), de = this._readableState;
    return L === "data" ? (de.readableListening = this.listenerCount("readable") > 0, de.flowing !== !1 && this.resume()) : L === "readable" && !de.endEmitted && !de.readableListening && (de.readableListening = de.needReadable = !0, de.flowing = !1, de.emittedReadable = !1, _("on readable", de.length, de.reading), de.length ? S(this) : de.reading || process$1.nextTick(k, this)), ne;
  }, oe.prototype.addListener = oe.prototype.on, oe.prototype.removeListener = function(L, j) {
    var ne = n.prototype.removeListener.call(this, L, j);
    return L === "readable" && process$1.nextTick(b, this), ne;
  }, oe.prototype.removeAllListeners = function(L) {
    var j = n.prototype.removeAllListeners.apply(this, arguments);
    return (L === "readable" || L === void 0) && process$1.nextTick(b, this), j;
  };
  function b(L) {
    var j = L._readableState;
    j.readableListening = L.listenerCount("readable") > 0, j.resumeScheduled && !j.paused ? j.flowing = !0 : L.listenerCount("data") > 0 && L.resume();
  }
  function k(L) {
    _("readable nexttick read 0"), L.read(0);
  }
  oe.prototype.resume = function() {
    var L = this._readableState;
    return L.flowing || (_("resume"), L.flowing = !L.readableListening, Z(this, L)), L.paused = !1, this;
  };
  function Z(L, j) {
    j.resumeScheduled || (j.resumeScheduled = !0, process$1.nextTick(te, L, j));
  }
  function te(L, j) {
    _("resume", j.reading), j.reading || L.read(0), j.resumeScheduled = !1, L.emit("resume"), V(L), j.flowing && !j.reading && L.read(0);
  }
  oe.prototype.pause = function() {
    return _("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (_("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function V(L) {
    var j = L._readableState;
    for (_("flow", j.flowing); j.flowing && L.read() !== null; ) ;
  }
  oe.prototype.wrap = function(L) {
    var j = this, ne = this._readableState, de = !1;
    L.on("end", function() {
      if (_("wrapped end"), ne.decoder && !ne.ended) {
        var me = ne.decoder.end();
        me && me.length && j.push(me);
      }
      j.push(null);
    }), L.on("data", function(me) {
      if (_("wrapped data"), ne.decoder && (me = ne.decoder.write(me)), !(ne.objectMode && me == null) && !(!ne.objectMode && (!me || !me.length))) {
        var we = j.push(me);
        we || (de = !0, L.pause());
      }
    });
    for (var pe in L)
      this[pe] === void 0 && typeof L[pe] == "function" && (this[pe] = /* @__PURE__ */ function(we) {
        return function() {
          return L[we].apply(L, arguments);
        };
      }(pe));
    for (var be = 0; be < ce.length; be++)
      L.on(ce[be], this.emit.bind(this, ce[be]));
    return this._read = function(me) {
      _("wrapped _read", me), de && (de = !1, L.resume());
    }, this;
  }, typeof Symbol == "function" && (oe.prototype[Symbol.asyncIterator] = function() {
    return X === void 0 && (X = requireAsync_iterator()), X(this);
  }), Object.defineProperty(oe.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(oe.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(oe.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(j) {
      this._readableState && (this._readableState.flowing = j);
    }
  }), oe._fromList = T, Object.defineProperty(oe.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function T(L, j) {
    if (j.length === 0) return null;
    var ne;
    return j.objectMode ? ne = j.buffer.shift() : !L || L >= j.length ? (j.decoder ? ne = j.buffer.join("") : j.buffer.length === 1 ? ne = j.buffer.first() : ne = j.buffer.concat(j.length), j.buffer.clear()) : ne = j.buffer.consume(L, j.decoder), ne;
  }
  function O(L) {
    var j = L._readableState;
    _("endReadable", j.endEmitted), j.endEmitted || (j.ended = !0, process$1.nextTick(Q, j, L));
  }
  function Q(L, j) {
    if (_("endReadableNT", L.endEmitted, L.length), !L.endEmitted && L.length === 0 && (L.endEmitted = !0, j.readable = !1, j.emit("end"), L.autoDestroy)) {
      var ne = j._writableState;
      (!ne || ne.autoDestroy && ne.finished) && j.destroy();
    }
  }
  typeof Symbol == "function" && (oe.from = function(L, j) {
    return ee === void 0 && (ee = requireFromBrowser()), ee(oe, L, j);
  });
  function ie(L, j) {
    for (var ne = 0, de = L.length; ne < de; ne++)
      if (L[ne] === j) return ne;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform$1;
  hasRequired_stream_transform = 1, _stream_transform$1 = l;
  var t = requireErrorsBrowser().codes, e = t.ERR_METHOD_NOT_IMPLEMENTED, n = t.ERR_MULTIPLE_CALLBACK, a = t.ERR_TRANSFORM_ALREADY_TRANSFORMING, u = t.ERR_TRANSFORM_WITH_LENGTH_0, o = require_stream_duplex$1();
  inherits_browserExports(l, o);
  function d(h, x) {
    var C = this._transformState;
    C.transforming = !1;
    var D = C.writecb;
    if (D === null)
      return this.emit("error", new n());
    C.writechunk = null, C.writecb = null, x != null && this.push(x), D(h);
    var q = this._readableState;
    q.reading = !1, (q.needReadable || q.length < q.highWaterMark) && this._read(q.highWaterMark);
  }
  function l(h) {
    if (!(this instanceof l)) return new l(h);
    o.call(this, h), this._transformState = {
      afterTransform: d.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, h && (typeof h.transform == "function" && (this._transform = h.transform), typeof h.flush == "function" && (this._flush = h.flush)), this.on("prefinish", _);
  }
  function _() {
    var h = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(x, C) {
      P(h, x, C);
    }) : P(this, null, null);
  }
  l.prototype.push = function(h, x) {
    return this._transformState.needTransform = !1, o.prototype.push.call(this, h, x);
  }, l.prototype._transform = function(h, x, C) {
    C(new e("_transform()"));
  }, l.prototype._write = function(h, x, C) {
    var D = this._transformState;
    if (D.writecb = C, D.writechunk = h, D.writeencoding = x, !D.transforming) {
      var q = this._readableState;
      (D.needTransform || q.needReadable || q.length < q.highWaterMark) && this._read(q.highWaterMark);
    }
  }, l.prototype._read = function(h) {
    var x = this._transformState;
    x.writechunk !== null && !x.transforming ? (x.transforming = !0, this._transform(x.writechunk, x.writeencoding, x.afterTransform)) : x.needTransform = !0;
  }, l.prototype._destroy = function(h, x) {
    o.prototype._destroy.call(this, h, function(C) {
      x(C);
    });
  };
  function P(h, x, C) {
    if (x) return h.emit("error", x);
    if (C != null && h.push(C), h._writableState.length) throw new u();
    if (h._transformState.transforming) throw new a();
    return h.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough$1;
  hasRequired_stream_passthrough = 1, _stream_passthrough$1 = e;
  var t = require_stream_transform();
  inherits_browserExports(e, t);
  function e(n) {
    if (!(this instanceof e)) return new e(n);
    t.call(this, n);
  }
  return e.prototype._transform = function(n, a, u) {
    u(null, n);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var t;
  function e(C) {
    var D = !1;
    return function() {
      D || (D = !0, C.apply(void 0, arguments));
    };
  }
  var n = requireErrorsBrowser().codes, a = n.ERR_MISSING_ARGS, u = n.ERR_STREAM_DESTROYED;
  function o(C) {
    if (C) throw C;
  }
  function d(C) {
    return C.setHeader && typeof C.abort == "function";
  }
  function l(C, D, q, H) {
    H = e(H);
    var Y = !1;
    C.on("close", function() {
      Y = !0;
    }), t === void 0 && (t = requireEndOfStream()), t(C, {
      readable: D,
      writable: q
    }, function(F) {
      if (F) return H(F);
      Y = !0, H();
    });
    var z = !1;
    return function(F) {
      if (!Y && !z) {
        if (z = !0, d(C)) return C.abort();
        if (typeof C.destroy == "function") return C.destroy();
        H(F || new u("pipe"));
      }
    };
  }
  function _(C) {
    C();
  }
  function P(C, D) {
    return C.pipe(D);
  }
  function h(C) {
    return !C.length || typeof C[C.length - 1] != "function" ? o : C.pop();
  }
  function x() {
    for (var C = arguments.length, D = new Array(C), q = 0; q < C; q++)
      D[q] = arguments[q];
    var H = h(D);
    if (Array.isArray(D[0]) && (D = D[0]), D.length < 2)
      throw new a("streams");
    var Y, z = D.map(function(F, X) {
      var ee = X < D.length - 1, se = X > 0;
      return l(F, ee, se, function(ce) {
        Y || (Y = ce), ce && z.forEach(_), !ee && (z.forEach(_), H(Y));
      });
    });
    return D.reduce(P);
  }
  return pipeline_1 = x, pipeline_1;
}
var streamBrowserify = Stream, EE = eventsExports.EventEmitter, inherits$q = inherits_browserExports;
inherits$q(Stream, EE);
Stream.Readable = require_stream_readable$1();
Stream.Writable = require_stream_writable$1();
Stream.Duplex = require_stream_duplex$1();
Stream.Transform = require_stream_transform();
Stream.PassThrough = require_stream_passthrough();
Stream.finished = requireEndOfStream();
Stream.pipeline = requirePipeline();
Stream.Stream = Stream;
function Stream() {
  EE.call(this);
}
Stream.prototype.pipe = function(t, e) {
  var n = this;
  function a(h) {
    t.writable && t.write(h) === !1 && n.pause && n.pause();
  }
  n.on("data", a);
  function u() {
    n.readable && n.resume && n.resume();
  }
  t.on("drain", u), !t._isStdio && (!e || e.end !== !1) && (n.on("end", d), n.on("close", l));
  var o = !1;
  function d() {
    o || (o = !0, t.end());
  }
  function l() {
    o || (o = !0, typeof t.destroy == "function" && t.destroy());
  }
  function _(h) {
    if (P(), EE.listenerCount(this, "error") === 0)
      throw h;
  }
  n.on("error", _), t.on("error", _);
  function P() {
    n.removeListener("data", a), t.removeListener("drain", u), n.removeListener("end", d), n.removeListener("close", l), n.removeListener("error", _), t.removeListener("error", _), n.removeListener("end", P), n.removeListener("close", P), t.removeListener("close", P);
  }
  return n.on("end", P), n.on("close", P), t.on("close", P), t.emit("pipe", n), t;
};
var Buffer$z = safeBufferExports$1.Buffer, Transform$7 = streamBrowserify.Transform, inherits$p = inherits_browserExports;
function HashBase$2(t) {
  Transform$7.call(this), this._block = Buffer$z.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
inherits$p(HashBase$2, Transform$7);
HashBase$2.prototype._transform = function(t, e, n) {
  var a = null;
  try {
    this.update(t, e);
  } catch (u) {
    a = u;
  }
  n(a);
};
HashBase$2.prototype._flush = function(t) {
  var e = null;
  try {
    this.push(this.digest());
  } catch (n) {
    e = n;
  }
  t(e);
};
var useUint8Array$1 = typeof Uint8Array < "u", useArrayBuffer$1 = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (Buffer$z.prototype instanceof Uint8Array || Buffer$z.TYPED_ARRAY_SUPPORT);
function toBuffer$4(t, e) {
  if (t instanceof Buffer$z) return t;
  if (typeof t == "string") return Buffer$z.from(t, e);
  if (useArrayBuffer$1 && ArrayBuffer.isView(t)) {
    if (t.byteLength === 0) return Buffer$z.alloc(0);
    var n = Buffer$z.from(t.buffer, t.byteOffset, t.byteLength);
    if (n.byteLength === t.byteLength) return n;
  }
  if (useUint8Array$1 && t instanceof Uint8Array || Buffer$z.isBuffer(t) && t.constructor && typeof t.constructor.isBuffer == "function" && t.constructor.isBuffer(t))
    return Buffer$z.from(t);
  throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
}
HashBase$2.prototype.update = function(t, e) {
  if (this._finalized) throw new Error("Digest already called");
  t = toBuffer$4(t, e);
  for (var n = this._block, a = 0; this._blockOffset + t.length - a >= this._blockSize; ) {
    for (var u = this._blockOffset; u < this._blockSize; ) n[u++] = t[a++];
    this._update(), this._blockOffset = 0;
  }
  for (; a < t.length; ) n[this._blockOffset++] = t[a++];
  for (var o = 0, d = t.length * 8; d > 0; ++o)
    this._length[o] += d, d = this._length[o] / 4294967296 | 0, d > 0 && (this._length[o] -= 4294967296 * d);
  return this;
};
HashBase$2.prototype._update = function() {
  throw new Error("_update is not implemented");
};
HashBase$2.prototype.digest = function(t) {
  if (this._finalized) throw new Error("Digest already called");
  this._finalized = !0;
  var e = this._digest();
  t !== void 0 && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
  for (var n = 0; n < 4; ++n) this._length[n] = 0;
  return e;
};
HashBase$2.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var hashBase = HashBase$2, inherits$o = inherits_browserExports, HashBase$1 = hashBase, Buffer$y = safeBufferExports$1.Buffer, ARRAY16$1 = new Array(16);
function MD5$3() {
  HashBase$1.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
inherits$o(MD5$3, HashBase$1);
MD5$3.prototype._update = function() {
  for (var t = ARRAY16$1, e = 0; e < 16; ++e) t[e] = this._block.readInt32LE(e * 4);
  var n = this._a, a = this._b, u = this._c, o = this._d;
  n = fnF(n, a, u, o, t[0], 3614090360, 7), o = fnF(o, n, a, u, t[1], 3905402710, 12), u = fnF(u, o, n, a, t[2], 606105819, 17), a = fnF(a, u, o, n, t[3], 3250441966, 22), n = fnF(n, a, u, o, t[4], 4118548399, 7), o = fnF(o, n, a, u, t[5], 1200080426, 12), u = fnF(u, o, n, a, t[6], 2821735955, 17), a = fnF(a, u, o, n, t[7], 4249261313, 22), n = fnF(n, a, u, o, t[8], 1770035416, 7), o = fnF(o, n, a, u, t[9], 2336552879, 12), u = fnF(u, o, n, a, t[10], 4294925233, 17), a = fnF(a, u, o, n, t[11], 2304563134, 22), n = fnF(n, a, u, o, t[12], 1804603682, 7), o = fnF(o, n, a, u, t[13], 4254626195, 12), u = fnF(u, o, n, a, t[14], 2792965006, 17), a = fnF(a, u, o, n, t[15], 1236535329, 22), n = fnG(n, a, u, o, t[1], 4129170786, 5), o = fnG(o, n, a, u, t[6], 3225465664, 9), u = fnG(u, o, n, a, t[11], 643717713, 14), a = fnG(a, u, o, n, t[0], 3921069994, 20), n = fnG(n, a, u, o, t[5], 3593408605, 5), o = fnG(o, n, a, u, t[10], 38016083, 9), u = fnG(u, o, n, a, t[15], 3634488961, 14), a = fnG(a, u, o, n, t[4], 3889429448, 20), n = fnG(n, a, u, o, t[9], 568446438, 5), o = fnG(o, n, a, u, t[14], 3275163606, 9), u = fnG(u, o, n, a, t[3], 4107603335, 14), a = fnG(a, u, o, n, t[8], 1163531501, 20), n = fnG(n, a, u, o, t[13], 2850285829, 5), o = fnG(o, n, a, u, t[2], 4243563512, 9), u = fnG(u, o, n, a, t[7], 1735328473, 14), a = fnG(a, u, o, n, t[12], 2368359562, 20), n = fnH(n, a, u, o, t[5], 4294588738, 4), o = fnH(o, n, a, u, t[8], 2272392833, 11), u = fnH(u, o, n, a, t[11], 1839030562, 16), a = fnH(a, u, o, n, t[14], 4259657740, 23), n = fnH(n, a, u, o, t[1], 2763975236, 4), o = fnH(o, n, a, u, t[4], 1272893353, 11), u = fnH(u, o, n, a, t[7], 4139469664, 16), a = fnH(a, u, o, n, t[10], 3200236656, 23), n = fnH(n, a, u, o, t[13], 681279174, 4), o = fnH(o, n, a, u, t[0], 3936430074, 11), u = fnH(u, o, n, a, t[3], 3572445317, 16), a = fnH(a, u, o, n, t[6], 76029189, 23), n = fnH(n, a, u, o, t[9], 3654602809, 4), o = fnH(o, n, a, u, t[12], 3873151461, 11), u = fnH(u, o, n, a, t[15], 530742520, 16), a = fnH(a, u, o, n, t[2], 3299628645, 23), n = fnI(n, a, u, o, t[0], 4096336452, 6), o = fnI(o, n, a, u, t[7], 1126891415, 10), u = fnI(u, o, n, a, t[14], 2878612391, 15), a = fnI(a, u, o, n, t[5], 4237533241, 21), n = fnI(n, a, u, o, t[12], 1700485571, 6), o = fnI(o, n, a, u, t[3], 2399980690, 10), u = fnI(u, o, n, a, t[10], 4293915773, 15), a = fnI(a, u, o, n, t[1], 2240044497, 21), n = fnI(n, a, u, o, t[8], 1873313359, 6), o = fnI(o, n, a, u, t[15], 4264355552, 10), u = fnI(u, o, n, a, t[6], 2734768916, 15), a = fnI(a, u, o, n, t[13], 1309151649, 21), n = fnI(n, a, u, o, t[4], 4149444226, 6), o = fnI(o, n, a, u, t[11], 3174756917, 10), u = fnI(u, o, n, a, t[2], 718787259, 15), a = fnI(a, u, o, n, t[9], 3951481745, 21), this._a = this._a + n | 0, this._b = this._b + a | 0, this._c = this._c + u | 0, this._d = this._d + o | 0;
};
MD5$3.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var t = Buffer$y.allocUnsafe(16);
  return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
};
function rotl$1(t, e) {
  return t << e | t >>> 32 - e;
}
function fnF(t, e, n, a, u, o, d) {
  return rotl$1(t + (e & n | ~e & a) + u + o | 0, d) + e | 0;
}
function fnG(t, e, n, a, u, o, d) {
  return rotl$1(t + (e & a | n & ~a) + u + o | 0, d) + e | 0;
}
function fnH(t, e, n, a, u, o, d) {
  return rotl$1(t + (e ^ n ^ a) + u + o | 0, d) + e | 0;
}
function fnI(t, e, n, a, u, o, d) {
  return rotl$1(t + (n ^ (e | ~a)) + u + o | 0, d) + e | 0;
}
var md5_js = MD5$3, Buffer$x = require$$1$2.Buffer, inherits$n = inherits_browserExports, HashBase = hashBase, ARRAY16 = new Array(16), zl = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], zr = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], sl = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sr = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], hl = [0, 1518500249, 1859775393, 2400959708, 2840853838], hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function RIPEMD160$4() {
  HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
inherits$n(RIPEMD160$4, HashBase);
RIPEMD160$4.prototype._update = function() {
  for (var t = ARRAY16, e = 0; e < 16; ++e) t[e] = this._block.readInt32LE(e * 4);
  for (var n = this._a | 0, a = this._b | 0, u = this._c | 0, o = this._d | 0, d = this._e | 0, l = this._a | 0, _ = this._b | 0, P = this._c | 0, h = this._d | 0, x = this._e | 0, C = 0; C < 80; C += 1) {
    var D, q;
    C < 16 ? (D = fn1(n, a, u, o, d, t[zl[C]], hl[0], sl[C]), q = fn5(l, _, P, h, x, t[zr[C]], hr[0], sr[C])) : C < 32 ? (D = fn2(n, a, u, o, d, t[zl[C]], hl[1], sl[C]), q = fn4(l, _, P, h, x, t[zr[C]], hr[1], sr[C])) : C < 48 ? (D = fn3(n, a, u, o, d, t[zl[C]], hl[2], sl[C]), q = fn3(l, _, P, h, x, t[zr[C]], hr[2], sr[C])) : C < 64 ? (D = fn4(n, a, u, o, d, t[zl[C]], hl[3], sl[C]), q = fn2(l, _, P, h, x, t[zr[C]], hr[3], sr[C])) : (D = fn5(n, a, u, o, d, t[zl[C]], hl[4], sl[C]), q = fn1(l, _, P, h, x, t[zr[C]], hr[4], sr[C])), n = d, d = o, o = rotl(u, 10), u = a, a = D, l = x, x = h, h = rotl(P, 10), P = _, _ = q;
  }
  var H = this._b + u + h | 0;
  this._b = this._c + o + x | 0, this._c = this._d + d + l | 0, this._d = this._e + n + _ | 0, this._e = this._a + a + P | 0, this._a = H;
};
RIPEMD160$4.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var t = Buffer$x.alloc ? Buffer$x.alloc(20) : new Buffer$x(20);
  return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t;
};
function rotl(t, e) {
  return t << e | t >>> 32 - e;
}
function fn1(t, e, n, a, u, o, d, l) {
  return rotl(t + (e ^ n ^ a) + o + d | 0, l) + u | 0;
}
function fn2(t, e, n, a, u, o, d, l) {
  return rotl(t + (e & n | ~e & a) + o + d | 0, l) + u | 0;
}
function fn3(t, e, n, a, u, o, d, l) {
  return rotl(t + ((e | ~n) ^ a) + o + d | 0, l) + u | 0;
}
function fn4(t, e, n, a, u, o, d, l) {
  return rotl(t + (e & a | n & ~a) + o + d | 0, l) + u | 0;
}
function fn5(t, e, n, a, u, o, d, l) {
  return rotl(t + (e ^ (n | ~a)) + o + d | 0, l) + u | 0;
}
var ripemd160 = RIPEMD160$4, sha_js = { exports: {} }, Buffer$w = safeBufferExports$1.Buffer;
function Hash$7(t, e) {
  this._block = Buffer$w.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0;
}
Hash$7.prototype.update = function(t, e) {
  typeof t == "string" && (e = e || "utf8", t = Buffer$w.from(t, e));
  for (var n = this._block, a = this._blockSize, u = t.length, o = this._len, d = 0; d < u; ) {
    for (var l = o % a, _ = Math.min(u - d, a - l), P = 0; P < _; P++)
      n[l + P] = t[d + P];
    o += _, d += _, o % a === 0 && this._update(n);
  }
  return this._len += u, this;
};
Hash$7.prototype.digest = function(t) {
  var e = this._len % this._blockSize;
  this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var n = this._len * 8;
  if (n <= 4294967295)
    this._block.writeUInt32BE(n, this._blockSize - 4);
  else {
    var a = (n & 4294967295) >>> 0, u = (n - a) / 4294967296;
    this._block.writeUInt32BE(u, this._blockSize - 8), this._block.writeUInt32BE(a, this._blockSize - 4);
  }
  this._update(this._block);
  var o = this._hash();
  return t ? o.toString(t) : o;
};
Hash$7.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var hash$3 = Hash$7, inherits$m = inherits_browserExports, Hash$6 = hash$3, Buffer$v = safeBufferExports$1.Buffer, K$4 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$5 = new Array(80);
function Sha() {
  this.init(), this._w = W$5, Hash$6.call(this, 64, 56);
}
inherits$m(Sha, Hash$6);
Sha.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl5$1(t) {
  return t << 5 | t >>> 27;
}
function rotl30$1(t) {
  return t << 30 | t >>> 2;
}
function ft$1(t, e, n, a) {
  return t === 0 ? e & n | ~e & a : t === 2 ? e & n | e & a | n & a : e ^ n ^ a;
}
Sha.prototype._update = function(t) {
  for (var e = this._w, n = this._a | 0, a = this._b | 0, u = this._c | 0, o = this._d | 0, d = this._e | 0, l = 0; l < 16; ++l) e[l] = t.readInt32BE(l * 4);
  for (; l < 80; ++l) e[l] = e[l - 3] ^ e[l - 8] ^ e[l - 14] ^ e[l - 16];
  for (var _ = 0; _ < 80; ++_) {
    var P = ~~(_ / 20), h = rotl5$1(n) + ft$1(P, a, u, o) + d + e[_] + K$4[P] | 0;
    d = o, o = u, u = rotl30$1(a), a = n, n = h;
  }
  this._a = n + this._a | 0, this._b = a + this._b | 0, this._c = u + this._c | 0, this._d = o + this._d | 0, this._e = d + this._e | 0;
};
Sha.prototype._hash = function() {
  var t = Buffer$v.allocUnsafe(20);
  return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
};
var sha$4 = Sha, inherits$l = inherits_browserExports, Hash$5 = hash$3, Buffer$u = safeBufferExports$1.Buffer, K$3 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$4 = new Array(80);
function Sha1() {
  this.init(), this._w = W$4, Hash$5.call(this, 64, 56);
}
inherits$l(Sha1, Hash$5);
Sha1.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl1(t) {
  return t << 1 | t >>> 31;
}
function rotl5(t) {
  return t << 5 | t >>> 27;
}
function rotl30(t) {
  return t << 30 | t >>> 2;
}
function ft(t, e, n, a) {
  return t === 0 ? e & n | ~e & a : t === 2 ? e & n | e & a | n & a : e ^ n ^ a;
}
Sha1.prototype._update = function(t) {
  for (var e = this._w, n = this._a | 0, a = this._b | 0, u = this._c | 0, o = this._d | 0, d = this._e | 0, l = 0; l < 16; ++l) e[l] = t.readInt32BE(l * 4);
  for (; l < 80; ++l) e[l] = rotl1(e[l - 3] ^ e[l - 8] ^ e[l - 14] ^ e[l - 16]);
  for (var _ = 0; _ < 80; ++_) {
    var P = ~~(_ / 20), h = rotl5(n) + ft(P, a, u, o) + d + e[_] + K$3[P] | 0;
    d = o, o = u, u = rotl30(a), a = n, n = h;
  }
  this._a = n + this._a | 0, this._b = a + this._b | 0, this._c = u + this._c | 0, this._d = o + this._d | 0, this._e = d + this._e | 0;
};
Sha1.prototype._hash = function() {
  var t = Buffer$u.allocUnsafe(20);
  return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
};
var sha1 = Sha1, inherits$k = inherits_browserExports, Hash$4 = hash$3, Buffer$t = safeBufferExports$1.Buffer, K$2 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], W$3 = new Array(64);
function Sha256$1() {
  this.init(), this._w = W$3, Hash$4.call(this, 64, 56);
}
inherits$k(Sha256$1, Hash$4);
Sha256$1.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function ch(t, e, n) {
  return n ^ t & (e ^ n);
}
function maj$1(t, e, n) {
  return t & e | n & (t | e);
}
function sigma0$1(t) {
  return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
}
function sigma1$1(t) {
  return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
}
function gamma0(t) {
  return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
}
function gamma1(t) {
  return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10;
}
Sha256$1.prototype._update = function(t) {
  for (var e = this._w, n = this._a | 0, a = this._b | 0, u = this._c | 0, o = this._d | 0, d = this._e | 0, l = this._f | 0, _ = this._g | 0, P = this._h | 0, h = 0; h < 16; ++h) e[h] = t.readInt32BE(h * 4);
  for (; h < 64; ++h) e[h] = gamma1(e[h - 2]) + e[h - 7] + gamma0(e[h - 15]) + e[h - 16] | 0;
  for (var x = 0; x < 64; ++x) {
    var C = P + sigma1$1(d) + ch(d, l, _) + K$2[x] + e[x] | 0, D = sigma0$1(n) + maj$1(n, a, u) | 0;
    P = _, _ = l, l = d, d = o + C | 0, o = u, u = a, a = n, n = C + D | 0;
  }
  this._a = n + this._a | 0, this._b = a + this._b | 0, this._c = u + this._c | 0, this._d = o + this._d | 0, this._e = d + this._e | 0, this._f = l + this._f | 0, this._g = _ + this._g | 0, this._h = P + this._h | 0;
};
Sha256$1.prototype._hash = function() {
  var t = Buffer$t.allocUnsafe(32);
  return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
};
var sha256$1 = Sha256$1, inherits$j = inherits_browserExports, Sha256 = sha256$1, Hash$3 = hash$3, Buffer$s = safeBufferExports$1.Buffer, W$2 = new Array(64);
function Sha224() {
  this.init(), this._w = W$2, Hash$3.call(this, 64, 56);
}
inherits$j(Sha224, Sha256);
Sha224.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
Sha224.prototype._hash = function() {
  var t = Buffer$s.allocUnsafe(28);
  return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
};
var sha224$1 = Sha224, inherits$i = inherits_browserExports, Hash$2 = hash$3, Buffer$r = safeBufferExports$1.Buffer, K$1 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], W$1 = new Array(160);
function Sha512() {
  this.init(), this._w = W$1, Hash$2.call(this, 128, 112);
}
inherits$i(Sha512, Hash$2);
Sha512.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function Ch(t, e, n) {
  return n ^ t & (e ^ n);
}
function maj(t, e, n) {
  return t & e | n & (t | e);
}
function sigma0(t, e) {
  return (t >>> 28 | e << 4) ^ (e >>> 2 | t << 30) ^ (e >>> 7 | t << 25);
}
function sigma1(t, e) {
  return (t >>> 14 | e << 18) ^ (t >>> 18 | e << 14) ^ (e >>> 9 | t << 23);
}
function Gamma0(t, e) {
  return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ t >>> 7;
}
function Gamma0l(t, e) {
  return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ (t >>> 7 | e << 25);
}
function Gamma1(t, e) {
  return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ t >>> 6;
}
function Gamma1l(t, e) {
  return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ (t >>> 6 | e << 26);
}
function getCarry(t, e) {
  return t >>> 0 < e >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(t) {
  for (var e = this._w, n = this._ah | 0, a = this._bh | 0, u = this._ch | 0, o = this._dh | 0, d = this._eh | 0, l = this._fh | 0, _ = this._gh | 0, P = this._hh | 0, h = this._al | 0, x = this._bl | 0, C = this._cl | 0, D = this._dl | 0, q = this._el | 0, H = this._fl | 0, Y = this._gl | 0, z = this._hl | 0, F = 0; F < 32; F += 2)
    e[F] = t.readInt32BE(F * 4), e[F + 1] = t.readInt32BE(F * 4 + 4);
  for (; F < 160; F += 2) {
    var X = e[F - 30], ee = e[F - 15 * 2 + 1], se = Gamma0(X, ee), ce = Gamma0l(ee, X);
    X = e[F - 2 * 2], ee = e[F - 2 * 2 + 1];
    var le = Gamma1(X, ee), he = Gamma1l(ee, X), oe = e[F - 7 * 2], _e = e[F - 7 * 2 + 1], J = e[F - 16 * 2], w = e[F - 16 * 2 + 1], m = ce + _e | 0, c = se + oe + getCarry(m, ce) | 0;
    m = m + he | 0, c = c + le + getCarry(m, he) | 0, m = m + w | 0, c = c + J + getCarry(m, w) | 0, e[F] = c, e[F + 1] = m;
  }
  for (var v = 0; v < 160; v += 2) {
    c = e[v], m = e[v + 1];
    var $ = maj(n, a, u), S = maj(h, x, C), A = sigma0(n, h), M = sigma0(h, n), p = sigma1(d, q), B = sigma1(q, d), b = K$1[v], k = K$1[v + 1], Z = Ch(d, l, _), te = Ch(q, H, Y), V = z + B | 0, T = P + p + getCarry(V, z) | 0;
    V = V + te | 0, T = T + Z + getCarry(V, te) | 0, V = V + k | 0, T = T + b + getCarry(V, k) | 0, V = V + m | 0, T = T + c + getCarry(V, m) | 0;
    var O = M + S | 0, Q = A + $ + getCarry(O, M) | 0;
    P = _, z = Y, _ = l, Y = H, l = d, H = q, q = D + V | 0, d = o + T + getCarry(q, D) | 0, o = u, D = C, u = a, C = x, a = n, x = h, h = V + O | 0, n = T + Q + getCarry(h, V) | 0;
  }
  this._al = this._al + h | 0, this._bl = this._bl + x | 0, this._cl = this._cl + C | 0, this._dl = this._dl + D | 0, this._el = this._el + q | 0, this._fl = this._fl + H | 0, this._gl = this._gl + Y | 0, this._hl = this._hl + z | 0, this._ah = this._ah + n + getCarry(this._al, h) | 0, this._bh = this._bh + a + getCarry(this._bl, x) | 0, this._ch = this._ch + u + getCarry(this._cl, C) | 0, this._dh = this._dh + o + getCarry(this._dl, D) | 0, this._eh = this._eh + d + getCarry(this._el, q) | 0, this._fh = this._fh + l + getCarry(this._fl, H) | 0, this._gh = this._gh + _ + getCarry(this._gl, Y) | 0, this._hh = this._hh + P + getCarry(this._hl, z) | 0;
};
Sha512.prototype._hash = function() {
  var t = Buffer$r.allocUnsafe(64);
  function e(n, a, u) {
    t.writeInt32BE(n, u), t.writeInt32BE(a, u + 4);
  }
  return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t;
};
var sha512$1 = Sha512, inherits$h = inherits_browserExports, SHA512$2 = sha512$1, Hash$1 = hash$3, Buffer$q = safeBufferExports$1.Buffer, W = new Array(160);
function Sha384() {
  this.init(), this._w = W, Hash$1.call(this, 128, 112);
}
inherits$h(Sha384, SHA512$2);
Sha384.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
Sha384.prototype._hash = function() {
  var t = Buffer$q.allocUnsafe(48);
  function e(n, a, u) {
    t.writeInt32BE(n, u), t.writeInt32BE(a, u + 4);
  }
  return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t;
};
var sha384$1 = Sha384;
sha_js.exports;
var exports = sha_js.exports = function(e) {
  e = e.toLowerCase();
  var n = exports[e];
  if (!n) throw new Error(e + " is not supported (we accept pull requests)");
  return new n();
};
exports.sha = sha$4;
exports.sha1 = sha1;
exports.sha224 = sha224$1;
exports.sha256 = sha256$1;
exports.sha384 = sha384$1;
exports.sha512 = sha512$1;
var sha_jsExports = sha_js.exports, Buffer$p = safeBufferExports$1.Buffer, Transform$6 = streamBrowserify.Transform, StringDecoder = string_decoder.StringDecoder, inherits$g = inherits_browserExports;
function CipherBase$1(t) {
  Transform$6.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
inherits$g(CipherBase$1, Transform$6);
var useUint8Array = typeof Uint8Array < "u", useArrayBuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (Buffer$p.prototype instanceof Uint8Array || Buffer$p.TYPED_ARRAY_SUPPORT);
function toBuffer$3(t, e) {
  if (t instanceof Buffer$p)
    return t;
  if (typeof t == "string")
    return Buffer$p.from(t, e);
  if (useArrayBuffer && ArrayBuffer.isView(t)) {
    if (t.byteLength === 0)
      return Buffer$p.alloc(0);
    var n = Buffer$p.from(t.buffer, t.byteOffset, t.byteLength);
    if (n.byteLength === t.byteLength)
      return n;
  }
  if (useUint8Array && t instanceof Uint8Array || Buffer$p.isBuffer(t) && t.constructor && typeof t.constructor.isBuffer == "function" && t.constructor.isBuffer(t))
    return Buffer$p.from(t);
  throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
}
CipherBase$1.prototype.update = function(t, e, n) {
  var a = toBuffer$3(t, e), u = this._update(a);
  return this.hashMode ? this : (n && (u = this._toString(u, n)), u);
};
CipherBase$1.prototype.setAutoPadding = function() {
};
CipherBase$1.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
CipherBase$1.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
CipherBase$1.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
CipherBase$1.prototype._transform = function(t, e, n) {
  var a;
  try {
    this.hashMode ? this._update(t) : this.push(this._update(t));
  } catch (u) {
    a = u;
  } finally {
    n(a);
  }
};
CipherBase$1.prototype._flush = function(t) {
  var e;
  try {
    this.push(this.__final());
  } catch (n) {
    e = n;
  }
  t(e);
};
CipherBase$1.prototype._finalOrDigest = function(t) {
  var e = this.__final() || Buffer$p.alloc(0);
  return t && (e = this._toString(e, t, !0)), e;
};
CipherBase$1.prototype._toString = function(t, e, n) {
  if (this._decoder || (this._decoder = new StringDecoder(e), this._encoding = e), this._encoding !== e)
    throw new Error("can’t switch encodings");
  var a = this._decoder.write(t);
  return n && (a += this._decoder.end()), a;
};
var cipherBase = CipherBase$1, inherits$f = inherits_browserExports, MD5$2 = md5_js, RIPEMD160$3 = ripemd160, sha$3 = sha_jsExports, Base$5 = cipherBase;
function Hash(t) {
  Base$5.call(this, "digest"), this._hash = t;
}
inherits$f(Hash, Base$5);
Hash.prototype._update = function(t) {
  this._hash.update(t);
};
Hash.prototype._final = function() {
  return this._hash.digest();
};
var browser$9 = function(e) {
  return e = e.toLowerCase(), e === "md5" ? new MD5$2() : e === "rmd160" || e === "ripemd160" ? new RIPEMD160$3() : new Hash(sha$3(e));
}, inherits$e = inherits_browserExports, Buffer$o = safeBufferExports$1.Buffer, Base$4 = cipherBase, ZEROS$2 = Buffer$o.alloc(128), blocksize = 64;
function Hmac$4(t, e) {
  Base$4.call(this, "digest"), typeof e == "string" && (e = Buffer$o.from(e)), this._alg = t, this._key = e, e.length > blocksize ? e = t(e) : e.length < blocksize && (e = Buffer$o.concat([e, ZEROS$2], blocksize));
  for (var n = this._ipad = Buffer$o.allocUnsafe(blocksize), a = this._opad = Buffer$o.allocUnsafe(blocksize), u = 0; u < blocksize; u++)
    n[u] = e[u] ^ 54, a[u] = e[u] ^ 92;
  this._hash = [n];
}
inherits$e(Hmac$4, Base$4);
Hmac$4.prototype._update = function(t) {
  this._hash.push(t);
};
Hmac$4.prototype._final = function() {
  var t = this._alg(Buffer$o.concat(this._hash));
  return this._alg(Buffer$o.concat([this._opad, t]));
};
var legacy = Hmac$4, MD5$1 = md5_js, md5$2 = function(t) {
  return new MD5$1().update(t).digest();
}, inherits$d = inherits_browserExports, Legacy = legacy, Base$3 = cipherBase, Buffer$n = safeBufferExports$1.Buffer, md5$1 = md5$2, RIPEMD160$2 = ripemd160, sha$2 = sha_jsExports, ZEROS$1 = Buffer$n.alloc(128);
function Hmac$3(t, e) {
  Base$3.call(this, "digest"), typeof e == "string" && (e = Buffer$n.from(e));
  var n = t === "sha512" || t === "sha384" ? 128 : 64;
  if (this._alg = t, this._key = e, e.length > n) {
    var a = t === "rmd160" ? new RIPEMD160$2() : sha$2(t);
    e = a.update(e).digest();
  } else e.length < n && (e = Buffer$n.concat([e, ZEROS$1], n));
  for (var u = this._ipad = Buffer$n.allocUnsafe(n), o = this._opad = Buffer$n.allocUnsafe(n), d = 0; d < n; d++)
    u[d] = e[d] ^ 54, o[d] = e[d] ^ 92;
  this._hash = t === "rmd160" ? new RIPEMD160$2() : sha$2(t), this._hash.update(u);
}
inherits$d(Hmac$3, Base$3);
Hmac$3.prototype._update = function(t) {
  this._hash.update(t);
};
Hmac$3.prototype._final = function() {
  var t = this._hash.digest(), e = this._alg === "rmd160" ? new RIPEMD160$2() : sha$2(this._alg);
  return e.update(this._opad).update(t).digest();
};
var browser$8 = function(e, n) {
  return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new Hmac$3("rmd160", n) : e === "md5" ? new Legacy(md5$1, n) : new Hmac$3(e, n);
};
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos = require$$6, browser$7 = {}, MAX_ALLOC = Math.pow(2, 30) - 1, precondition = function(t, e) {
  if (typeof t != "number")
    throw new TypeError("Iterations not a number");
  if (t < 0)
    throw new TypeError("Bad iterations");
  if (typeof e != "number")
    throw new TypeError("Key length not a number");
  if (e < 0 || e > MAX_ALLOC || e !== e)
    throw new TypeError("Bad key length");
}, defaultEncoding$2;
if (commonjsGlobal.process && commonjsGlobal.process.browser)
  defaultEncoding$2 = "utf-8";
else if (commonjsGlobal.process && commonjsGlobal.process.version) {
  var pVersionMajor = parseInt(process$1.version.split(".")[0].slice(1), 10);
  defaultEncoding$2 = pVersionMajor >= 6 ? "utf-8" : "binary";
} else
  defaultEncoding$2 = "utf-8";
var defaultEncoding_1 = defaultEncoding$2, Buffer$m = safeBufferExports$1.Buffer, toBuffer$2 = function(t, e, n) {
  if (Buffer$m.isBuffer(t))
    return t;
  if (typeof t == "string")
    return Buffer$m.from(t, e);
  if (ArrayBuffer.isView(t))
    return Buffer$m.from(t.buffer);
  throw new TypeError(n + " must be a string, a Buffer, a typed array or a DataView");
}, md5 = md5$2, RIPEMD160$1 = ripemd160, sha$1 = sha_jsExports, Buffer$l = safeBufferExports$1.Buffer, checkParameters$1 = precondition, defaultEncoding$1 = defaultEncoding_1, toBuffer$1 = toBuffer$2, ZEROS = Buffer$l.alloc(128), sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};
function Hmac$2(t, e, n) {
  var a = getDigest(t), u = t === "sha512" || t === "sha384" ? 128 : 64;
  e.length > u ? e = a(e) : e.length < u && (e = Buffer$l.concat([e, ZEROS], u));
  for (var o = Buffer$l.allocUnsafe(u + sizes[t]), d = Buffer$l.allocUnsafe(u + sizes[t]), l = 0; l < u; l++)
    o[l] = e[l] ^ 54, d[l] = e[l] ^ 92;
  var _ = Buffer$l.allocUnsafe(u + n + 4);
  o.copy(_, 0, 0, u), this.ipad1 = _, this.ipad2 = o, this.opad = d, this.alg = t, this.blocksize = u, this.hash = a, this.size = sizes[t];
}
Hmac$2.prototype.run = function(t, e) {
  t.copy(e, this.blocksize);
  var n = this.hash(e);
  return n.copy(this.opad, this.blocksize), this.hash(this.opad);
};
function getDigest(t) {
  function e(a) {
    return sha$1(t).update(a).digest();
  }
  function n(a) {
    return new RIPEMD160$1().update(a).digest();
  }
  return t === "rmd160" || t === "ripemd160" ? n : t === "md5" ? md5 : e;
}
function pbkdf2(t, e, n, a, u) {
  checkParameters$1(n, a), t = toBuffer$1(t, defaultEncoding$1, "Password"), e = toBuffer$1(e, defaultEncoding$1, "Salt"), u = u || "sha1";
  var o = new Hmac$2(u, t, e.length), d = Buffer$l.allocUnsafe(a), l = Buffer$l.allocUnsafe(e.length + 4);
  e.copy(l, 0, 0, e.length);
  for (var _ = 0, P = sizes[u], h = Math.ceil(a / P), x = 1; x <= h; x++) {
    l.writeUInt32BE(x, e.length);
    for (var C = o.run(l, o.ipad1), D = C, q = 1; q < n; q++) {
      D = o.run(D, o.ipad2);
      for (var H = 0; H < P; H++) C[H] ^= D[H];
    }
    C.copy(d, _), _ += P;
  }
  return d;
}
var syncBrowser = pbkdf2, Buffer$k = safeBufferExports$1.Buffer, checkParameters = precondition, defaultEncoding = defaultEncoding_1, sync = syncBrowser, toBuffer = toBuffer$2, ZERO_BUF, subtle = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, toBrowser = {
  sha: "SHA-1",
  "sha-1": "SHA-1",
  sha1: "SHA-1",
  sha256: "SHA-256",
  "sha-256": "SHA-256",
  sha384: "SHA-384",
  "sha-384": "SHA-384",
  "sha-512": "SHA-512",
  sha512: "SHA-512"
}, checks = [];
function checkNative(t) {
  if (commonjsGlobal.process && !commonjsGlobal.process.browser || !subtle || !subtle.importKey || !subtle.deriveBits)
    return Promise.resolve(!1);
  if (checks[t] !== void 0)
    return checks[t];
  ZERO_BUF = ZERO_BUF || Buffer$k.alloc(8);
  var e = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, t).then(function() {
    return !0;
  }).catch(function() {
    return !1;
  });
  return checks[t] = e, e;
}
var nextTick$1;
function getNextTick() {
  return nextTick$1 || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? nextTick$1 = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? nextTick$1 = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? nextTick$1 = commonjsGlobal.setImmediate : nextTick$1 = commonjsGlobal.setTimeout, nextTick$1);
}
function browserPbkdf2(t, e, n, a, u) {
  return subtle.importKey(
    "raw",
    t,
    { name: "PBKDF2" },
    !1,
    ["deriveBits"]
  ).then(function(o) {
    return subtle.deriveBits({
      name: "PBKDF2",
      salt: e,
      iterations: n,
      hash: {
        name: u
      }
    }, o, a << 3);
  }).then(function(o) {
    return Buffer$k.from(o);
  });
}
function resolvePromise(t, e) {
  t.then(function(n) {
    getNextTick()(function() {
      e(null, n);
    });
  }, function(n) {
    getNextTick()(function() {
      e(n);
    });
  });
}
var async = function(t, e, n, a, u, o) {
  typeof u == "function" && (o = u, u = void 0), u = u || "sha1";
  var d = toBrowser[u.toLowerCase()];
  if (!d || typeof commonjsGlobal.Promise != "function") {
    getNextTick()(function() {
      var l;
      try {
        l = sync(t, e, n, a, u);
      } catch (_) {
        return o(_);
      }
      o(null, l);
    });
    return;
  }
  if (checkParameters(n, a), t = toBuffer(t, defaultEncoding, "Password"), e = toBuffer(e, defaultEncoding, "Salt"), typeof o != "function") throw new Error("No callback provided to pbkdf2");
  resolvePromise(checkNative(d).then(function(l) {
    return l ? browserPbkdf2(t, e, n, a, d) : sync(t, e, n, a, u);
  }), o);
};
browser$7.pbkdf2 = async;
browser$7.pbkdf2Sync = syncBrowser;
var browser$6 = {}, des$2 = {}, utils$n = {};
utils$n.readUInt32BE = function(e, n) {
  var a = e[0 + n] << 24 | e[1 + n] << 16 | e[2 + n] << 8 | e[3 + n];
  return a >>> 0;
};
utils$n.writeUInt32BE = function(e, n, a) {
  e[0 + a] = n >>> 24, e[1 + a] = n >>> 16 & 255, e[2 + a] = n >>> 8 & 255, e[3 + a] = n & 255;
};
utils$n.ip = function(e, n, a, u) {
  for (var o = 0, d = 0, l = 6; l >= 0; l -= 2) {
    for (var _ = 0; _ <= 24; _ += 8)
      o <<= 1, o |= n >>> _ + l & 1;
    for (var _ = 0; _ <= 24; _ += 8)
      o <<= 1, o |= e >>> _ + l & 1;
  }
  for (var l = 6; l >= 0; l -= 2) {
    for (var _ = 1; _ <= 25; _ += 8)
      d <<= 1, d |= n >>> _ + l & 1;
    for (var _ = 1; _ <= 25; _ += 8)
      d <<= 1, d |= e >>> _ + l & 1;
  }
  a[u + 0] = o >>> 0, a[u + 1] = d >>> 0;
};
utils$n.rip = function(e, n, a, u) {
  for (var o = 0, d = 0, l = 0; l < 4; l++)
    for (var _ = 24; _ >= 0; _ -= 8)
      o <<= 1, o |= n >>> _ + l & 1, o <<= 1, o |= e >>> _ + l & 1;
  for (var l = 4; l < 8; l++)
    for (var _ = 24; _ >= 0; _ -= 8)
      d <<= 1, d |= n >>> _ + l & 1, d <<= 1, d |= e >>> _ + l & 1;
  a[u + 0] = o >>> 0, a[u + 1] = d >>> 0;
};
utils$n.pc1 = function(e, n, a, u) {
  for (var o = 0, d = 0, l = 7; l >= 5; l--) {
    for (var _ = 0; _ <= 24; _ += 8)
      o <<= 1, o |= n >> _ + l & 1;
    for (var _ = 0; _ <= 24; _ += 8)
      o <<= 1, o |= e >> _ + l & 1;
  }
  for (var _ = 0; _ <= 24; _ += 8)
    o <<= 1, o |= n >> _ + l & 1;
  for (var l = 1; l <= 3; l++) {
    for (var _ = 0; _ <= 24; _ += 8)
      d <<= 1, d |= n >> _ + l & 1;
    for (var _ = 0; _ <= 24; _ += 8)
      d <<= 1, d |= e >> _ + l & 1;
  }
  for (var _ = 0; _ <= 24; _ += 8)
    d <<= 1, d |= e >> _ + l & 1;
  a[u + 0] = o >>> 0, a[u + 1] = d >>> 0;
};
utils$n.r28shl = function(e, n) {
  return e << n & 268435455 | e >>> 28 - n;
};
var pc2table = [
  // inL => outL
  14,
  11,
  17,
  4,
  27,
  23,
  25,
  0,
  13,
  22,
  7,
  18,
  5,
  9,
  16,
  24,
  2,
  20,
  12,
  21,
  1,
  8,
  15,
  26,
  // inR => outR
  15,
  4,
  25,
  19,
  9,
  1,
  26,
  16,
  5,
  11,
  23,
  8,
  12,
  7,
  17,
  0,
  22,
  3,
  10,
  14,
  6,
  20,
  27,
  24
];
utils$n.pc2 = function(e, n, a, u) {
  for (var o = 0, d = 0, l = pc2table.length >>> 1, _ = 0; _ < l; _++)
    o <<= 1, o |= e >>> pc2table[_] & 1;
  for (var _ = l; _ < pc2table.length; _++)
    d <<= 1, d |= n >>> pc2table[_] & 1;
  a[u + 0] = o >>> 0, a[u + 1] = d >>> 0;
};
utils$n.expand = function(e, n, a) {
  var u = 0, o = 0;
  u = (e & 1) << 5 | e >>> 27;
  for (var d = 23; d >= 15; d -= 4)
    u <<= 6, u |= e >>> d & 63;
  for (var d = 11; d >= 3; d -= 4)
    o |= e >>> d & 63, o <<= 6;
  o |= (e & 31) << 1 | e >>> 31, n[a + 0] = u >>> 0, n[a + 1] = o >>> 0;
};
var sTable = [
  14,
  0,
  4,
  15,
  13,
  7,
  1,
  4,
  2,
  14,
  15,
  2,
  11,
  13,
  8,
  1,
  3,
  10,
  10,
  6,
  6,
  12,
  12,
  11,
  5,
  9,
  9,
  5,
  0,
  3,
  7,
  8,
  4,
  15,
  1,
  12,
  14,
  8,
  8,
  2,
  13,
  4,
  6,
  9,
  2,
  1,
  11,
  7,
  15,
  5,
  12,
  11,
  9,
  3,
  7,
  14,
  3,
  10,
  10,
  0,
  5,
  6,
  0,
  13,
  15,
  3,
  1,
  13,
  8,
  4,
  14,
  7,
  6,
  15,
  11,
  2,
  3,
  8,
  4,
  14,
  9,
  12,
  7,
  0,
  2,
  1,
  13,
  10,
  12,
  6,
  0,
  9,
  5,
  11,
  10,
  5,
  0,
  13,
  14,
  8,
  7,
  10,
  11,
  1,
  10,
  3,
  4,
  15,
  13,
  4,
  1,
  2,
  5,
  11,
  8,
  6,
  12,
  7,
  6,
  12,
  9,
  0,
  3,
  5,
  2,
  14,
  15,
  9,
  10,
  13,
  0,
  7,
  9,
  0,
  14,
  9,
  6,
  3,
  3,
  4,
  15,
  6,
  5,
  10,
  1,
  2,
  13,
  8,
  12,
  5,
  7,
  14,
  11,
  12,
  4,
  11,
  2,
  15,
  8,
  1,
  13,
  1,
  6,
  10,
  4,
  13,
  9,
  0,
  8,
  6,
  15,
  9,
  3,
  8,
  0,
  7,
  11,
  4,
  1,
  15,
  2,
  14,
  12,
  3,
  5,
  11,
  10,
  5,
  14,
  2,
  7,
  12,
  7,
  13,
  13,
  8,
  14,
  11,
  3,
  5,
  0,
  6,
  6,
  15,
  9,
  0,
  10,
  3,
  1,
  4,
  2,
  7,
  8,
  2,
  5,
  12,
  11,
  1,
  12,
  10,
  4,
  14,
  15,
  9,
  10,
  3,
  6,
  15,
  9,
  0,
  0,
  6,
  12,
  10,
  11,
  1,
  7,
  13,
  13,
  8,
  15,
  9,
  1,
  4,
  3,
  5,
  14,
  11,
  5,
  12,
  2,
  7,
  8,
  2,
  4,
  14,
  2,
  14,
  12,
  11,
  4,
  2,
  1,
  12,
  7,
  4,
  10,
  7,
  11,
  13,
  6,
  1,
  8,
  5,
  5,
  0,
  3,
  15,
  15,
  10,
  13,
  3,
  0,
  9,
  14,
  8,
  9,
  6,
  4,
  11,
  2,
  8,
  1,
  12,
  11,
  7,
  10,
  1,
  13,
  14,
  7,
  2,
  8,
  13,
  15,
  6,
  9,
  15,
  12,
  0,
  5,
  9,
  6,
  10,
  3,
  4,
  0,
  5,
  14,
  3,
  12,
  10,
  1,
  15,
  10,
  4,
  15,
  2,
  9,
  7,
  2,
  12,
  6,
  9,
  8,
  5,
  0,
  6,
  13,
  1,
  3,
  13,
  4,
  14,
  14,
  0,
  7,
  11,
  5,
  3,
  11,
  8,
  9,
  4,
  14,
  3,
  15,
  2,
  5,
  12,
  2,
  9,
  8,
  5,
  12,
  15,
  3,
  10,
  7,
  11,
  0,
  14,
  4,
  1,
  10,
  7,
  1,
  6,
  13,
  0,
  11,
  8,
  6,
  13,
  4,
  13,
  11,
  0,
  2,
  11,
  14,
  7,
  15,
  4,
  0,
  9,
  8,
  1,
  13,
  10,
  3,
  14,
  12,
  3,
  9,
  5,
  7,
  12,
  5,
  2,
  10,
  15,
  6,
  8,
  1,
  6,
  1,
  6,
  4,
  11,
  11,
  13,
  13,
  8,
  12,
  1,
  3,
  4,
  7,
  10,
  14,
  7,
  10,
  9,
  15,
  5,
  6,
  0,
  8,
  15,
  0,
  14,
  5,
  2,
  9,
  3,
  2,
  12,
  13,
  1,
  2,
  15,
  8,
  13,
  4,
  8,
  6,
  10,
  15,
  3,
  11,
  7,
  1,
  4,
  10,
  12,
  9,
  5,
  3,
  6,
  14,
  11,
  5,
  0,
  0,
  14,
  12,
  9,
  7,
  2,
  7,
  2,
  11,
  1,
  4,
  14,
  1,
  7,
  9,
  4,
  12,
  10,
  14,
  8,
  2,
  13,
  0,
  15,
  6,
  12,
  10,
  9,
  13,
  0,
  15,
  3,
  3,
  5,
  5,
  6,
  8,
  11
];
utils$n.substitute = function(e, n) {
  for (var a = 0, u = 0; u < 4; u++) {
    var o = e >>> 18 - u * 6 & 63, d = sTable[u * 64 + o];
    a <<= 4, a |= d;
  }
  for (var u = 0; u < 4; u++) {
    var o = n >>> 18 - u * 6 & 63, d = sTable[4 * 64 + u * 64 + o];
    a <<= 4, a |= d;
  }
  return a >>> 0;
};
var permuteTable = [
  16,
  25,
  12,
  11,
  3,
  20,
  4,
  15,
  31,
  17,
  9,
  6,
  27,
  14,
  1,
  22,
  30,
  24,
  8,
  18,
  0,
  5,
  29,
  23,
  13,
  19,
  2,
  26,
  10,
  21,
  28,
  7
];
utils$n.permute = function(e) {
  for (var n = 0, a = 0; a < permuteTable.length; a++)
    n <<= 1, n |= e >>> permuteTable[a] & 1;
  return n >>> 0;
};
utils$n.padSplit = function(e, n, a) {
  for (var u = e.toString(2); u.length < n; )
    u = "0" + u;
  for (var o = [], d = 0; d < n; d += a)
    o.push(u.slice(d, d + a));
  return o.join(" ");
};
var minimalisticAssert = assert$i;
function assert$i(t, e) {
  if (!t)
    throw new Error(e || "Assertion failed");
}
assert$i.equal = function(e, n, a) {
  if (e != n)
    throw new Error(a || "Assertion failed: " + e + " != " + n);
};
var assert$h = minimalisticAssert;
function Cipher$3(t) {
  this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = t.padding !== !1;
}
var cipher = Cipher$3;
Cipher$3.prototype._init = function() {
};
Cipher$3.prototype.update = function(e) {
  return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e);
};
Cipher$3.prototype._buffer = function(e, n) {
  for (var a = Math.min(this.buffer.length - this.bufferOff, e.length - n), u = 0; u < a; u++)
    this.buffer[this.bufferOff + u] = e[n + u];
  return this.bufferOff += a, a;
};
Cipher$3.prototype._flushBuffer = function(e, n) {
  return this._update(this.buffer, 0, e, n), this.bufferOff = 0, this.blockSize;
};
Cipher$3.prototype._updateEncrypt = function(e) {
  var n = 0, a = 0, u = (this.bufferOff + e.length) / this.blockSize | 0, o = new Array(u * this.blockSize);
  this.bufferOff !== 0 && (n += this._buffer(e, n), this.bufferOff === this.buffer.length && (a += this._flushBuffer(o, a)));
  for (var d = e.length - (e.length - n) % this.blockSize; n < d; n += this.blockSize)
    this._update(e, n, o, a), a += this.blockSize;
  for (; n < e.length; n++, this.bufferOff++)
    this.buffer[this.bufferOff] = e[n];
  return o;
};
Cipher$3.prototype._updateDecrypt = function(e) {
  for (var n = 0, a = 0, u = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, o = new Array(u * this.blockSize); u > 0; u--)
    n += this._buffer(e, n), a += this._flushBuffer(o, a);
  return n += this._buffer(e, n), o;
};
Cipher$3.prototype.final = function(e) {
  var n;
  e && (n = this.update(e));
  var a;
  return this.type === "encrypt" ? a = this._finalEncrypt() : a = this._finalDecrypt(), n ? n.concat(a) : a;
};
Cipher$3.prototype._pad = function(e, n) {
  if (n === 0)
    return !1;
  for (; n < e.length; )
    e[n++] = 0;
  return !0;
};
Cipher$3.prototype._finalEncrypt = function() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];
  var e = new Array(this.blockSize);
  return this._update(this.buffer, 0, e, 0), e;
};
Cipher$3.prototype._unpad = function(e) {
  return e;
};
Cipher$3.prototype._finalDecrypt = function() {
  assert$h.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
  var e = new Array(this.blockSize);
  return this._flushBuffer(e, 0), this._unpad(e);
};
var assert$g = minimalisticAssert, inherits$c = inherits_browserExports, utils$m = utils$n, Cipher$2 = cipher;
function DESState() {
  this.tmp = new Array(2), this.keys = null;
}
function DES$3(t) {
  Cipher$2.call(this, t);
  var e = new DESState();
  this._desState = e, this.deriveKeys(e, t.key);
}
inherits$c(DES$3, Cipher$2);
var des$1 = DES$3;
DES$3.create = function(e) {
  return new DES$3(e);
};
var shiftTable = [
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1
];
DES$3.prototype.deriveKeys = function(e, n) {
  e.keys = new Array(16 * 2), assert$g.equal(n.length, this.blockSize, "Invalid key length");
  var a = utils$m.readUInt32BE(n, 0), u = utils$m.readUInt32BE(n, 4);
  utils$m.pc1(a, u, e.tmp, 0), a = e.tmp[0], u = e.tmp[1];
  for (var o = 0; o < e.keys.length; o += 2) {
    var d = shiftTable[o >>> 1];
    a = utils$m.r28shl(a, d), u = utils$m.r28shl(u, d), utils$m.pc2(a, u, e.keys, o);
  }
};
DES$3.prototype._update = function(e, n, a, u) {
  var o = this._desState, d = utils$m.readUInt32BE(e, n), l = utils$m.readUInt32BE(e, n + 4);
  utils$m.ip(d, l, o.tmp, 0), d = o.tmp[0], l = o.tmp[1], this.type === "encrypt" ? this._encrypt(o, d, l, o.tmp, 0) : this._decrypt(o, d, l, o.tmp, 0), d = o.tmp[0], l = o.tmp[1], utils$m.writeUInt32BE(a, d, u), utils$m.writeUInt32BE(a, l, u + 4);
};
DES$3.prototype._pad = function(e, n) {
  if (this.padding === !1)
    return !1;
  for (var a = e.length - n, u = n; u < e.length; u++)
    e[u] = a;
  return !0;
};
DES$3.prototype._unpad = function(e) {
  if (this.padding === !1)
    return e;
  for (var n = e[e.length - 1], a = e.length - n; a < e.length; a++)
    assert$g.equal(e[a], n);
  return e.slice(0, e.length - n);
};
DES$3.prototype._encrypt = function(e, n, a, u, o) {
  for (var d = n, l = a, _ = 0; _ < e.keys.length; _ += 2) {
    var P = e.keys[_], h = e.keys[_ + 1];
    utils$m.expand(l, e.tmp, 0), P ^= e.tmp[0], h ^= e.tmp[1];
    var x = utils$m.substitute(P, h), C = utils$m.permute(x), D = l;
    l = (d ^ C) >>> 0, d = D;
  }
  utils$m.rip(l, d, u, o);
};
DES$3.prototype._decrypt = function(e, n, a, u, o) {
  for (var d = a, l = n, _ = e.keys.length - 2; _ >= 0; _ -= 2) {
    var P = e.keys[_], h = e.keys[_ + 1];
    utils$m.expand(d, e.tmp, 0), P ^= e.tmp[0], h ^= e.tmp[1];
    var x = utils$m.substitute(P, h), C = utils$m.permute(x), D = d;
    d = (l ^ C) >>> 0, l = D;
  }
  utils$m.rip(d, l, u, o);
};
var cbc$1 = {}, assert$f = minimalisticAssert, inherits$b = inherits_browserExports, proto = {};
function CBCState(t) {
  assert$f.equal(t.length, 8, "Invalid IV length"), this.iv = new Array(8);
  for (var e = 0; e < this.iv.length; e++)
    this.iv[e] = t[e];
}
function instantiate(t) {
  function e(o) {
    t.call(this, o), this._cbcInit();
  }
  inherits$b(e, t);
  for (var n = Object.keys(proto), a = 0; a < n.length; a++) {
    var u = n[a];
    e.prototype[u] = proto[u];
  }
  return e.create = function(d) {
    return new e(d);
  }, e;
}
cbc$1.instantiate = instantiate;
proto._cbcInit = function() {
  var e = new CBCState(this.options.iv);
  this._cbcState = e;
};
proto._update = function(e, n, a, u) {
  var o = this._cbcState, d = this.constructor.super_.prototype, l = o.iv;
  if (this.type === "encrypt") {
    for (var _ = 0; _ < this.blockSize; _++)
      l[_] ^= e[n + _];
    d._update.call(this, l, 0, a, u);
    for (var _ = 0; _ < this.blockSize; _++)
      l[_] = a[u + _];
  } else {
    d._update.call(this, e, n, a, u);
    for (var _ = 0; _ < this.blockSize; _++)
      a[u + _] ^= l[_];
    for (var _ = 0; _ < this.blockSize; _++)
      l[_] = e[n + _];
  }
};
var assert$e = minimalisticAssert, inherits$a = inherits_browserExports, Cipher$1 = cipher, DES$2 = des$1;
function EDEState(t, e) {
  assert$e.equal(e.length, 24, "Invalid key length");
  var n = e.slice(0, 8), a = e.slice(8, 16), u = e.slice(16, 24);
  t === "encrypt" ? this.ciphers = [
    DES$2.create({ type: "encrypt", key: n }),
    DES$2.create({ type: "decrypt", key: a }),
    DES$2.create({ type: "encrypt", key: u })
  ] : this.ciphers = [
    DES$2.create({ type: "decrypt", key: u }),
    DES$2.create({ type: "encrypt", key: a }),
    DES$2.create({ type: "decrypt", key: n })
  ];
}
function EDE(t) {
  Cipher$1.call(this, t);
  var e = new EDEState(this.type, this.options.key);
  this._edeState = e;
}
inherits$a(EDE, Cipher$1);
var ede = EDE;
EDE.create = function(e) {
  return new EDE(e);
};
EDE.prototype._update = function(e, n, a, u) {
  var o = this._edeState;
  o.ciphers[0]._update(e, n, a, u), o.ciphers[1]._update(a, u, a, u), o.ciphers[2]._update(a, u, a, u);
};
EDE.prototype._pad = DES$2.prototype._pad;
EDE.prototype._unpad = DES$2.prototype._unpad;
des$2.utils = utils$n;
des$2.Cipher = cipher;
des$2.DES = des$1;
des$2.CBC = cbc$1;
des$2.EDE = ede;
var CipherBase = cipherBase, des = des$2, inherits$9 = inherits_browserExports, Buffer$j = safeBufferExports$1.Buffer, modes$3 = {
  "des-ede3-cbc": des.CBC.instantiate(des.EDE),
  "des-ede3": des.EDE,
  "des-ede-cbc": des.CBC.instantiate(des.EDE),
  "des-ede": des.EDE,
  "des-cbc": des.CBC.instantiate(des.DES),
  "des-ecb": des.DES
};
modes$3.des = modes$3["des-cbc"];
modes$3.des3 = modes$3["des-ede3-cbc"];
var browserifyDes = DES$1;
inherits$9(DES$1, CipherBase);
function DES$1(t) {
  CipherBase.call(this);
  var e = t.mode.toLowerCase(), n = modes$3[e], a;
  t.decrypt ? a = "decrypt" : a = "encrypt";
  var u = t.key;
  Buffer$j.isBuffer(u) || (u = Buffer$j.from(u)), (e === "des-ede" || e === "des-ede-cbc") && (u = Buffer$j.concat([u, u.slice(0, 8)]));
  var o = t.iv;
  Buffer$j.isBuffer(o) || (o = Buffer$j.from(o)), this._des = n.create({
    key: u,
    iv: o,
    type: a
  });
}
DES$1.prototype._update = function(t) {
  return Buffer$j.from(this._des.update(t));
};
DES$1.prototype._final = function() {
  return Buffer$j.from(this._des.final());
};
var browser$5 = {}, encrypter = {}, ecb = {};
ecb.encrypt = function(t, e) {
  return t._cipher.encryptBlock(e);
};
ecb.decrypt = function(t, e) {
  return t._cipher.decryptBlock(e);
};
var cbc = {}, bufferXor = function(e, n) {
  for (var a = Math.min(e.length, n.length), u = new Buffer$C(a), o = 0; o < a; ++o)
    u[o] = e[o] ^ n[o];
  return u;
}, xor$7 = bufferXor;
cbc.encrypt = function(t, e) {
  var n = xor$7(e, t._prev);
  return t._prev = t._cipher.encryptBlock(n), t._prev;
};
cbc.decrypt = function(t, e) {
  var n = t._prev;
  t._prev = e;
  var a = t._cipher.decryptBlock(e);
  return xor$7(a, n);
};
var cfb = {}, Buffer$i = safeBufferExports$1.Buffer, xor$6 = bufferXor;
function encryptStart(t, e, n) {
  var a = e.length, u = xor$6(e, t._cache);
  return t._cache = t._cache.slice(a), t._prev = Buffer$i.concat([t._prev, n ? e : u]), u;
}
cfb.encrypt = function(t, e, n) {
  for (var a = Buffer$i.allocUnsafe(0), u; e.length; )
    if (t._cache.length === 0 && (t._cache = t._cipher.encryptBlock(t._prev), t._prev = Buffer$i.allocUnsafe(0)), t._cache.length <= e.length)
      u = t._cache.length, a = Buffer$i.concat([a, encryptStart(t, e.slice(0, u), n)]), e = e.slice(u);
    else {
      a = Buffer$i.concat([a, encryptStart(t, e, n)]);
      break;
    }
  return a;
};
var cfb8 = {}, Buffer$h = safeBufferExports$1.Buffer;
function encryptByte$1(t, e, n) {
  var a = t._cipher.encryptBlock(t._prev), u = a[0] ^ e;
  return t._prev = Buffer$h.concat([
    t._prev.slice(1),
    Buffer$h.from([n ? e : u])
  ]), u;
}
cfb8.encrypt = function(t, e, n) {
  for (var a = e.length, u = Buffer$h.allocUnsafe(a), o = -1; ++o < a; )
    u[o] = encryptByte$1(t, e[o], n);
  return u;
};
var cfb1 = {}, Buffer$g = safeBufferExports$1.Buffer;
function encryptByte(t, e, n) {
  for (var a, u = -1, o = 8, d = 0, l, _; ++u < o; )
    a = t._cipher.encryptBlock(t._prev), l = e & 1 << 7 - u ? 128 : 0, _ = a[0] ^ l, d += (_ & 128) >> u % 8, t._prev = shiftIn(t._prev, n ? l : _);
  return d;
}
function shiftIn(t, e) {
  var n = t.length, a = -1, u = Buffer$g.allocUnsafe(t.length);
  for (t = Buffer$g.concat([t, Buffer$g.from([e])]); ++a < n; )
    u[a] = t[a] << 1 | t[a + 1] >> 7;
  return u;
}
cfb1.encrypt = function(t, e, n) {
  for (var a = e.length, u = Buffer$g.allocUnsafe(a), o = -1; ++o < a; )
    u[o] = encryptByte(t, e[o], n);
  return u;
};
var ofb = {}, xor$5 = bufferXor;
function getBlock$1(t) {
  return t._prev = t._cipher.encryptBlock(t._prev), t._prev;
}
ofb.encrypt = function(t, e) {
  for (; t._cache.length < e.length; )
    t._cache = Buffer$C.concat([t._cache, getBlock$1(t)]);
  var n = t._cache.slice(0, e.length);
  return t._cache = t._cache.slice(e.length), xor$5(e, n);
};
var ctr = {};
function incr32$2(t) {
  for (var e = t.length, n; e--; )
    if (n = t.readUInt8(e), n === 255)
      t.writeUInt8(0, e);
    else {
      n++, t.writeUInt8(n, e);
      break;
    }
}
var incr32_1 = incr32$2, xor$4 = bufferXor, Buffer$f = safeBufferExports$1.Buffer, incr32$1 = incr32_1;
function getBlock(t) {
  var e = t._cipher.encryptBlockRaw(t._prev);
  return incr32$1(t._prev), e;
}
var blockSize = 16;
ctr.encrypt = function(t, e) {
  var n = Math.ceil(e.length / blockSize), a = t._cache.length;
  t._cache = Buffer$f.concat([
    t._cache,
    Buffer$f.allocUnsafe(n * blockSize)
  ]);
  for (var u = 0; u < n; u++) {
    var o = getBlock(t), d = a + u * blockSize;
    t._cache.writeUInt32BE(o[0], d + 0), t._cache.writeUInt32BE(o[1], d + 4), t._cache.writeUInt32BE(o[2], d + 8), t._cache.writeUInt32BE(o[3], d + 12);
  }
  var l = t._cache.slice(0, e.length);
  return t._cache = t._cache.slice(e.length), xor$4(e, l);
};
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modeModules = {
  ECB: ecb,
  CBC: cbc,
  CFB: cfb,
  CFB8: cfb8,
  CFB1: cfb1,
  OFB: ofb,
  CTR: ctr,
  GCM: ctr
}, modes$2 = require$$2;
for (var key$2 in modes$2)
  modes$2[key$2].module = modeModules[modes$2[key$2].mode];
var modes_1 = modes$2, aes$5 = {}, Buffer$e = safeBufferExports$1.Buffer;
function asUInt32Array(t) {
  Buffer$e.isBuffer(t) || (t = Buffer$e.from(t));
  for (var e = t.length / 4 | 0, n = new Array(e), a = 0; a < e; a++)
    n[a] = t.readUInt32BE(a * 4);
  return n;
}
function scrubVec(t) {
  for (var e = 0; e < t.length; t++)
    t[e] = 0;
}
function cryptBlock(t, e, n, a, u) {
  for (var o = n[0], d = n[1], l = n[2], _ = n[3], P = t[0] ^ e[0], h = t[1] ^ e[1], x = t[2] ^ e[2], C = t[3] ^ e[3], D, q, H, Y, z = 4, F = 1; F < u; F++)
    D = o[P >>> 24] ^ d[h >>> 16 & 255] ^ l[x >>> 8 & 255] ^ _[C & 255] ^ e[z++], q = o[h >>> 24] ^ d[x >>> 16 & 255] ^ l[C >>> 8 & 255] ^ _[P & 255] ^ e[z++], H = o[x >>> 24] ^ d[C >>> 16 & 255] ^ l[P >>> 8 & 255] ^ _[h & 255] ^ e[z++], Y = o[C >>> 24] ^ d[P >>> 16 & 255] ^ l[h >>> 8 & 255] ^ _[x & 255] ^ e[z++], P = D, h = q, x = H, C = Y;
  return D = (a[P >>> 24] << 24 | a[h >>> 16 & 255] << 16 | a[x >>> 8 & 255] << 8 | a[C & 255]) ^ e[z++], q = (a[h >>> 24] << 24 | a[x >>> 16 & 255] << 16 | a[C >>> 8 & 255] << 8 | a[P & 255]) ^ e[z++], H = (a[x >>> 24] << 24 | a[C >>> 16 & 255] << 16 | a[P >>> 8 & 255] << 8 | a[h & 255]) ^ e[z++], Y = (a[C >>> 24] << 24 | a[P >>> 16 & 255] << 16 | a[h >>> 8 & 255] << 8 | a[x & 255]) ^ e[z++], D = D >>> 0, q = q >>> 0, H = H >>> 0, Y = Y >>> 0, [D, q, H, Y];
}
var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], G = function() {
  for (var t = new Array(256), e = 0; e < 256; e++)
    e < 128 ? t[e] = e << 1 : t[e] = e << 1 ^ 283;
  for (var n = [], a = [], u = [[], [], [], []], o = [[], [], [], []], d = 0, l = 0, _ = 0; _ < 256; ++_) {
    var P = l ^ l << 1 ^ l << 2 ^ l << 3 ^ l << 4;
    P = P >>> 8 ^ P & 255 ^ 99, n[d] = P, a[P] = d;
    var h = t[d], x = t[h], C = t[x], D = t[P] * 257 ^ P * 16843008;
    u[0][d] = D << 24 | D >>> 8, u[1][d] = D << 16 | D >>> 16, u[2][d] = D << 8 | D >>> 24, u[3][d] = D, D = C * 16843009 ^ x * 65537 ^ h * 257 ^ d * 16843008, o[0][P] = D << 24 | D >>> 8, o[1][P] = D << 16 | D >>> 16, o[2][P] = D << 8 | D >>> 24, o[3][P] = D, d === 0 ? d = l = 1 : (d = h ^ t[t[t[C ^ h]]], l ^= t[t[l]]);
  }
  return {
    SBOX: n,
    INV_SBOX: a,
    SUB_MIX: u,
    INV_SUB_MIX: o
  };
}();
function AES(t) {
  this._key = asUInt32Array(t), this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
  for (var t = this._key, e = t.length, n = e + 6, a = (n + 1) * 4, u = [], o = 0; o < e; o++)
    u[o] = t[o];
  for (o = e; o < a; o++) {
    var d = u[o - 1];
    o % e === 0 ? (d = d << 8 | d >>> 24, d = G.SBOX[d >>> 24] << 24 | G.SBOX[d >>> 16 & 255] << 16 | G.SBOX[d >>> 8 & 255] << 8 | G.SBOX[d & 255], d ^= RCON[o / e | 0] << 24) : e > 6 && o % e === 4 && (d = G.SBOX[d >>> 24] << 24 | G.SBOX[d >>> 16 & 255] << 16 | G.SBOX[d >>> 8 & 255] << 8 | G.SBOX[d & 255]), u[o] = u[o - e] ^ d;
  }
  for (var l = [], _ = 0; _ < a; _++) {
    var P = a - _, h = u[P - (_ % 4 ? 0 : 4)];
    _ < 4 || P <= 4 ? l[_] = h : l[_] = G.INV_SUB_MIX[0][G.SBOX[h >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[h >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[h >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[h & 255]];
  }
  this._nRounds = n, this._keySchedule = u, this._invKeySchedule = l;
};
AES.prototype.encryptBlockRaw = function(t) {
  return t = asUInt32Array(t), cryptBlock(t, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(t) {
  var e = this.encryptBlockRaw(t), n = Buffer$e.allocUnsafe(16);
  return n.writeUInt32BE(e[0], 0), n.writeUInt32BE(e[1], 4), n.writeUInt32BE(e[2], 8), n.writeUInt32BE(e[3], 12), n;
};
AES.prototype.decryptBlock = function(t) {
  t = asUInt32Array(t);
  var e = t[1];
  t[1] = t[3], t[3] = e;
  var n = cryptBlock(t, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds), a = Buffer$e.allocUnsafe(16);
  return a.writeUInt32BE(n[0], 0), a.writeUInt32BE(n[3], 4), a.writeUInt32BE(n[2], 8), a.writeUInt32BE(n[1], 12), a;
};
AES.prototype.scrub = function() {
  scrubVec(this._keySchedule), scrubVec(this._invKeySchedule), scrubVec(this._key);
};
aes$5.AES = AES;
var Buffer$d = safeBufferExports$1.Buffer, ZEROES = Buffer$d.alloc(16, 0);
function toArray$1(t) {
  return [
    t.readUInt32BE(0),
    t.readUInt32BE(4),
    t.readUInt32BE(8),
    t.readUInt32BE(12)
  ];
}
function fromArray(t) {
  var e = Buffer$d.allocUnsafe(16);
  return e.writeUInt32BE(t[0] >>> 0, 0), e.writeUInt32BE(t[1] >>> 0, 4), e.writeUInt32BE(t[2] >>> 0, 8), e.writeUInt32BE(t[3] >>> 0, 12), e;
}
function GHASH$1(t) {
  this.h = t, this.state = Buffer$d.alloc(16, 0), this.cache = Buffer$d.allocUnsafe(0);
}
GHASH$1.prototype.ghash = function(t) {
  for (var e = -1; ++e < t.length; )
    this.state[e] ^= t[e];
  this._multiply();
};
GHASH$1.prototype._multiply = function() {
  for (var t = toArray$1(this.h), e = [0, 0, 0, 0], n, a, u, o = -1; ++o < 128; ) {
    for (a = (this.state[~~(o / 8)] & 1 << 7 - o % 8) !== 0, a && (e[0] ^= t[0], e[1] ^= t[1], e[2] ^= t[2], e[3] ^= t[3]), u = (t[3] & 1) !== 0, n = 3; n > 0; n--)
      t[n] = t[n] >>> 1 | (t[n - 1] & 1) << 31;
    t[0] = t[0] >>> 1, u && (t[0] = t[0] ^ 225 << 24);
  }
  this.state = fromArray(e);
};
GHASH$1.prototype.update = function(t) {
  this.cache = Buffer$d.concat([this.cache, t]);
  for (var e; this.cache.length >= 16; )
    e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e);
};
GHASH$1.prototype.final = function(t, e) {
  return this.cache.length && this.ghash(Buffer$d.concat([this.cache, ZEROES], 16)), this.ghash(fromArray([0, t, 0, e])), this.state;
};
var ghash = GHASH$1, aes$4 = aes$5, Buffer$c = safeBufferExports$1.Buffer, Transform$5 = cipherBase, inherits$8 = inherits_browserExports, GHASH = ghash, xor$3 = bufferXor, incr32 = incr32_1;
function xorTest(t, e) {
  var n = 0;
  t.length !== e.length && n++;
  for (var a = Math.min(t.length, e.length), u = 0; u < a; ++u)
    n += t[u] ^ e[u];
  return n;
}
function calcIv(t, e, n) {
  if (e.length === 12)
    return t._finID = Buffer$c.concat([e, Buffer$c.from([0, 0, 0, 1])]), Buffer$c.concat([e, Buffer$c.from([0, 0, 0, 2])]);
  var a = new GHASH(n), u = e.length, o = u % 16;
  a.update(e), o && (o = 16 - o, a.update(Buffer$c.alloc(o, 0))), a.update(Buffer$c.alloc(8, 0));
  var d = u * 8, l = Buffer$c.alloc(8);
  l.writeUIntBE(d, 0, 8), a.update(l), t._finID = a.state;
  var _ = Buffer$c.from(t._finID);
  return incr32(_), _;
}
function StreamCipher$3(t, e, n, a) {
  Transform$5.call(this);
  var u = Buffer$c.alloc(4, 0);
  this._cipher = new aes$4.AES(e);
  var o = this._cipher.encryptBlock(u);
  this._ghash = new GHASH(o), n = calcIv(this, n, o), this._prev = Buffer$c.from(n), this._cache = Buffer$c.allocUnsafe(0), this._secCache = Buffer$c.allocUnsafe(0), this._decrypt = a, this._alen = 0, this._len = 0, this._mode = t, this._authTag = null, this._called = !1;
}
inherits$8(StreamCipher$3, Transform$5);
StreamCipher$3.prototype._update = function(t) {
  if (!this._called && this._alen) {
    var e = 16 - this._alen % 16;
    e < 16 && (e = Buffer$c.alloc(e, 0), this._ghash.update(e));
  }
  this._called = !0;
  var n = this._mode.encrypt(this, t);
  return this._decrypt ? this._ghash.update(t) : this._ghash.update(n), this._len += t.length, n;
};
StreamCipher$3.prototype._final = function() {
  if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
  var t = xor$3(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && xorTest(t, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
  this._authTag = t, this._cipher.scrub();
};
StreamCipher$3.prototype.getAuthTag = function() {
  if (this._decrypt || !Buffer$c.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
  return this._authTag;
};
StreamCipher$3.prototype.setAuthTag = function(e) {
  if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
  this._authTag = e;
};
StreamCipher$3.prototype.setAAD = function(e) {
  if (this._called) throw new Error("Attempting to set AAD in unsupported state");
  this._ghash.update(e), this._alen += e.length;
};
var authCipher = StreamCipher$3, aes$3 = aes$5, Buffer$b = safeBufferExports$1.Buffer, Transform$4 = cipherBase, inherits$7 = inherits_browserExports;
function StreamCipher$2(t, e, n, a) {
  Transform$4.call(this), this._cipher = new aes$3.AES(e), this._prev = Buffer$b.from(n), this._cache = Buffer$b.allocUnsafe(0), this._secCache = Buffer$b.allocUnsafe(0), this._decrypt = a, this._mode = t;
}
inherits$7(StreamCipher$2, Transform$4);
StreamCipher$2.prototype._update = function(t) {
  return this._mode.encrypt(this, t, this._decrypt);
};
StreamCipher$2.prototype._final = function() {
  this._cipher.scrub();
};
var streamCipher = StreamCipher$2, Buffer$a = safeBufferExports$1.Buffer, MD5 = md5_js;
function EVP_BytesToKey(t, e, n, a) {
  if (Buffer$a.isBuffer(t) || (t = Buffer$a.from(t, "binary")), e && (Buffer$a.isBuffer(e) || (e = Buffer$a.from(e, "binary")), e.length !== 8))
    throw new RangeError("salt should be Buffer with 8 byte length");
  for (var u = n / 8, o = Buffer$a.alloc(u), d = Buffer$a.alloc(a || 0), l = Buffer$a.alloc(0); u > 0 || a > 0; ) {
    var _ = new MD5();
    _.update(l), _.update(t), e && _.update(e), l = _.digest();
    var P = 0;
    if (u > 0) {
      var h = o.length - u;
      P = Math.min(u, l.length), l.copy(o, h, 0, P), u -= P;
    }
    if (P < l.length && a > 0) {
      var x = d.length - a, C = Math.min(a, l.length - P);
      l.copy(d, x, P, P + C), a -= C;
    }
  }
  return l.fill(0), { key: o, iv: d };
}
var evp_bytestokey = EVP_BytesToKey, MODES$1 = modes_1, AuthCipher$1 = authCipher, Buffer$9 = safeBufferExports$1.Buffer, StreamCipher$1 = streamCipher, Transform$3 = cipherBase, aes$2 = aes$5, ebtk$2 = evp_bytestokey, inherits$6 = inherits_browserExports;
function Cipher(t, e, n) {
  Transform$3.call(this), this._cache = new Splitter$1(), this._cipher = new aes$2.AES(e), this._prev = Buffer$9.from(n), this._mode = t, this._autopadding = !0;
}
inherits$6(Cipher, Transform$3);
Cipher.prototype._update = function(t) {
  this._cache.add(t);
  for (var e, n, a = []; e = this._cache.get(); )
    n = this._mode.encrypt(this, e), a.push(n);
  return Buffer$9.concat(a);
};
var PADDING = Buffer$9.alloc(16, 16);
Cipher.prototype._final = function() {
  var t = this._cache.flush();
  if (this._autopadding)
    return t = this._mode.encrypt(this, t), this._cipher.scrub(), t;
  if (!t.equals(PADDING))
    throw this._cipher.scrub(), new Error("data not multiple of block length");
};
Cipher.prototype.setAutoPadding = function(t) {
  return this._autopadding = !!t, this;
};
function Splitter$1() {
  this.cache = Buffer$9.allocUnsafe(0);
}
Splitter$1.prototype.add = function(t) {
  this.cache = Buffer$9.concat([this.cache, t]);
};
Splitter$1.prototype.get = function() {
  if (this.cache.length > 15) {
    var t = this.cache.slice(0, 16);
    return this.cache = this.cache.slice(16), t;
  }
  return null;
};
Splitter$1.prototype.flush = function() {
  for (var t = 16 - this.cache.length, e = Buffer$9.allocUnsafe(t), n = -1; ++n < t; )
    e.writeUInt8(t, n);
  return Buffer$9.concat([this.cache, e]);
};
function createCipheriv$1(t, e, n) {
  var a = MODES$1[t.toLowerCase()];
  if (!a) throw new TypeError("invalid suite type");
  if (typeof e == "string" && (e = Buffer$9.from(e)), e.length !== a.key / 8) throw new TypeError("invalid key length " + e.length);
  if (typeof n == "string" && (n = Buffer$9.from(n)), a.mode !== "GCM" && n.length !== a.iv) throw new TypeError("invalid iv length " + n.length);
  return a.type === "stream" ? new StreamCipher$1(a.module, e, n) : a.type === "auth" ? new AuthCipher$1(a.module, e, n) : new Cipher(a.module, e, n);
}
function createCipher$1(t, e) {
  var n = MODES$1[t.toLowerCase()];
  if (!n) throw new TypeError("invalid suite type");
  var a = ebtk$2(e, !1, n.key, n.iv);
  return createCipheriv$1(t, a.key, a.iv);
}
encrypter.createCipheriv = createCipheriv$1;
encrypter.createCipher = createCipher$1;
var decrypter = {}, AuthCipher = authCipher, Buffer$8 = safeBufferExports$1.Buffer, MODES = modes_1, StreamCipher = streamCipher, Transform$2 = cipherBase, aes$1 = aes$5, ebtk$1 = evp_bytestokey, inherits$5 = inherits_browserExports;
function Decipher(t, e, n) {
  Transform$2.call(this), this._cache = new Splitter(), this._last = void 0, this._cipher = new aes$1.AES(e), this._prev = Buffer$8.from(n), this._mode = t, this._autopadding = !0;
}
inherits$5(Decipher, Transform$2);
Decipher.prototype._update = function(t) {
  this._cache.add(t);
  for (var e, n, a = []; e = this._cache.get(this._autopadding); )
    n = this._mode.decrypt(this, e), a.push(n);
  return Buffer$8.concat(a);
};
Decipher.prototype._final = function() {
  var t = this._cache.flush();
  if (this._autopadding)
    return unpad(this._mode.decrypt(this, t));
  if (t)
    throw new Error("data not multiple of block length");
};
Decipher.prototype.setAutoPadding = function(t) {
  return this._autopadding = !!t, this;
};
function Splitter() {
  this.cache = Buffer$8.allocUnsafe(0);
}
Splitter.prototype.add = function(t) {
  this.cache = Buffer$8.concat([this.cache, t]);
};
Splitter.prototype.get = function(t) {
  var e;
  if (t) {
    if (this.cache.length > 16)
      return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
  } else if (this.cache.length >= 16)
    return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
  return null;
};
Splitter.prototype.flush = function() {
  if (this.cache.length) return this.cache;
};
function unpad(t) {
  var e = t[15];
  if (e < 1 || e > 16)
    throw new Error("unable to decrypt data");
  for (var n = -1; ++n < e; )
    if (t[n + (16 - e)] !== e)
      throw new Error("unable to decrypt data");
  if (e !== 16)
    return t.slice(0, 16 - e);
}
function createDecipheriv$1(t, e, n) {
  var a = MODES[t.toLowerCase()];
  if (!a) throw new TypeError("invalid suite type");
  if (typeof n == "string" && (n = Buffer$8.from(n)), a.mode !== "GCM" && n.length !== a.iv) throw new TypeError("invalid iv length " + n.length);
  if (typeof e == "string" && (e = Buffer$8.from(e)), e.length !== a.key / 8) throw new TypeError("invalid key length " + e.length);
  return a.type === "stream" ? new StreamCipher(a.module, e, n, !0) : a.type === "auth" ? new AuthCipher(a.module, e, n, !0) : new Decipher(a.module, e, n);
}
function createDecipher$1(t, e) {
  var n = MODES[t.toLowerCase()];
  if (!n) throw new TypeError("invalid suite type");
  var a = ebtk$1(e, !1, n.key, n.iv);
  return createDecipheriv$1(t, a.key, a.iv);
}
decrypter.createDecipher = createDecipher$1;
decrypter.createDecipheriv = createDecipheriv$1;
var ciphers$2 = encrypter, deciphers = decrypter, modes$1 = require$$2;
function getCiphers$1() {
  return Object.keys(modes$1);
}
browser$5.createCipher = browser$5.Cipher = ciphers$2.createCipher;
browser$5.createCipheriv = browser$5.Cipheriv = ciphers$2.createCipheriv;
browser$5.createDecipher = browser$5.Decipher = deciphers.createDecipher;
browser$5.createDecipheriv = browser$5.Decipheriv = deciphers.createDecipheriv;
browser$5.listCiphers = browser$5.getCiphers = getCiphers$1;
var modes = {};
(function(t) {
  t["des-ecb"] = {
    key: 8,
    iv: 0
  }, t["des-cbc"] = t.des = {
    key: 8,
    iv: 8
  }, t["des-ede3-cbc"] = t.des3 = {
    key: 24,
    iv: 8
  }, t["des-ede3"] = {
    key: 24,
    iv: 0
  }, t["des-ede-cbc"] = {
    key: 16,
    iv: 8
  }, t["des-ede"] = {
    key: 16,
    iv: 0
  };
})(modes);
var DES = browserifyDes, aes = browser$5, aesModes = modes_1, desModes = modes, ebtk = evp_bytestokey;
function createCipher(t, e) {
  t = t.toLowerCase();
  var n, a;
  if (aesModes[t])
    n = aesModes[t].key, a = aesModes[t].iv;
  else if (desModes[t])
    n = desModes[t].key * 8, a = desModes[t].iv;
  else
    throw new TypeError("invalid suite type");
  var u = ebtk(e, !1, n, a);
  return createCipheriv(t, u.key, u.iv);
}
function createDecipher(t, e) {
  t = t.toLowerCase();
  var n, a;
  if (aesModes[t])
    n = aesModes[t].key, a = aesModes[t].iv;
  else if (desModes[t])
    n = desModes[t].key * 8, a = desModes[t].iv;
  else
    throw new TypeError("invalid suite type");
  var u = ebtk(e, !1, n, a);
  return createDecipheriv(t, u.key, u.iv);
}
function createCipheriv(t, e, n) {
  if (t = t.toLowerCase(), aesModes[t]) return aes.createCipheriv(t, e, n);
  if (desModes[t]) return new DES({ key: e, iv: n, mode: t });
  throw new TypeError("invalid suite type");
}
function createDecipheriv(t, e, n) {
  if (t = t.toLowerCase(), aesModes[t]) return aes.createDecipheriv(t, e, n);
  if (desModes[t]) return new DES({ key: e, iv: n, mode: t, decrypt: !0 });
  throw new TypeError("invalid suite type");
}
function getCiphers() {
  return Object.keys(desModes).concat(aes.getCiphers());
}
browser$6.createCipher = browser$6.Cipher = createCipher;
browser$6.createCipheriv = browser$6.Cipheriv = createCipheriv;
browser$6.createDecipher = browser$6.Decipher = createDecipher;
browser$6.createDecipheriv = browser$6.Decipheriv = createDecipheriv;
browser$6.listCiphers = browser$6.getCiphers = getCiphers;
var browser$4 = {}, bn$1 = { exports: {} };
bn$1.exports;
(function(t) {
  (function(e, n) {
    function a(J, w) {
      if (!J) throw new Error(w || "Assertion failed");
    }
    function u(J, w) {
      J.super_ = w;
      var m = function() {
      };
      m.prototype = w.prototype, J.prototype = new m(), J.prototype.constructor = J;
    }
    function o(J, w, m) {
      if (o.isBN(J))
        return J;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, J !== null && ((w === "le" || w === "be") && (m = w, w = 10), this._init(J || 0, w || 10, m || "be"));
    }
    typeof e == "object" ? e.exports = o : n.BN = o, o.BN = o, o.wordSize = 26;
    var d;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? d = window.Buffer : d = require$$1$2.Buffer;
    } catch {
    }
    o.isBN = function(w) {
      return w instanceof o ? !0 : w !== null && typeof w == "object" && w.constructor.wordSize === o.wordSize && Array.isArray(w.words);
    }, o.max = function(w, m) {
      return w.cmp(m) > 0 ? w : m;
    }, o.min = function(w, m) {
      return w.cmp(m) < 0 ? w : m;
    }, o.prototype._init = function(w, m, c) {
      if (typeof w == "number")
        return this._initNumber(w, m, c);
      if (typeof w == "object")
        return this._initArray(w, m, c);
      m === "hex" && (m = 16), a(m === (m | 0) && m >= 2 && m <= 36), w = w.toString().replace(/\s+/g, "");
      var v = 0;
      w[0] === "-" && (v++, this.negative = 1), v < w.length && (m === 16 ? this._parseHex(w, v, c) : (this._parseBase(w, m, v), c === "le" && this._initArray(this.toArray(), m, c)));
    }, o.prototype._initNumber = function(w, m, c) {
      w < 0 && (this.negative = 1, w = -w), w < 67108864 ? (this.words = [w & 67108863], this.length = 1) : w < 4503599627370496 ? (this.words = [
        w & 67108863,
        w / 67108864 & 67108863
      ], this.length = 2) : (a(w < 9007199254740992), this.words = [
        w & 67108863,
        w / 67108864 & 67108863,
        1
      ], this.length = 3), c === "le" && this._initArray(this.toArray(), m, c);
    }, o.prototype._initArray = function(w, m, c) {
      if (a(typeof w.length == "number"), w.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(w.length / 3), this.words = new Array(this.length);
      for (var v = 0; v < this.length; v++)
        this.words[v] = 0;
      var $, S, A = 0;
      if (c === "be")
        for (v = w.length - 1, $ = 0; v >= 0; v -= 3)
          S = w[v] | w[v - 1] << 8 | w[v - 2] << 16, this.words[$] |= S << A & 67108863, this.words[$ + 1] = S >>> 26 - A & 67108863, A += 24, A >= 26 && (A -= 26, $++);
      else if (c === "le")
        for (v = 0, $ = 0; v < w.length; v += 3)
          S = w[v] | w[v + 1] << 8 | w[v + 2] << 16, this.words[$] |= S << A & 67108863, this.words[$ + 1] = S >>> 26 - A & 67108863, A += 24, A >= 26 && (A -= 26, $++);
      return this.strip();
    };
    function l(J, w) {
      var m = J.charCodeAt(w);
      return m >= 65 && m <= 70 ? m - 55 : m >= 97 && m <= 102 ? m - 87 : m - 48 & 15;
    }
    function _(J, w, m) {
      var c = l(J, m);
      return m - 1 >= w && (c |= l(J, m - 1) << 4), c;
    }
    o.prototype._parseHex = function(w, m, c) {
      this.length = Math.ceil((w.length - m) / 6), this.words = new Array(this.length);
      for (var v = 0; v < this.length; v++)
        this.words[v] = 0;
      var $ = 0, S = 0, A;
      if (c === "be")
        for (v = w.length - 1; v >= m; v -= 2)
          A = _(w, m, v) << $, this.words[S] |= A & 67108863, $ >= 18 ? ($ -= 18, S += 1, this.words[S] |= A >>> 26) : $ += 8;
      else {
        var M = w.length - m;
        for (v = M % 2 === 0 ? m + 1 : m; v < w.length; v += 2)
          A = _(w, m, v) << $, this.words[S] |= A & 67108863, $ >= 18 ? ($ -= 18, S += 1, this.words[S] |= A >>> 26) : $ += 8;
      }
      this.strip();
    };
    function P(J, w, m, c) {
      for (var v = 0, $ = Math.min(J.length, m), S = w; S < $; S++) {
        var A = J.charCodeAt(S) - 48;
        v *= c, A >= 49 ? v += A - 49 + 10 : A >= 17 ? v += A - 17 + 10 : v += A;
      }
      return v;
    }
    o.prototype._parseBase = function(w, m, c) {
      this.words = [0], this.length = 1;
      for (var v = 0, $ = 1; $ <= 67108863; $ *= m)
        v++;
      v--, $ = $ / m | 0;
      for (var S = w.length - c, A = S % v, M = Math.min(S, S - A) + c, p = 0, B = c; B < M; B += v)
        p = P(w, B, B + v, m), this.imuln($), this.words[0] + p < 67108864 ? this.words[0] += p : this._iaddn(p);
      if (A !== 0) {
        var b = 1;
        for (p = P(w, B, w.length, m), B = 0; B < A; B++)
          b *= m;
        this.imuln(b), this.words[0] + p < 67108864 ? this.words[0] += p : this._iaddn(p);
      }
      this.strip();
    }, o.prototype.copy = function(w) {
      w.words = new Array(this.length);
      for (var m = 0; m < this.length; m++)
        w.words[m] = this.words[m];
      w.length = this.length, w.negative = this.negative, w.red = this.red;
    }, o.prototype.clone = function() {
      var w = new o(null);
      return this.copy(w), w;
    }, o.prototype._expand = function(w) {
      for (; this.length < w; )
        this.words[this.length++] = 0;
      return this;
    }, o.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, o.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, o.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var h = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], x = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], C = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    o.prototype.toString = function(w, m) {
      w = w || 10, m = m | 0 || 1;
      var c;
      if (w === 16 || w === "hex") {
        c = "";
        for (var v = 0, $ = 0, S = 0; S < this.length; S++) {
          var A = this.words[S], M = ((A << v | $) & 16777215).toString(16);
          $ = A >>> 24 - v & 16777215, v += 2, v >= 26 && (v -= 26, S--), $ !== 0 || S !== this.length - 1 ? c = h[6 - M.length] + M + c : c = M + c;
        }
        for ($ !== 0 && (c = $.toString(16) + c); c.length % m !== 0; )
          c = "0" + c;
        return this.negative !== 0 && (c = "-" + c), c;
      }
      if (w === (w | 0) && w >= 2 && w <= 36) {
        var p = x[w], B = C[w];
        c = "";
        var b = this.clone();
        for (b.negative = 0; !b.isZero(); ) {
          var k = b.modn(B).toString(w);
          b = b.idivn(B), b.isZero() ? c = k + c : c = h[p - k.length] + k + c;
        }
        for (this.isZero() && (c = "0" + c); c.length % m !== 0; )
          c = "0" + c;
        return this.negative !== 0 && (c = "-" + c), c;
      }
      a(!1, "Base should be between 2 and 36");
    }, o.prototype.toNumber = function() {
      var w = this.words[0];
      return this.length === 2 ? w += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? w += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && a(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -w : w;
    }, o.prototype.toJSON = function() {
      return this.toString(16);
    }, o.prototype.toBuffer = function(w, m) {
      return a(typeof d < "u"), this.toArrayLike(d, w, m);
    }, o.prototype.toArray = function(w, m) {
      return this.toArrayLike(Array, w, m);
    }, o.prototype.toArrayLike = function(w, m, c) {
      var v = this.byteLength(), $ = c || Math.max(1, v);
      a(v <= $, "byte array longer than desired length"), a($ > 0, "Requested array length <= 0"), this.strip();
      var S = m === "le", A = new w($), M, p, B = this.clone();
      if (S) {
        for (p = 0; !B.isZero(); p++)
          M = B.andln(255), B.iushrn(8), A[p] = M;
        for (; p < $; p++)
          A[p] = 0;
      } else {
        for (p = 0; p < $ - v; p++)
          A[p] = 0;
        for (p = 0; !B.isZero(); p++)
          M = B.andln(255), B.iushrn(8), A[$ - p - 1] = M;
      }
      return A;
    }, Math.clz32 ? o.prototype._countBits = function(w) {
      return 32 - Math.clz32(w);
    } : o.prototype._countBits = function(w) {
      var m = w, c = 0;
      return m >= 4096 && (c += 13, m >>>= 13), m >= 64 && (c += 7, m >>>= 7), m >= 8 && (c += 4, m >>>= 4), m >= 2 && (c += 2, m >>>= 2), c + m;
    }, o.prototype._zeroBits = function(w) {
      if (w === 0) return 26;
      var m = w, c = 0;
      return m & 8191 || (c += 13, m >>>= 13), m & 127 || (c += 7, m >>>= 7), m & 15 || (c += 4, m >>>= 4), m & 3 || (c += 2, m >>>= 2), m & 1 || c++, c;
    }, o.prototype.bitLength = function() {
      var w = this.words[this.length - 1], m = this._countBits(w);
      return (this.length - 1) * 26 + m;
    };
    function D(J) {
      for (var w = new Array(J.bitLength()), m = 0; m < w.length; m++) {
        var c = m / 26 | 0, v = m % 26;
        w[m] = (J.words[c] & 1 << v) >>> v;
      }
      return w;
    }
    o.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var w = 0, m = 0; m < this.length; m++) {
        var c = this._zeroBits(this.words[m]);
        if (w += c, c !== 26) break;
      }
      return w;
    }, o.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, o.prototype.toTwos = function(w) {
      return this.negative !== 0 ? this.abs().inotn(w).iaddn(1) : this.clone();
    }, o.prototype.fromTwos = function(w) {
      return this.testn(w - 1) ? this.notn(w).iaddn(1).ineg() : this.clone();
    }, o.prototype.isNeg = function() {
      return this.negative !== 0;
    }, o.prototype.neg = function() {
      return this.clone().ineg();
    }, o.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, o.prototype.iuor = function(w) {
      for (; this.length < w.length; )
        this.words[this.length++] = 0;
      for (var m = 0; m < w.length; m++)
        this.words[m] = this.words[m] | w.words[m];
      return this.strip();
    }, o.prototype.ior = function(w) {
      return a((this.negative | w.negative) === 0), this.iuor(w);
    }, o.prototype.or = function(w) {
      return this.length > w.length ? this.clone().ior(w) : w.clone().ior(this);
    }, o.prototype.uor = function(w) {
      return this.length > w.length ? this.clone().iuor(w) : w.clone().iuor(this);
    }, o.prototype.iuand = function(w) {
      var m;
      this.length > w.length ? m = w : m = this;
      for (var c = 0; c < m.length; c++)
        this.words[c] = this.words[c] & w.words[c];
      return this.length = m.length, this.strip();
    }, o.prototype.iand = function(w) {
      return a((this.negative | w.negative) === 0), this.iuand(w);
    }, o.prototype.and = function(w) {
      return this.length > w.length ? this.clone().iand(w) : w.clone().iand(this);
    }, o.prototype.uand = function(w) {
      return this.length > w.length ? this.clone().iuand(w) : w.clone().iuand(this);
    }, o.prototype.iuxor = function(w) {
      var m, c;
      this.length > w.length ? (m = this, c = w) : (m = w, c = this);
      for (var v = 0; v < c.length; v++)
        this.words[v] = m.words[v] ^ c.words[v];
      if (this !== m)
        for (; v < m.length; v++)
          this.words[v] = m.words[v];
      return this.length = m.length, this.strip();
    }, o.prototype.ixor = function(w) {
      return a((this.negative | w.negative) === 0), this.iuxor(w);
    }, o.prototype.xor = function(w) {
      return this.length > w.length ? this.clone().ixor(w) : w.clone().ixor(this);
    }, o.prototype.uxor = function(w) {
      return this.length > w.length ? this.clone().iuxor(w) : w.clone().iuxor(this);
    }, o.prototype.inotn = function(w) {
      a(typeof w == "number" && w >= 0);
      var m = Math.ceil(w / 26) | 0, c = w % 26;
      this._expand(m), c > 0 && m--;
      for (var v = 0; v < m; v++)
        this.words[v] = ~this.words[v] & 67108863;
      return c > 0 && (this.words[v] = ~this.words[v] & 67108863 >> 26 - c), this.strip();
    }, o.prototype.notn = function(w) {
      return this.clone().inotn(w);
    }, o.prototype.setn = function(w, m) {
      a(typeof w == "number" && w >= 0);
      var c = w / 26 | 0, v = w % 26;
      return this._expand(c + 1), m ? this.words[c] = this.words[c] | 1 << v : this.words[c] = this.words[c] & ~(1 << v), this.strip();
    }, o.prototype.iadd = function(w) {
      var m;
      if (this.negative !== 0 && w.negative === 0)
        return this.negative = 0, m = this.isub(w), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && w.negative !== 0)
        return w.negative = 0, m = this.isub(w), w.negative = 1, m._normSign();
      var c, v;
      this.length > w.length ? (c = this, v = w) : (c = w, v = this);
      for (var $ = 0, S = 0; S < v.length; S++)
        m = (c.words[S] | 0) + (v.words[S] | 0) + $, this.words[S] = m & 67108863, $ = m >>> 26;
      for (; $ !== 0 && S < c.length; S++)
        m = (c.words[S] | 0) + $, this.words[S] = m & 67108863, $ = m >>> 26;
      if (this.length = c.length, $ !== 0)
        this.words[this.length] = $, this.length++;
      else if (c !== this)
        for (; S < c.length; S++)
          this.words[S] = c.words[S];
      return this;
    }, o.prototype.add = function(w) {
      var m;
      return w.negative !== 0 && this.negative === 0 ? (w.negative = 0, m = this.sub(w), w.negative ^= 1, m) : w.negative === 0 && this.negative !== 0 ? (this.negative = 0, m = w.sub(this), this.negative = 1, m) : this.length > w.length ? this.clone().iadd(w) : w.clone().iadd(this);
    }, o.prototype.isub = function(w) {
      if (w.negative !== 0) {
        w.negative = 0;
        var m = this.iadd(w);
        return w.negative = 1, m._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(w), this.negative = 1, this._normSign();
      var c = this.cmp(w);
      if (c === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var v, $;
      c > 0 ? (v = this, $ = w) : (v = w, $ = this);
      for (var S = 0, A = 0; A < $.length; A++)
        m = (v.words[A] | 0) - ($.words[A] | 0) + S, S = m >> 26, this.words[A] = m & 67108863;
      for (; S !== 0 && A < v.length; A++)
        m = (v.words[A] | 0) + S, S = m >> 26, this.words[A] = m & 67108863;
      if (S === 0 && A < v.length && v !== this)
        for (; A < v.length; A++)
          this.words[A] = v.words[A];
      return this.length = Math.max(this.length, A), v !== this && (this.negative = 1), this.strip();
    }, o.prototype.sub = function(w) {
      return this.clone().isub(w);
    };
    function q(J, w, m) {
      m.negative = w.negative ^ J.negative;
      var c = J.length + w.length | 0;
      m.length = c, c = c - 1 | 0;
      var v = J.words[0] | 0, $ = w.words[0] | 0, S = v * $, A = S & 67108863, M = S / 67108864 | 0;
      m.words[0] = A;
      for (var p = 1; p < c; p++) {
        for (var B = M >>> 26, b = M & 67108863, k = Math.min(p, w.length - 1), Z = Math.max(0, p - J.length + 1); Z <= k; Z++) {
          var te = p - Z | 0;
          v = J.words[te] | 0, $ = w.words[Z] | 0, S = v * $ + b, B += S / 67108864 | 0, b = S & 67108863;
        }
        m.words[p] = b | 0, M = B | 0;
      }
      return M !== 0 ? m.words[p] = M | 0 : m.length--, m.strip();
    }
    var H = function(w, m, c) {
      var v = w.words, $ = m.words, S = c.words, A = 0, M, p, B, b = v[0] | 0, k = b & 8191, Z = b >>> 13, te = v[1] | 0, V = te & 8191, T = te >>> 13, O = v[2] | 0, Q = O & 8191, ie = O >>> 13, L = v[3] | 0, j = L & 8191, ne = L >>> 13, de = v[4] | 0, pe = de & 8191, be = de >>> 13, me = v[5] | 0, we = me & 8191, ue = me >>> 13, Oe = v[6] | 0, xe = Oe & 8191, je = Oe >>> 13, Ne = v[7] | 0, ge = Ne & 8191, Me = Ne >>> 13, qe = v[8] | 0, Se = qe & 8191, ke = qe >>> 13, Le = v[9] | 0, N = Le & 8191, E = Le >>> 13, I = $[0] | 0, U = I & 8191, re = I >>> 13, ae = $[1] | 0, fe = ae & 8191, ye = ae >>> 13, Ee = $[2] | 0, ve = Ee & 8191, Be = Ee >>> 13, $e = $[3] | 0, Ae = $e & 8191, He = $e >>> 13, ze = $[4] | 0, Re = ze & 8191, Ke = ze >>> 13, Ge = $[5] | 0, Pe = Ge & 8191, We = Ge >>> 13, Ve = $[6] | 0, Ie = Ve & 8191, Je = Ve >>> 13, Ye = $[7] | 0, Ce = Ye & 8191, Ze = Ye >>> 13, Xe = $[8] | 0, Te = Xe & 8191, Qe = Xe >>> 13, er = $[9] | 0, De = er & 8191, rr = er >>> 13;
      c.negative = w.negative ^ m.negative, c.length = 19, M = Math.imul(k, U), p = Math.imul(k, re), p = p + Math.imul(Z, U) | 0, B = Math.imul(Z, re);
      var Fe = (A + M | 0) + ((p & 8191) << 13) | 0;
      A = (B + (p >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, M = Math.imul(V, U), p = Math.imul(V, re), p = p + Math.imul(T, U) | 0, B = Math.imul(T, re), M = M + Math.imul(k, fe) | 0, p = p + Math.imul(k, ye) | 0, p = p + Math.imul(Z, fe) | 0, B = B + Math.imul(Z, ye) | 0;
      var Ue = (A + M | 0) + ((p & 8191) << 13) | 0;
      A = (B + (p >>> 13) | 0) + (Ue >>> 26) | 0, Ue &= 67108863, M = Math.imul(Q, U), p = Math.imul(Q, re), p = p + Math.imul(ie, U) | 0, B = Math.imul(ie, re), M = M + Math.imul(V, fe) | 0, p = p + Math.imul(V, ye) | 0, p = p + Math.imul(T, fe) | 0, B = B + Math.imul(T, ye) | 0, M = M + Math.imul(k, ve) | 0, p = p + Math.imul(k, Be) | 0, p = p + Math.imul(Z, ve) | 0, B = B + Math.imul(Z, Be) | 0;
      var fr = (A + M | 0) + ((p & 8191) << 13) | 0;
      A = (B + (p >>> 13) | 0) + (fr >>> 26) | 0, fr &= 67108863, M = Math.imul(j, U), p = Math.imul(j, re), p = p + Math.imul(ne, U) | 0, B = Math.imul(ne, re), M = M + Math.imul(Q, fe) | 0, p = p + Math.imul(Q, ye) | 0, p = p + Math.imul(ie, fe) | 0, B = B + Math.imul(ie, ye) | 0, M = M + Math.imul(V, ve) | 0, p = p + Math.imul(V, Be) | 0, p = p + Math.imul(T, ve) | 0, B = B + Math.imul(T, Be) | 0, M = M + Math.imul(k, Ae) | 0, p = p + Math.imul(k, He) | 0, p = p + Math.imul(Z, Ae) | 0, B = B + Math.imul(Z, He) | 0;
      var or = (A + M | 0) + ((p & 8191) << 13) | 0;
      A = (B + (p >>> 13) | 0) + (or >>> 26) | 0, or &= 67108863, M = Math.imul(pe, U), p = Math.imul(pe, re), p = p + Math.imul(be, U) | 0, B = Math.imul(be, re), M = M + Math.imul(j, fe) | 0, p = p + Math.imul(j, ye) | 0, p = p + Math.imul(ne, fe) | 0, B = B + Math.imul(ne, ye) | 0, M = M + Math.imul(Q, ve) | 0, p = p + Math.imul(Q, Be) | 0, p = p + Math.imul(ie, ve) | 0, B = B + Math.imul(ie, Be) | 0, M = M + Math.imul(V, Ae) | 0, p = p + Math.imul(V, He) | 0, p = p + Math.imul(T, Ae) | 0, B = B + Math.imul(T, He) | 0, M = M + Math.imul(k, Re) | 0, p = p + Math.imul(k, Ke) | 0, p = p + Math.imul(Z, Re) | 0, B = B + Math.imul(Z, Ke) | 0;
      var ur = (A + M | 0) + ((p & 8191) << 13) | 0;
      A = (B + (p >>> 13) | 0) + (ur >>> 26) | 0, ur &= 67108863, M = Math.imul(we, U), p = Math.imul(we, re), p = p + Math.imul(ue, U) | 0, B = Math.imul(ue, re), M = M + Math.imul(pe, fe) | 0, p = p + Math.imul(pe, ye) | 0, p = p + Math.imul(be, fe) | 0, B = B + Math.imul(be, ye) | 0, M = M + Math.imul(j, ve) | 0, p = p + Math.imul(j, Be) | 0, p = p + Math.imul(ne, ve) | 0, B = B + Math.imul(ne, Be) | 0, M = M + Math.imul(Q, Ae) | 0, p = p + Math.imul(Q, He) | 0, p = p + Math.imul(ie, Ae) | 0, B = B + Math.imul(ie, He) | 0, M = M + Math.imul(V, Re) | 0, p = p + Math.imul(V, Ke) | 0, p = p + Math.imul(T, Re) | 0, B = B + Math.imul(T, Ke) | 0, M = M + Math.imul(k, Pe) | 0, p = p + Math.imul(k, We) | 0, p = p + Math.imul(Z, Pe) | 0, B = B + Math.imul(Z, We) | 0;
      var cr = (A + M | 0) + ((p & 8191) << 13) | 0;
      A = (B + (p >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, M = Math.imul(xe, U), p = Math.imul(xe, re), p = p + Math.imul(je, U) | 0, B = Math.imul(je, re), M = M + Math.imul(we, fe) | 0, p = p + Math.imul(we, ye) | 0, p = p + Math.imul(ue, fe) | 0, B = B + Math.imul(ue, ye) | 0, M = M + Math.imul(pe, ve) | 0, p = p + Math.imul(pe, Be) | 0, p = p + Math.imul(be, ve) | 0, B = B + Math.imul(be, Be) | 0, M = M + Math.imul(j, Ae) | 0, p = p + Math.imul(j, He) | 0, p = p + Math.imul(ne, Ae) | 0, B = B + Math.imul(ne, He) | 0, M = M + Math.imul(Q, Re) | 0, p = p + Math.imul(Q, Ke) | 0, p = p + Math.imul(ie, Re) | 0, B = B + Math.imul(ie, Ke) | 0, M = M + Math.imul(V, Pe) | 0, p = p + Math.imul(V, We) | 0, p = p + Math.imul(T, Pe) | 0, B = B + Math.imul(T, We) | 0, M = M + Math.imul(k, Ie) | 0, p = p + Math.imul(k, Je) | 0, p = p + Math.imul(Z, Ie) | 0, B = B + Math.imul(Z, Je) | 0;
      var dr = (A + M | 0) + ((p & 8191) << 13) | 0;
      A = (B + (p >>> 13) | 0) + (dr >>> 26) | 0, dr &= 67108863, M = Math.imul(ge, U), p = Math.imul(ge, re), p = p + Math.imul(Me, U) | 0, B = Math.imul(Me, re), M = M + Math.imul(xe, fe) | 0, p = p + Math.imul(xe, ye) | 0, p = p + Math.imul(je, fe) | 0, B = B + Math.imul(je, ye) | 0, M = M + Math.imul(we, ve) | 0, p = p + Math.imul(we, Be) | 0, p = p + Math.imul(ue, ve) | 0, B = B + Math.imul(ue, Be) | 0, M = M + Math.imul(pe, Ae) | 0, p = p + Math.imul(pe, He) | 0, p = p + Math.imul(be, Ae) | 0, B = B + Math.imul(be, He) | 0, M = M + Math.imul(j, Re) | 0, p = p + Math.imul(j, Ke) | 0, p = p + Math.imul(ne, Re) | 0, B = B + Math.imul(ne, Ke) | 0, M = M + Math.imul(Q, Pe) | 0, p = p + Math.imul(Q, We) | 0, p = p + Math.imul(ie, Pe) | 0, B = B + Math.imul(ie, We) | 0, M = M + Math.imul(V, Ie) | 0, p = p + Math.imul(V, Je) | 0, p = p + Math.imul(T, Ie) | 0, B = B + Math.imul(T, Je) | 0, M = M + Math.imul(k, Ce) | 0, p = p + Math.imul(k, Ze) | 0, p = p + Math.imul(Z, Ce) | 0, B = B + Math.imul(Z, Ze) | 0;
      var lr = (A + M | 0) + ((p & 8191) << 13) | 0;
      A = (B + (p >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, M = Math.imul(Se, U), p = Math.imul(Se, re), p = p + Math.imul(ke, U) | 0, B = Math.imul(ke, re), M = M + Math.imul(ge, fe) | 0, p = p + Math.imul(ge, ye) | 0, p = p + Math.imul(Me, fe) | 0, B = B + Math.imul(Me, ye) | 0, M = M + Math.imul(xe, ve) | 0, p = p + Math.imul(xe, Be) | 0, p = p + Math.imul(je, ve) | 0, B = B + Math.imul(je, Be) | 0, M = M + Math.imul(we, Ae) | 0, p = p + Math.imul(we, He) | 0, p = p + Math.imul(ue, Ae) | 0, B = B + Math.imul(ue, He) | 0, M = M + Math.imul(pe, Re) | 0, p = p + Math.imul(pe, Ke) | 0, p = p + Math.imul(be, Re) | 0, B = B + Math.imul(be, Ke) | 0, M = M + Math.imul(j, Pe) | 0, p = p + Math.imul(j, We) | 0, p = p + Math.imul(ne, Pe) | 0, B = B + Math.imul(ne, We) | 0, M = M + Math.imul(Q, Ie) | 0, p = p + Math.imul(Q, Je) | 0, p = p + Math.imul(ie, Ie) | 0, B = B + Math.imul(ie, Je) | 0, M = M + Math.imul(V, Ce) | 0, p = p + Math.imul(V, Ze) | 0, p = p + Math.imul(T, Ce) | 0, B = B + Math.imul(T, Ze) | 0, M = M + Math.imul(k, Te) | 0, p = p + Math.imul(k, Qe) | 0, p = p + Math.imul(Z, Te) | 0, B = B + Math.imul(Z, Qe) | 0;
      var pr = (A + M | 0) + ((p & 8191) << 13) | 0;
      A = (B + (p >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, M = Math.imul(N, U), p = Math.imul(N, re), p = p + Math.imul(E, U) | 0, B = Math.imul(E, re), M = M + Math.imul(Se, fe) | 0, p = p + Math.imul(Se, ye) | 0, p = p + Math.imul(ke, fe) | 0, B = B + Math.imul(ke, ye) | 0, M = M + Math.imul(ge, ve) | 0, p = p + Math.imul(ge, Be) | 0, p = p + Math.imul(Me, ve) | 0, B = B + Math.imul(Me, Be) | 0, M = M + Math.imul(xe, Ae) | 0, p = p + Math.imul(xe, He) | 0, p = p + Math.imul(je, Ae) | 0, B = B + Math.imul(je, He) | 0, M = M + Math.imul(we, Re) | 0, p = p + Math.imul(we, Ke) | 0, p = p + Math.imul(ue, Re) | 0, B = B + Math.imul(ue, Ke) | 0, M = M + Math.imul(pe, Pe) | 0, p = p + Math.imul(pe, We) | 0, p = p + Math.imul(be, Pe) | 0, B = B + Math.imul(be, We) | 0, M = M + Math.imul(j, Ie) | 0, p = p + Math.imul(j, Je) | 0, p = p + Math.imul(ne, Ie) | 0, B = B + Math.imul(ne, Je) | 0, M = M + Math.imul(Q, Ce) | 0, p = p + Math.imul(Q, Ze) | 0, p = p + Math.imul(ie, Ce) | 0, B = B + Math.imul(ie, Ze) | 0, M = M + Math.imul(V, Te) | 0, p = p + Math.imul(V, Qe) | 0, p = p + Math.imul(T, Te) | 0, B = B + Math.imul(T, Qe) | 0, M = M + Math.imul(k, De) | 0, p = p + Math.imul(k, rr) | 0, p = p + Math.imul(Z, De) | 0, B = B + Math.imul(Z, rr) | 0;
      var br = (A + M | 0) + ((p & 8191) << 13) | 0;
      A = (B + (p >>> 13) | 0) + (br >>> 26) | 0, br &= 67108863, M = Math.imul(N, fe), p = Math.imul(N, ye), p = p + Math.imul(E, fe) | 0, B = Math.imul(E, ye), M = M + Math.imul(Se, ve) | 0, p = p + Math.imul(Se, Be) | 0, p = p + Math.imul(ke, ve) | 0, B = B + Math.imul(ke, Be) | 0, M = M + Math.imul(ge, Ae) | 0, p = p + Math.imul(ge, He) | 0, p = p + Math.imul(Me, Ae) | 0, B = B + Math.imul(Me, He) | 0, M = M + Math.imul(xe, Re) | 0, p = p + Math.imul(xe, Ke) | 0, p = p + Math.imul(je, Re) | 0, B = B + Math.imul(je, Ke) | 0, M = M + Math.imul(we, Pe) | 0, p = p + Math.imul(we, We) | 0, p = p + Math.imul(ue, Pe) | 0, B = B + Math.imul(ue, We) | 0, M = M + Math.imul(pe, Ie) | 0, p = p + Math.imul(pe, Je) | 0, p = p + Math.imul(be, Ie) | 0, B = B + Math.imul(be, Je) | 0, M = M + Math.imul(j, Ce) | 0, p = p + Math.imul(j, Ze) | 0, p = p + Math.imul(ne, Ce) | 0, B = B + Math.imul(ne, Ze) | 0, M = M + Math.imul(Q, Te) | 0, p = p + Math.imul(Q, Qe) | 0, p = p + Math.imul(ie, Te) | 0, B = B + Math.imul(ie, Qe) | 0, M = M + Math.imul(V, De) | 0, p = p + Math.imul(V, rr) | 0, p = p + Math.imul(T, De) | 0, B = B + Math.imul(T, rr) | 0;
      var vr = (A + M | 0) + ((p & 8191) << 13) | 0;
      A = (B + (p >>> 13) | 0) + (vr >>> 26) | 0, vr &= 67108863, M = Math.imul(N, ve), p = Math.imul(N, Be), p = p + Math.imul(E, ve) | 0, B = Math.imul(E, Be), M = M + Math.imul(Se, Ae) | 0, p = p + Math.imul(Se, He) | 0, p = p + Math.imul(ke, Ae) | 0, B = B + Math.imul(ke, He) | 0, M = M + Math.imul(ge, Re) | 0, p = p + Math.imul(ge, Ke) | 0, p = p + Math.imul(Me, Re) | 0, B = B + Math.imul(Me, Ke) | 0, M = M + Math.imul(xe, Pe) | 0, p = p + Math.imul(xe, We) | 0, p = p + Math.imul(je, Pe) | 0, B = B + Math.imul(je, We) | 0, M = M + Math.imul(we, Ie) | 0, p = p + Math.imul(we, Je) | 0, p = p + Math.imul(ue, Ie) | 0, B = B + Math.imul(ue, Je) | 0, M = M + Math.imul(pe, Ce) | 0, p = p + Math.imul(pe, Ze) | 0, p = p + Math.imul(be, Ce) | 0, B = B + Math.imul(be, Ze) | 0, M = M + Math.imul(j, Te) | 0, p = p + Math.imul(j, Qe) | 0, p = p + Math.imul(ne, Te) | 0, B = B + Math.imul(ne, Qe) | 0, M = M + Math.imul(Q, De) | 0, p = p + Math.imul(Q, rr) | 0, p = p + Math.imul(ie, De) | 0, B = B + Math.imul(ie, rr) | 0;
      var yr = (A + M | 0) + ((p & 8191) << 13) | 0;
      A = (B + (p >>> 13) | 0) + (yr >>> 26) | 0, yr &= 67108863, M = Math.imul(N, Ae), p = Math.imul(N, He), p = p + Math.imul(E, Ae) | 0, B = Math.imul(E, He), M = M + Math.imul(Se, Re) | 0, p = p + Math.imul(Se, Ke) | 0, p = p + Math.imul(ke, Re) | 0, B = B + Math.imul(ke, Ke) | 0, M = M + Math.imul(ge, Pe) | 0, p = p + Math.imul(ge, We) | 0, p = p + Math.imul(Me, Pe) | 0, B = B + Math.imul(Me, We) | 0, M = M + Math.imul(xe, Ie) | 0, p = p + Math.imul(xe, Je) | 0, p = p + Math.imul(je, Ie) | 0, B = B + Math.imul(je, Je) | 0, M = M + Math.imul(we, Ce) | 0, p = p + Math.imul(we, Ze) | 0, p = p + Math.imul(ue, Ce) | 0, B = B + Math.imul(ue, Ze) | 0, M = M + Math.imul(pe, Te) | 0, p = p + Math.imul(pe, Qe) | 0, p = p + Math.imul(be, Te) | 0, B = B + Math.imul(be, Qe) | 0, M = M + Math.imul(j, De) | 0, p = p + Math.imul(j, rr) | 0, p = p + Math.imul(ne, De) | 0, B = B + Math.imul(ne, rr) | 0;
      var gr = (A + M | 0) + ((p & 8191) << 13) | 0;
      A = (B + (p >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, M = Math.imul(N, Re), p = Math.imul(N, Ke), p = p + Math.imul(E, Re) | 0, B = Math.imul(E, Ke), M = M + Math.imul(Se, Pe) | 0, p = p + Math.imul(Se, We) | 0, p = p + Math.imul(ke, Pe) | 0, B = B + Math.imul(ke, We) | 0, M = M + Math.imul(ge, Ie) | 0, p = p + Math.imul(ge, Je) | 0, p = p + Math.imul(Me, Ie) | 0, B = B + Math.imul(Me, Je) | 0, M = M + Math.imul(xe, Ce) | 0, p = p + Math.imul(xe, Ze) | 0, p = p + Math.imul(je, Ce) | 0, B = B + Math.imul(je, Ze) | 0, M = M + Math.imul(we, Te) | 0, p = p + Math.imul(we, Qe) | 0, p = p + Math.imul(ue, Te) | 0, B = B + Math.imul(ue, Qe) | 0, M = M + Math.imul(pe, De) | 0, p = p + Math.imul(pe, rr) | 0, p = p + Math.imul(be, De) | 0, B = B + Math.imul(be, rr) | 0;
      var wr = (A + M | 0) + ((p & 8191) << 13) | 0;
      A = (B + (p >>> 13) | 0) + (wr >>> 26) | 0, wr &= 67108863, M = Math.imul(N, Pe), p = Math.imul(N, We), p = p + Math.imul(E, Pe) | 0, B = Math.imul(E, We), M = M + Math.imul(Se, Ie) | 0, p = p + Math.imul(Se, Je) | 0, p = p + Math.imul(ke, Ie) | 0, B = B + Math.imul(ke, Je) | 0, M = M + Math.imul(ge, Ce) | 0, p = p + Math.imul(ge, Ze) | 0, p = p + Math.imul(Me, Ce) | 0, B = B + Math.imul(Me, Ze) | 0, M = M + Math.imul(xe, Te) | 0, p = p + Math.imul(xe, Qe) | 0, p = p + Math.imul(je, Te) | 0, B = B + Math.imul(je, Qe) | 0, M = M + Math.imul(we, De) | 0, p = p + Math.imul(we, rr) | 0, p = p + Math.imul(ue, De) | 0, B = B + Math.imul(ue, rr) | 0;
      var _r = (A + M | 0) + ((p & 8191) << 13) | 0;
      A = (B + (p >>> 13) | 0) + (_r >>> 26) | 0, _r &= 67108863, M = Math.imul(N, Ie), p = Math.imul(N, Je), p = p + Math.imul(E, Ie) | 0, B = Math.imul(E, Je), M = M + Math.imul(Se, Ce) | 0, p = p + Math.imul(Se, Ze) | 0, p = p + Math.imul(ke, Ce) | 0, B = B + Math.imul(ke, Ze) | 0, M = M + Math.imul(ge, Te) | 0, p = p + Math.imul(ge, Qe) | 0, p = p + Math.imul(Me, Te) | 0, B = B + Math.imul(Me, Qe) | 0, M = M + Math.imul(xe, De) | 0, p = p + Math.imul(xe, rr) | 0, p = p + Math.imul(je, De) | 0, B = B + Math.imul(je, rr) | 0;
      var $r = (A + M | 0) + ((p & 8191) << 13) | 0;
      A = (B + (p >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, M = Math.imul(N, Ce), p = Math.imul(N, Ze), p = p + Math.imul(E, Ce) | 0, B = Math.imul(E, Ze), M = M + Math.imul(Se, Te) | 0, p = p + Math.imul(Se, Qe) | 0, p = p + Math.imul(ke, Te) | 0, B = B + Math.imul(ke, Qe) | 0, M = M + Math.imul(ge, De) | 0, p = p + Math.imul(ge, rr) | 0, p = p + Math.imul(Me, De) | 0, B = B + Math.imul(Me, rr) | 0;
      var xr = (A + M | 0) + ((p & 8191) << 13) | 0;
      A = (B + (p >>> 13) | 0) + (xr >>> 26) | 0, xr &= 67108863, M = Math.imul(N, Te), p = Math.imul(N, Qe), p = p + Math.imul(E, Te) | 0, B = Math.imul(E, Qe), M = M + Math.imul(Se, De) | 0, p = p + Math.imul(Se, rr) | 0, p = p + Math.imul(ke, De) | 0, B = B + Math.imul(ke, rr) | 0;
      var Sr = (A + M | 0) + ((p & 8191) << 13) | 0;
      A = (B + (p >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, M = Math.imul(N, De), p = Math.imul(N, rr), p = p + Math.imul(E, De) | 0, B = Math.imul(E, rr);
      var Er = (A + M | 0) + ((p & 8191) << 13) | 0;
      return A = (B + (p >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, S[0] = Fe, S[1] = Ue, S[2] = fr, S[3] = or, S[4] = ur, S[5] = cr, S[6] = dr, S[7] = lr, S[8] = pr, S[9] = br, S[10] = vr, S[11] = yr, S[12] = gr, S[13] = wr, S[14] = _r, S[15] = $r, S[16] = xr, S[17] = Sr, S[18] = Er, A !== 0 && (S[19] = A, c.length++), c;
    };
    Math.imul || (H = q);
    function Y(J, w, m) {
      m.negative = w.negative ^ J.negative, m.length = J.length + w.length;
      for (var c = 0, v = 0, $ = 0; $ < m.length - 1; $++) {
        var S = v;
        v = 0;
        for (var A = c & 67108863, M = Math.min($, w.length - 1), p = Math.max(0, $ - J.length + 1); p <= M; p++) {
          var B = $ - p, b = J.words[B] | 0, k = w.words[p] | 0, Z = b * k, te = Z & 67108863;
          S = S + (Z / 67108864 | 0) | 0, te = te + A | 0, A = te & 67108863, S = S + (te >>> 26) | 0, v += S >>> 26, S &= 67108863;
        }
        m.words[$] = A, c = S, S = v;
      }
      return c !== 0 ? m.words[$] = c : m.length--, m.strip();
    }
    function z(J, w, m) {
      var c = new F();
      return c.mulp(J, w, m);
    }
    o.prototype.mulTo = function(w, m) {
      var c, v = this.length + w.length;
      return this.length === 10 && w.length === 10 ? c = H(this, w, m) : v < 63 ? c = q(this, w, m) : v < 1024 ? c = Y(this, w, m) : c = z(this, w, m), c;
    };
    function F(J, w) {
      this.x = J, this.y = w;
    }
    F.prototype.makeRBT = function(w) {
      for (var m = new Array(w), c = o.prototype._countBits(w) - 1, v = 0; v < w; v++)
        m[v] = this.revBin(v, c, w);
      return m;
    }, F.prototype.revBin = function(w, m, c) {
      if (w === 0 || w === c - 1) return w;
      for (var v = 0, $ = 0; $ < m; $++)
        v |= (w & 1) << m - $ - 1, w >>= 1;
      return v;
    }, F.prototype.permute = function(w, m, c, v, $, S) {
      for (var A = 0; A < S; A++)
        v[A] = m[w[A]], $[A] = c[w[A]];
    }, F.prototype.transform = function(w, m, c, v, $, S) {
      this.permute(S, w, m, c, v, $);
      for (var A = 1; A < $; A <<= 1)
        for (var M = A << 1, p = Math.cos(2 * Math.PI / M), B = Math.sin(2 * Math.PI / M), b = 0; b < $; b += M)
          for (var k = p, Z = B, te = 0; te < A; te++) {
            var V = c[b + te], T = v[b + te], O = c[b + te + A], Q = v[b + te + A], ie = k * O - Z * Q;
            Q = k * Q + Z * O, O = ie, c[b + te] = V + O, v[b + te] = T + Q, c[b + te + A] = V - O, v[b + te + A] = T - Q, te !== M && (ie = p * k - B * Z, Z = p * Z + B * k, k = ie);
          }
    }, F.prototype.guessLen13b = function(w, m) {
      var c = Math.max(m, w) | 1, v = c & 1, $ = 0;
      for (c = c / 2 | 0; c; c = c >>> 1)
        $++;
      return 1 << $ + 1 + v;
    }, F.prototype.conjugate = function(w, m, c) {
      if (!(c <= 1))
        for (var v = 0; v < c / 2; v++) {
          var $ = w[v];
          w[v] = w[c - v - 1], w[c - v - 1] = $, $ = m[v], m[v] = -m[c - v - 1], m[c - v - 1] = -$;
        }
    }, F.prototype.normalize13b = function(w, m) {
      for (var c = 0, v = 0; v < m / 2; v++) {
        var $ = Math.round(w[2 * v + 1] / m) * 8192 + Math.round(w[2 * v] / m) + c;
        w[v] = $ & 67108863, $ < 67108864 ? c = 0 : c = $ / 67108864 | 0;
      }
      return w;
    }, F.prototype.convert13b = function(w, m, c, v) {
      for (var $ = 0, S = 0; S < m; S++)
        $ = $ + (w[S] | 0), c[2 * S] = $ & 8191, $ = $ >>> 13, c[2 * S + 1] = $ & 8191, $ = $ >>> 13;
      for (S = 2 * m; S < v; ++S)
        c[S] = 0;
      a($ === 0), a(($ & -8192) === 0);
    }, F.prototype.stub = function(w) {
      for (var m = new Array(w), c = 0; c < w; c++)
        m[c] = 0;
      return m;
    }, F.prototype.mulp = function(w, m, c) {
      var v = 2 * this.guessLen13b(w.length, m.length), $ = this.makeRBT(v), S = this.stub(v), A = new Array(v), M = new Array(v), p = new Array(v), B = new Array(v), b = new Array(v), k = new Array(v), Z = c.words;
      Z.length = v, this.convert13b(w.words, w.length, A, v), this.convert13b(m.words, m.length, B, v), this.transform(A, S, M, p, v, $), this.transform(B, S, b, k, v, $);
      for (var te = 0; te < v; te++) {
        var V = M[te] * b[te] - p[te] * k[te];
        p[te] = M[te] * k[te] + p[te] * b[te], M[te] = V;
      }
      return this.conjugate(M, p, v), this.transform(M, p, Z, S, v, $), this.conjugate(Z, S, v), this.normalize13b(Z, v), c.negative = w.negative ^ m.negative, c.length = w.length + m.length, c.strip();
    }, o.prototype.mul = function(w) {
      var m = new o(null);
      return m.words = new Array(this.length + w.length), this.mulTo(w, m);
    }, o.prototype.mulf = function(w) {
      var m = new o(null);
      return m.words = new Array(this.length + w.length), z(this, w, m);
    }, o.prototype.imul = function(w) {
      return this.clone().mulTo(w, this);
    }, o.prototype.imuln = function(w) {
      a(typeof w == "number"), a(w < 67108864);
      for (var m = 0, c = 0; c < this.length; c++) {
        var v = (this.words[c] | 0) * w, $ = (v & 67108863) + (m & 67108863);
        m >>= 26, m += v / 67108864 | 0, m += $ >>> 26, this.words[c] = $ & 67108863;
      }
      return m !== 0 && (this.words[c] = m, this.length++), this;
    }, o.prototype.muln = function(w) {
      return this.clone().imuln(w);
    }, o.prototype.sqr = function() {
      return this.mul(this);
    }, o.prototype.isqr = function() {
      return this.imul(this.clone());
    }, o.prototype.pow = function(w) {
      var m = D(w);
      if (m.length === 0) return new o(1);
      for (var c = this, v = 0; v < m.length && m[v] === 0; v++, c = c.sqr())
        ;
      if (++v < m.length)
        for (var $ = c.sqr(); v < m.length; v++, $ = $.sqr())
          m[v] !== 0 && (c = c.mul($));
      return c;
    }, o.prototype.iushln = function(w) {
      a(typeof w == "number" && w >= 0);
      var m = w % 26, c = (w - m) / 26, v = 67108863 >>> 26 - m << 26 - m, $;
      if (m !== 0) {
        var S = 0;
        for ($ = 0; $ < this.length; $++) {
          var A = this.words[$] & v, M = (this.words[$] | 0) - A << m;
          this.words[$] = M | S, S = A >>> 26 - m;
        }
        S && (this.words[$] = S, this.length++);
      }
      if (c !== 0) {
        for ($ = this.length - 1; $ >= 0; $--)
          this.words[$ + c] = this.words[$];
        for ($ = 0; $ < c; $++)
          this.words[$] = 0;
        this.length += c;
      }
      return this.strip();
    }, o.prototype.ishln = function(w) {
      return a(this.negative === 0), this.iushln(w);
    }, o.prototype.iushrn = function(w, m, c) {
      a(typeof w == "number" && w >= 0);
      var v;
      m ? v = (m - m % 26) / 26 : v = 0;
      var $ = w % 26, S = Math.min((w - $) / 26, this.length), A = 67108863 ^ 67108863 >>> $ << $, M = c;
      if (v -= S, v = Math.max(0, v), M) {
        for (var p = 0; p < S; p++)
          M.words[p] = this.words[p];
        M.length = S;
      }
      if (S !== 0) if (this.length > S)
        for (this.length -= S, p = 0; p < this.length; p++)
          this.words[p] = this.words[p + S];
      else
        this.words[0] = 0, this.length = 1;
      var B = 0;
      for (p = this.length - 1; p >= 0 && (B !== 0 || p >= v); p--) {
        var b = this.words[p] | 0;
        this.words[p] = B << 26 - $ | b >>> $, B = b & A;
      }
      return M && B !== 0 && (M.words[M.length++] = B), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, o.prototype.ishrn = function(w, m, c) {
      return a(this.negative === 0), this.iushrn(w, m, c);
    }, o.prototype.shln = function(w) {
      return this.clone().ishln(w);
    }, o.prototype.ushln = function(w) {
      return this.clone().iushln(w);
    }, o.prototype.shrn = function(w) {
      return this.clone().ishrn(w);
    }, o.prototype.ushrn = function(w) {
      return this.clone().iushrn(w);
    }, o.prototype.testn = function(w) {
      a(typeof w == "number" && w >= 0);
      var m = w % 26, c = (w - m) / 26, v = 1 << m;
      if (this.length <= c) return !1;
      var $ = this.words[c];
      return !!($ & v);
    }, o.prototype.imaskn = function(w) {
      a(typeof w == "number" && w >= 0);
      var m = w % 26, c = (w - m) / 26;
      if (a(this.negative === 0, "imaskn works only with positive numbers"), this.length <= c)
        return this;
      if (m !== 0 && c++, this.length = Math.min(c, this.length), m !== 0) {
        var v = 67108863 ^ 67108863 >>> m << m;
        this.words[this.length - 1] &= v;
      }
      return this.strip();
    }, o.prototype.maskn = function(w) {
      return this.clone().imaskn(w);
    }, o.prototype.iaddn = function(w) {
      return a(typeof w == "number"), a(w < 67108864), w < 0 ? this.isubn(-w) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < w ? (this.words[0] = w - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(w), this.negative = 1, this) : this._iaddn(w);
    }, o.prototype._iaddn = function(w) {
      this.words[0] += w;
      for (var m = 0; m < this.length && this.words[m] >= 67108864; m++)
        this.words[m] -= 67108864, m === this.length - 1 ? this.words[m + 1] = 1 : this.words[m + 1]++;
      return this.length = Math.max(this.length, m + 1), this;
    }, o.prototype.isubn = function(w) {
      if (a(typeof w == "number"), a(w < 67108864), w < 0) return this.iaddn(-w);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(w), this.negative = 1, this;
      if (this.words[0] -= w, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var m = 0; m < this.length && this.words[m] < 0; m++)
          this.words[m] += 67108864, this.words[m + 1] -= 1;
      return this.strip();
    }, o.prototype.addn = function(w) {
      return this.clone().iaddn(w);
    }, o.prototype.subn = function(w) {
      return this.clone().isubn(w);
    }, o.prototype.iabs = function() {
      return this.negative = 0, this;
    }, o.prototype.abs = function() {
      return this.clone().iabs();
    }, o.prototype._ishlnsubmul = function(w, m, c) {
      var v = w.length + c, $;
      this._expand(v);
      var S, A = 0;
      for ($ = 0; $ < w.length; $++) {
        S = (this.words[$ + c] | 0) + A;
        var M = (w.words[$] | 0) * m;
        S -= M & 67108863, A = (S >> 26) - (M / 67108864 | 0), this.words[$ + c] = S & 67108863;
      }
      for (; $ < this.length - c; $++)
        S = (this.words[$ + c] | 0) + A, A = S >> 26, this.words[$ + c] = S & 67108863;
      if (A === 0) return this.strip();
      for (a(A === -1), A = 0, $ = 0; $ < this.length; $++)
        S = -(this.words[$] | 0) + A, A = S >> 26, this.words[$] = S & 67108863;
      return this.negative = 1, this.strip();
    }, o.prototype._wordDiv = function(w, m) {
      var c = this.length - w.length, v = this.clone(), $ = w, S = $.words[$.length - 1] | 0, A = this._countBits(S);
      c = 26 - A, c !== 0 && ($ = $.ushln(c), v.iushln(c), S = $.words[$.length - 1] | 0);
      var M = v.length - $.length, p;
      if (m !== "mod") {
        p = new o(null), p.length = M + 1, p.words = new Array(p.length);
        for (var B = 0; B < p.length; B++)
          p.words[B] = 0;
      }
      var b = v.clone()._ishlnsubmul($, 1, M);
      b.negative === 0 && (v = b, p && (p.words[M] = 1));
      for (var k = M - 1; k >= 0; k--) {
        var Z = (v.words[$.length + k] | 0) * 67108864 + (v.words[$.length + k - 1] | 0);
        for (Z = Math.min(Z / S | 0, 67108863), v._ishlnsubmul($, Z, k); v.negative !== 0; )
          Z--, v.negative = 0, v._ishlnsubmul($, 1, k), v.isZero() || (v.negative ^= 1);
        p && (p.words[k] = Z);
      }
      return p && p.strip(), v.strip(), m !== "div" && c !== 0 && v.iushrn(c), {
        div: p || null,
        mod: v
      };
    }, o.prototype.divmod = function(w, m, c) {
      if (a(!w.isZero()), this.isZero())
        return {
          div: new o(0),
          mod: new o(0)
        };
      var v, $, S;
      return this.negative !== 0 && w.negative === 0 ? (S = this.neg().divmod(w, m), m !== "mod" && (v = S.div.neg()), m !== "div" && ($ = S.mod.neg(), c && $.negative !== 0 && $.iadd(w)), {
        div: v,
        mod: $
      }) : this.negative === 0 && w.negative !== 0 ? (S = this.divmod(w.neg(), m), m !== "mod" && (v = S.div.neg()), {
        div: v,
        mod: S.mod
      }) : this.negative & w.negative ? (S = this.neg().divmod(w.neg(), m), m !== "div" && ($ = S.mod.neg(), c && $.negative !== 0 && $.isub(w)), {
        div: S.div,
        mod: $
      }) : w.length > this.length || this.cmp(w) < 0 ? {
        div: new o(0),
        mod: this
      } : w.length === 1 ? m === "div" ? {
        div: this.divn(w.words[0]),
        mod: null
      } : m === "mod" ? {
        div: null,
        mod: new o(this.modn(w.words[0]))
      } : {
        div: this.divn(w.words[0]),
        mod: new o(this.modn(w.words[0]))
      } : this._wordDiv(w, m);
    }, o.prototype.div = function(w) {
      return this.divmod(w, "div", !1).div;
    }, o.prototype.mod = function(w) {
      return this.divmod(w, "mod", !1).mod;
    }, o.prototype.umod = function(w) {
      return this.divmod(w, "mod", !0).mod;
    }, o.prototype.divRound = function(w) {
      var m = this.divmod(w);
      if (m.mod.isZero()) return m.div;
      var c = m.div.negative !== 0 ? m.mod.isub(w) : m.mod, v = w.ushrn(1), $ = w.andln(1), S = c.cmp(v);
      return S < 0 || $ === 1 && S === 0 ? m.div : m.div.negative !== 0 ? m.div.isubn(1) : m.div.iaddn(1);
    }, o.prototype.modn = function(w) {
      a(w <= 67108863);
      for (var m = (1 << 26) % w, c = 0, v = this.length - 1; v >= 0; v--)
        c = (m * c + (this.words[v] | 0)) % w;
      return c;
    }, o.prototype.idivn = function(w) {
      a(w <= 67108863);
      for (var m = 0, c = this.length - 1; c >= 0; c--) {
        var v = (this.words[c] | 0) + m * 67108864;
        this.words[c] = v / w | 0, m = v % w;
      }
      return this.strip();
    }, o.prototype.divn = function(w) {
      return this.clone().idivn(w);
    }, o.prototype.egcd = function(w) {
      a(w.negative === 0), a(!w.isZero());
      var m = this, c = w.clone();
      m.negative !== 0 ? m = m.umod(w) : m = m.clone();
      for (var v = new o(1), $ = new o(0), S = new o(0), A = new o(1), M = 0; m.isEven() && c.isEven(); )
        m.iushrn(1), c.iushrn(1), ++M;
      for (var p = c.clone(), B = m.clone(); !m.isZero(); ) {
        for (var b = 0, k = 1; !(m.words[0] & k) && b < 26; ++b, k <<= 1) ;
        if (b > 0)
          for (m.iushrn(b); b-- > 0; )
            (v.isOdd() || $.isOdd()) && (v.iadd(p), $.isub(B)), v.iushrn(1), $.iushrn(1);
        for (var Z = 0, te = 1; !(c.words[0] & te) && Z < 26; ++Z, te <<= 1) ;
        if (Z > 0)
          for (c.iushrn(Z); Z-- > 0; )
            (S.isOdd() || A.isOdd()) && (S.iadd(p), A.isub(B)), S.iushrn(1), A.iushrn(1);
        m.cmp(c) >= 0 ? (m.isub(c), v.isub(S), $.isub(A)) : (c.isub(m), S.isub(v), A.isub($));
      }
      return {
        a: S,
        b: A,
        gcd: c.iushln(M)
      };
    }, o.prototype._invmp = function(w) {
      a(w.negative === 0), a(!w.isZero());
      var m = this, c = w.clone();
      m.negative !== 0 ? m = m.umod(w) : m = m.clone();
      for (var v = new o(1), $ = new o(0), S = c.clone(); m.cmpn(1) > 0 && c.cmpn(1) > 0; ) {
        for (var A = 0, M = 1; !(m.words[0] & M) && A < 26; ++A, M <<= 1) ;
        if (A > 0)
          for (m.iushrn(A); A-- > 0; )
            v.isOdd() && v.iadd(S), v.iushrn(1);
        for (var p = 0, B = 1; !(c.words[0] & B) && p < 26; ++p, B <<= 1) ;
        if (p > 0)
          for (c.iushrn(p); p-- > 0; )
            $.isOdd() && $.iadd(S), $.iushrn(1);
        m.cmp(c) >= 0 ? (m.isub(c), v.isub($)) : (c.isub(m), $.isub(v));
      }
      var b;
      return m.cmpn(1) === 0 ? b = v : b = $, b.cmpn(0) < 0 && b.iadd(w), b;
    }, o.prototype.gcd = function(w) {
      if (this.isZero()) return w.abs();
      if (w.isZero()) return this.abs();
      var m = this.clone(), c = w.clone();
      m.negative = 0, c.negative = 0;
      for (var v = 0; m.isEven() && c.isEven(); v++)
        m.iushrn(1), c.iushrn(1);
      do {
        for (; m.isEven(); )
          m.iushrn(1);
        for (; c.isEven(); )
          c.iushrn(1);
        var $ = m.cmp(c);
        if ($ < 0) {
          var S = m;
          m = c, c = S;
        } else if ($ === 0 || c.cmpn(1) === 0)
          break;
        m.isub(c);
      } while (!0);
      return c.iushln(v);
    }, o.prototype.invm = function(w) {
      return this.egcd(w).a.umod(w);
    }, o.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, o.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, o.prototype.andln = function(w) {
      return this.words[0] & w;
    }, o.prototype.bincn = function(w) {
      a(typeof w == "number");
      var m = w % 26, c = (w - m) / 26, v = 1 << m;
      if (this.length <= c)
        return this._expand(c + 1), this.words[c] |= v, this;
      for (var $ = v, S = c; $ !== 0 && S < this.length; S++) {
        var A = this.words[S] | 0;
        A += $, $ = A >>> 26, A &= 67108863, this.words[S] = A;
      }
      return $ !== 0 && (this.words[S] = $, this.length++), this;
    }, o.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, o.prototype.cmpn = function(w) {
      var m = w < 0;
      if (this.negative !== 0 && !m) return -1;
      if (this.negative === 0 && m) return 1;
      this.strip();
      var c;
      if (this.length > 1)
        c = 1;
      else {
        m && (w = -w), a(w <= 67108863, "Number is too big");
        var v = this.words[0] | 0;
        c = v === w ? 0 : v < w ? -1 : 1;
      }
      return this.negative !== 0 ? -c | 0 : c;
    }, o.prototype.cmp = function(w) {
      if (this.negative !== 0 && w.negative === 0) return -1;
      if (this.negative === 0 && w.negative !== 0) return 1;
      var m = this.ucmp(w);
      return this.negative !== 0 ? -m | 0 : m;
    }, o.prototype.ucmp = function(w) {
      if (this.length > w.length) return 1;
      if (this.length < w.length) return -1;
      for (var m = 0, c = this.length - 1; c >= 0; c--) {
        var v = this.words[c] | 0, $ = w.words[c] | 0;
        if (v !== $) {
          v < $ ? m = -1 : v > $ && (m = 1);
          break;
        }
      }
      return m;
    }, o.prototype.gtn = function(w) {
      return this.cmpn(w) === 1;
    }, o.prototype.gt = function(w) {
      return this.cmp(w) === 1;
    }, o.prototype.gten = function(w) {
      return this.cmpn(w) >= 0;
    }, o.prototype.gte = function(w) {
      return this.cmp(w) >= 0;
    }, o.prototype.ltn = function(w) {
      return this.cmpn(w) === -1;
    }, o.prototype.lt = function(w) {
      return this.cmp(w) === -1;
    }, o.prototype.lten = function(w) {
      return this.cmpn(w) <= 0;
    }, o.prototype.lte = function(w) {
      return this.cmp(w) <= 0;
    }, o.prototype.eqn = function(w) {
      return this.cmpn(w) === 0;
    }, o.prototype.eq = function(w) {
      return this.cmp(w) === 0;
    }, o.red = function(w) {
      return new oe(w);
    }, o.prototype.toRed = function(w) {
      return a(!this.red, "Already a number in reduction context"), a(this.negative === 0, "red works only with positives"), w.convertTo(this)._forceRed(w);
    }, o.prototype.fromRed = function() {
      return a(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, o.prototype._forceRed = function(w) {
      return this.red = w, this;
    }, o.prototype.forceRed = function(w) {
      return a(!this.red, "Already a number in reduction context"), this._forceRed(w);
    }, o.prototype.redAdd = function(w) {
      return a(this.red, "redAdd works only with red numbers"), this.red.add(this, w);
    }, o.prototype.redIAdd = function(w) {
      return a(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, w);
    }, o.prototype.redSub = function(w) {
      return a(this.red, "redSub works only with red numbers"), this.red.sub(this, w);
    }, o.prototype.redISub = function(w) {
      return a(this.red, "redISub works only with red numbers"), this.red.isub(this, w);
    }, o.prototype.redShl = function(w) {
      return a(this.red, "redShl works only with red numbers"), this.red.shl(this, w);
    }, o.prototype.redMul = function(w) {
      return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, w), this.red.mul(this, w);
    }, o.prototype.redIMul = function(w) {
      return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, w), this.red.imul(this, w);
    }, o.prototype.redSqr = function() {
      return a(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, o.prototype.redISqr = function() {
      return a(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, o.prototype.redSqrt = function() {
      return a(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, o.prototype.redInvm = function() {
      return a(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, o.prototype.redNeg = function() {
      return a(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, o.prototype.redPow = function(w) {
      return a(this.red && !w.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, w);
    };
    var X = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function ee(J, w) {
      this.name = J, this.p = new o(w, 16), this.n = this.p.bitLength(), this.k = new o(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    ee.prototype._tmp = function() {
      var w = new o(null);
      return w.words = new Array(Math.ceil(this.n / 13)), w;
    }, ee.prototype.ireduce = function(w) {
      var m = w, c;
      do
        this.split(m, this.tmp), m = this.imulK(m), m = m.iadd(this.tmp), c = m.bitLength();
      while (c > this.n);
      var v = c < this.n ? -1 : m.ucmp(this.p);
      return v === 0 ? (m.words[0] = 0, m.length = 1) : v > 0 ? m.isub(this.p) : m.strip !== void 0 ? m.strip() : m._strip(), m;
    }, ee.prototype.split = function(w, m) {
      w.iushrn(this.n, 0, m);
    }, ee.prototype.imulK = function(w) {
      return w.imul(this.k);
    };
    function se() {
      ee.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    u(se, ee), se.prototype.split = function(w, m) {
      for (var c = 4194303, v = Math.min(w.length, 9), $ = 0; $ < v; $++)
        m.words[$] = w.words[$];
      if (m.length = v, w.length <= 9) {
        w.words[0] = 0, w.length = 1;
        return;
      }
      var S = w.words[9];
      for (m.words[m.length++] = S & c, $ = 10; $ < w.length; $++) {
        var A = w.words[$] | 0;
        w.words[$ - 10] = (A & c) << 4 | S >>> 22, S = A;
      }
      S >>>= 22, w.words[$ - 10] = S, S === 0 && w.length > 10 ? w.length -= 10 : w.length -= 9;
    }, se.prototype.imulK = function(w) {
      w.words[w.length] = 0, w.words[w.length + 1] = 0, w.length += 2;
      for (var m = 0, c = 0; c < w.length; c++) {
        var v = w.words[c] | 0;
        m += v * 977, w.words[c] = m & 67108863, m = v * 64 + (m / 67108864 | 0);
      }
      return w.words[w.length - 1] === 0 && (w.length--, w.words[w.length - 1] === 0 && w.length--), w;
    };
    function ce() {
      ee.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    u(ce, ee);
    function le() {
      ee.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    u(le, ee);
    function he() {
      ee.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    u(he, ee), he.prototype.imulK = function(w) {
      for (var m = 0, c = 0; c < w.length; c++) {
        var v = (w.words[c] | 0) * 19 + m, $ = v & 67108863;
        v >>>= 26, w.words[c] = $, m = v;
      }
      return m !== 0 && (w.words[w.length++] = m), w;
    }, o._prime = function(w) {
      if (X[w]) return X[w];
      var m;
      if (w === "k256")
        m = new se();
      else if (w === "p224")
        m = new ce();
      else if (w === "p192")
        m = new le();
      else if (w === "p25519")
        m = new he();
      else
        throw new Error("Unknown prime " + w);
      return X[w] = m, m;
    };
    function oe(J) {
      if (typeof J == "string") {
        var w = o._prime(J);
        this.m = w.p, this.prime = w;
      } else
        a(J.gtn(1), "modulus must be greater than 1"), this.m = J, this.prime = null;
    }
    oe.prototype._verify1 = function(w) {
      a(w.negative === 0, "red works only with positives"), a(w.red, "red works only with red numbers");
    }, oe.prototype._verify2 = function(w, m) {
      a((w.negative | m.negative) === 0, "red works only with positives"), a(
        w.red && w.red === m.red,
        "red works only with red numbers"
      );
    }, oe.prototype.imod = function(w) {
      return this.prime ? this.prime.ireduce(w)._forceRed(this) : w.umod(this.m)._forceRed(this);
    }, oe.prototype.neg = function(w) {
      return w.isZero() ? w.clone() : this.m.sub(w)._forceRed(this);
    }, oe.prototype.add = function(w, m) {
      this._verify2(w, m);
      var c = w.add(m);
      return c.cmp(this.m) >= 0 && c.isub(this.m), c._forceRed(this);
    }, oe.prototype.iadd = function(w, m) {
      this._verify2(w, m);
      var c = w.iadd(m);
      return c.cmp(this.m) >= 0 && c.isub(this.m), c;
    }, oe.prototype.sub = function(w, m) {
      this._verify2(w, m);
      var c = w.sub(m);
      return c.cmpn(0) < 0 && c.iadd(this.m), c._forceRed(this);
    }, oe.prototype.isub = function(w, m) {
      this._verify2(w, m);
      var c = w.isub(m);
      return c.cmpn(0) < 0 && c.iadd(this.m), c;
    }, oe.prototype.shl = function(w, m) {
      return this._verify1(w), this.imod(w.ushln(m));
    }, oe.prototype.imul = function(w, m) {
      return this._verify2(w, m), this.imod(w.imul(m));
    }, oe.prototype.mul = function(w, m) {
      return this._verify2(w, m), this.imod(w.mul(m));
    }, oe.prototype.isqr = function(w) {
      return this.imul(w, w.clone());
    }, oe.prototype.sqr = function(w) {
      return this.mul(w, w);
    }, oe.prototype.sqrt = function(w) {
      if (w.isZero()) return w.clone();
      var m = this.m.andln(3);
      if (a(m % 2 === 1), m === 3) {
        var c = this.m.add(new o(1)).iushrn(2);
        return this.pow(w, c);
      }
      for (var v = this.m.subn(1), $ = 0; !v.isZero() && v.andln(1) === 0; )
        $++, v.iushrn(1);
      a(!v.isZero());
      var S = new o(1).toRed(this), A = S.redNeg(), M = this.m.subn(1).iushrn(1), p = this.m.bitLength();
      for (p = new o(2 * p * p).toRed(this); this.pow(p, M).cmp(A) !== 0; )
        p.redIAdd(A);
      for (var B = this.pow(p, v), b = this.pow(w, v.addn(1).iushrn(1)), k = this.pow(w, v), Z = $; k.cmp(S) !== 0; ) {
        for (var te = k, V = 0; te.cmp(S) !== 0; V++)
          te = te.redSqr();
        a(V < Z);
        var T = this.pow(B, new o(1).iushln(Z - V - 1));
        b = b.redMul(T), B = T.redSqr(), k = k.redMul(B), Z = V;
      }
      return b;
    }, oe.prototype.invm = function(w) {
      var m = w._invmp(this.m);
      return m.negative !== 0 ? (m.negative = 0, this.imod(m).redNeg()) : this.imod(m);
    }, oe.prototype.pow = function(w, m) {
      if (m.isZero()) return new o(1).toRed(this);
      if (m.cmpn(1) === 0) return w.clone();
      var c = 4, v = new Array(1 << c);
      v[0] = new o(1).toRed(this), v[1] = w;
      for (var $ = 2; $ < v.length; $++)
        v[$] = this.mul(v[$ - 1], w);
      var S = v[0], A = 0, M = 0, p = m.bitLength() % 26;
      for (p === 0 && (p = 26), $ = m.length - 1; $ >= 0; $--) {
        for (var B = m.words[$], b = p - 1; b >= 0; b--) {
          var k = B >> b & 1;
          if (S !== v[0] && (S = this.sqr(S)), k === 0 && A === 0) {
            M = 0;
            continue;
          }
          A <<= 1, A |= k, M++, !(M !== c && ($ !== 0 || b !== 0)) && (S = this.mul(S, v[A]), M = 0, A = 0);
        }
        p = 26;
      }
      return S;
    }, oe.prototype.convertTo = function(w) {
      var m = w.umod(this.m);
      return m === w ? m.clone() : m;
    }, oe.prototype.convertFrom = function(w) {
      var m = w.clone();
      return m.red = null, m;
    }, o.mont = function(w) {
      return new _e(w);
    };
    function _e(J) {
      oe.call(this, J), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    u(_e, oe), _e.prototype.convertTo = function(w) {
      return this.imod(w.ushln(this.shift));
    }, _e.prototype.convertFrom = function(w) {
      var m = this.imod(w.mul(this.rinv));
      return m.red = null, m;
    }, _e.prototype.imul = function(w, m) {
      if (w.isZero() || m.isZero())
        return w.words[0] = 0, w.length = 1, w;
      var c = w.imul(m), v = c.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = c.isub(v).iushrn(this.shift), S = $;
      return $.cmp(this.m) >= 0 ? S = $.isub(this.m) : $.cmpn(0) < 0 && (S = $.iadd(this.m)), S._forceRed(this);
    }, _e.prototype.mul = function(w, m) {
      if (w.isZero() || m.isZero()) return new o(0)._forceRed(this);
      var c = w.mul(m), v = c.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $ = c.isub(v).iushrn(this.shift), S = $;
      return $.cmp(this.m) >= 0 ? S = $.isub(this.m) : $.cmpn(0) < 0 && (S = $.iadd(this.m)), S._forceRed(this);
    }, _e.prototype.invm = function(w) {
      var m = this.imod(w._invmp(this.m).mul(this.r2));
      return m._forceRed(this);
    };
  })(t, commonjsGlobal);
})(bn$1);
var bnExports$1 = bn$1.exports, brorand = { exports: {} };
brorand.exports;
var hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var t;
  brorand.exports = function(u) {
    return t || (t = new e(null)), t.generate(u);
  };
  function e(a) {
    this.rand = a;
  }
  if (brorand.exports.Rand = e, e.prototype.generate = function(u) {
    return this._rand(u);
  }, e.prototype._rand = function(u) {
    if (this.rand.getBytes)
      return this.rand.getBytes(u);
    for (var o = new Uint8Array(u), d = 0; d < o.length; d++)
      o[d] = this.rand.getByte();
    return o;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? e.prototype._rand = function(u) {
      var o = new Uint8Array(u);
      return self.crypto.getRandomValues(o), o;
    } : self.msCrypto && self.msCrypto.getRandomValues ? e.prototype._rand = function(u) {
      var o = new Uint8Array(u);
      return self.msCrypto.getRandomValues(o), o;
    } : typeof window == "object" && (e.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var n = requireCryptoBrowserify();
      if (typeof n.randomBytes != "function")
        throw new Error("Not supported");
      e.prototype._rand = function(u) {
        return n.randomBytes(u);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr;
  hasRequiredMr = 1;
  var t = bnExports$1, e = requireBrorand();
  function n(a) {
    this.rand = a || new e.Rand();
  }
  return mr = n, n.create = function(u) {
    return new n(u);
  }, n.prototype._randbelow = function(u) {
    var o = u.bitLength(), d = Math.ceil(o / 8);
    do
      var l = new t(this.rand.generate(d));
    while (l.cmp(u) >= 0);
    return l;
  }, n.prototype._randrange = function(u, o) {
    var d = o.sub(u);
    return u.add(this._randbelow(d));
  }, n.prototype.test = function(u, o, d) {
    var l = u.bitLength(), _ = t.mont(u), P = new t(1).toRed(_);
    o || (o = Math.max(1, l / 48 | 0));
    for (var h = u.subn(1), x = 0; !h.testn(x); x++)
      ;
    for (var C = u.shrn(x), D = h.toRed(_), q = !0; o > 0; o--) {
      var H = this._randrange(new t(2), h);
      d && d(H);
      var Y = H.toRed(_).redPow(C);
      if (!(Y.cmp(P) === 0 || Y.cmp(D) === 0)) {
        for (var z = 1; z < x; z++) {
          if (Y = Y.redSqr(), Y.cmp(P) === 0)
            return !1;
          if (Y.cmp(D) === 0)
            break;
        }
        if (z === x)
          return !1;
      }
    }
    return q;
  }, n.prototype.getDivisor = function(u, o) {
    var d = u.bitLength(), l = t.mont(u), _ = new t(1).toRed(l);
    o || (o = Math.max(1, d / 48 | 0));
    for (var P = u.subn(1), h = 0; !P.testn(h); h++)
      ;
    for (var x = u.shrn(h), C = P.toRed(l); o > 0; o--) {
      var D = this._randrange(new t(2), P), q = u.gcd(D);
      if (q.cmpn(1) !== 0)
        return q;
      var H = D.toRed(l).redPow(x);
      if (!(H.cmp(_) === 0 || H.cmp(C) === 0)) {
        for (var Y = 1; Y < h; Y++) {
          if (H = H.redSqr(), H.cmp(_) === 0)
            return H.fromRed().subn(1).gcd(u);
          if (H.cmp(C) === 0)
            break;
        }
        if (Y === h)
          return H = H.redSqr(), H.fromRed().subn(1).gcd(u);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var t = browserExports;
  generatePrime = Y, Y.simpleSieve = q, Y.fermatTest = H;
  var e = bnExports$1, n = new e(24), a = requireMr(), u = new a(), o = new e(1), d = new e(2), l = new e(5);
  new e(16), new e(8);
  var _ = new e(10), P = new e(3);
  new e(7);
  var h = new e(11), x = new e(4);
  new e(12);
  var C = null;
  function D() {
    if (C !== null)
      return C;
    var z = 1048576, F = [];
    F[0] = 2;
    for (var X = 1, ee = 3; ee < z; ee += 2) {
      for (var se = Math.ceil(Math.sqrt(ee)), ce = 0; ce < X && F[ce] <= se && ee % F[ce] !== 0; ce++)
        ;
      X !== ce && F[ce] <= se || (F[X++] = ee);
    }
    return C = F, F;
  }
  function q(z) {
    for (var F = D(), X = 0; X < F.length; X++)
      if (z.modn(F[X]) === 0)
        return z.cmpn(F[X]) === 0;
    return !0;
  }
  function H(z) {
    var F = e.mont(z);
    return d.toRed(F).redPow(z.subn(1)).fromRed().cmpn(1) === 0;
  }
  function Y(z, F) {
    if (z < 16)
      return F === 2 || F === 5 ? new e([140, 123]) : new e([140, 39]);
    F = new e(F);
    for (var X, ee; ; ) {
      for (X = new e(t(Math.ceil(z / 8))); X.bitLength() > z; )
        X.ishrn(1);
      if (X.isEven() && X.iadd(o), X.testn(1) || X.iadd(d), F.cmp(d)) {
        if (!F.cmp(l))
          for (; X.mod(_).cmp(P); )
            X.iadd(x);
      } else for (; X.mod(n).cmp(h); )
        X.iadd(x);
      if (ee = X.shrn(1), q(ee) && q(X) && H(ee) && H(X) && u.test(ee) && u.test(X))
        return X;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var t = bnExports$1, e = requireMr(), n = new e(), a = new t(24), u = new t(11), o = new t(10), d = new t(3), l = new t(7), _ = requireGeneratePrime(), P = browserExports;
  dh = q;
  function h(Y, z) {
    return z = z || "utf8", Buffer$C.isBuffer(Y) || (Y = new Buffer$C(Y, z)), this._pub = new t(Y), this;
  }
  function x(Y, z) {
    return z = z || "utf8", Buffer$C.isBuffer(Y) || (Y = new Buffer$C(Y, z)), this._priv = new t(Y), this;
  }
  var C = {};
  function D(Y, z) {
    var F = z.toString("hex"), X = [F, Y.toString(16)].join("_");
    if (X in C)
      return C[X];
    var ee = 0;
    if (Y.isEven() || !_.simpleSieve || !_.fermatTest(Y) || !n.test(Y))
      return ee += 1, F === "02" || F === "05" ? ee += 8 : ee += 4, C[X] = ee, ee;
    n.test(Y.shrn(1)) || (ee += 2);
    var se;
    switch (F) {
      case "02":
        Y.mod(a).cmp(u) && (ee += 8);
        break;
      case "05":
        se = Y.mod(o), se.cmp(d) && se.cmp(l) && (ee += 8);
        break;
      default:
        ee += 4;
    }
    return C[X] = ee, ee;
  }
  function q(Y, z, F) {
    this.setGenerator(z), this.__prime = new t(Y), this._prime = t.mont(this.__prime), this._primeLen = Y.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, F ? (this.setPublicKey = h, this.setPrivateKey = x) : this._primeCode = 8;
  }
  Object.defineProperty(q.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = D(this.__prime, this.__gen)), this._primeCode;
    }
  }), q.prototype.generateKeys = function() {
    return this._priv || (this._priv = new t(P(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, q.prototype.computeSecret = function(Y) {
    Y = new t(Y), Y = Y.toRed(this._prime);
    var z = Y.redPow(this._priv).fromRed(), F = new Buffer$C(z.toArray()), X = this.getPrime();
    if (F.length < X.length) {
      var ee = new Buffer$C(X.length - F.length);
      ee.fill(0), F = Buffer$C.concat([ee, F]);
    }
    return F;
  }, q.prototype.getPublicKey = function(z) {
    return H(this._pub, z);
  }, q.prototype.getPrivateKey = function(z) {
    return H(this._priv, z);
  }, q.prototype.getPrime = function(Y) {
    return H(this.__prime, Y);
  }, q.prototype.getGenerator = function(Y) {
    return H(this._gen, Y);
  }, q.prototype.setGenerator = function(Y, z) {
    return z = z || "utf8", Buffer$C.isBuffer(Y) || (Y = new Buffer$C(Y, z)), this.__gen = Y, this._gen = new t(Y), this;
  };
  function H(Y, z) {
    var F = new Buffer$C(Y.toArray());
    return z ? F.toString(z) : F;
  }
  return dh;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$4;
  hasRequiredBrowser$2 = 1;
  var t = requireGeneratePrime(), e = require$$1$1, n = requireDh();
  function a(d) {
    var l = new Buffer$C(e[d].prime, "hex"), _ = new Buffer$C(e[d].gen, "hex");
    return new n(l, _);
  }
  var u = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function o(d, l, _, P) {
    return Buffer$C.isBuffer(l) || u[l] === void 0 ? o(d, "binary", l, _) : (l = l || "binary", P = P || "binary", _ = _ || new Buffer$C([2]), Buffer$C.isBuffer(_) || (_ = new Buffer$C(_, P)), typeof d == "number" ? new n(t(d, _), _, !0) : (Buffer$C.isBuffer(d) || (d = new Buffer$C(d, l)), new n(d, _, !0)));
  }
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = a, browser$4.createDiffieHellman = browser$4.DiffieHellman = o, browser$4;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} };
processNextickArgs.exports;
typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick } : processNextickArgs.exports = process$1;
function nextTick(t, e, n, a) {
  if (typeof t != "function")
    throw new TypeError('"callback" argument must be a function');
  var u = arguments.length, o, d;
  switch (u) {
    case 0:
    case 1:
      return process$1.nextTick(t);
    case 2:
      return process$1.nextTick(function() {
        t.call(null, e);
      });
    case 3:
      return process$1.nextTick(function() {
        t.call(null, e, n);
      });
    case 4:
      return process$1.nextTick(function() {
        t.call(null, e, n, a);
      });
    default:
      for (o = new Array(u - 1), d = 0; d < o.length; )
        o[d++] = arguments[d];
      return process$1.nextTick(function() {
        t.apply(null, o);
      });
  }
}
var processNextickArgsExports = processNextickArgs.exports, toString = {}.toString, isarray = Array.isArray || function(t) {
  return toString.call(t) == "[object Array]";
}, streamBrowser = eventsExports.EventEmitter, util$2 = {};
function isArray(t) {
  return Array.isArray ? Array.isArray(t) : objectToString(t) === "[object Array]";
}
util$2.isArray = isArray;
function isBoolean(t) {
  return typeof t == "boolean";
}
util$2.isBoolean = isBoolean;
function isNull(t) {
  return t === null;
}
util$2.isNull = isNull;
function isNullOrUndefined(t) {
  return t == null;
}
util$2.isNullOrUndefined = isNullOrUndefined;
function isNumber(t) {
  return typeof t == "number";
}
util$2.isNumber = isNumber;
function isString(t) {
  return typeof t == "string";
}
util$2.isString = isString;
function isSymbol(t) {
  return typeof t == "symbol";
}
util$2.isSymbol = isSymbol;
function isUndefined(t) {
  return t === void 0;
}
util$2.isUndefined = isUndefined;
function isRegExp(t) {
  return objectToString(t) === "[object RegExp]";
}
util$2.isRegExp = isRegExp;
function isObject(t) {
  return typeof t == "object" && t !== null;
}
util$2.isObject = isObject;
function isDate(t) {
  return objectToString(t) === "[object Date]";
}
util$2.isDate = isDate;
function isError(t) {
  return objectToString(t) === "[object Error]" || t instanceof Error;
}
util$2.isError = isError;
function isFunction(t) {
  return typeof t == "function";
}
util$2.isFunction = isFunction;
function isPrimitive(t) {
  return t === null || typeof t == "boolean" || typeof t == "number" || typeof t == "string" || typeof t == "symbol" || // ES6 symbol
  typeof t > "u";
}
util$2.isPrimitive = isPrimitive;
util$2.isBuffer = require$$1$2.Buffer.isBuffer;
function objectToString(t) {
  return Object.prototype.toString.call(t);
}
var BufferList = { exports: {} };
BufferList.exports;
var hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(t) {
    function e(o, d) {
      if (!(o instanceof d))
        throw new TypeError("Cannot call a class as a function");
    }
    var n = safeBufferExports.Buffer, a = util$3;
    function u(o, d, l) {
      o.copy(d, l);
    }
    t.exports = function() {
      function o() {
        e(this, o), this.head = null, this.tail = null, this.length = 0;
      }
      return o.prototype.push = function(l) {
        var _ = { data: l, next: null };
        this.length > 0 ? this.tail.next = _ : this.head = _, this.tail = _, ++this.length;
      }, o.prototype.unshift = function(l) {
        var _ = { data: l, next: this.head };
        this.length === 0 && (this.tail = _), this.head = _, ++this.length;
      }, o.prototype.shift = function() {
        if (this.length !== 0) {
          var l = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, l;
        }
      }, o.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, o.prototype.join = function(l) {
        if (this.length === 0) return "";
        for (var _ = this.head, P = "" + _.data; _ = _.next; )
          P += l + _.data;
        return P;
      }, o.prototype.concat = function(l) {
        if (this.length === 0) return n.alloc(0);
        for (var _ = n.allocUnsafe(l >>> 0), P = this.head, h = 0; P; )
          u(P.data, _, h), h += P.data.length, P = P.next;
        return _;
      }, o;
    }(), a && a.inspect && a.inspect.custom && (t.exports.prototype[a.inspect.custom] = function() {
      var o = a.inspect({ length: this.length });
      return this.constructor.name + " " + o;
    });
  }(BufferList)), BufferList.exports;
}
var pna = processNextickArgsExports;
function destroy(t, e) {
  var n = this, a = this._readableState && this._readableState.destroyed, u = this._writableState && this._writableState.destroyed;
  return a || u ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, pna.nextTick(emitErrorNT, this, t)) : pna.nextTick(emitErrorNT, this, t)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(t || null, function(o) {
    !e && o ? n._writableState ? n._writableState.errorEmitted || (n._writableState.errorEmitted = !0, pna.nextTick(emitErrorNT, n, o)) : pna.nextTick(emitErrorNT, n, o) : e && e(o);
  }), this);
}
function undestroy() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT(t, e) {
  t.emit("error", e);
}
var destroy_1 = {
  destroy,
  undestroy
}, _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var t = processNextickArgsExports;
  _stream_writable = H;
  function e(S) {
    var A = this;
    this.next = null, this.entry = null, this.finish = function() {
      $(A, S);
    };
  }
  var n = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : t.nextTick, a;
  H.WritableState = D;
  var u = Object.create(util$2);
  u.inherits = inherits_browserExports;
  var o = {
    deprecate: browser$a
  }, d = streamBrowser, l = safeBufferExports.Buffer, _ = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function P(S) {
    return l.from(S);
  }
  function h(S) {
    return l.isBuffer(S) || S instanceof _;
  }
  var x = destroy_1;
  u.inherits(H, d);
  function C() {
  }
  function D(S, A) {
    a = a || require_stream_duplex(), S = S || {};
    var M = A instanceof a;
    this.objectMode = !!S.objectMode, M && (this.objectMode = this.objectMode || !!S.writableObjectMode);
    var p = S.highWaterMark, B = S.writableHighWaterMark, b = this.objectMode ? 16 : 16 * 1024;
    p || p === 0 ? this.highWaterMark = p : M && (B || B === 0) ? this.highWaterMark = B : this.highWaterMark = b, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var k = S.decodeStrings === !1;
    this.decodeStrings = !k, this.defaultEncoding = S.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Z) {
      le(A, Z);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  D.prototype.getBuffer = function() {
    for (var A = this.bufferedRequest, M = []; A; )
      M.push(A), A = A.next;
    return M;
  }, function() {
    try {
      Object.defineProperty(D.prototype, "buffer", {
        get: o.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var q;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (q = Function.prototype[Symbol.hasInstance], Object.defineProperty(H, Symbol.hasInstance, {
    value: function(S) {
      return q.call(this, S) ? !0 : this !== H ? !1 : S && S._writableState instanceof D;
    }
  })) : q = function(S) {
    return S instanceof this;
  };
  function H(S) {
    if (a = a || require_stream_duplex(), !q.call(H, this) && !(this instanceof a))
      return new H(S);
    this._writableState = new D(S, this), this.writable = !0, S && (typeof S.write == "function" && (this._write = S.write), typeof S.writev == "function" && (this._writev = S.writev), typeof S.destroy == "function" && (this._destroy = S.destroy), typeof S.final == "function" && (this._final = S.final)), d.call(this);
  }
  H.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function Y(S, A) {
    var M = new Error("write after end");
    S.emit("error", M), t.nextTick(A, M);
  }
  function z(S, A, M, p) {
    var B = !0, b = !1;
    return M === null ? b = new TypeError("May not write null values to stream") : typeof M != "string" && M !== void 0 && !A.objectMode && (b = new TypeError("Invalid non-string/buffer chunk")), b && (S.emit("error", b), t.nextTick(p, b), B = !1), B;
  }
  H.prototype.write = function(S, A, M) {
    var p = this._writableState, B = !1, b = !p.objectMode && h(S);
    return b && !l.isBuffer(S) && (S = P(S)), typeof A == "function" && (M = A, A = null), b ? A = "buffer" : A || (A = p.defaultEncoding), typeof M != "function" && (M = C), p.ended ? Y(this, M) : (b || z(this, p, S, M)) && (p.pendingcb++, B = X(this, p, b, S, A, M)), B;
  }, H.prototype.cork = function() {
    var S = this._writableState;
    S.corked++;
  }, H.prototype.uncork = function() {
    var S = this._writableState;
    S.corked && (S.corked--, !S.writing && !S.corked && !S.bufferProcessing && S.bufferedRequest && _e(this, S));
  }, H.prototype.setDefaultEncoding = function(A) {
    if (typeof A == "string" && (A = A.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((A + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + A);
    return this._writableState.defaultEncoding = A, this;
  };
  function F(S, A, M) {
    return !S.objectMode && S.decodeStrings !== !1 && typeof A == "string" && (A = l.from(A, M)), A;
  }
  Object.defineProperty(H.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function X(S, A, M, p, B, b) {
    if (!M) {
      var k = F(A, p, B);
      p !== k && (M = !0, B = "buffer", p = k);
    }
    var Z = A.objectMode ? 1 : p.length;
    A.length += Z;
    var te = A.length < A.highWaterMark;
    if (te || (A.needDrain = !0), A.writing || A.corked) {
      var V = A.lastBufferedRequest;
      A.lastBufferedRequest = {
        chunk: p,
        encoding: B,
        isBuf: M,
        callback: b,
        next: null
      }, V ? V.next = A.lastBufferedRequest : A.bufferedRequest = A.lastBufferedRequest, A.bufferedRequestCount += 1;
    } else
      ee(S, A, !1, Z, p, B, b);
    return te;
  }
  function ee(S, A, M, p, B, b, k) {
    A.writelen = p, A.writecb = k, A.writing = !0, A.sync = !0, M ? S._writev(B, A.onwrite) : S._write(B, b, A.onwrite), A.sync = !1;
  }
  function se(S, A, M, p, B) {
    --A.pendingcb, M ? (t.nextTick(B, p), t.nextTick(c, S, A), S._writableState.errorEmitted = !0, S.emit("error", p)) : (B(p), S._writableState.errorEmitted = !0, S.emit("error", p), c(S, A));
  }
  function ce(S) {
    S.writing = !1, S.writecb = null, S.length -= S.writelen, S.writelen = 0;
  }
  function le(S, A) {
    var M = S._writableState, p = M.sync, B = M.writecb;
    if (ce(M), A) se(S, M, p, A, B);
    else {
      var b = J(M);
      !b && !M.corked && !M.bufferProcessing && M.bufferedRequest && _e(S, M), p ? n(he, S, M, b, B) : he(S, M, b, B);
    }
  }
  function he(S, A, M, p) {
    M || oe(S, A), A.pendingcb--, p(), c(S, A);
  }
  function oe(S, A) {
    A.length === 0 && A.needDrain && (A.needDrain = !1, S.emit("drain"));
  }
  function _e(S, A) {
    A.bufferProcessing = !0;
    var M = A.bufferedRequest;
    if (S._writev && M && M.next) {
      var p = A.bufferedRequestCount, B = new Array(p), b = A.corkedRequestsFree;
      b.entry = M;
      for (var k = 0, Z = !0; M; )
        B[k] = M, M.isBuf || (Z = !1), M = M.next, k += 1;
      B.allBuffers = Z, ee(S, A, !0, A.length, B, "", b.finish), A.pendingcb++, A.lastBufferedRequest = null, b.next ? (A.corkedRequestsFree = b.next, b.next = null) : A.corkedRequestsFree = new e(A), A.bufferedRequestCount = 0;
    } else {
      for (; M; ) {
        var te = M.chunk, V = M.encoding, T = M.callback, O = A.objectMode ? 1 : te.length;
        if (ee(S, A, !1, O, te, V, T), M = M.next, A.bufferedRequestCount--, A.writing)
          break;
      }
      M === null && (A.lastBufferedRequest = null);
    }
    A.bufferedRequest = M, A.bufferProcessing = !1;
  }
  H.prototype._write = function(S, A, M) {
    M(new Error("_write() is not implemented"));
  }, H.prototype._writev = null, H.prototype.end = function(S, A, M) {
    var p = this._writableState;
    typeof S == "function" ? (M = S, S = null, A = null) : typeof A == "function" && (M = A, A = null), S != null && this.write(S, A), p.corked && (p.corked = 1, this.uncork()), p.ending || v(this, p, M);
  };
  function J(S) {
    return S.ending && S.length === 0 && S.bufferedRequest === null && !S.finished && !S.writing;
  }
  function w(S, A) {
    S._final(function(M) {
      A.pendingcb--, M && S.emit("error", M), A.prefinished = !0, S.emit("prefinish"), c(S, A);
    });
  }
  function m(S, A) {
    !A.prefinished && !A.finalCalled && (typeof S._final == "function" ? (A.pendingcb++, A.finalCalled = !0, t.nextTick(w, S, A)) : (A.prefinished = !0, S.emit("prefinish")));
  }
  function c(S, A) {
    var M = J(A);
    return M && (m(S, A), A.pendingcb === 0 && (A.finished = !0, S.emit("finish"))), M;
  }
  function v(S, A, M) {
    A.ending = !0, c(S, A), M && (A.finished ? t.nextTick(M) : S.once("finish", M)), A.ended = !0, S.writable = !1;
  }
  function $(S, A, M) {
    var p = S.entry;
    for (S.entry = null; p; ) {
      var B = p.callback;
      A.pendingcb--, B(M), p = p.next;
    }
    A.corkedRequestsFree.next = S;
  }
  return Object.defineProperty(H.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(S) {
      this._writableState && (this._writableState.destroyed = S);
    }
  }), H.prototype.destroy = x.destroy, H.prototype._undestroy = x.undestroy, H.prototype._destroy = function(S, A) {
    this.end(), A(S);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var t = processNextickArgsExports, e = Object.keys || function(x) {
    var C = [];
    for (var D in x)
      C.push(D);
    return C;
  };
  _stream_duplex = _;
  var n = Object.create(util$2);
  n.inherits = inherits_browserExports;
  var a = require_stream_readable(), u = require_stream_writable();
  n.inherits(_, a);
  for (var o = e(u.prototype), d = 0; d < o.length; d++) {
    var l = o[d];
    _.prototype[l] || (_.prototype[l] = u.prototype[l]);
  }
  function _(x) {
    if (!(this instanceof _)) return new _(x);
    a.call(this, x), u.call(this, x), x && x.readable === !1 && (this.readable = !1), x && x.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, x && x.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", P);
  }
  Object.defineProperty(_.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function P() {
    this.allowHalfOpen || this._writableState.ended || t.nextTick(h, this);
  }
  function h(x) {
    x.end();
  }
  return Object.defineProperty(_.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(x) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = x, this._writableState.destroyed = x);
    }
  }), _.prototype._destroy = function(x, C) {
    this.push(null), this.end(), t.nextTick(C, x);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var t = processNextickArgsExports;
  _stream_readable = F;
  var e = isarray, n;
  F.ReadableState = z, eventsExports.EventEmitter;
  var a = function(T, O) {
    return T.listeners(O).length;
  }, u = streamBrowser, o = safeBufferExports.Buffer, d = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function l(T) {
    return o.from(T);
  }
  function _(T) {
    return o.isBuffer(T) || T instanceof d;
  }
  var P = Object.create(util$2);
  P.inherits = inherits_browserExports;
  var h = util$3, x = void 0;
  h && h.debuglog ? x = h.debuglog("stream") : x = function() {
  };
  var C = requireBufferList(), D = destroy_1, q;
  P.inherits(F, u);
  var H = ["error", "close", "destroy", "pause", "resume"];
  function Y(T, O, Q) {
    if (typeof T.prependListener == "function") return T.prependListener(O, Q);
    !T._events || !T._events[O] ? T.on(O, Q) : e(T._events[O]) ? T._events[O].unshift(Q) : T._events[O] = [Q, T._events[O]];
  }
  function z(T, O) {
    n = n || require_stream_duplex(), T = T || {};
    var Q = O instanceof n;
    this.objectMode = !!T.objectMode, Q && (this.objectMode = this.objectMode || !!T.readableObjectMode);
    var ie = T.highWaterMark, L = T.readableHighWaterMark, j = this.objectMode ? 16 : 16 * 1024;
    ie || ie === 0 ? this.highWaterMark = ie : Q && (L || L === 0) ? this.highWaterMark = L : this.highWaterMark = j, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new C(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = T.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, T.encoding && (q || (q = string_decoder.StringDecoder), this.decoder = new q(T.encoding), this.encoding = T.encoding);
  }
  function F(T) {
    if (n = n || require_stream_duplex(), !(this instanceof F)) return new F(T);
    this._readableState = new z(T, this), this.readable = !0, T && (typeof T.read == "function" && (this._read = T.read), typeof T.destroy == "function" && (this._destroy = T.destroy)), u.call(this);
  }
  Object.defineProperty(F.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(T) {
      this._readableState && (this._readableState.destroyed = T);
    }
  }), F.prototype.destroy = D.destroy, F.prototype._undestroy = D.undestroy, F.prototype._destroy = function(T, O) {
    this.push(null), O(T);
  }, F.prototype.push = function(T, O) {
    var Q = this._readableState, ie;
    return Q.objectMode ? ie = !0 : typeof T == "string" && (O = O || Q.defaultEncoding, O !== Q.encoding && (T = o.from(T, O), O = ""), ie = !0), X(this, T, O, !1, ie);
  }, F.prototype.unshift = function(T) {
    return X(this, T, null, !0, !1);
  };
  function X(T, O, Q, ie, L) {
    var j = T._readableState;
    if (O === null)
      j.reading = !1, _e(T, j);
    else {
      var ne;
      L || (ne = se(j, O)), ne ? T.emit("error", ne) : j.objectMode || O && O.length > 0 ? (typeof O != "string" && !j.objectMode && Object.getPrototypeOf(O) !== o.prototype && (O = l(O)), ie ? j.endEmitted ? T.emit("error", new Error("stream.unshift() after end event")) : ee(T, j, O, !0) : j.ended ? T.emit("error", new Error("stream.push() after EOF")) : (j.reading = !1, j.decoder && !Q ? (O = j.decoder.write(O), j.objectMode || O.length !== 0 ? ee(T, j, O, !1) : m(T, j)) : ee(T, j, O, !1))) : ie || (j.reading = !1);
    }
    return ce(j);
  }
  function ee(T, O, Q, ie) {
    O.flowing && O.length === 0 && !O.sync ? (T.emit("data", Q), T.read(0)) : (O.length += O.objectMode ? 1 : Q.length, ie ? O.buffer.unshift(Q) : O.buffer.push(Q), O.needReadable && J(T)), m(T, O);
  }
  function se(T, O) {
    var Q;
    return !_(O) && typeof O != "string" && O !== void 0 && !T.objectMode && (Q = new TypeError("Invalid non-string/buffer chunk")), Q;
  }
  function ce(T) {
    return !T.ended && (T.needReadable || T.length < T.highWaterMark || T.length === 0);
  }
  F.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, F.prototype.setEncoding = function(T) {
    return q || (q = string_decoder.StringDecoder), this._readableState.decoder = new q(T), this._readableState.encoding = T, this;
  };
  var le = 8388608;
  function he(T) {
    return T >= le ? T = le : (T--, T |= T >>> 1, T |= T >>> 2, T |= T >>> 4, T |= T >>> 8, T |= T >>> 16, T++), T;
  }
  function oe(T, O) {
    return T <= 0 || O.length === 0 && O.ended ? 0 : O.objectMode ? 1 : T !== T ? O.flowing && O.length ? O.buffer.head.data.length : O.length : (T > O.highWaterMark && (O.highWaterMark = he(T)), T <= O.length ? T : O.ended ? O.length : (O.needReadable = !0, 0));
  }
  F.prototype.read = function(T) {
    x("read", T), T = parseInt(T, 10);
    var O = this._readableState, Q = T;
    if (T !== 0 && (O.emittedReadable = !1), T === 0 && O.needReadable && (O.length >= O.highWaterMark || O.ended))
      return x("read: emitReadable", O.length, O.ended), O.length === 0 && O.ended ? Z(this) : J(this), null;
    if (T = oe(T, O), T === 0 && O.ended)
      return O.length === 0 && Z(this), null;
    var ie = O.needReadable;
    x("need readable", ie), (O.length === 0 || O.length - T < O.highWaterMark) && (ie = !0, x("length less than watermark", ie)), O.ended || O.reading ? (ie = !1, x("reading or ended", ie)) : ie && (x("do read"), O.reading = !0, O.sync = !0, O.length === 0 && (O.needReadable = !0), this._read(O.highWaterMark), O.sync = !1, O.reading || (T = oe(Q, O)));
    var L;
    return T > 0 ? L = p(T, O) : L = null, L === null ? (O.needReadable = !0, T = 0) : O.length -= T, O.length === 0 && (O.ended || (O.needReadable = !0), Q !== T && O.ended && Z(this)), L !== null && this.emit("data", L), L;
  };
  function _e(T, O) {
    if (!O.ended) {
      if (O.decoder) {
        var Q = O.decoder.end();
        Q && Q.length && (O.buffer.push(Q), O.length += O.objectMode ? 1 : Q.length);
      }
      O.ended = !0, J(T);
    }
  }
  function J(T) {
    var O = T._readableState;
    O.needReadable = !1, O.emittedReadable || (x("emitReadable", O.flowing), O.emittedReadable = !0, O.sync ? t.nextTick(w, T) : w(T));
  }
  function w(T) {
    x("emit readable"), T.emit("readable"), M(T);
  }
  function m(T, O) {
    O.readingMore || (O.readingMore = !0, t.nextTick(c, T, O));
  }
  function c(T, O) {
    for (var Q = O.length; !O.reading && !O.flowing && !O.ended && O.length < O.highWaterMark && (x("maybeReadMore read 0"), T.read(0), Q !== O.length); )
      Q = O.length;
    O.readingMore = !1;
  }
  F.prototype._read = function(T) {
    this.emit("error", new Error("_read() is not implemented"));
  }, F.prototype.pipe = function(T, O) {
    var Q = this, ie = this._readableState;
    switch (ie.pipesCount) {
      case 0:
        ie.pipes = T;
        break;
      case 1:
        ie.pipes = [ie.pipes, T];
        break;
      default:
        ie.pipes.push(T);
        break;
    }
    ie.pipesCount += 1, x("pipe count=%d opts=%j", ie.pipesCount, O);
    var L = (!O || O.end !== !1) && T !== process$1.stdout && T !== process$1.stderr, j = L ? de : Ne;
    ie.endEmitted ? t.nextTick(j) : Q.once("end", j), T.on("unpipe", ne);
    function ne(ge, Me) {
      x("onunpipe"), ge === Q && Me && Me.hasUnpiped === !1 && (Me.hasUnpiped = !0, me());
    }
    function de() {
      x("onend"), T.end();
    }
    var pe = v(Q);
    T.on("drain", pe);
    var be = !1;
    function me() {
      x("cleanup"), T.removeListener("close", xe), T.removeListener("finish", je), T.removeListener("drain", pe), T.removeListener("error", Oe), T.removeListener("unpipe", ne), Q.removeListener("end", de), Q.removeListener("end", Ne), Q.removeListener("data", ue), be = !0, ie.awaitDrain && (!T._writableState || T._writableState.needDrain) && pe();
    }
    var we = !1;
    Q.on("data", ue);
    function ue(ge) {
      x("ondata"), we = !1;
      var Me = T.write(ge);
      Me === !1 && !we && ((ie.pipesCount === 1 && ie.pipes === T || ie.pipesCount > 1 && V(ie.pipes, T) !== -1) && !be && (x("false write response, pause", ie.awaitDrain), ie.awaitDrain++, we = !0), Q.pause());
    }
    function Oe(ge) {
      x("onerror", ge), Ne(), T.removeListener("error", Oe), a(T, "error") === 0 && T.emit("error", ge);
    }
    Y(T, "error", Oe);
    function xe() {
      T.removeListener("finish", je), Ne();
    }
    T.once("close", xe);
    function je() {
      x("onfinish"), T.removeListener("close", xe), Ne();
    }
    T.once("finish", je);
    function Ne() {
      x("unpipe"), Q.unpipe(T);
    }
    return T.emit("pipe", Q), ie.flowing || (x("pipe resume"), Q.resume()), T;
  };
  function v(T) {
    return function() {
      var O = T._readableState;
      x("pipeOnDrain", O.awaitDrain), O.awaitDrain && O.awaitDrain--, O.awaitDrain === 0 && a(T, "data") && (O.flowing = !0, M(T));
    };
  }
  F.prototype.unpipe = function(T) {
    var O = this._readableState, Q = { hasUnpiped: !1 };
    if (O.pipesCount === 0) return this;
    if (O.pipesCount === 1)
      return T && T !== O.pipes ? this : (T || (T = O.pipes), O.pipes = null, O.pipesCount = 0, O.flowing = !1, T && T.emit("unpipe", this, Q), this);
    if (!T) {
      var ie = O.pipes, L = O.pipesCount;
      O.pipes = null, O.pipesCount = 0, O.flowing = !1;
      for (var j = 0; j < L; j++)
        ie[j].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var ne = V(O.pipes, T);
    return ne === -1 ? this : (O.pipes.splice(ne, 1), O.pipesCount -= 1, O.pipesCount === 1 && (O.pipes = O.pipes[0]), T.emit("unpipe", this, Q), this);
  }, F.prototype.on = function(T, O) {
    var Q = u.prototype.on.call(this, T, O);
    if (T === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (T === "readable") {
      var ie = this._readableState;
      !ie.endEmitted && !ie.readableListening && (ie.readableListening = ie.needReadable = !0, ie.emittedReadable = !1, ie.reading ? ie.length && J(this) : t.nextTick($, this));
    }
    return Q;
  }, F.prototype.addListener = F.prototype.on;
  function $(T) {
    x("readable nexttick read 0"), T.read(0);
  }
  F.prototype.resume = function() {
    var T = this._readableState;
    return T.flowing || (x("resume"), T.flowing = !0, S(this, T)), this;
  };
  function S(T, O) {
    O.resumeScheduled || (O.resumeScheduled = !0, t.nextTick(A, T, O));
  }
  function A(T, O) {
    O.reading || (x("resume read 0"), T.read(0)), O.resumeScheduled = !1, O.awaitDrain = 0, T.emit("resume"), M(T), O.flowing && !O.reading && T.read(0);
  }
  F.prototype.pause = function() {
    return x("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (x("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function M(T) {
    var O = T._readableState;
    for (x("flow", O.flowing); O.flowing && T.read() !== null; )
      ;
  }
  F.prototype.wrap = function(T) {
    var O = this, Q = this._readableState, ie = !1;
    T.on("end", function() {
      if (x("wrapped end"), Q.decoder && !Q.ended) {
        var ne = Q.decoder.end();
        ne && ne.length && O.push(ne);
      }
      O.push(null);
    }), T.on("data", function(ne) {
      if (x("wrapped data"), Q.decoder && (ne = Q.decoder.write(ne)), !(Q.objectMode && ne == null) && !(!Q.objectMode && (!ne || !ne.length))) {
        var de = O.push(ne);
        de || (ie = !0, T.pause());
      }
    });
    for (var L in T)
      this[L] === void 0 && typeof T[L] == "function" && (this[L] = /* @__PURE__ */ function(ne) {
        return function() {
          return T[ne].apply(T, arguments);
        };
      }(L));
    for (var j = 0; j < H.length; j++)
      T.on(H[j], this.emit.bind(this, H[j]));
    return this._read = function(ne) {
      x("wrapped _read", ne), ie && (ie = !1, T.resume());
    }, this;
  }, Object.defineProperty(F.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), F._fromList = p;
  function p(T, O) {
    if (O.length === 0) return null;
    var Q;
    return O.objectMode ? Q = O.buffer.shift() : !T || T >= O.length ? (O.decoder ? Q = O.buffer.join("") : O.buffer.length === 1 ? Q = O.buffer.head.data : Q = O.buffer.concat(O.length), O.buffer.clear()) : Q = B(T, O.buffer, O.decoder), Q;
  }
  function B(T, O, Q) {
    var ie;
    return T < O.head.data.length ? (ie = O.head.data.slice(0, T), O.head.data = O.head.data.slice(T)) : T === O.head.data.length ? ie = O.shift() : ie = Q ? b(T, O) : k(T, O), ie;
  }
  function b(T, O) {
    var Q = O.head, ie = 1, L = Q.data;
    for (T -= L.length; Q = Q.next; ) {
      var j = Q.data, ne = T > j.length ? j.length : T;
      if (ne === j.length ? L += j : L += j.slice(0, T), T -= ne, T === 0) {
        ne === j.length ? (++ie, Q.next ? O.head = Q.next : O.head = O.tail = null) : (O.head = Q, Q.data = j.slice(ne));
        break;
      }
      ++ie;
    }
    return O.length -= ie, L;
  }
  function k(T, O) {
    var Q = o.allocUnsafe(T), ie = O.head, L = 1;
    for (ie.data.copy(Q), T -= ie.data.length; ie = ie.next; ) {
      var j = ie.data, ne = T > j.length ? j.length : T;
      if (j.copy(Q, Q.length - T, 0, ne), T -= ne, T === 0) {
        ne === j.length ? (++L, ie.next ? O.head = ie.next : O.head = O.tail = null) : (O.head = ie, ie.data = j.slice(ne));
        break;
      }
      ++L;
    }
    return O.length -= L, Q;
  }
  function Z(T) {
    var O = T._readableState;
    if (O.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    O.endEmitted || (O.ended = !0, t.nextTick(te, O, T));
  }
  function te(T, O) {
    !T.endEmitted && T.length === 0 && (T.endEmitted = !0, O.readable = !1, O.emit("end"));
  }
  function V(T, O) {
    for (var Q = 0, ie = T.length; Q < ie; Q++)
      if (T[Q] === O) return Q;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$1, Duplex = require_stream_duplex(), util$1 = Object.create(util$2);
util$1.inherits = inherits_browserExports;
util$1.inherits(Transform$1, Duplex);
function afterTransform(t, e) {
  var n = this._transformState;
  n.transforming = !1;
  var a = n.writecb;
  if (!a)
    return this.emit("error", new Error("write callback called multiple times"));
  n.writechunk = null, n.writecb = null, e != null && this.push(e), a(t);
  var u = this._readableState;
  u.reading = !1, (u.needReadable || u.length < u.highWaterMark) && this._read(u.highWaterMark);
}
function Transform$1(t) {
  if (!(this instanceof Transform$1)) return new Transform$1(t);
  Duplex.call(this, t), this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", prefinish);
}
function prefinish() {
  var t = this;
  typeof this._flush == "function" ? this._flush(function(e, n) {
    done(t, e, n);
  }) : done(this, null, null);
}
Transform$1.prototype.push = function(t, e) {
  return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, t, e);
};
Transform$1.prototype._transform = function(t, e, n) {
  throw new Error("_transform() is not implemented");
};
Transform$1.prototype._write = function(t, e, n) {
  var a = this._transformState;
  if (a.writecb = n, a.writechunk = t, a.writeencoding = e, !a.transforming) {
    var u = this._readableState;
    (a.needTransform || u.needReadable || u.length < u.highWaterMark) && this._read(u.highWaterMark);
  }
};
Transform$1.prototype._read = function(t) {
  var e = this._transformState;
  e.writechunk !== null && e.writecb && !e.transforming ? (e.transforming = !0, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = !0;
};
Transform$1.prototype._destroy = function(t, e) {
  var n = this;
  Duplex.prototype._destroy.call(this, t, function(a) {
    e(a), n.emit("close");
  });
};
function done(t, e, n) {
  if (e) return t.emit("error", e);
  if (n != null && t.push(n), t._writableState.length) throw new Error("Calling transform done when ws.length != 0");
  if (t._transformState.transforming) throw new Error("Calling transform done when still transforming");
  return t.push(null);
}
var _stream_passthrough = PassThrough, Transform = _stream_transform, util = Object.create(util$2);
util.inherits = inherits_browserExports;
util.inherits(PassThrough, Transform);
function PassThrough(t) {
  if (!(this instanceof PassThrough)) return new PassThrough(t);
  Transform.call(this, t);
}
PassThrough.prototype._transform = function(t, e, n) {
  n(null, t);
};
readableBrowser.exports;
(function(t, e) {
  e = t.exports = require_stream_readable(), e.Stream = e, e.Readable = e, e.Writable = require_stream_writable(), e.Duplex = require_stream_duplex(), e.Transform = _stream_transform, e.PassThrough = _stream_passthrough;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports, sign = { exports: {} }, bn = { exports: {} };
bn.exports;
(function(t) {
  (function(e, n) {
    function a(m, c) {
      if (!m) throw new Error(c || "Assertion failed");
    }
    function u(m, c) {
      m.super_ = c;
      var v = function() {
      };
      v.prototype = c.prototype, m.prototype = new v(), m.prototype.constructor = m;
    }
    function o(m, c, v) {
      if (o.isBN(m))
        return m;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, m !== null && ((c === "le" || c === "be") && (v = c, c = 10), this._init(m || 0, c || 10, v || "be"));
    }
    typeof e == "object" ? e.exports = o : n.BN = o, o.BN = o, o.wordSize = 26;
    var d;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? d = window.Buffer : d = require$$1$2.Buffer;
    } catch {
    }
    o.isBN = function(c) {
      return c instanceof o ? !0 : c !== null && typeof c == "object" && c.constructor.wordSize === o.wordSize && Array.isArray(c.words);
    }, o.max = function(c, v) {
      return c.cmp(v) > 0 ? c : v;
    }, o.min = function(c, v) {
      return c.cmp(v) < 0 ? c : v;
    }, o.prototype._init = function(c, v, $) {
      if (typeof c == "number")
        return this._initNumber(c, v, $);
      if (typeof c == "object")
        return this._initArray(c, v, $);
      v === "hex" && (v = 16), a(v === (v | 0) && v >= 2 && v <= 36), c = c.toString().replace(/\s+/g, "");
      var S = 0;
      c[0] === "-" && (S++, this.negative = 1), S < c.length && (v === 16 ? this._parseHex(c, S, $) : (this._parseBase(c, v, S), $ === "le" && this._initArray(this.toArray(), v, $)));
    }, o.prototype._initNumber = function(c, v, $) {
      c < 0 && (this.negative = 1, c = -c), c < 67108864 ? (this.words = [c & 67108863], this.length = 1) : c < 4503599627370496 ? (this.words = [
        c & 67108863,
        c / 67108864 & 67108863
      ], this.length = 2) : (a(c < 9007199254740992), this.words = [
        c & 67108863,
        c / 67108864 & 67108863,
        1
      ], this.length = 3), $ === "le" && this._initArray(this.toArray(), v, $);
    }, o.prototype._initArray = function(c, v, $) {
      if (a(typeof c.length == "number"), c.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(c.length / 3), this.words = new Array(this.length);
      for (var S = 0; S < this.length; S++)
        this.words[S] = 0;
      var A, M, p = 0;
      if ($ === "be")
        for (S = c.length - 1, A = 0; S >= 0; S -= 3)
          M = c[S] | c[S - 1] << 8 | c[S - 2] << 16, this.words[A] |= M << p & 67108863, this.words[A + 1] = M >>> 26 - p & 67108863, p += 24, p >= 26 && (p -= 26, A++);
      else if ($ === "le")
        for (S = 0, A = 0; S < c.length; S += 3)
          M = c[S] | c[S + 1] << 8 | c[S + 2] << 16, this.words[A] |= M << p & 67108863, this.words[A + 1] = M >>> 26 - p & 67108863, p += 24, p >= 26 && (p -= 26, A++);
      return this._strip();
    };
    function l(m, c) {
      var v = m.charCodeAt(c);
      if (v >= 48 && v <= 57)
        return v - 48;
      if (v >= 65 && v <= 70)
        return v - 55;
      if (v >= 97 && v <= 102)
        return v - 87;
      a(!1, "Invalid character in " + m);
    }
    function _(m, c, v) {
      var $ = l(m, v);
      return v - 1 >= c && ($ |= l(m, v - 1) << 4), $;
    }
    o.prototype._parseHex = function(c, v, $) {
      this.length = Math.ceil((c.length - v) / 6), this.words = new Array(this.length);
      for (var S = 0; S < this.length; S++)
        this.words[S] = 0;
      var A = 0, M = 0, p;
      if ($ === "be")
        for (S = c.length - 1; S >= v; S -= 2)
          p = _(c, v, S) << A, this.words[M] |= p & 67108863, A >= 18 ? (A -= 18, M += 1, this.words[M] |= p >>> 26) : A += 8;
      else {
        var B = c.length - v;
        for (S = B % 2 === 0 ? v + 1 : v; S < c.length; S += 2)
          p = _(c, v, S) << A, this.words[M] |= p & 67108863, A >= 18 ? (A -= 18, M += 1, this.words[M] |= p >>> 26) : A += 8;
      }
      this._strip();
    };
    function P(m, c, v, $) {
      for (var S = 0, A = 0, M = Math.min(m.length, v), p = c; p < M; p++) {
        var B = m.charCodeAt(p) - 48;
        S *= $, B >= 49 ? A = B - 49 + 10 : B >= 17 ? A = B - 17 + 10 : A = B, a(B >= 0 && A < $, "Invalid character"), S += A;
      }
      return S;
    }
    o.prototype._parseBase = function(c, v, $) {
      this.words = [0], this.length = 1;
      for (var S = 0, A = 1; A <= 67108863; A *= v)
        S++;
      S--, A = A / v | 0;
      for (var M = c.length - $, p = M % S, B = Math.min(M, M - p) + $, b = 0, k = $; k < B; k += S)
        b = P(c, k, k + S, v), this.imuln(A), this.words[0] + b < 67108864 ? this.words[0] += b : this._iaddn(b);
      if (p !== 0) {
        var Z = 1;
        for (b = P(c, k, c.length, v), k = 0; k < p; k++)
          Z *= v;
        this.imuln(Z), this.words[0] + b < 67108864 ? this.words[0] += b : this._iaddn(b);
      }
      this._strip();
    }, o.prototype.copy = function(c) {
      c.words = new Array(this.length);
      for (var v = 0; v < this.length; v++)
        c.words[v] = this.words[v];
      c.length = this.length, c.negative = this.negative, c.red = this.red;
    };
    function h(m, c) {
      m.words = c.words, m.length = c.length, m.negative = c.negative, m.red = c.red;
    }
    if (o.prototype._move = function(c) {
      h(c, this);
    }, o.prototype.clone = function() {
      var c = new o(null);
      return this.copy(c), c;
    }, o.prototype._expand = function(c) {
      for (; this.length < c; )
        this.words[this.length++] = 0;
      return this;
    }, o.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, o.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        o.prototype[Symbol.for("nodejs.util.inspect.custom")] = x;
      } catch {
        o.prototype.inspect = x;
      }
    else
      o.prototype.inspect = x;
    function x() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var C = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], D = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], q = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    o.prototype.toString = function(c, v) {
      c = c || 10, v = v | 0 || 1;
      var $;
      if (c === 16 || c === "hex") {
        $ = "";
        for (var S = 0, A = 0, M = 0; M < this.length; M++) {
          var p = this.words[M], B = ((p << S | A) & 16777215).toString(16);
          A = p >>> 24 - S & 16777215, S += 2, S >= 26 && (S -= 26, M--), A !== 0 || M !== this.length - 1 ? $ = C[6 - B.length] + B + $ : $ = B + $;
        }
        for (A !== 0 && ($ = A.toString(16) + $); $.length % v !== 0; )
          $ = "0" + $;
        return this.negative !== 0 && ($ = "-" + $), $;
      }
      if (c === (c | 0) && c >= 2 && c <= 36) {
        var b = D[c], k = q[c];
        $ = "";
        var Z = this.clone();
        for (Z.negative = 0; !Z.isZero(); ) {
          var te = Z.modrn(k).toString(c);
          Z = Z.idivn(k), Z.isZero() ? $ = te + $ : $ = C[b - te.length] + te + $;
        }
        for (this.isZero() && ($ = "0" + $); $.length % v !== 0; )
          $ = "0" + $;
        return this.negative !== 0 && ($ = "-" + $), $;
      }
      a(!1, "Base should be between 2 and 36");
    }, o.prototype.toNumber = function() {
      var c = this.words[0];
      return this.length === 2 ? c += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? c += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && a(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -c : c;
    }, o.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, d && (o.prototype.toBuffer = function(c, v) {
      return this.toArrayLike(d, c, v);
    }), o.prototype.toArray = function(c, v) {
      return this.toArrayLike(Array, c, v);
    };
    var H = function(c, v) {
      return c.allocUnsafe ? c.allocUnsafe(v) : new c(v);
    };
    o.prototype.toArrayLike = function(c, v, $) {
      this._strip();
      var S = this.byteLength(), A = $ || Math.max(1, S);
      a(S <= A, "byte array longer than desired length"), a(A > 0, "Requested array length <= 0");
      var M = H(c, A), p = v === "le" ? "LE" : "BE";
      return this["_toArrayLike" + p](M, S), M;
    }, o.prototype._toArrayLikeLE = function(c, v) {
      for (var $ = 0, S = 0, A = 0, M = 0; A < this.length; A++) {
        var p = this.words[A] << M | S;
        c[$++] = p & 255, $ < c.length && (c[$++] = p >> 8 & 255), $ < c.length && (c[$++] = p >> 16 & 255), M === 6 ? ($ < c.length && (c[$++] = p >> 24 & 255), S = 0, M = 0) : (S = p >>> 24, M += 2);
      }
      if ($ < c.length)
        for (c[$++] = S; $ < c.length; )
          c[$++] = 0;
    }, o.prototype._toArrayLikeBE = function(c, v) {
      for (var $ = c.length - 1, S = 0, A = 0, M = 0; A < this.length; A++) {
        var p = this.words[A] << M | S;
        c[$--] = p & 255, $ >= 0 && (c[$--] = p >> 8 & 255), $ >= 0 && (c[$--] = p >> 16 & 255), M === 6 ? ($ >= 0 && (c[$--] = p >> 24 & 255), S = 0, M = 0) : (S = p >>> 24, M += 2);
      }
      if ($ >= 0)
        for (c[$--] = S; $ >= 0; )
          c[$--] = 0;
    }, Math.clz32 ? o.prototype._countBits = function(c) {
      return 32 - Math.clz32(c);
    } : o.prototype._countBits = function(c) {
      var v = c, $ = 0;
      return v >= 4096 && ($ += 13, v >>>= 13), v >= 64 && ($ += 7, v >>>= 7), v >= 8 && ($ += 4, v >>>= 4), v >= 2 && ($ += 2, v >>>= 2), $ + v;
    }, o.prototype._zeroBits = function(c) {
      if (c === 0) return 26;
      var v = c, $ = 0;
      return v & 8191 || ($ += 13, v >>>= 13), v & 127 || ($ += 7, v >>>= 7), v & 15 || ($ += 4, v >>>= 4), v & 3 || ($ += 2, v >>>= 2), v & 1 || $++, $;
    }, o.prototype.bitLength = function() {
      var c = this.words[this.length - 1], v = this._countBits(c);
      return (this.length - 1) * 26 + v;
    };
    function Y(m) {
      for (var c = new Array(m.bitLength()), v = 0; v < c.length; v++) {
        var $ = v / 26 | 0, S = v % 26;
        c[v] = m.words[$] >>> S & 1;
      }
      return c;
    }
    o.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var c = 0, v = 0; v < this.length; v++) {
        var $ = this._zeroBits(this.words[v]);
        if (c += $, $ !== 26) break;
      }
      return c;
    }, o.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, o.prototype.toTwos = function(c) {
      return this.negative !== 0 ? this.abs().inotn(c).iaddn(1) : this.clone();
    }, o.prototype.fromTwos = function(c) {
      return this.testn(c - 1) ? this.notn(c).iaddn(1).ineg() : this.clone();
    }, o.prototype.isNeg = function() {
      return this.negative !== 0;
    }, o.prototype.neg = function() {
      return this.clone().ineg();
    }, o.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, o.prototype.iuor = function(c) {
      for (; this.length < c.length; )
        this.words[this.length++] = 0;
      for (var v = 0; v < c.length; v++)
        this.words[v] = this.words[v] | c.words[v];
      return this._strip();
    }, o.prototype.ior = function(c) {
      return a((this.negative | c.negative) === 0), this.iuor(c);
    }, o.prototype.or = function(c) {
      return this.length > c.length ? this.clone().ior(c) : c.clone().ior(this);
    }, o.prototype.uor = function(c) {
      return this.length > c.length ? this.clone().iuor(c) : c.clone().iuor(this);
    }, o.prototype.iuand = function(c) {
      var v;
      this.length > c.length ? v = c : v = this;
      for (var $ = 0; $ < v.length; $++)
        this.words[$] = this.words[$] & c.words[$];
      return this.length = v.length, this._strip();
    }, o.prototype.iand = function(c) {
      return a((this.negative | c.negative) === 0), this.iuand(c);
    }, o.prototype.and = function(c) {
      return this.length > c.length ? this.clone().iand(c) : c.clone().iand(this);
    }, o.prototype.uand = function(c) {
      return this.length > c.length ? this.clone().iuand(c) : c.clone().iuand(this);
    }, o.prototype.iuxor = function(c) {
      var v, $;
      this.length > c.length ? (v = this, $ = c) : (v = c, $ = this);
      for (var S = 0; S < $.length; S++)
        this.words[S] = v.words[S] ^ $.words[S];
      if (this !== v)
        for (; S < v.length; S++)
          this.words[S] = v.words[S];
      return this.length = v.length, this._strip();
    }, o.prototype.ixor = function(c) {
      return a((this.negative | c.negative) === 0), this.iuxor(c);
    }, o.prototype.xor = function(c) {
      return this.length > c.length ? this.clone().ixor(c) : c.clone().ixor(this);
    }, o.prototype.uxor = function(c) {
      return this.length > c.length ? this.clone().iuxor(c) : c.clone().iuxor(this);
    }, o.prototype.inotn = function(c) {
      a(typeof c == "number" && c >= 0);
      var v = Math.ceil(c / 26) | 0, $ = c % 26;
      this._expand(v), $ > 0 && v--;
      for (var S = 0; S < v; S++)
        this.words[S] = ~this.words[S] & 67108863;
      return $ > 0 && (this.words[S] = ~this.words[S] & 67108863 >> 26 - $), this._strip();
    }, o.prototype.notn = function(c) {
      return this.clone().inotn(c);
    }, o.prototype.setn = function(c, v) {
      a(typeof c == "number" && c >= 0);
      var $ = c / 26 | 0, S = c % 26;
      return this._expand($ + 1), v ? this.words[$] = this.words[$] | 1 << S : this.words[$] = this.words[$] & ~(1 << S), this._strip();
    }, o.prototype.iadd = function(c) {
      var v;
      if (this.negative !== 0 && c.negative === 0)
        return this.negative = 0, v = this.isub(c), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && c.negative !== 0)
        return c.negative = 0, v = this.isub(c), c.negative = 1, v._normSign();
      var $, S;
      this.length > c.length ? ($ = this, S = c) : ($ = c, S = this);
      for (var A = 0, M = 0; M < S.length; M++)
        v = ($.words[M] | 0) + (S.words[M] | 0) + A, this.words[M] = v & 67108863, A = v >>> 26;
      for (; A !== 0 && M < $.length; M++)
        v = ($.words[M] | 0) + A, this.words[M] = v & 67108863, A = v >>> 26;
      if (this.length = $.length, A !== 0)
        this.words[this.length] = A, this.length++;
      else if ($ !== this)
        for (; M < $.length; M++)
          this.words[M] = $.words[M];
      return this;
    }, o.prototype.add = function(c) {
      var v;
      return c.negative !== 0 && this.negative === 0 ? (c.negative = 0, v = this.sub(c), c.negative ^= 1, v) : c.negative === 0 && this.negative !== 0 ? (this.negative = 0, v = c.sub(this), this.negative = 1, v) : this.length > c.length ? this.clone().iadd(c) : c.clone().iadd(this);
    }, o.prototype.isub = function(c) {
      if (c.negative !== 0) {
        c.negative = 0;
        var v = this.iadd(c);
        return c.negative = 1, v._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(c), this.negative = 1, this._normSign();
      var $ = this.cmp(c);
      if ($ === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var S, A;
      $ > 0 ? (S = this, A = c) : (S = c, A = this);
      for (var M = 0, p = 0; p < A.length; p++)
        v = (S.words[p] | 0) - (A.words[p] | 0) + M, M = v >> 26, this.words[p] = v & 67108863;
      for (; M !== 0 && p < S.length; p++)
        v = (S.words[p] | 0) + M, M = v >> 26, this.words[p] = v & 67108863;
      if (M === 0 && p < S.length && S !== this)
        for (; p < S.length; p++)
          this.words[p] = S.words[p];
      return this.length = Math.max(this.length, p), S !== this && (this.negative = 1), this._strip();
    }, o.prototype.sub = function(c) {
      return this.clone().isub(c);
    };
    function z(m, c, v) {
      v.negative = c.negative ^ m.negative;
      var $ = m.length + c.length | 0;
      v.length = $, $ = $ - 1 | 0;
      var S = m.words[0] | 0, A = c.words[0] | 0, M = S * A, p = M & 67108863, B = M / 67108864 | 0;
      v.words[0] = p;
      for (var b = 1; b < $; b++) {
        for (var k = B >>> 26, Z = B & 67108863, te = Math.min(b, c.length - 1), V = Math.max(0, b - m.length + 1); V <= te; V++) {
          var T = b - V | 0;
          S = m.words[T] | 0, A = c.words[V] | 0, M = S * A + Z, k += M / 67108864 | 0, Z = M & 67108863;
        }
        v.words[b] = Z | 0, B = k | 0;
      }
      return B !== 0 ? v.words[b] = B | 0 : v.length--, v._strip();
    }
    var F = function(c, v, $) {
      var S = c.words, A = v.words, M = $.words, p = 0, B, b, k, Z = S[0] | 0, te = Z & 8191, V = Z >>> 13, T = S[1] | 0, O = T & 8191, Q = T >>> 13, ie = S[2] | 0, L = ie & 8191, j = ie >>> 13, ne = S[3] | 0, de = ne & 8191, pe = ne >>> 13, be = S[4] | 0, me = be & 8191, we = be >>> 13, ue = S[5] | 0, Oe = ue & 8191, xe = ue >>> 13, je = S[6] | 0, Ne = je & 8191, ge = je >>> 13, Me = S[7] | 0, qe = Me & 8191, Se = Me >>> 13, ke = S[8] | 0, Le = ke & 8191, N = ke >>> 13, E = S[9] | 0, I = E & 8191, U = E >>> 13, re = A[0] | 0, ae = re & 8191, fe = re >>> 13, ye = A[1] | 0, Ee = ye & 8191, ve = ye >>> 13, Be = A[2] | 0, $e = Be & 8191, Ae = Be >>> 13, He = A[3] | 0, ze = He & 8191, Re = He >>> 13, Ke = A[4] | 0, Ge = Ke & 8191, Pe = Ke >>> 13, We = A[5] | 0, Ve = We & 8191, Ie = We >>> 13, Je = A[6] | 0, Ye = Je & 8191, Ce = Je >>> 13, Ze = A[7] | 0, Xe = Ze & 8191, Te = Ze >>> 13, Qe = A[8] | 0, er = Qe & 8191, De = Qe >>> 13, rr = A[9] | 0, Fe = rr & 8191, Ue = rr >>> 13;
      $.negative = c.negative ^ v.negative, $.length = 19, B = Math.imul(te, ae), b = Math.imul(te, fe), b = b + Math.imul(V, ae) | 0, k = Math.imul(V, fe);
      var fr = (p + B | 0) + ((b & 8191) << 13) | 0;
      p = (k + (b >>> 13) | 0) + (fr >>> 26) | 0, fr &= 67108863, B = Math.imul(O, ae), b = Math.imul(O, fe), b = b + Math.imul(Q, ae) | 0, k = Math.imul(Q, fe), B = B + Math.imul(te, Ee) | 0, b = b + Math.imul(te, ve) | 0, b = b + Math.imul(V, Ee) | 0, k = k + Math.imul(V, ve) | 0;
      var or = (p + B | 0) + ((b & 8191) << 13) | 0;
      p = (k + (b >>> 13) | 0) + (or >>> 26) | 0, or &= 67108863, B = Math.imul(L, ae), b = Math.imul(L, fe), b = b + Math.imul(j, ae) | 0, k = Math.imul(j, fe), B = B + Math.imul(O, Ee) | 0, b = b + Math.imul(O, ve) | 0, b = b + Math.imul(Q, Ee) | 0, k = k + Math.imul(Q, ve) | 0, B = B + Math.imul(te, $e) | 0, b = b + Math.imul(te, Ae) | 0, b = b + Math.imul(V, $e) | 0, k = k + Math.imul(V, Ae) | 0;
      var ur = (p + B | 0) + ((b & 8191) << 13) | 0;
      p = (k + (b >>> 13) | 0) + (ur >>> 26) | 0, ur &= 67108863, B = Math.imul(de, ae), b = Math.imul(de, fe), b = b + Math.imul(pe, ae) | 0, k = Math.imul(pe, fe), B = B + Math.imul(L, Ee) | 0, b = b + Math.imul(L, ve) | 0, b = b + Math.imul(j, Ee) | 0, k = k + Math.imul(j, ve) | 0, B = B + Math.imul(O, $e) | 0, b = b + Math.imul(O, Ae) | 0, b = b + Math.imul(Q, $e) | 0, k = k + Math.imul(Q, Ae) | 0, B = B + Math.imul(te, ze) | 0, b = b + Math.imul(te, Re) | 0, b = b + Math.imul(V, ze) | 0, k = k + Math.imul(V, Re) | 0;
      var cr = (p + B | 0) + ((b & 8191) << 13) | 0;
      p = (k + (b >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, B = Math.imul(me, ae), b = Math.imul(me, fe), b = b + Math.imul(we, ae) | 0, k = Math.imul(we, fe), B = B + Math.imul(de, Ee) | 0, b = b + Math.imul(de, ve) | 0, b = b + Math.imul(pe, Ee) | 0, k = k + Math.imul(pe, ve) | 0, B = B + Math.imul(L, $e) | 0, b = b + Math.imul(L, Ae) | 0, b = b + Math.imul(j, $e) | 0, k = k + Math.imul(j, Ae) | 0, B = B + Math.imul(O, ze) | 0, b = b + Math.imul(O, Re) | 0, b = b + Math.imul(Q, ze) | 0, k = k + Math.imul(Q, Re) | 0, B = B + Math.imul(te, Ge) | 0, b = b + Math.imul(te, Pe) | 0, b = b + Math.imul(V, Ge) | 0, k = k + Math.imul(V, Pe) | 0;
      var dr = (p + B | 0) + ((b & 8191) << 13) | 0;
      p = (k + (b >>> 13) | 0) + (dr >>> 26) | 0, dr &= 67108863, B = Math.imul(Oe, ae), b = Math.imul(Oe, fe), b = b + Math.imul(xe, ae) | 0, k = Math.imul(xe, fe), B = B + Math.imul(me, Ee) | 0, b = b + Math.imul(me, ve) | 0, b = b + Math.imul(we, Ee) | 0, k = k + Math.imul(we, ve) | 0, B = B + Math.imul(de, $e) | 0, b = b + Math.imul(de, Ae) | 0, b = b + Math.imul(pe, $e) | 0, k = k + Math.imul(pe, Ae) | 0, B = B + Math.imul(L, ze) | 0, b = b + Math.imul(L, Re) | 0, b = b + Math.imul(j, ze) | 0, k = k + Math.imul(j, Re) | 0, B = B + Math.imul(O, Ge) | 0, b = b + Math.imul(O, Pe) | 0, b = b + Math.imul(Q, Ge) | 0, k = k + Math.imul(Q, Pe) | 0, B = B + Math.imul(te, Ve) | 0, b = b + Math.imul(te, Ie) | 0, b = b + Math.imul(V, Ve) | 0, k = k + Math.imul(V, Ie) | 0;
      var lr = (p + B | 0) + ((b & 8191) << 13) | 0;
      p = (k + (b >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, B = Math.imul(Ne, ae), b = Math.imul(Ne, fe), b = b + Math.imul(ge, ae) | 0, k = Math.imul(ge, fe), B = B + Math.imul(Oe, Ee) | 0, b = b + Math.imul(Oe, ve) | 0, b = b + Math.imul(xe, Ee) | 0, k = k + Math.imul(xe, ve) | 0, B = B + Math.imul(me, $e) | 0, b = b + Math.imul(me, Ae) | 0, b = b + Math.imul(we, $e) | 0, k = k + Math.imul(we, Ae) | 0, B = B + Math.imul(de, ze) | 0, b = b + Math.imul(de, Re) | 0, b = b + Math.imul(pe, ze) | 0, k = k + Math.imul(pe, Re) | 0, B = B + Math.imul(L, Ge) | 0, b = b + Math.imul(L, Pe) | 0, b = b + Math.imul(j, Ge) | 0, k = k + Math.imul(j, Pe) | 0, B = B + Math.imul(O, Ve) | 0, b = b + Math.imul(O, Ie) | 0, b = b + Math.imul(Q, Ve) | 0, k = k + Math.imul(Q, Ie) | 0, B = B + Math.imul(te, Ye) | 0, b = b + Math.imul(te, Ce) | 0, b = b + Math.imul(V, Ye) | 0, k = k + Math.imul(V, Ce) | 0;
      var pr = (p + B | 0) + ((b & 8191) << 13) | 0;
      p = (k + (b >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, B = Math.imul(qe, ae), b = Math.imul(qe, fe), b = b + Math.imul(Se, ae) | 0, k = Math.imul(Se, fe), B = B + Math.imul(Ne, Ee) | 0, b = b + Math.imul(Ne, ve) | 0, b = b + Math.imul(ge, Ee) | 0, k = k + Math.imul(ge, ve) | 0, B = B + Math.imul(Oe, $e) | 0, b = b + Math.imul(Oe, Ae) | 0, b = b + Math.imul(xe, $e) | 0, k = k + Math.imul(xe, Ae) | 0, B = B + Math.imul(me, ze) | 0, b = b + Math.imul(me, Re) | 0, b = b + Math.imul(we, ze) | 0, k = k + Math.imul(we, Re) | 0, B = B + Math.imul(de, Ge) | 0, b = b + Math.imul(de, Pe) | 0, b = b + Math.imul(pe, Ge) | 0, k = k + Math.imul(pe, Pe) | 0, B = B + Math.imul(L, Ve) | 0, b = b + Math.imul(L, Ie) | 0, b = b + Math.imul(j, Ve) | 0, k = k + Math.imul(j, Ie) | 0, B = B + Math.imul(O, Ye) | 0, b = b + Math.imul(O, Ce) | 0, b = b + Math.imul(Q, Ye) | 0, k = k + Math.imul(Q, Ce) | 0, B = B + Math.imul(te, Xe) | 0, b = b + Math.imul(te, Te) | 0, b = b + Math.imul(V, Xe) | 0, k = k + Math.imul(V, Te) | 0;
      var br = (p + B | 0) + ((b & 8191) << 13) | 0;
      p = (k + (b >>> 13) | 0) + (br >>> 26) | 0, br &= 67108863, B = Math.imul(Le, ae), b = Math.imul(Le, fe), b = b + Math.imul(N, ae) | 0, k = Math.imul(N, fe), B = B + Math.imul(qe, Ee) | 0, b = b + Math.imul(qe, ve) | 0, b = b + Math.imul(Se, Ee) | 0, k = k + Math.imul(Se, ve) | 0, B = B + Math.imul(Ne, $e) | 0, b = b + Math.imul(Ne, Ae) | 0, b = b + Math.imul(ge, $e) | 0, k = k + Math.imul(ge, Ae) | 0, B = B + Math.imul(Oe, ze) | 0, b = b + Math.imul(Oe, Re) | 0, b = b + Math.imul(xe, ze) | 0, k = k + Math.imul(xe, Re) | 0, B = B + Math.imul(me, Ge) | 0, b = b + Math.imul(me, Pe) | 0, b = b + Math.imul(we, Ge) | 0, k = k + Math.imul(we, Pe) | 0, B = B + Math.imul(de, Ve) | 0, b = b + Math.imul(de, Ie) | 0, b = b + Math.imul(pe, Ve) | 0, k = k + Math.imul(pe, Ie) | 0, B = B + Math.imul(L, Ye) | 0, b = b + Math.imul(L, Ce) | 0, b = b + Math.imul(j, Ye) | 0, k = k + Math.imul(j, Ce) | 0, B = B + Math.imul(O, Xe) | 0, b = b + Math.imul(O, Te) | 0, b = b + Math.imul(Q, Xe) | 0, k = k + Math.imul(Q, Te) | 0, B = B + Math.imul(te, er) | 0, b = b + Math.imul(te, De) | 0, b = b + Math.imul(V, er) | 0, k = k + Math.imul(V, De) | 0;
      var vr = (p + B | 0) + ((b & 8191) << 13) | 0;
      p = (k + (b >>> 13) | 0) + (vr >>> 26) | 0, vr &= 67108863, B = Math.imul(I, ae), b = Math.imul(I, fe), b = b + Math.imul(U, ae) | 0, k = Math.imul(U, fe), B = B + Math.imul(Le, Ee) | 0, b = b + Math.imul(Le, ve) | 0, b = b + Math.imul(N, Ee) | 0, k = k + Math.imul(N, ve) | 0, B = B + Math.imul(qe, $e) | 0, b = b + Math.imul(qe, Ae) | 0, b = b + Math.imul(Se, $e) | 0, k = k + Math.imul(Se, Ae) | 0, B = B + Math.imul(Ne, ze) | 0, b = b + Math.imul(Ne, Re) | 0, b = b + Math.imul(ge, ze) | 0, k = k + Math.imul(ge, Re) | 0, B = B + Math.imul(Oe, Ge) | 0, b = b + Math.imul(Oe, Pe) | 0, b = b + Math.imul(xe, Ge) | 0, k = k + Math.imul(xe, Pe) | 0, B = B + Math.imul(me, Ve) | 0, b = b + Math.imul(me, Ie) | 0, b = b + Math.imul(we, Ve) | 0, k = k + Math.imul(we, Ie) | 0, B = B + Math.imul(de, Ye) | 0, b = b + Math.imul(de, Ce) | 0, b = b + Math.imul(pe, Ye) | 0, k = k + Math.imul(pe, Ce) | 0, B = B + Math.imul(L, Xe) | 0, b = b + Math.imul(L, Te) | 0, b = b + Math.imul(j, Xe) | 0, k = k + Math.imul(j, Te) | 0, B = B + Math.imul(O, er) | 0, b = b + Math.imul(O, De) | 0, b = b + Math.imul(Q, er) | 0, k = k + Math.imul(Q, De) | 0, B = B + Math.imul(te, Fe) | 0, b = b + Math.imul(te, Ue) | 0, b = b + Math.imul(V, Fe) | 0, k = k + Math.imul(V, Ue) | 0;
      var yr = (p + B | 0) + ((b & 8191) << 13) | 0;
      p = (k + (b >>> 13) | 0) + (yr >>> 26) | 0, yr &= 67108863, B = Math.imul(I, Ee), b = Math.imul(I, ve), b = b + Math.imul(U, Ee) | 0, k = Math.imul(U, ve), B = B + Math.imul(Le, $e) | 0, b = b + Math.imul(Le, Ae) | 0, b = b + Math.imul(N, $e) | 0, k = k + Math.imul(N, Ae) | 0, B = B + Math.imul(qe, ze) | 0, b = b + Math.imul(qe, Re) | 0, b = b + Math.imul(Se, ze) | 0, k = k + Math.imul(Se, Re) | 0, B = B + Math.imul(Ne, Ge) | 0, b = b + Math.imul(Ne, Pe) | 0, b = b + Math.imul(ge, Ge) | 0, k = k + Math.imul(ge, Pe) | 0, B = B + Math.imul(Oe, Ve) | 0, b = b + Math.imul(Oe, Ie) | 0, b = b + Math.imul(xe, Ve) | 0, k = k + Math.imul(xe, Ie) | 0, B = B + Math.imul(me, Ye) | 0, b = b + Math.imul(me, Ce) | 0, b = b + Math.imul(we, Ye) | 0, k = k + Math.imul(we, Ce) | 0, B = B + Math.imul(de, Xe) | 0, b = b + Math.imul(de, Te) | 0, b = b + Math.imul(pe, Xe) | 0, k = k + Math.imul(pe, Te) | 0, B = B + Math.imul(L, er) | 0, b = b + Math.imul(L, De) | 0, b = b + Math.imul(j, er) | 0, k = k + Math.imul(j, De) | 0, B = B + Math.imul(O, Fe) | 0, b = b + Math.imul(O, Ue) | 0, b = b + Math.imul(Q, Fe) | 0, k = k + Math.imul(Q, Ue) | 0;
      var gr = (p + B | 0) + ((b & 8191) << 13) | 0;
      p = (k + (b >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, B = Math.imul(I, $e), b = Math.imul(I, Ae), b = b + Math.imul(U, $e) | 0, k = Math.imul(U, Ae), B = B + Math.imul(Le, ze) | 0, b = b + Math.imul(Le, Re) | 0, b = b + Math.imul(N, ze) | 0, k = k + Math.imul(N, Re) | 0, B = B + Math.imul(qe, Ge) | 0, b = b + Math.imul(qe, Pe) | 0, b = b + Math.imul(Se, Ge) | 0, k = k + Math.imul(Se, Pe) | 0, B = B + Math.imul(Ne, Ve) | 0, b = b + Math.imul(Ne, Ie) | 0, b = b + Math.imul(ge, Ve) | 0, k = k + Math.imul(ge, Ie) | 0, B = B + Math.imul(Oe, Ye) | 0, b = b + Math.imul(Oe, Ce) | 0, b = b + Math.imul(xe, Ye) | 0, k = k + Math.imul(xe, Ce) | 0, B = B + Math.imul(me, Xe) | 0, b = b + Math.imul(me, Te) | 0, b = b + Math.imul(we, Xe) | 0, k = k + Math.imul(we, Te) | 0, B = B + Math.imul(de, er) | 0, b = b + Math.imul(de, De) | 0, b = b + Math.imul(pe, er) | 0, k = k + Math.imul(pe, De) | 0, B = B + Math.imul(L, Fe) | 0, b = b + Math.imul(L, Ue) | 0, b = b + Math.imul(j, Fe) | 0, k = k + Math.imul(j, Ue) | 0;
      var wr = (p + B | 0) + ((b & 8191) << 13) | 0;
      p = (k + (b >>> 13) | 0) + (wr >>> 26) | 0, wr &= 67108863, B = Math.imul(I, ze), b = Math.imul(I, Re), b = b + Math.imul(U, ze) | 0, k = Math.imul(U, Re), B = B + Math.imul(Le, Ge) | 0, b = b + Math.imul(Le, Pe) | 0, b = b + Math.imul(N, Ge) | 0, k = k + Math.imul(N, Pe) | 0, B = B + Math.imul(qe, Ve) | 0, b = b + Math.imul(qe, Ie) | 0, b = b + Math.imul(Se, Ve) | 0, k = k + Math.imul(Se, Ie) | 0, B = B + Math.imul(Ne, Ye) | 0, b = b + Math.imul(Ne, Ce) | 0, b = b + Math.imul(ge, Ye) | 0, k = k + Math.imul(ge, Ce) | 0, B = B + Math.imul(Oe, Xe) | 0, b = b + Math.imul(Oe, Te) | 0, b = b + Math.imul(xe, Xe) | 0, k = k + Math.imul(xe, Te) | 0, B = B + Math.imul(me, er) | 0, b = b + Math.imul(me, De) | 0, b = b + Math.imul(we, er) | 0, k = k + Math.imul(we, De) | 0, B = B + Math.imul(de, Fe) | 0, b = b + Math.imul(de, Ue) | 0, b = b + Math.imul(pe, Fe) | 0, k = k + Math.imul(pe, Ue) | 0;
      var _r = (p + B | 0) + ((b & 8191) << 13) | 0;
      p = (k + (b >>> 13) | 0) + (_r >>> 26) | 0, _r &= 67108863, B = Math.imul(I, Ge), b = Math.imul(I, Pe), b = b + Math.imul(U, Ge) | 0, k = Math.imul(U, Pe), B = B + Math.imul(Le, Ve) | 0, b = b + Math.imul(Le, Ie) | 0, b = b + Math.imul(N, Ve) | 0, k = k + Math.imul(N, Ie) | 0, B = B + Math.imul(qe, Ye) | 0, b = b + Math.imul(qe, Ce) | 0, b = b + Math.imul(Se, Ye) | 0, k = k + Math.imul(Se, Ce) | 0, B = B + Math.imul(Ne, Xe) | 0, b = b + Math.imul(Ne, Te) | 0, b = b + Math.imul(ge, Xe) | 0, k = k + Math.imul(ge, Te) | 0, B = B + Math.imul(Oe, er) | 0, b = b + Math.imul(Oe, De) | 0, b = b + Math.imul(xe, er) | 0, k = k + Math.imul(xe, De) | 0, B = B + Math.imul(me, Fe) | 0, b = b + Math.imul(me, Ue) | 0, b = b + Math.imul(we, Fe) | 0, k = k + Math.imul(we, Ue) | 0;
      var $r = (p + B | 0) + ((b & 8191) << 13) | 0;
      p = (k + (b >>> 13) | 0) + ($r >>> 26) | 0, $r &= 67108863, B = Math.imul(I, Ve), b = Math.imul(I, Ie), b = b + Math.imul(U, Ve) | 0, k = Math.imul(U, Ie), B = B + Math.imul(Le, Ye) | 0, b = b + Math.imul(Le, Ce) | 0, b = b + Math.imul(N, Ye) | 0, k = k + Math.imul(N, Ce) | 0, B = B + Math.imul(qe, Xe) | 0, b = b + Math.imul(qe, Te) | 0, b = b + Math.imul(Se, Xe) | 0, k = k + Math.imul(Se, Te) | 0, B = B + Math.imul(Ne, er) | 0, b = b + Math.imul(Ne, De) | 0, b = b + Math.imul(ge, er) | 0, k = k + Math.imul(ge, De) | 0, B = B + Math.imul(Oe, Fe) | 0, b = b + Math.imul(Oe, Ue) | 0, b = b + Math.imul(xe, Fe) | 0, k = k + Math.imul(xe, Ue) | 0;
      var xr = (p + B | 0) + ((b & 8191) << 13) | 0;
      p = (k + (b >>> 13) | 0) + (xr >>> 26) | 0, xr &= 67108863, B = Math.imul(I, Ye), b = Math.imul(I, Ce), b = b + Math.imul(U, Ye) | 0, k = Math.imul(U, Ce), B = B + Math.imul(Le, Xe) | 0, b = b + Math.imul(Le, Te) | 0, b = b + Math.imul(N, Xe) | 0, k = k + Math.imul(N, Te) | 0, B = B + Math.imul(qe, er) | 0, b = b + Math.imul(qe, De) | 0, b = b + Math.imul(Se, er) | 0, k = k + Math.imul(Se, De) | 0, B = B + Math.imul(Ne, Fe) | 0, b = b + Math.imul(Ne, Ue) | 0, b = b + Math.imul(ge, Fe) | 0, k = k + Math.imul(ge, Ue) | 0;
      var Sr = (p + B | 0) + ((b & 8191) << 13) | 0;
      p = (k + (b >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, B = Math.imul(I, Xe), b = Math.imul(I, Te), b = b + Math.imul(U, Xe) | 0, k = Math.imul(U, Te), B = B + Math.imul(Le, er) | 0, b = b + Math.imul(Le, De) | 0, b = b + Math.imul(N, er) | 0, k = k + Math.imul(N, De) | 0, B = B + Math.imul(qe, Fe) | 0, b = b + Math.imul(qe, Ue) | 0, b = b + Math.imul(Se, Fe) | 0, k = k + Math.imul(Se, Ue) | 0;
      var Er = (p + B | 0) + ((b & 8191) << 13) | 0;
      p = (k + (b >>> 13) | 0) + (Er >>> 26) | 0, Er &= 67108863, B = Math.imul(I, er), b = Math.imul(I, De), b = b + Math.imul(U, er) | 0, k = Math.imul(U, De), B = B + Math.imul(Le, Fe) | 0, b = b + Math.imul(Le, Ue) | 0, b = b + Math.imul(N, Fe) | 0, k = k + Math.imul(N, Ue) | 0;
      var Or = (p + B | 0) + ((b & 8191) << 13) | 0;
      p = (k + (b >>> 13) | 0) + (Or >>> 26) | 0, Or &= 67108863, B = Math.imul(I, Fe), b = Math.imul(I, Ue), b = b + Math.imul(U, Fe) | 0, k = Math.imul(U, Ue);
      var Nr = (p + B | 0) + ((b & 8191) << 13) | 0;
      return p = (k + (b >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, M[0] = fr, M[1] = or, M[2] = ur, M[3] = cr, M[4] = dr, M[5] = lr, M[6] = pr, M[7] = br, M[8] = vr, M[9] = yr, M[10] = gr, M[11] = wr, M[12] = _r, M[13] = $r, M[14] = xr, M[15] = Sr, M[16] = Er, M[17] = Or, M[18] = Nr, p !== 0 && (M[19] = p, $.length++), $;
    };
    Math.imul || (F = z);
    function X(m, c, v) {
      v.negative = c.negative ^ m.negative, v.length = m.length + c.length;
      for (var $ = 0, S = 0, A = 0; A < v.length - 1; A++) {
        var M = S;
        S = 0;
        for (var p = $ & 67108863, B = Math.min(A, c.length - 1), b = Math.max(0, A - m.length + 1); b <= B; b++) {
          var k = A - b, Z = m.words[k] | 0, te = c.words[b] | 0, V = Z * te, T = V & 67108863;
          M = M + (V / 67108864 | 0) | 0, T = T + p | 0, p = T & 67108863, M = M + (T >>> 26) | 0, S += M >>> 26, M &= 67108863;
        }
        v.words[A] = p, $ = M, M = S;
      }
      return $ !== 0 ? v.words[A] = $ : v.length--, v._strip();
    }
    function ee(m, c, v) {
      return X(m, c, v);
    }
    o.prototype.mulTo = function(c, v) {
      var $, S = this.length + c.length;
      return this.length === 10 && c.length === 10 ? $ = F(this, c, v) : S < 63 ? $ = z(this, c, v) : S < 1024 ? $ = X(this, c, v) : $ = ee(this, c, v), $;
    }, o.prototype.mul = function(c) {
      var v = new o(null);
      return v.words = new Array(this.length + c.length), this.mulTo(c, v);
    }, o.prototype.mulf = function(c) {
      var v = new o(null);
      return v.words = new Array(this.length + c.length), ee(this, c, v);
    }, o.prototype.imul = function(c) {
      return this.clone().mulTo(c, this);
    }, o.prototype.imuln = function(c) {
      var v = c < 0;
      v && (c = -c), a(typeof c == "number"), a(c < 67108864);
      for (var $ = 0, S = 0; S < this.length; S++) {
        var A = (this.words[S] | 0) * c, M = (A & 67108863) + ($ & 67108863);
        $ >>= 26, $ += A / 67108864 | 0, $ += M >>> 26, this.words[S] = M & 67108863;
      }
      return $ !== 0 && (this.words[S] = $, this.length++), v ? this.ineg() : this;
    }, o.prototype.muln = function(c) {
      return this.clone().imuln(c);
    }, o.prototype.sqr = function() {
      return this.mul(this);
    }, o.prototype.isqr = function() {
      return this.imul(this.clone());
    }, o.prototype.pow = function(c) {
      var v = Y(c);
      if (v.length === 0) return new o(1);
      for (var $ = this, S = 0; S < v.length && v[S] === 0; S++, $ = $.sqr())
        ;
      if (++S < v.length)
        for (var A = $.sqr(); S < v.length; S++, A = A.sqr())
          v[S] !== 0 && ($ = $.mul(A));
      return $;
    }, o.prototype.iushln = function(c) {
      a(typeof c == "number" && c >= 0);
      var v = c % 26, $ = (c - v) / 26, S = 67108863 >>> 26 - v << 26 - v, A;
      if (v !== 0) {
        var M = 0;
        for (A = 0; A < this.length; A++) {
          var p = this.words[A] & S, B = (this.words[A] | 0) - p << v;
          this.words[A] = B | M, M = p >>> 26 - v;
        }
        M && (this.words[A] = M, this.length++);
      }
      if ($ !== 0) {
        for (A = this.length - 1; A >= 0; A--)
          this.words[A + $] = this.words[A];
        for (A = 0; A < $; A++)
          this.words[A] = 0;
        this.length += $;
      }
      return this._strip();
    }, o.prototype.ishln = function(c) {
      return a(this.negative === 0), this.iushln(c);
    }, o.prototype.iushrn = function(c, v, $) {
      a(typeof c == "number" && c >= 0);
      var S;
      v ? S = (v - v % 26) / 26 : S = 0;
      var A = c % 26, M = Math.min((c - A) / 26, this.length), p = 67108863 ^ 67108863 >>> A << A, B = $;
      if (S -= M, S = Math.max(0, S), B) {
        for (var b = 0; b < M; b++)
          B.words[b] = this.words[b];
        B.length = M;
      }
      if (M !== 0) if (this.length > M)
        for (this.length -= M, b = 0; b < this.length; b++)
          this.words[b] = this.words[b + M];
      else
        this.words[0] = 0, this.length = 1;
      var k = 0;
      for (b = this.length - 1; b >= 0 && (k !== 0 || b >= S); b--) {
        var Z = this.words[b] | 0;
        this.words[b] = k << 26 - A | Z >>> A, k = Z & p;
      }
      return B && k !== 0 && (B.words[B.length++] = k), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, o.prototype.ishrn = function(c, v, $) {
      return a(this.negative === 0), this.iushrn(c, v, $);
    }, o.prototype.shln = function(c) {
      return this.clone().ishln(c);
    }, o.prototype.ushln = function(c) {
      return this.clone().iushln(c);
    }, o.prototype.shrn = function(c) {
      return this.clone().ishrn(c);
    }, o.prototype.ushrn = function(c) {
      return this.clone().iushrn(c);
    }, o.prototype.testn = function(c) {
      a(typeof c == "number" && c >= 0);
      var v = c % 26, $ = (c - v) / 26, S = 1 << v;
      if (this.length <= $) return !1;
      var A = this.words[$];
      return !!(A & S);
    }, o.prototype.imaskn = function(c) {
      a(typeof c == "number" && c >= 0);
      var v = c % 26, $ = (c - v) / 26;
      if (a(this.negative === 0, "imaskn works only with positive numbers"), this.length <= $)
        return this;
      if (v !== 0 && $++, this.length = Math.min($, this.length), v !== 0) {
        var S = 67108863 ^ 67108863 >>> v << v;
        this.words[this.length - 1] &= S;
      }
      return this._strip();
    }, o.prototype.maskn = function(c) {
      return this.clone().imaskn(c);
    }, o.prototype.iaddn = function(c) {
      return a(typeof c == "number"), a(c < 67108864), c < 0 ? this.isubn(-c) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= c ? (this.words[0] = c - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(c), this.negative = 1, this) : this._iaddn(c);
    }, o.prototype._iaddn = function(c) {
      this.words[0] += c;
      for (var v = 0; v < this.length && this.words[v] >= 67108864; v++)
        this.words[v] -= 67108864, v === this.length - 1 ? this.words[v + 1] = 1 : this.words[v + 1]++;
      return this.length = Math.max(this.length, v + 1), this;
    }, o.prototype.isubn = function(c) {
      if (a(typeof c == "number"), a(c < 67108864), c < 0) return this.iaddn(-c);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(c), this.negative = 1, this;
      if (this.words[0] -= c, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var v = 0; v < this.length && this.words[v] < 0; v++)
          this.words[v] += 67108864, this.words[v + 1] -= 1;
      return this._strip();
    }, o.prototype.addn = function(c) {
      return this.clone().iaddn(c);
    }, o.prototype.subn = function(c) {
      return this.clone().isubn(c);
    }, o.prototype.iabs = function() {
      return this.negative = 0, this;
    }, o.prototype.abs = function() {
      return this.clone().iabs();
    }, o.prototype._ishlnsubmul = function(c, v, $) {
      var S = c.length + $, A;
      this._expand(S);
      var M, p = 0;
      for (A = 0; A < c.length; A++) {
        M = (this.words[A + $] | 0) + p;
        var B = (c.words[A] | 0) * v;
        M -= B & 67108863, p = (M >> 26) - (B / 67108864 | 0), this.words[A + $] = M & 67108863;
      }
      for (; A < this.length - $; A++)
        M = (this.words[A + $] | 0) + p, p = M >> 26, this.words[A + $] = M & 67108863;
      if (p === 0) return this._strip();
      for (a(p === -1), p = 0, A = 0; A < this.length; A++)
        M = -(this.words[A] | 0) + p, p = M >> 26, this.words[A] = M & 67108863;
      return this.negative = 1, this._strip();
    }, o.prototype._wordDiv = function(c, v) {
      var $ = this.length - c.length, S = this.clone(), A = c, M = A.words[A.length - 1] | 0, p = this._countBits(M);
      $ = 26 - p, $ !== 0 && (A = A.ushln($), S.iushln($), M = A.words[A.length - 1] | 0);
      var B = S.length - A.length, b;
      if (v !== "mod") {
        b = new o(null), b.length = B + 1, b.words = new Array(b.length);
        for (var k = 0; k < b.length; k++)
          b.words[k] = 0;
      }
      var Z = S.clone()._ishlnsubmul(A, 1, B);
      Z.negative === 0 && (S = Z, b && (b.words[B] = 1));
      for (var te = B - 1; te >= 0; te--) {
        var V = (S.words[A.length + te] | 0) * 67108864 + (S.words[A.length + te - 1] | 0);
        for (V = Math.min(V / M | 0, 67108863), S._ishlnsubmul(A, V, te); S.negative !== 0; )
          V--, S.negative = 0, S._ishlnsubmul(A, 1, te), S.isZero() || (S.negative ^= 1);
        b && (b.words[te] = V);
      }
      return b && b._strip(), S._strip(), v !== "div" && $ !== 0 && S.iushrn($), {
        div: b || null,
        mod: S
      };
    }, o.prototype.divmod = function(c, v, $) {
      if (a(!c.isZero()), this.isZero())
        return {
          div: new o(0),
          mod: new o(0)
        };
      var S, A, M;
      return this.negative !== 0 && c.negative === 0 ? (M = this.neg().divmod(c, v), v !== "mod" && (S = M.div.neg()), v !== "div" && (A = M.mod.neg(), $ && A.negative !== 0 && A.iadd(c)), {
        div: S,
        mod: A
      }) : this.negative === 0 && c.negative !== 0 ? (M = this.divmod(c.neg(), v), v !== "mod" && (S = M.div.neg()), {
        div: S,
        mod: M.mod
      }) : this.negative & c.negative ? (M = this.neg().divmod(c.neg(), v), v !== "div" && (A = M.mod.neg(), $ && A.negative !== 0 && A.isub(c)), {
        div: M.div,
        mod: A
      }) : c.length > this.length || this.cmp(c) < 0 ? {
        div: new o(0),
        mod: this
      } : c.length === 1 ? v === "div" ? {
        div: this.divn(c.words[0]),
        mod: null
      } : v === "mod" ? {
        div: null,
        mod: new o(this.modrn(c.words[0]))
      } : {
        div: this.divn(c.words[0]),
        mod: new o(this.modrn(c.words[0]))
      } : this._wordDiv(c, v);
    }, o.prototype.div = function(c) {
      return this.divmod(c, "div", !1).div;
    }, o.prototype.mod = function(c) {
      return this.divmod(c, "mod", !1).mod;
    }, o.prototype.umod = function(c) {
      return this.divmod(c, "mod", !0).mod;
    }, o.prototype.divRound = function(c) {
      var v = this.divmod(c);
      if (v.mod.isZero()) return v.div;
      var $ = v.div.negative !== 0 ? v.mod.isub(c) : v.mod, S = c.ushrn(1), A = c.andln(1), M = $.cmp(S);
      return M < 0 || A === 1 && M === 0 ? v.div : v.div.negative !== 0 ? v.div.isubn(1) : v.div.iaddn(1);
    }, o.prototype.modrn = function(c) {
      var v = c < 0;
      v && (c = -c), a(c <= 67108863);
      for (var $ = (1 << 26) % c, S = 0, A = this.length - 1; A >= 0; A--)
        S = ($ * S + (this.words[A] | 0)) % c;
      return v ? -S : S;
    }, o.prototype.modn = function(c) {
      return this.modrn(c);
    }, o.prototype.idivn = function(c) {
      var v = c < 0;
      v && (c = -c), a(c <= 67108863);
      for (var $ = 0, S = this.length - 1; S >= 0; S--) {
        var A = (this.words[S] | 0) + $ * 67108864;
        this.words[S] = A / c | 0, $ = A % c;
      }
      return this._strip(), v ? this.ineg() : this;
    }, o.prototype.divn = function(c) {
      return this.clone().idivn(c);
    }, o.prototype.egcd = function(c) {
      a(c.negative === 0), a(!c.isZero());
      var v = this, $ = c.clone();
      v.negative !== 0 ? v = v.umod(c) : v = v.clone();
      for (var S = new o(1), A = new o(0), M = new o(0), p = new o(1), B = 0; v.isEven() && $.isEven(); )
        v.iushrn(1), $.iushrn(1), ++B;
      for (var b = $.clone(), k = v.clone(); !v.isZero(); ) {
        for (var Z = 0, te = 1; !(v.words[0] & te) && Z < 26; ++Z, te <<= 1) ;
        if (Z > 0)
          for (v.iushrn(Z); Z-- > 0; )
            (S.isOdd() || A.isOdd()) && (S.iadd(b), A.isub(k)), S.iushrn(1), A.iushrn(1);
        for (var V = 0, T = 1; !($.words[0] & T) && V < 26; ++V, T <<= 1) ;
        if (V > 0)
          for ($.iushrn(V); V-- > 0; )
            (M.isOdd() || p.isOdd()) && (M.iadd(b), p.isub(k)), M.iushrn(1), p.iushrn(1);
        v.cmp($) >= 0 ? (v.isub($), S.isub(M), A.isub(p)) : ($.isub(v), M.isub(S), p.isub(A));
      }
      return {
        a: M,
        b: p,
        gcd: $.iushln(B)
      };
    }, o.prototype._invmp = function(c) {
      a(c.negative === 0), a(!c.isZero());
      var v = this, $ = c.clone();
      v.negative !== 0 ? v = v.umod(c) : v = v.clone();
      for (var S = new o(1), A = new o(0), M = $.clone(); v.cmpn(1) > 0 && $.cmpn(1) > 0; ) {
        for (var p = 0, B = 1; !(v.words[0] & B) && p < 26; ++p, B <<= 1) ;
        if (p > 0)
          for (v.iushrn(p); p-- > 0; )
            S.isOdd() && S.iadd(M), S.iushrn(1);
        for (var b = 0, k = 1; !($.words[0] & k) && b < 26; ++b, k <<= 1) ;
        if (b > 0)
          for ($.iushrn(b); b-- > 0; )
            A.isOdd() && A.iadd(M), A.iushrn(1);
        v.cmp($) >= 0 ? (v.isub($), S.isub(A)) : ($.isub(v), A.isub(S));
      }
      var Z;
      return v.cmpn(1) === 0 ? Z = S : Z = A, Z.cmpn(0) < 0 && Z.iadd(c), Z;
    }, o.prototype.gcd = function(c) {
      if (this.isZero()) return c.abs();
      if (c.isZero()) return this.abs();
      var v = this.clone(), $ = c.clone();
      v.negative = 0, $.negative = 0;
      for (var S = 0; v.isEven() && $.isEven(); S++)
        v.iushrn(1), $.iushrn(1);
      do {
        for (; v.isEven(); )
          v.iushrn(1);
        for (; $.isEven(); )
          $.iushrn(1);
        var A = v.cmp($);
        if (A < 0) {
          var M = v;
          v = $, $ = M;
        } else if (A === 0 || $.cmpn(1) === 0)
          break;
        v.isub($);
      } while (!0);
      return $.iushln(S);
    }, o.prototype.invm = function(c) {
      return this.egcd(c).a.umod(c);
    }, o.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, o.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, o.prototype.andln = function(c) {
      return this.words[0] & c;
    }, o.prototype.bincn = function(c) {
      a(typeof c == "number");
      var v = c % 26, $ = (c - v) / 26, S = 1 << v;
      if (this.length <= $)
        return this._expand($ + 1), this.words[$] |= S, this;
      for (var A = S, M = $; A !== 0 && M < this.length; M++) {
        var p = this.words[M] | 0;
        p += A, A = p >>> 26, p &= 67108863, this.words[M] = p;
      }
      return A !== 0 && (this.words[M] = A, this.length++), this;
    }, o.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, o.prototype.cmpn = function(c) {
      var v = c < 0;
      if (this.negative !== 0 && !v) return -1;
      if (this.negative === 0 && v) return 1;
      this._strip();
      var $;
      if (this.length > 1)
        $ = 1;
      else {
        v && (c = -c), a(c <= 67108863, "Number is too big");
        var S = this.words[0] | 0;
        $ = S === c ? 0 : S < c ? -1 : 1;
      }
      return this.negative !== 0 ? -$ | 0 : $;
    }, o.prototype.cmp = function(c) {
      if (this.negative !== 0 && c.negative === 0) return -1;
      if (this.negative === 0 && c.negative !== 0) return 1;
      var v = this.ucmp(c);
      return this.negative !== 0 ? -v | 0 : v;
    }, o.prototype.ucmp = function(c) {
      if (this.length > c.length) return 1;
      if (this.length < c.length) return -1;
      for (var v = 0, $ = this.length - 1; $ >= 0; $--) {
        var S = this.words[$] | 0, A = c.words[$] | 0;
        if (S !== A) {
          S < A ? v = -1 : S > A && (v = 1);
          break;
        }
      }
      return v;
    }, o.prototype.gtn = function(c) {
      return this.cmpn(c) === 1;
    }, o.prototype.gt = function(c) {
      return this.cmp(c) === 1;
    }, o.prototype.gten = function(c) {
      return this.cmpn(c) >= 0;
    }, o.prototype.gte = function(c) {
      return this.cmp(c) >= 0;
    }, o.prototype.ltn = function(c) {
      return this.cmpn(c) === -1;
    }, o.prototype.lt = function(c) {
      return this.cmp(c) === -1;
    }, o.prototype.lten = function(c) {
      return this.cmpn(c) <= 0;
    }, o.prototype.lte = function(c) {
      return this.cmp(c) <= 0;
    }, o.prototype.eqn = function(c) {
      return this.cmpn(c) === 0;
    }, o.prototype.eq = function(c) {
      return this.cmp(c) === 0;
    }, o.red = function(c) {
      return new J(c);
    }, o.prototype.toRed = function(c) {
      return a(!this.red, "Already a number in reduction context"), a(this.negative === 0, "red works only with positives"), c.convertTo(this)._forceRed(c);
    }, o.prototype.fromRed = function() {
      return a(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, o.prototype._forceRed = function(c) {
      return this.red = c, this;
    }, o.prototype.forceRed = function(c) {
      return a(!this.red, "Already a number in reduction context"), this._forceRed(c);
    }, o.prototype.redAdd = function(c) {
      return a(this.red, "redAdd works only with red numbers"), this.red.add(this, c);
    }, o.prototype.redIAdd = function(c) {
      return a(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, c);
    }, o.prototype.redSub = function(c) {
      return a(this.red, "redSub works only with red numbers"), this.red.sub(this, c);
    }, o.prototype.redISub = function(c) {
      return a(this.red, "redISub works only with red numbers"), this.red.isub(this, c);
    }, o.prototype.redShl = function(c) {
      return a(this.red, "redShl works only with red numbers"), this.red.shl(this, c);
    }, o.prototype.redMul = function(c) {
      return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, c), this.red.mul(this, c);
    }, o.prototype.redIMul = function(c) {
      return a(this.red, "redMul works only with red numbers"), this.red._verify2(this, c), this.red.imul(this, c);
    }, o.prototype.redSqr = function() {
      return a(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, o.prototype.redISqr = function() {
      return a(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, o.prototype.redSqrt = function() {
      return a(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, o.prototype.redInvm = function() {
      return a(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, o.prototype.redNeg = function() {
      return a(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, o.prototype.redPow = function(c) {
      return a(this.red && !c.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, c);
    };
    var se = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function ce(m, c) {
      this.name = m, this.p = new o(c, 16), this.n = this.p.bitLength(), this.k = new o(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    ce.prototype._tmp = function() {
      var c = new o(null);
      return c.words = new Array(Math.ceil(this.n / 13)), c;
    }, ce.prototype.ireduce = function(c) {
      var v = c, $;
      do
        this.split(v, this.tmp), v = this.imulK(v), v = v.iadd(this.tmp), $ = v.bitLength();
      while ($ > this.n);
      var S = $ < this.n ? -1 : v.ucmp(this.p);
      return S === 0 ? (v.words[0] = 0, v.length = 1) : S > 0 ? v.isub(this.p) : v.strip !== void 0 ? v.strip() : v._strip(), v;
    }, ce.prototype.split = function(c, v) {
      c.iushrn(this.n, 0, v);
    }, ce.prototype.imulK = function(c) {
      return c.imul(this.k);
    };
    function le() {
      ce.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    u(le, ce), le.prototype.split = function(c, v) {
      for (var $ = 4194303, S = Math.min(c.length, 9), A = 0; A < S; A++)
        v.words[A] = c.words[A];
      if (v.length = S, c.length <= 9) {
        c.words[0] = 0, c.length = 1;
        return;
      }
      var M = c.words[9];
      for (v.words[v.length++] = M & $, A = 10; A < c.length; A++) {
        var p = c.words[A] | 0;
        c.words[A - 10] = (p & $) << 4 | M >>> 22, M = p;
      }
      M >>>= 22, c.words[A - 10] = M, M === 0 && c.length > 10 ? c.length -= 10 : c.length -= 9;
    }, le.prototype.imulK = function(c) {
      c.words[c.length] = 0, c.words[c.length + 1] = 0, c.length += 2;
      for (var v = 0, $ = 0; $ < c.length; $++) {
        var S = c.words[$] | 0;
        v += S * 977, c.words[$] = v & 67108863, v = S * 64 + (v / 67108864 | 0);
      }
      return c.words[c.length - 1] === 0 && (c.length--, c.words[c.length - 1] === 0 && c.length--), c;
    };
    function he() {
      ce.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    u(he, ce);
    function oe() {
      ce.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    u(oe, ce);
    function _e() {
      ce.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    u(_e, ce), _e.prototype.imulK = function(c) {
      for (var v = 0, $ = 0; $ < c.length; $++) {
        var S = (c.words[$] | 0) * 19 + v, A = S & 67108863;
        S >>>= 26, c.words[$] = A, v = S;
      }
      return v !== 0 && (c.words[c.length++] = v), c;
    }, o._prime = function(c) {
      if (se[c]) return se[c];
      var v;
      if (c === "k256")
        v = new le();
      else if (c === "p224")
        v = new he();
      else if (c === "p192")
        v = new oe();
      else if (c === "p25519")
        v = new _e();
      else
        throw new Error("Unknown prime " + c);
      return se[c] = v, v;
    };
    function J(m) {
      if (typeof m == "string") {
        var c = o._prime(m);
        this.m = c.p, this.prime = c;
      } else
        a(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null;
    }
    J.prototype._verify1 = function(c) {
      a(c.negative === 0, "red works only with positives"), a(c.red, "red works only with red numbers");
    }, J.prototype._verify2 = function(c, v) {
      a((c.negative | v.negative) === 0, "red works only with positives"), a(
        c.red && c.red === v.red,
        "red works only with red numbers"
      );
    }, J.prototype.imod = function(c) {
      return this.prime ? this.prime.ireduce(c)._forceRed(this) : (h(c, c.umod(this.m)._forceRed(this)), c);
    }, J.prototype.neg = function(c) {
      return c.isZero() ? c.clone() : this.m.sub(c)._forceRed(this);
    }, J.prototype.add = function(c, v) {
      this._verify2(c, v);
      var $ = c.add(v);
      return $.cmp(this.m) >= 0 && $.isub(this.m), $._forceRed(this);
    }, J.prototype.iadd = function(c, v) {
      this._verify2(c, v);
      var $ = c.iadd(v);
      return $.cmp(this.m) >= 0 && $.isub(this.m), $;
    }, J.prototype.sub = function(c, v) {
      this._verify2(c, v);
      var $ = c.sub(v);
      return $.cmpn(0) < 0 && $.iadd(this.m), $._forceRed(this);
    }, J.prototype.isub = function(c, v) {
      this._verify2(c, v);
      var $ = c.isub(v);
      return $.cmpn(0) < 0 && $.iadd(this.m), $;
    }, J.prototype.shl = function(c, v) {
      return this._verify1(c), this.imod(c.ushln(v));
    }, J.prototype.imul = function(c, v) {
      return this._verify2(c, v), this.imod(c.imul(v));
    }, J.prototype.mul = function(c, v) {
      return this._verify2(c, v), this.imod(c.mul(v));
    }, J.prototype.isqr = function(c) {
      return this.imul(c, c.clone());
    }, J.prototype.sqr = function(c) {
      return this.mul(c, c);
    }, J.prototype.sqrt = function(c) {
      if (c.isZero()) return c.clone();
      var v = this.m.andln(3);
      if (a(v % 2 === 1), v === 3) {
        var $ = this.m.add(new o(1)).iushrn(2);
        return this.pow(c, $);
      }
      for (var S = this.m.subn(1), A = 0; !S.isZero() && S.andln(1) === 0; )
        A++, S.iushrn(1);
      a(!S.isZero());
      var M = new o(1).toRed(this), p = M.redNeg(), B = this.m.subn(1).iushrn(1), b = this.m.bitLength();
      for (b = new o(2 * b * b).toRed(this); this.pow(b, B).cmp(p) !== 0; )
        b.redIAdd(p);
      for (var k = this.pow(b, S), Z = this.pow(c, S.addn(1).iushrn(1)), te = this.pow(c, S), V = A; te.cmp(M) !== 0; ) {
        for (var T = te, O = 0; T.cmp(M) !== 0; O++)
          T = T.redSqr();
        a(O < V);
        var Q = this.pow(k, new o(1).iushln(V - O - 1));
        Z = Z.redMul(Q), k = Q.redSqr(), te = te.redMul(k), V = O;
      }
      return Z;
    }, J.prototype.invm = function(c) {
      var v = c._invmp(this.m);
      return v.negative !== 0 ? (v.negative = 0, this.imod(v).redNeg()) : this.imod(v);
    }, J.prototype.pow = function(c, v) {
      if (v.isZero()) return new o(1).toRed(this);
      if (v.cmpn(1) === 0) return c.clone();
      var $ = 4, S = new Array(1 << $);
      S[0] = new o(1).toRed(this), S[1] = c;
      for (var A = 2; A < S.length; A++)
        S[A] = this.mul(S[A - 1], c);
      var M = S[0], p = 0, B = 0, b = v.bitLength() % 26;
      for (b === 0 && (b = 26), A = v.length - 1; A >= 0; A--) {
        for (var k = v.words[A], Z = b - 1; Z >= 0; Z--) {
          var te = k >> Z & 1;
          if (M !== S[0] && (M = this.sqr(M)), te === 0 && p === 0) {
            B = 0;
            continue;
          }
          p <<= 1, p |= te, B++, !(B !== $ && (A !== 0 || Z !== 0)) && (M = this.mul(M, S[p]), B = 0, p = 0);
        }
        b = 26;
      }
      return M;
    }, J.prototype.convertTo = function(c) {
      var v = c.umod(this.m);
      return v === c ? v.clone() : v;
    }, J.prototype.convertFrom = function(c) {
      var v = c.clone();
      return v.red = null, v;
    }, o.mont = function(c) {
      return new w(c);
    };
    function w(m) {
      J.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    u(w, J), w.prototype.convertTo = function(c) {
      return this.imod(c.ushln(this.shift));
    }, w.prototype.convertFrom = function(c) {
      var v = this.imod(c.mul(this.rinv));
      return v.red = null, v;
    }, w.prototype.imul = function(c, v) {
      if (c.isZero() || v.isZero())
        return c.words[0] = 0, c.length = 1, c;
      var $ = c.imul(v), S = $.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = $.isub(S).iushrn(this.shift), M = A;
      return A.cmp(this.m) >= 0 ? M = A.isub(this.m) : A.cmpn(0) < 0 && (M = A.iadd(this.m)), M._forceRed(this);
    }, w.prototype.mul = function(c, v) {
      if (c.isZero() || v.isZero()) return new o(0)._forceRed(this);
      var $ = c.mul(v), S = $.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = $.isub(S).iushrn(this.shift), M = A;
      return A.cmp(this.m) >= 0 ? M = A.isub(this.m) : A.cmpn(0) < 0 && (M = A.iadd(this.m)), M._forceRed(this);
    }, w.prototype.invm = function(c) {
      var v = this.imod(c._invmp(this.m).mul(this.r2));
      return v._forceRed(this);
    };
  })(t, commonjsGlobal);
})(bn);
var bnExports = bn.exports, BN$a = bnExports, randomBytes$1 = browserExports, Buffer$7 = safeBufferExports$1.Buffer;
function getr(t) {
  var e = t.modulus.byteLength(), n;
  do
    n = new BN$a(randomBytes$1(e));
  while (n.cmp(t.modulus) >= 0 || !n.umod(t.prime1) || !n.umod(t.prime2));
  return n;
}
function blind(t) {
  var e = getr(t), n = e.toRed(BN$a.mont(t.modulus)).redPow(new BN$a(t.publicExponent)).fromRed();
  return { blinder: n, unblinder: e.invm(t.modulus) };
}
function crt$2(t, e) {
  var n = blind(e), a = e.modulus.byteLength(), u = new BN$a(t).mul(n.blinder).umod(e.modulus), o = u.toRed(BN$a.mont(e.prime1)), d = u.toRed(BN$a.mont(e.prime2)), l = e.coefficient, _ = e.prime1, P = e.prime2, h = o.redPow(e.exponent1).fromRed(), x = d.redPow(e.exponent2).fromRed(), C = h.isub(x).imul(l).umod(_).imul(P);
  return x.iadd(C).imul(n.unblinder).umod(e.modulus).toArrayLike(Buffer$7, "be", a);
}
crt$2.getr = getr;
var browserifyRsa = crt$2, elliptic = {};
const name = "elliptic", version$1 = "6.6.1", description = "EC cryptography", main = "lib/elliptic.js", files = [
  "lib"
], scripts = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author = "Fedor Indutny <fedor@indutny.com>", license = "MIT", bugs = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage = "https://github.com/indutny/elliptic", devDependencies = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0 = {
  name,
  version: version$1,
  description,
  main,
  files,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  dependencies
};
var utils$l = {}, utils$k = {};
(function(t) {
  var e = t;
  function n(o, d) {
    if (Array.isArray(o))
      return o.slice();
    if (!o)
      return [];
    var l = [];
    if (typeof o != "string") {
      for (var _ = 0; _ < o.length; _++)
        l[_] = o[_] | 0;
      return l;
    }
    if (d === "hex") {
      o = o.replace(/[^a-z0-9]+/ig, ""), o.length % 2 !== 0 && (o = "0" + o);
      for (var _ = 0; _ < o.length; _ += 2)
        l.push(parseInt(o[_] + o[_ + 1], 16));
    } else
      for (var _ = 0; _ < o.length; _++) {
        var P = o.charCodeAt(_), h = P >> 8, x = P & 255;
        h ? l.push(h, x) : l.push(x);
      }
    return l;
  }
  e.toArray = n;
  function a(o) {
    return o.length === 1 ? "0" + o : o;
  }
  e.zero2 = a;
  function u(o) {
    for (var d = "", l = 0; l < o.length; l++)
      d += a(o[l].toString(16));
    return d;
  }
  e.toHex = u, e.encode = function(d, l) {
    return l === "hex" ? u(d) : d;
  };
})(utils$k);
(function(t) {
  var e = t, n = bnExports$1, a = minimalisticAssert, u = utils$k;
  e.assert = a, e.toArray = u.toArray, e.zero2 = u.zero2, e.toHex = u.toHex, e.encode = u.encode;
  function o(h, x, C) {
    var D = new Array(Math.max(h.bitLength(), C) + 1), q;
    for (q = 0; q < D.length; q += 1)
      D[q] = 0;
    var H = 1 << x + 1, Y = h.clone();
    for (q = 0; q < D.length; q++) {
      var z, F = Y.andln(H - 1);
      Y.isOdd() ? (F > (H >> 1) - 1 ? z = (H >> 1) - F : z = F, Y.isubn(z)) : z = 0, D[q] = z, Y.iushrn(1);
    }
    return D;
  }
  e.getNAF = o;
  function d(h, x) {
    var C = [
      [],
      []
    ];
    h = h.clone(), x = x.clone();
    for (var D = 0, q = 0, H; h.cmpn(-D) > 0 || x.cmpn(-q) > 0; ) {
      var Y = h.andln(3) + D & 3, z = x.andln(3) + q & 3;
      Y === 3 && (Y = -1), z === 3 && (z = -1);
      var F;
      Y & 1 ? (H = h.andln(7) + D & 7, (H === 3 || H === 5) && z === 2 ? F = -Y : F = Y) : F = 0, C[0].push(F);
      var X;
      z & 1 ? (H = x.andln(7) + q & 7, (H === 3 || H === 5) && Y === 2 ? X = -z : X = z) : X = 0, C[1].push(X), 2 * D === F + 1 && (D = 1 - D), 2 * q === X + 1 && (q = 1 - q), h.iushrn(1), x.iushrn(1);
    }
    return C;
  }
  e.getJSF = d;
  function l(h, x, C) {
    var D = "_" + x;
    h.prototype[x] = function() {
      return this[D] !== void 0 ? this[D] : this[D] = C.call(this);
    };
  }
  e.cachedProperty = l;
  function _(h) {
    return typeof h == "string" ? e.toArray(h, "hex") : h;
  }
  e.parseBytes = _;
  function P(h) {
    return new n(h, "hex", "le");
  }
  e.intFromLE = P;
})(utils$l);
var curve = {}, BN$9 = bnExports$1, utils$j = utils$l, getNAF = utils$j.getNAF, getJSF = utils$j.getJSF, assert$d = utils$j.assert;
function BaseCurve(t, e) {
  this.type = t, this.p = new BN$9(e.p, 16), this.red = e.prime ? BN$9.red(e.prime) : BN$9.mont(this.p), this.zero = new BN$9(0).toRed(this.red), this.one = new BN$9(1).toRed(this.red), this.two = new BN$9(2).toRed(this.red), this.n = e.n && new BN$9(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var n = this.n && this.p.div(this.n);
  !n || n.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base$1 = BaseCurve;
BaseCurve.prototype.point = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function(e, n) {
  assert$d(e.precomputed);
  var a = e._getDoubles(), u = getNAF(n, 1, this._bitLength), o = (1 << a.step + 1) - (a.step % 2 === 0 ? 2 : 1);
  o /= 3;
  var d = [], l, _;
  for (l = 0; l < u.length; l += a.step) {
    _ = 0;
    for (var P = l + a.step - 1; P >= l; P--)
      _ = (_ << 1) + u[P];
    d.push(_);
  }
  for (var h = this.jpoint(null, null, null), x = this.jpoint(null, null, null), C = o; C > 0; C--) {
    for (l = 0; l < d.length; l++)
      _ = d[l], _ === C ? x = x.mixedAdd(a.points[l]) : _ === -C && (x = x.mixedAdd(a.points[l].neg()));
    h = h.add(x);
  }
  return h.toP();
};
BaseCurve.prototype._wnafMul = function(e, n) {
  var a = 4, u = e._getNAFPoints(a);
  a = u.wnd;
  for (var o = u.points, d = getNAF(n, a, this._bitLength), l = this.jpoint(null, null, null), _ = d.length - 1; _ >= 0; _--) {
    for (var P = 0; _ >= 0 && d[_] === 0; _--)
      P++;
    if (_ >= 0 && P++, l = l.dblp(P), _ < 0)
      break;
    var h = d[_];
    assert$d(h !== 0), e.type === "affine" ? h > 0 ? l = l.mixedAdd(o[h - 1 >> 1]) : l = l.mixedAdd(o[-h - 1 >> 1].neg()) : h > 0 ? l = l.add(o[h - 1 >> 1]) : l = l.add(o[-h - 1 >> 1].neg());
  }
  return e.type === "affine" ? l.toP() : l;
};
BaseCurve.prototype._wnafMulAdd = function(e, n, a, u, o) {
  var d = this._wnafT1, l = this._wnafT2, _ = this._wnafT3, P = 0, h, x, C;
  for (h = 0; h < u; h++) {
    C = n[h];
    var D = C._getNAFPoints(e);
    d[h] = D.wnd, l[h] = D.points;
  }
  for (h = u - 1; h >= 1; h -= 2) {
    var q = h - 1, H = h;
    if (d[q] !== 1 || d[H] !== 1) {
      _[q] = getNAF(a[q], d[q], this._bitLength), _[H] = getNAF(a[H], d[H], this._bitLength), P = Math.max(_[q].length, P), P = Math.max(_[H].length, P);
      continue;
    }
    var Y = [
      n[q],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      n[H]
      /* 7 */
    ];
    n[q].y.cmp(n[H].y) === 0 ? (Y[1] = n[q].add(n[H]), Y[2] = n[q].toJ().mixedAdd(n[H].neg())) : n[q].y.cmp(n[H].y.redNeg()) === 0 ? (Y[1] = n[q].toJ().mixedAdd(n[H]), Y[2] = n[q].add(n[H].neg())) : (Y[1] = n[q].toJ().mixedAdd(n[H]), Y[2] = n[q].toJ().mixedAdd(n[H].neg()));
    var z = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], F = getJSF(a[q], a[H]);
    for (P = Math.max(F[0].length, P), _[q] = new Array(P), _[H] = new Array(P), x = 0; x < P; x++) {
      var X = F[0][x] | 0, ee = F[1][x] | 0;
      _[q][x] = z[(X + 1) * 3 + (ee + 1)], _[H][x] = 0, l[q] = Y;
    }
  }
  var se = this.jpoint(null, null, null), ce = this._wnafT4;
  for (h = P; h >= 0; h--) {
    for (var le = 0; h >= 0; ) {
      var he = !0;
      for (x = 0; x < u; x++)
        ce[x] = _[x][h] | 0, ce[x] !== 0 && (he = !1);
      if (!he)
        break;
      le++, h--;
    }
    if (h >= 0 && le++, se = se.dblp(le), h < 0)
      break;
    for (x = 0; x < u; x++) {
      var oe = ce[x];
      oe !== 0 && (oe > 0 ? C = l[x][oe - 1 >> 1] : oe < 0 && (C = l[x][-oe - 1 >> 1].neg()), C.type === "affine" ? se = se.mixedAdd(C) : se = se.add(C));
    }
  }
  for (h = 0; h < u; h++)
    l[h] = null;
  return o ? se : se.toP();
};
function BasePoint(t, e) {
  this.curve = t, this.type = e, this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function(e, n) {
  e = utils$j.toArray(e, n);
  var a = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * a) {
    e[0] === 6 ? assert$d(e[e.length - 1] % 2 === 0) : e[0] === 7 && assert$d(e[e.length - 1] % 2 === 1);
    var u = this.point(
      e.slice(1, 1 + a),
      e.slice(1 + a, 1 + 2 * a)
    );
    return u;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === a)
    return this.pointFromX(e.slice(1, 1 + a), e[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function(e) {
  return this.encode(e, !0);
};
BasePoint.prototype._encode = function(e) {
  var n = this.curve.p.byteLength(), a = this.getX().toArray("be", n);
  return e ? [this.getY().isEven() ? 2 : 3].concat(a) : [4].concat(a, this.getY().toArray("be", n));
};
BasePoint.prototype.encode = function(e, n) {
  return utils$j.encode(this._encode(n), e);
};
BasePoint.prototype.precompute = function(e) {
  if (this.precomputed)
    return this;
  var n = {
    doubles: null,
    naf: null,
    beta: null
  };
  return n.naf = this._getNAFPoints(8), n.doubles = this._getDoubles(4, e), n.beta = this._getBeta(), this.precomputed = n, this;
};
BasePoint.prototype._hasDoubles = function(e) {
  if (!this.precomputed)
    return !1;
  var n = this.precomputed.doubles;
  return n ? n.points.length >= Math.ceil((e.bitLength() + 1) / n.step) : !1;
};
BasePoint.prototype._getDoubles = function(e, n) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var a = [this], u = this, o = 0; o < n; o += e) {
    for (var d = 0; d < e; d++)
      u = u.dbl();
    a.push(u);
  }
  return {
    step: e,
    points: a
  };
};
BasePoint.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var n = [this], a = (1 << e) - 1, u = a === 1 ? null : this.dbl(), o = 1; o < a; o++)
    n[o] = n[o - 1].add(u);
  return {
    wnd: e,
    points: n
  };
};
BasePoint.prototype._getBeta = function() {
  return null;
};
BasePoint.prototype.dblp = function(e) {
  for (var n = this, a = 0; a < e; a++)
    n = n.dbl();
  return n;
};
var utils$i = utils$l, BN$8 = bnExports$1, inherits$4 = inherits_browserExports, Base$2 = base$1, assert$c = utils$i.assert;
function ShortCurve(t) {
  Base$2.call(this, "short", t), this.a = new BN$8(t.a, 16).toRed(this.red), this.b = new BN$8(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits$4(ShortCurve, Base$2);
var short = ShortCurve;
ShortCurve.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var n, a;
    if (e.beta)
      n = new BN$8(e.beta, 16).toRed(this.red);
    else {
      var u = this._getEndoRoots(this.p);
      n = u[0].cmp(u[1]) < 0 ? u[0] : u[1], n = n.toRed(this.red);
    }
    if (e.lambda)
      a = new BN$8(e.lambda, 16);
    else {
      var o = this._getEndoRoots(this.n);
      this.g.mul(o[0]).x.cmp(this.g.x.redMul(n)) === 0 ? a = o[0] : (a = o[1], assert$c(this.g.mul(a).x.cmp(this.g.x.redMul(n)) === 0));
    }
    var d;
    return e.basis ? d = e.basis.map(function(l) {
      return {
        a: new BN$8(l.a, 16),
        b: new BN$8(l.b, 16)
      };
    }) : d = this._getEndoBasis(a), {
      beta: n,
      lambda: a,
      basis: d
    };
  }
};
ShortCurve.prototype._getEndoRoots = function(e) {
  var n = e === this.p ? this.red : BN$8.mont(e), a = new BN$8(2).toRed(n).redInvm(), u = a.redNeg(), o = new BN$8(3).toRed(n).redNeg().redSqrt().redMul(a), d = u.redAdd(o).fromRed(), l = u.redSub(o).fromRed();
  return [d, l];
};
ShortCurve.prototype._getEndoBasis = function(e) {
  for (var n = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), a = e, u = this.n.clone(), o = new BN$8(1), d = new BN$8(0), l = new BN$8(0), _ = new BN$8(1), P, h, x, C, D, q, H, Y = 0, z, F; a.cmpn(0) !== 0; ) {
    var X = u.div(a);
    z = u.sub(X.mul(a)), F = l.sub(X.mul(o));
    var ee = _.sub(X.mul(d));
    if (!x && z.cmp(n) < 0)
      P = H.neg(), h = o, x = z.neg(), C = F;
    else if (x && ++Y === 2)
      break;
    H = z, u = a, a = z, l = o, o = F, _ = d, d = ee;
  }
  D = z.neg(), q = F;
  var se = x.sqr().add(C.sqr()), ce = D.sqr().add(q.sqr());
  return ce.cmp(se) >= 0 && (D = P, q = h), x.negative && (x = x.neg(), C = C.neg()), D.negative && (D = D.neg(), q = q.neg()), [
    { a: x, b: C },
    { a: D, b: q }
  ];
};
ShortCurve.prototype._endoSplit = function(e) {
  var n = this.endo.basis, a = n[0], u = n[1], o = u.b.mul(e).divRound(this.n), d = a.b.neg().mul(e).divRound(this.n), l = o.mul(a.a), _ = d.mul(u.a), P = o.mul(a.b), h = d.mul(u.b), x = e.sub(l).sub(_), C = P.add(h).neg();
  return { k1: x, k2: C };
};
ShortCurve.prototype.pointFromX = function(e, n) {
  e = new BN$8(e, 16), e.red || (e = e.toRed(this.red));
  var a = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), u = a.redSqrt();
  if (u.redSqr().redSub(a).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var o = u.fromRed().isOdd();
  return (n && !o || !n && o) && (u = u.redNeg()), this.point(e, u);
};
ShortCurve.prototype.validate = function(e) {
  if (e.inf)
    return !0;
  var n = e.x, a = e.y, u = this.a.redMul(n), o = n.redSqr().redMul(n).redIAdd(u).redIAdd(this.b);
  return a.redSqr().redISub(o).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function(e, n, a) {
  for (var u = this._endoWnafT1, o = this._endoWnafT2, d = 0; d < e.length; d++) {
    var l = this._endoSplit(n[d]), _ = e[d], P = _._getBeta();
    l.k1.negative && (l.k1.ineg(), _ = _.neg(!0)), l.k2.negative && (l.k2.ineg(), P = P.neg(!0)), u[d * 2] = _, u[d * 2 + 1] = P, o[d * 2] = l.k1, o[d * 2 + 1] = l.k2;
  }
  for (var h = this._wnafMulAdd(1, u, o, d * 2, a), x = 0; x < d * 2; x++)
    u[x] = null, o[x] = null;
  return h;
};
function Point$2(t, e, n, a) {
  Base$2.BasePoint.call(this, t, "affine"), e === null && n === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$8(e, 16), this.y = new BN$8(n, 16), a && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits$4(Point$2, Base$2.BasePoint);
ShortCurve.prototype.point = function(e, n, a) {
  return new Point$2(this, e, n, a);
};
ShortCurve.prototype.pointFromJSON = function(e, n) {
  return Point$2.fromJSON(this, e, n);
};
Point$2.prototype._getBeta = function() {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var n = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var a = this.curve, u = function(o) {
        return a.point(o.x.redMul(a.endo.beta), o.y);
      };
      e.beta = n, n.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(u)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(u)
        }
      };
    }
    return n;
  }
};
Point$2.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point$2.fromJSON = function(e, n, a) {
  typeof n == "string" && (n = JSON.parse(n));
  var u = e.point(n[0], n[1], a);
  if (!n[2])
    return u;
  function o(l) {
    return e.point(l[0], l[1], a);
  }
  var d = n[2];
  return u.precomputed = {
    beta: null,
    doubles: d.doubles && {
      step: d.doubles.step,
      points: [u].concat(d.doubles.points.map(o))
    },
    naf: d.naf && {
      wnd: d.naf.wnd,
      points: [u].concat(d.naf.points.map(o))
    }
  }, u;
};
Point$2.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function() {
  return this.inf;
};
Point$2.prototype.add = function(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var n = this.y.redSub(e.y);
  n.cmpn(0) !== 0 && (n = n.redMul(this.x.redSub(e.x).redInvm()));
  var a = n.redSqr().redISub(this.x).redISub(e.x), u = n.redMul(this.x.redSub(a)).redISub(this.y);
  return this.curve.point(a, u);
};
Point$2.prototype.dbl = function() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var n = this.curve.a, a = this.x.redSqr(), u = e.redInvm(), o = a.redAdd(a).redIAdd(a).redIAdd(n).redMul(u), d = o.redSqr().redISub(this.x.redAdd(this.x)), l = o.redMul(this.x.redSub(d)).redISub(this.y);
  return this.curve.point(d, l);
};
Point$2.prototype.getX = function() {
  return this.x.fromRed();
};
Point$2.prototype.getY = function() {
  return this.y.fromRed();
};
Point$2.prototype.mul = function(e) {
  return e = new BN$8(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
Point$2.prototype.mulAdd = function(e, n, a) {
  var u = [this, n], o = [e, a];
  return this.curve.endo ? this.curve._endoWnafMulAdd(u, o) : this.curve._wnafMulAdd(1, u, o, 2);
};
Point$2.prototype.jmulAdd = function(e, n, a) {
  var u = [this, n], o = [e, a];
  return this.curve.endo ? this.curve._endoWnafMulAdd(u, o, !0) : this.curve._wnafMulAdd(1, u, o, 2, !0);
};
Point$2.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
Point$2.prototype.neg = function(e) {
  if (this.inf)
    return this;
  var n = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var a = this.precomputed, u = function(o) {
      return o.neg();
    };
    n.precomputed = {
      naf: a.naf && {
        wnd: a.naf.wnd,
        points: a.naf.points.map(u)
      },
      doubles: a.doubles && {
        step: a.doubles.step,
        points: a.doubles.points.map(u)
      }
    };
  }
  return n;
};
Point$2.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function JPoint(t, e, n, a) {
  Base$2.BasePoint.call(this, t, "jacobian"), e === null && n === null && a === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$8(0)) : (this.x = new BN$8(e, 16), this.y = new BN$8(n, 16), this.z = new BN$8(a, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits$4(JPoint, Base$2.BasePoint);
ShortCurve.prototype.jpoint = function(e, n, a) {
  return new JPoint(this, e, n, a);
};
JPoint.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), n = e.redSqr(), a = this.x.redMul(n), u = this.y.redMul(n).redMul(e);
  return this.curve.point(a, u);
};
JPoint.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var n = e.z.redSqr(), a = this.z.redSqr(), u = this.x.redMul(n), o = e.x.redMul(a), d = this.y.redMul(n.redMul(e.z)), l = e.y.redMul(a.redMul(this.z)), _ = u.redSub(o), P = d.redSub(l);
  if (_.cmpn(0) === 0)
    return P.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var h = _.redSqr(), x = h.redMul(_), C = u.redMul(h), D = P.redSqr().redIAdd(x).redISub(C).redISub(C), q = P.redMul(C.redISub(D)).redISub(d.redMul(x)), H = this.z.redMul(e.z).redMul(_);
  return this.curve.jpoint(D, q, H);
};
JPoint.prototype.mixedAdd = function(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var n = this.z.redSqr(), a = this.x, u = e.x.redMul(n), o = this.y, d = e.y.redMul(n).redMul(this.z), l = a.redSub(u), _ = o.redSub(d);
  if (l.cmpn(0) === 0)
    return _.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var P = l.redSqr(), h = P.redMul(l), x = a.redMul(P), C = _.redSqr().redIAdd(h).redISub(x).redISub(x), D = _.redMul(x.redISub(C)).redISub(o.redMul(h)), q = this.z.redMul(l);
  return this.curve.jpoint(C, D, q);
};
JPoint.prototype.dblp = function(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var n;
  if (this.curve.zeroA || this.curve.threeA) {
    var a = this;
    for (n = 0; n < e; n++)
      a = a.dbl();
    return a;
  }
  var u = this.curve.a, o = this.curve.tinv, d = this.x, l = this.y, _ = this.z, P = _.redSqr().redSqr(), h = l.redAdd(l);
  for (n = 0; n < e; n++) {
    var x = d.redSqr(), C = h.redSqr(), D = C.redSqr(), q = x.redAdd(x).redIAdd(x).redIAdd(u.redMul(P)), H = d.redMul(C), Y = q.redSqr().redISub(H.redAdd(H)), z = H.redISub(Y), F = q.redMul(z);
    F = F.redIAdd(F).redISub(D);
    var X = h.redMul(_);
    n + 1 < e && (P = P.redMul(D)), d = Y, _ = X, h = F;
  }
  return this.curve.jpoint(d, h.redMul(o), _);
};
JPoint.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint.prototype._zeroDbl = function() {
  var e, n, a;
  if (this.zOne) {
    var u = this.x.redSqr(), o = this.y.redSqr(), d = o.redSqr(), l = this.x.redAdd(o).redSqr().redISub(u).redISub(d);
    l = l.redIAdd(l);
    var _ = u.redAdd(u).redIAdd(u), P = _.redSqr().redISub(l).redISub(l), h = d.redIAdd(d);
    h = h.redIAdd(h), h = h.redIAdd(h), e = P, n = _.redMul(l.redISub(P)).redISub(h), a = this.y.redAdd(this.y);
  } else {
    var x = this.x.redSqr(), C = this.y.redSqr(), D = C.redSqr(), q = this.x.redAdd(C).redSqr().redISub(x).redISub(D);
    q = q.redIAdd(q);
    var H = x.redAdd(x).redIAdd(x), Y = H.redSqr(), z = D.redIAdd(D);
    z = z.redIAdd(z), z = z.redIAdd(z), e = Y.redISub(q).redISub(q), n = H.redMul(q.redISub(e)).redISub(z), a = this.y.redMul(this.z), a = a.redIAdd(a);
  }
  return this.curve.jpoint(e, n, a);
};
JPoint.prototype._threeDbl = function() {
  var e, n, a;
  if (this.zOne) {
    var u = this.x.redSqr(), o = this.y.redSqr(), d = o.redSqr(), l = this.x.redAdd(o).redSqr().redISub(u).redISub(d);
    l = l.redIAdd(l);
    var _ = u.redAdd(u).redIAdd(u).redIAdd(this.curve.a), P = _.redSqr().redISub(l).redISub(l);
    e = P;
    var h = d.redIAdd(d);
    h = h.redIAdd(h), h = h.redIAdd(h), n = _.redMul(l.redISub(P)).redISub(h), a = this.y.redAdd(this.y);
  } else {
    var x = this.z.redSqr(), C = this.y.redSqr(), D = this.x.redMul(C), q = this.x.redSub(x).redMul(this.x.redAdd(x));
    q = q.redAdd(q).redIAdd(q);
    var H = D.redIAdd(D);
    H = H.redIAdd(H);
    var Y = H.redAdd(H);
    e = q.redSqr().redISub(Y), a = this.y.redAdd(this.z).redSqr().redISub(C).redISub(x);
    var z = C.redSqr();
    z = z.redIAdd(z), z = z.redIAdd(z), z = z.redIAdd(z), n = q.redMul(H.redISub(e)).redISub(z);
  }
  return this.curve.jpoint(e, n, a);
};
JPoint.prototype._dbl = function() {
  var e = this.curve.a, n = this.x, a = this.y, u = this.z, o = u.redSqr().redSqr(), d = n.redSqr(), l = a.redSqr(), _ = d.redAdd(d).redIAdd(d).redIAdd(e.redMul(o)), P = n.redAdd(n);
  P = P.redIAdd(P);
  var h = P.redMul(l), x = _.redSqr().redISub(h.redAdd(h)), C = h.redISub(x), D = l.redSqr();
  D = D.redIAdd(D), D = D.redIAdd(D), D = D.redIAdd(D);
  var q = _.redMul(C).redISub(D), H = a.redAdd(a).redMul(u);
  return this.curve.jpoint(x, q, H);
};
JPoint.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), n = this.y.redSqr(), a = this.z.redSqr(), u = n.redSqr(), o = e.redAdd(e).redIAdd(e), d = o.redSqr(), l = this.x.redAdd(n).redSqr().redISub(e).redISub(u);
  l = l.redIAdd(l), l = l.redAdd(l).redIAdd(l), l = l.redISub(d);
  var _ = l.redSqr(), P = u.redIAdd(u);
  P = P.redIAdd(P), P = P.redIAdd(P), P = P.redIAdd(P);
  var h = o.redIAdd(l).redSqr().redISub(d).redISub(_).redISub(P), x = n.redMul(h);
  x = x.redIAdd(x), x = x.redIAdd(x);
  var C = this.x.redMul(_).redISub(x);
  C = C.redIAdd(C), C = C.redIAdd(C);
  var D = this.y.redMul(h.redMul(P.redISub(h)).redISub(l.redMul(_)));
  D = D.redIAdd(D), D = D.redIAdd(D), D = D.redIAdd(D);
  var q = this.z.redAdd(l).redSqr().redISub(a).redISub(_);
  return this.curve.jpoint(C, D, q);
};
JPoint.prototype.mul = function(e, n) {
  return e = new BN$8(e, n), this.curve._wnafMul(this, e);
};
JPoint.prototype.eq = function(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var n = this.z.redSqr(), a = e.z.redSqr();
  if (this.x.redMul(a).redISub(e.x.redMul(n)).cmpn(0) !== 0)
    return !1;
  var u = n.redMul(this.z), o = a.redMul(e.z);
  return this.y.redMul(o).redISub(e.y.redMul(u)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function(e) {
  var n = this.z.redSqr(), a = e.toRed(this.curve.red).redMul(n);
  if (this.x.cmp(a) === 0)
    return !0;
  for (var u = e.clone(), o = this.curve.redN.redMul(n); ; ) {
    if (u.iadd(this.curve.n), u.cmp(this.curve.p) >= 0)
      return !1;
    if (a.redIAdd(o), this.x.cmp(a) === 0)
      return !0;
  }
};
JPoint.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var BN$7 = bnExports$1, inherits$3 = inherits_browserExports, Base$1 = base$1, utils$h = utils$l;
function MontCurve(t) {
  Base$1.call(this, "mont", t), this.a = new BN$7(t.a, 16).toRed(this.red), this.b = new BN$7(t.b, 16).toRed(this.red), this.i4 = new BN$7(4).toRed(this.red).redInvm(), this.two = new BN$7(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$3(MontCurve, Base$1);
var mont = MontCurve;
MontCurve.prototype.validate = function(e) {
  var n = e.normalize().x, a = n.redSqr(), u = a.redMul(n).redAdd(a.redMul(this.a)).redAdd(n), o = u.redSqrt();
  return o.redSqr().cmp(u) === 0;
};
function Point$1(t, e, n) {
  Base$1.BasePoint.call(this, t, "projective"), e === null && n === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN$7(e, 16), this.z = new BN$7(n, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
inherits$3(Point$1, Base$1.BasePoint);
MontCurve.prototype.decodePoint = function(e, n) {
  return this.point(utils$h.toArray(e, n), 1);
};
MontCurve.prototype.point = function(e, n) {
  return new Point$1(this, e, n);
};
MontCurve.prototype.pointFromJSON = function(e) {
  return Point$1.fromJSON(this, e);
};
Point$1.prototype.precompute = function() {
};
Point$1.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$1.fromJSON = function(e, n) {
  return new Point$1(e, n[0], n[1] || e.one);
};
Point$1.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
Point$1.prototype.dbl = function() {
  var e = this.x.redAdd(this.z), n = e.redSqr(), a = this.x.redSub(this.z), u = a.redSqr(), o = n.redSub(u), d = n.redMul(u), l = o.redMul(u.redAdd(this.curve.a24.redMul(o)));
  return this.curve.point(d, l);
};
Point$1.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.diffAdd = function(e, n) {
  var a = this.x.redAdd(this.z), u = this.x.redSub(this.z), o = e.x.redAdd(e.z), d = e.x.redSub(e.z), l = d.redMul(a), _ = o.redMul(u), P = n.z.redMul(l.redAdd(_).redSqr()), h = n.x.redMul(l.redISub(_).redSqr());
  return this.curve.point(P, h);
};
Point$1.prototype.mul = function(e) {
  for (var n = e.clone(), a = this, u = this.curve.point(null, null), o = this, d = []; n.cmpn(0) !== 0; n.iushrn(1))
    d.push(n.andln(1));
  for (var l = d.length - 1; l >= 0; l--)
    d[l] === 0 ? (a = a.diffAdd(u, o), u = u.dbl()) : (u = a.diffAdd(u, o), a = a.dbl());
  return u;
};
Point$1.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.eq = function(e) {
  return this.getX().cmp(e.getX()) === 0;
};
Point$1.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Point$1.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var utils$g = utils$l, BN$6 = bnExports$1, inherits$2 = inherits_browserExports, Base = base$1, assert$b = utils$g.assert;
function EdwardsCurve(t) {
  this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, Base.call(this, "edwards", t), this.a = new BN$6(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN$6(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN$6(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert$b(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
}
inherits$2(EdwardsCurve, Base);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function(e) {
  return this.mOneA ? e.redNeg() : this.a.redMul(e);
};
EdwardsCurve.prototype._mulC = function(e) {
  return this.oneC ? e : this.c.redMul(e);
};
EdwardsCurve.prototype.jpoint = function(e, n, a, u) {
  return this.point(e, n, a, u);
};
EdwardsCurve.prototype.pointFromX = function(e, n) {
  e = new BN$6(e, 16), e.red || (e = e.toRed(this.red));
  var a = e.redSqr(), u = this.c2.redSub(this.a.redMul(a)), o = this.one.redSub(this.c2.redMul(this.d).redMul(a)), d = u.redMul(o.redInvm()), l = d.redSqrt();
  if (l.redSqr().redSub(d).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var _ = l.fromRed().isOdd();
  return (n && !_ || !n && _) && (l = l.redNeg()), this.point(e, l);
};
EdwardsCurve.prototype.pointFromY = function(e, n) {
  e = new BN$6(e, 16), e.red || (e = e.toRed(this.red));
  var a = e.redSqr(), u = a.redSub(this.c2), o = a.redMul(this.d).redMul(this.c2).redSub(this.a), d = u.redMul(o.redInvm());
  if (d.cmp(this.zero) === 0) {
    if (n)
      throw new Error("invalid point");
    return this.point(this.zero, e);
  }
  var l = d.redSqrt();
  if (l.redSqr().redSub(d).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return l.fromRed().isOdd() !== n && (l = l.redNeg()), this.point(l, e);
};
EdwardsCurve.prototype.validate = function(e) {
  if (e.isInfinity())
    return !0;
  e.normalize();
  var n = e.x.redSqr(), a = e.y.redSqr(), u = n.redMul(this.a).redAdd(a), o = this.c2.redMul(this.one.redAdd(this.d.redMul(n).redMul(a)));
  return u.cmp(o) === 0;
};
function Point(t, e, n, a, u) {
  Base.BasePoint.call(this, t, "projective"), e === null && n === null && a === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN$6(e, 16), this.y = new BN$6(n, 16), this.z = a ? new BN$6(a, 16) : this.curve.one, this.t = u && new BN$6(u, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
inherits$2(Point, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function(e) {
  return Point.fromJSON(this, e);
};
EdwardsCurve.prototype.point = function(e, n, a, u) {
  return new Point(this, e, n, a, u);
};
Point.fromJSON = function(e, n) {
  return new Point(e, n[0], n[1], n[2]);
};
Point.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function() {
  var e = this.x.redSqr(), n = this.y.redSqr(), a = this.z.redSqr();
  a = a.redIAdd(a);
  var u = this.curve._mulA(e), o = this.x.redAdd(this.y).redSqr().redISub(e).redISub(n), d = u.redAdd(n), l = d.redSub(a), _ = u.redSub(n), P = o.redMul(l), h = d.redMul(_), x = o.redMul(_), C = l.redMul(d);
  return this.curve.point(P, h, C, x);
};
Point.prototype._projDbl = function() {
  var e = this.x.redAdd(this.y).redSqr(), n = this.x.redSqr(), a = this.y.redSqr(), u, o, d, l, _, P;
  if (this.curve.twisted) {
    l = this.curve._mulA(n);
    var h = l.redAdd(a);
    this.zOne ? (u = e.redSub(n).redSub(a).redMul(h.redSub(this.curve.two)), o = h.redMul(l.redSub(a)), d = h.redSqr().redSub(h).redSub(h)) : (_ = this.z.redSqr(), P = h.redSub(_).redISub(_), u = e.redSub(n).redISub(a).redMul(P), o = h.redMul(l.redSub(a)), d = h.redMul(P));
  } else
    l = n.redAdd(a), _ = this.curve._mulC(this.z).redSqr(), P = l.redSub(_).redSub(_), u = this.curve._mulC(e.redISub(l)).redMul(P), o = this.curve._mulC(l).redMul(n.redISub(a)), d = l.redMul(P);
  return this.curve.point(u, o, d);
};
Point.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
Point.prototype._extAdd = function(e) {
  var n = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), a = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), u = this.t.redMul(this.curve.dd).redMul(e.t), o = this.z.redMul(e.z.redAdd(e.z)), d = a.redSub(n), l = o.redSub(u), _ = o.redAdd(u), P = a.redAdd(n), h = d.redMul(l), x = _.redMul(P), C = d.redMul(P), D = l.redMul(_);
  return this.curve.point(h, x, D, C);
};
Point.prototype._projAdd = function(e) {
  var n = this.z.redMul(e.z), a = n.redSqr(), u = this.x.redMul(e.x), o = this.y.redMul(e.y), d = this.curve.d.redMul(u).redMul(o), l = a.redSub(d), _ = a.redAdd(d), P = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(u).redISub(o), h = n.redMul(l).redMul(P), x, C;
  return this.curve.twisted ? (x = n.redMul(_).redMul(o.redSub(this.curve._mulA(u))), C = l.redMul(_)) : (x = n.redMul(_).redMul(o.redSub(u)), C = this.curve._mulC(l).redMul(_)), this.curve.point(h, x, C);
};
Point.prototype.add = function(e) {
  return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
};
Point.prototype.mul = function(e) {
  return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
};
Point.prototype.mulAdd = function(e, n, a) {
  return this.curve._wnafMulAdd(1, [this, n], [e, a], 2, !1);
};
Point.prototype.jmulAdd = function(e, n, a) {
  return this.curve._wnafMulAdd(1, [this, n], [e, a], 2, !0);
};
Point.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var e = this.z.redInvm();
  return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this;
};
Point.prototype.neg = function() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
Point.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
Point.prototype.eq = function(e) {
  return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
};
Point.prototype.eqXToP = function(e) {
  var n = e.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(n) === 0)
    return !0;
  for (var a = e.clone(), u = this.curve.redN.redMul(this.z); ; ) {
    if (a.iadd(this.curve.n), a.cmp(this.curve.p) >= 0)
      return !1;
    if (n.redIAdd(u), this.x.cmp(n) === 0)
      return !0;
  }
};
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;
(function(t) {
  var e = t;
  e.base = base$1, e.short = short, e.mont = mont, e.edwards = edwards;
})(curve);
var curves$1 = {}, hash$2 = {}, utils$f = {}, assert$a = minimalisticAssert, inherits$1 = inherits_browserExports;
utils$f.inherits = inherits$1;
function isSurrogatePair(t, e) {
  return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? !1 : (t.charCodeAt(e + 1) & 64512) === 56320;
}
function toArray(t, e) {
  if (Array.isArray(t))
    return t.slice();
  if (!t)
    return [];
  var n = [];
  if (typeof t == "string")
    if (e) {
      if (e === "hex")
        for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), u = 0; u < t.length; u += 2)
          n.push(parseInt(t[u] + t[u + 1], 16));
    } else for (var a = 0, u = 0; u < t.length; u++) {
      var o = t.charCodeAt(u);
      o < 128 ? n[a++] = o : o < 2048 ? (n[a++] = o >> 6 | 192, n[a++] = o & 63 | 128) : isSurrogatePair(t, u) ? (o = 65536 + ((o & 1023) << 10) + (t.charCodeAt(++u) & 1023), n[a++] = o >> 18 | 240, n[a++] = o >> 12 & 63 | 128, n[a++] = o >> 6 & 63 | 128, n[a++] = o & 63 | 128) : (n[a++] = o >> 12 | 224, n[a++] = o >> 6 & 63 | 128, n[a++] = o & 63 | 128);
    }
  else
    for (u = 0; u < t.length; u++)
      n[u] = t[u] | 0;
  return n;
}
utils$f.toArray = toArray;
function toHex(t) {
  for (var e = "", n = 0; n < t.length; n++)
    e += zero2(t[n].toString(16));
  return e;
}
utils$f.toHex = toHex;
function htonl(t) {
  var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
  return e >>> 0;
}
utils$f.htonl = htonl;
function toHex32(t, e) {
  for (var n = "", a = 0; a < t.length; a++) {
    var u = t[a];
    e === "little" && (u = htonl(u)), n += zero8(u.toString(16));
  }
  return n;
}
utils$f.toHex32 = toHex32;
function zero2(t) {
  return t.length === 1 ? "0" + t : t;
}
utils$f.zero2 = zero2;
function zero8(t) {
  return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
}
utils$f.zero8 = zero8;
function join32(t, e, n, a) {
  var u = n - e;
  assert$a(u % 4 === 0);
  for (var o = new Array(u / 4), d = 0, l = e; d < o.length; d++, l += 4) {
    var _;
    a === "big" ? _ = t[l] << 24 | t[l + 1] << 16 | t[l + 2] << 8 | t[l + 3] : _ = t[l + 3] << 24 | t[l + 2] << 16 | t[l + 1] << 8 | t[l], o[d] = _ >>> 0;
  }
  return o;
}
utils$f.join32 = join32;
function split32(t, e) {
  for (var n = new Array(t.length * 4), a = 0, u = 0; a < t.length; a++, u += 4) {
    var o = t[a];
    e === "big" ? (n[u] = o >>> 24, n[u + 1] = o >>> 16 & 255, n[u + 2] = o >>> 8 & 255, n[u + 3] = o & 255) : (n[u + 3] = o >>> 24, n[u + 2] = o >>> 16 & 255, n[u + 1] = o >>> 8 & 255, n[u] = o & 255);
  }
  return n;
}
utils$f.split32 = split32;
function rotr32$1(t, e) {
  return t >>> e | t << 32 - e;
}
utils$f.rotr32 = rotr32$1;
function rotl32$2(t, e) {
  return t << e | t >>> 32 - e;
}
utils$f.rotl32 = rotl32$2;
function sum32$3(t, e) {
  return t + e >>> 0;
}
utils$f.sum32 = sum32$3;
function sum32_3$1(t, e, n) {
  return t + e + n >>> 0;
}
utils$f.sum32_3 = sum32_3$1;
function sum32_4$2(t, e, n, a) {
  return t + e + n + a >>> 0;
}
utils$f.sum32_4 = sum32_4$2;
function sum32_5$2(t, e, n, a, u) {
  return t + e + n + a + u >>> 0;
}
utils$f.sum32_5 = sum32_5$2;
function sum64$1(t, e, n, a) {
  var u = t[e], o = t[e + 1], d = a + o >>> 0, l = (d < a ? 1 : 0) + n + u;
  t[e] = l >>> 0, t[e + 1] = d;
}
utils$f.sum64 = sum64$1;
function sum64_hi$1(t, e, n, a) {
  var u = e + a >>> 0, o = (u < e ? 1 : 0) + t + n;
  return o >>> 0;
}
utils$f.sum64_hi = sum64_hi$1;
function sum64_lo$1(t, e, n, a) {
  var u = e + a;
  return u >>> 0;
}
utils$f.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(t, e, n, a, u, o, d, l) {
  var _ = 0, P = e;
  P = P + a >>> 0, _ += P < e ? 1 : 0, P = P + o >>> 0, _ += P < o ? 1 : 0, P = P + l >>> 0, _ += P < l ? 1 : 0;
  var h = t + n + u + d + _;
  return h >>> 0;
}
utils$f.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(t, e, n, a, u, o, d, l) {
  var _ = e + a + o + l;
  return _ >>> 0;
}
utils$f.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(t, e, n, a, u, o, d, l, _, P) {
  var h = 0, x = e;
  x = x + a >>> 0, h += x < e ? 1 : 0, x = x + o >>> 0, h += x < o ? 1 : 0, x = x + l >>> 0, h += x < l ? 1 : 0, x = x + P >>> 0, h += x < P ? 1 : 0;
  var C = t + n + u + d + _ + h;
  return C >>> 0;
}
utils$f.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(t, e, n, a, u, o, d, l, _, P) {
  var h = e + a + o + l + P;
  return h >>> 0;
}
utils$f.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(t, e, n) {
  var a = e << 32 - n | t >>> n;
  return a >>> 0;
}
utils$f.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(t, e, n) {
  var a = t << 32 - n | e >>> n;
  return a >>> 0;
}
utils$f.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(t, e, n) {
  return t >>> n;
}
utils$f.shr64_hi = shr64_hi$1;
function shr64_lo$1(t, e, n) {
  var a = t << 32 - n | e >>> n;
  return a >>> 0;
}
utils$f.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$e = utils$f, assert$9 = minimalisticAssert;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function(e, n) {
  if (e = utils$e.toArray(e, n), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
    e = this.pending;
    var a = e.length % this._delta8;
    this.pending = e.slice(e.length - a, e.length), this.pending.length === 0 && (this.pending = null), e = utils$e.join32(e, 0, e.length - a, this.endian);
    for (var u = 0; u < e.length; u += this._delta32)
      this._update(e, u, u + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function(e) {
  return this.update(this._pad()), assert$9(this.pending === null), this._digest(e);
};
BlockHash$4.prototype._pad = function() {
  var e = this.pendingTotal, n = this._delta8, a = n - (e + this.padLength) % n, u = new Array(a + this.padLength);
  u[0] = 128;
  for (var o = 1; o < a; o++)
    u[o] = 0;
  if (e <<= 3, this.endian === "big") {
    for (var d = 8; d < this.padLength; d++)
      u[o++] = 0;
    u[o++] = 0, u[o++] = 0, u[o++] = 0, u[o++] = 0, u[o++] = e >>> 24 & 255, u[o++] = e >>> 16 & 255, u[o++] = e >>> 8 & 255, u[o++] = e & 255;
  } else
    for (u[o++] = e & 255, u[o++] = e >>> 8 & 255, u[o++] = e >>> 16 & 255, u[o++] = e >>> 24 & 255, u[o++] = 0, u[o++] = 0, u[o++] = 0, u[o++] = 0, d = 8; d < this.padLength; d++)
      u[o++] = 0;
  return u;
};
var sha = {}, common$4 = {}, utils$d = utils$f, rotr32 = utils$d.rotr32;
function ft_1$1(t, e, n, a) {
  if (t === 0)
    return ch32$1(e, n, a);
  if (t === 1 || t === 3)
    return p32(e, n, a);
  if (t === 2)
    return maj32$1(e, n, a);
}
common$4.ft_1 = ft_1$1;
function ch32$1(t, e, n) {
  return t & e ^ ~t & n;
}
common$4.ch32 = ch32$1;
function maj32$1(t, e, n) {
  return t & e ^ t & n ^ e & n;
}
common$4.maj32 = maj32$1;
function p32(t, e, n) {
  return t ^ e ^ n;
}
common$4.p32 = p32;
function s0_256$1(t) {
  return rotr32(t, 2) ^ rotr32(t, 13) ^ rotr32(t, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(t) {
  return rotr32(t, 6) ^ rotr32(t, 11) ^ rotr32(t, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(t) {
  return rotr32(t, 7) ^ rotr32(t, 18) ^ t >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(t) {
  return rotr32(t, 17) ^ rotr32(t, 19) ^ t >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$c = utils$f, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$c.rotl32, sum32$2 = utils$c.sum32, sum32_5$1 = utils$c.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
utils$c.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function(e, n) {
  for (var a = this.W, u = 0; u < 16; u++)
    a[u] = e[n + u];
  for (; u < a.length; u++)
    a[u] = rotl32$1(a[u - 3] ^ a[u - 8] ^ a[u - 14] ^ a[u - 16], 1);
  var o = this.h[0], d = this.h[1], l = this.h[2], _ = this.h[3], P = this.h[4];
  for (u = 0; u < a.length; u++) {
    var h = ~~(u / 20), x = sum32_5$1(rotl32$1(o, 5), ft_1(h, d, l, _), P, a[u], sha1_K[h]);
    P = _, _ = l, l = rotl32$1(d, 30), d = o, o = x;
  }
  this.h[0] = sum32$2(this.h[0], o), this.h[1] = sum32$2(this.h[1], d), this.h[2] = sum32$2(this.h[2], l), this.h[3] = sum32$2(this.h[3], _), this.h[4] = sum32$2(this.h[4], P);
};
SHA1.prototype._digest = function(e) {
  return e === "hex" ? utils$c.toHex32(this.h, "big") : utils$c.split32(this.h, "big");
};
var utils$b = utils$f, common$2 = common$5, shaCommon = common$4, assert$8 = minimalisticAssert, sum32$1 = utils$b.sum32, sum32_4$1 = utils$b.sum32_4, sum32_5 = utils$b.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = sha256_K, this.W = new Array(64);
}
utils$b.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function(e, n) {
  for (var a = this.W, u = 0; u < 16; u++)
    a[u] = e[n + u];
  for (; u < a.length; u++)
    a[u] = sum32_4$1(g1_256(a[u - 2]), a[u - 7], g0_256(a[u - 15]), a[u - 16]);
  var o = this.h[0], d = this.h[1], l = this.h[2], _ = this.h[3], P = this.h[4], h = this.h[5], x = this.h[6], C = this.h[7];
  for (assert$8(this.k.length === a.length), u = 0; u < a.length; u++) {
    var D = sum32_5(C, s1_256(P), ch32(P, h, x), this.k[u], a[u]), q = sum32$1(s0_256(o), maj32(o, d, l));
    C = x, x = h, h = P, P = sum32$1(_, D), _ = l, l = d, d = o, o = sum32$1(D, q);
  }
  this.h[0] = sum32$1(this.h[0], o), this.h[1] = sum32$1(this.h[1], d), this.h[2] = sum32$1(this.h[2], l), this.h[3] = sum32$1(this.h[3], _), this.h[4] = sum32$1(this.h[4], P), this.h[5] = sum32$1(this.h[5], h), this.h[6] = sum32$1(this.h[6], x), this.h[7] = sum32$1(this.h[7], C);
};
SHA256$1.prototype._digest = function(e) {
  return e === "hex" ? utils$b.toHex32(this.h, "big") : utils$b.split32(this.h, "big");
};
var utils$a = utils$f, SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$a.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function(e) {
  return e === "hex" ? utils$a.toHex32(this.h.slice(0, 7), "big") : utils$a.split32(this.h.slice(0, 7), "big");
};
var utils$9 = utils$f, common$1 = common$5, assert$7 = minimalisticAssert, rotr64_hi = utils$9.rotr64_hi, rotr64_lo = utils$9.rotr64_lo, shr64_hi = utils$9.shr64_hi, shr64_lo = utils$9.shr64_lo, sum64 = utils$9.sum64, sum64_hi = utils$9.sum64_hi, sum64_lo = utils$9.sum64_lo, sum64_4_hi = utils$9.sum64_4_hi, sum64_4_lo = utils$9.sum64_4_lo, sum64_5_hi = utils$9.sum64_5_hi, sum64_5_lo = utils$9.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = sha512_K, this.W = new Array(160);
}
utils$9.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function(e, n) {
  for (var a = this.W, u = 0; u < 32; u++)
    a[u] = e[n + u];
  for (; u < a.length; u += 2) {
    var o = g1_512_hi(a[u - 4], a[u - 3]), d = g1_512_lo(a[u - 4], a[u - 3]), l = a[u - 14], _ = a[u - 13], P = g0_512_hi(a[u - 30], a[u - 29]), h = g0_512_lo(a[u - 30], a[u - 29]), x = a[u - 32], C = a[u - 31];
    a[u] = sum64_4_hi(
      o,
      d,
      l,
      _,
      P,
      h,
      x,
      C
    ), a[u + 1] = sum64_4_lo(
      o,
      d,
      l,
      _,
      P,
      h,
      x,
      C
    );
  }
};
SHA512$1.prototype._update = function(e, n) {
  this._prepareBlock(e, n);
  var a = this.W, u = this.h[0], o = this.h[1], d = this.h[2], l = this.h[3], _ = this.h[4], P = this.h[5], h = this.h[6], x = this.h[7], C = this.h[8], D = this.h[9], q = this.h[10], H = this.h[11], Y = this.h[12], z = this.h[13], F = this.h[14], X = this.h[15];
  assert$7(this.k.length === a.length);
  for (var ee = 0; ee < a.length; ee += 2) {
    var se = F, ce = X, le = s1_512_hi(C, D), he = s1_512_lo(C, D), oe = ch64_hi(C, D, q, H, Y), _e = ch64_lo(C, D, q, H, Y, z), J = this.k[ee], w = this.k[ee + 1], m = a[ee], c = a[ee + 1], v = sum64_5_hi(
      se,
      ce,
      le,
      he,
      oe,
      _e,
      J,
      w,
      m,
      c
    ), $ = sum64_5_lo(
      se,
      ce,
      le,
      he,
      oe,
      _e,
      J,
      w,
      m,
      c
    );
    se = s0_512_hi(u, o), ce = s0_512_lo(u, o), le = maj64_hi(u, o, d, l, _), he = maj64_lo(u, o, d, l, _, P);
    var S = sum64_hi(se, ce, le, he), A = sum64_lo(se, ce, le, he);
    F = Y, X = z, Y = q, z = H, q = C, H = D, C = sum64_hi(h, x, v, $), D = sum64_lo(x, x, v, $), h = _, x = P, _ = d, P = l, d = u, l = o, u = sum64_hi(v, $, S, A), o = sum64_lo(v, $, S, A);
  }
  sum64(this.h, 0, u, o), sum64(this.h, 2, d, l), sum64(this.h, 4, _, P), sum64(this.h, 6, h, x), sum64(this.h, 8, C, D), sum64(this.h, 10, q, H), sum64(this.h, 12, Y, z), sum64(this.h, 14, F, X);
};
SHA512$1.prototype._digest = function(e) {
  return e === "hex" ? utils$9.toHex32(this.h, "big") : utils$9.split32(this.h, "big");
};
function ch64_hi(t, e, n, a, u) {
  var o = t & n ^ ~t & u;
  return o < 0 && (o += 4294967296), o;
}
function ch64_lo(t, e, n, a, u, o) {
  var d = e & a ^ ~e & o;
  return d < 0 && (d += 4294967296), d;
}
function maj64_hi(t, e, n, a, u) {
  var o = t & n ^ t & u ^ n & u;
  return o < 0 && (o += 4294967296), o;
}
function maj64_lo(t, e, n, a, u, o) {
  var d = e & a ^ e & o ^ a & o;
  return d < 0 && (d += 4294967296), d;
}
function s0_512_hi(t, e) {
  var n = rotr64_hi(t, e, 28), a = rotr64_hi(e, t, 2), u = rotr64_hi(e, t, 7), o = n ^ a ^ u;
  return o < 0 && (o += 4294967296), o;
}
function s0_512_lo(t, e) {
  var n = rotr64_lo(t, e, 28), a = rotr64_lo(e, t, 2), u = rotr64_lo(e, t, 7), o = n ^ a ^ u;
  return o < 0 && (o += 4294967296), o;
}
function s1_512_hi(t, e) {
  var n = rotr64_hi(t, e, 14), a = rotr64_hi(t, e, 18), u = rotr64_hi(e, t, 9), o = n ^ a ^ u;
  return o < 0 && (o += 4294967296), o;
}
function s1_512_lo(t, e) {
  var n = rotr64_lo(t, e, 14), a = rotr64_lo(t, e, 18), u = rotr64_lo(e, t, 9), o = n ^ a ^ u;
  return o < 0 && (o += 4294967296), o;
}
function g0_512_hi(t, e) {
  var n = rotr64_hi(t, e, 1), a = rotr64_hi(t, e, 8), u = shr64_hi(t, e, 7), o = n ^ a ^ u;
  return o < 0 && (o += 4294967296), o;
}
function g0_512_lo(t, e) {
  var n = rotr64_lo(t, e, 1), a = rotr64_lo(t, e, 8), u = shr64_lo(t, e, 7), o = n ^ a ^ u;
  return o < 0 && (o += 4294967296), o;
}
function g1_512_hi(t, e) {
  var n = rotr64_hi(t, e, 19), a = rotr64_hi(e, t, 29), u = shr64_hi(t, e, 6), o = n ^ a ^ u;
  return o < 0 && (o += 4294967296), o;
}
function g1_512_lo(t, e) {
  var n = rotr64_lo(t, e, 19), a = rotr64_lo(e, t, 29), u = shr64_lo(t, e, 6), o = n ^ a ^ u;
  return o < 0 && (o += 4294967296), o;
}
var utils$8 = utils$f, SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$8.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function(e) {
  return e === "hex" ? utils$8.toHex32(this.h.slice(0, 12), "big") : utils$8.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {}, utils$7 = utils$f, common = common$5, rotl32 = utils$7.rotl32, sum32 = utils$7.sum32, sum32_3 = utils$7.sum32_3, sum32_4 = utils$7.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
utils$7.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function(e, n) {
  for (var a = this.h[0], u = this.h[1], o = this.h[2], d = this.h[3], l = this.h[4], _ = a, P = u, h = o, x = d, C = l, D = 0; D < 80; D++) {
    var q = sum32(
      rotl32(
        sum32_4(a, f(D, u, o, d), e[r[D] + n], K(D)),
        s[D]
      ),
      l
    );
    a = l, l = d, d = rotl32(o, 10), o = u, u = q, q = sum32(
      rotl32(
        sum32_4(_, f(79 - D, P, h, x), e[rh[D] + n], Kh(D)),
        sh[D]
      ),
      C
    ), _ = C, C = x, x = rotl32(h, 10), h = P, P = q;
  }
  q = sum32_3(this.h[1], o, x), this.h[1] = sum32_3(this.h[2], d, C), this.h[2] = sum32_3(this.h[3], l, _), this.h[3] = sum32_3(this.h[4], a, P), this.h[4] = sum32_3(this.h[0], u, h), this.h[0] = q;
};
RIPEMD160.prototype._digest = function(e) {
  return e === "hex" ? utils$7.toHex32(this.h, "little") : utils$7.split32(this.h, "little");
};
function f(t, e, n, a) {
  return t <= 15 ? e ^ n ^ a : t <= 31 ? e & n | ~e & a : t <= 47 ? (e | ~n) ^ a : t <= 63 ? e & a | n & ~a : e ^ (n | ~a);
}
function K(t) {
  return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
}
function Kh(t) {
  return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
}
var r = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], s = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], utils$6 = utils$f, assert$6 = minimalisticAssert;
function Hmac$1(t, e, n) {
  if (!(this instanceof Hmac$1))
    return new Hmac$1(t, e, n);
  this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(utils$6.toArray(e, n));
}
var hmac = Hmac$1;
Hmac$1.prototype._init = function(e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()), assert$6(e.length <= this.blockSize);
  for (var n = e.length; n < this.blockSize; n++)
    e.push(0);
  for (n = 0; n < e.length; n++)
    e[n] ^= 54;
  for (this.inner = new this.Hash().update(e), n = 0; n < e.length; n++)
    e[n] ^= 106;
  this.outer = new this.Hash().update(e);
};
Hmac$1.prototype.update = function(e, n) {
  return this.inner.update(e, n), this;
};
Hmac$1.prototype.digest = function(e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function(t) {
  var e = t;
  e.utils = utils$f, e.common = common$5, e.sha = sha, e.ripemd = ripemd, e.hmac = hmac, e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160;
})(hash$2);
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
(function(t) {
  var e = t, n = hash$2, a = curve, u = utils$l, o = u.assert;
  function d(P) {
    P.type === "short" ? this.curve = new a.short(P) : P.type === "edwards" ? this.curve = new a.edwards(P) : this.curve = new a.mont(P), this.g = this.curve.g, this.n = this.curve.n, this.hash = P.hash, o(this.g.validate(), "Invalid curve"), o(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  e.PresetCurve = d;
  function l(P, h) {
    Object.defineProperty(e, P, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var x = new d(h);
        return Object.defineProperty(e, P, {
          configurable: !0,
          enumerable: !0,
          value: x
        }), x;
      }
    });
  }
  l("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: n.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), l("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: n.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), l("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: n.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), l("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: n.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), l("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: n.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), l("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: n.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), l("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: n.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var _;
  try {
    _ = requireSecp256k1();
  } catch {
    _ = void 0;
  }
  l("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: n.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      _
    ]
  });
})(curves$1);
var hash$1 = hash$2, utils$5 = utils$k, assert$5 = minimalisticAssert;
function HmacDRBG(t) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(t);
  this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var e = utils$5.toArray(t.entropy, t.entropyEnc || "hex"), n = utils$5.toArray(t.nonce, t.nonceEnc || "hex"), a = utils$5.toArray(t.pers, t.persEnc || "hex");
  assert$5(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(e, n, a);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function(e, n, a) {
  var u = e.concat(n).concat(a);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var o = 0; o < this.V.length; o++)
    this.K[o] = 0, this.V[o] = 1;
  this._update(u), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function() {
  return new hash$1.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function(e) {
  var n = this._hmac().update(this.V).update([0]);
  e && (n = n.update(e)), this.K = n.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG.prototype.reseed = function(e, n, a, u) {
  typeof n != "string" && (u = a, a = n, n = null), e = utils$5.toArray(e, n), a = utils$5.toArray(a, u), assert$5(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(a || [])), this._reseed = 1;
};
HmacDRBG.prototype.generate = function(e, n, a, u) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof n != "string" && (u = a, a = n, n = null), a && (a = utils$5.toArray(a, u || "hex"), this._update(a));
  for (var o = []; o.length < e; )
    this.V = this._hmac().update(this.V).digest(), o = o.concat(this.V);
  var d = o.slice(0, e);
  return this._update(a), this._reseed++, utils$5.encode(d, n);
};
var BN$5 = bnExports$1, utils$4 = utils$l, assert$4 = utils$4.assert;
function KeyPair$2(t, e) {
  this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
}
var key$1 = KeyPair$2;
KeyPair$2.fromPublic = function(e, n, a) {
  return n instanceof KeyPair$2 ? n : new KeyPair$2(e, {
    pub: n,
    pubEnc: a
  });
};
KeyPair$2.fromPrivate = function(e, n, a) {
  return n instanceof KeyPair$2 ? n : new KeyPair$2(e, {
    priv: n,
    privEnc: a
  });
};
KeyPair$2.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair$2.prototype.getPublic = function(e, n) {
  return typeof e == "string" && (n = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), n ? this.pub.encode(n, e) : this.pub;
};
KeyPair$2.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair$2.prototype._importPrivate = function(e, n) {
  this.priv = new BN$5(e, n || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$2.prototype._importPublic = function(e, n) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? assert$4(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$4(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, n);
};
KeyPair$2.prototype.derive = function(e) {
  return e.validate() || assert$4(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
KeyPair$2.prototype.sign = function(e, n, a) {
  return this.ec.sign(e, this, n, a);
};
KeyPair$2.prototype.verify = function(e, n, a) {
  return this.ec.verify(e, n, this, void 0, a);
};
KeyPair$2.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$4 = bnExports$1, utils$3 = utils$l, assert$3 = utils$3.assert;
function Signature$2(t, e) {
  if (t instanceof Signature$2)
    return t;
  this._importDER(t, e) || (assert$3(t.r && t.s, "Signature without r or s"), this.r = new BN$4(t.r, 16), this.s = new BN$4(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
}
var signature$1 = Signature$2;
function Position() {
  this.place = 0;
}
function getLength(t, e) {
  var n = t[e.place++];
  if (!(n & 128))
    return n;
  var a = n & 15;
  if (a === 0 || a > 4 || t[e.place] === 0)
    return !1;
  for (var u = 0, o = 0, d = e.place; o < a; o++, d++)
    u <<= 8, u |= t[d], u >>>= 0;
  return u <= 127 ? !1 : (e.place = d, u);
}
function rmPadding(t) {
  for (var e = 0, n = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < n; )
    e++;
  return e === 0 ? t : t.slice(e);
}
Signature$2.prototype._importDER = function(e, n) {
  e = utils$3.toArray(e, n);
  var a = new Position();
  if (e[a.place++] !== 48)
    return !1;
  var u = getLength(e, a);
  if (u === !1 || u + a.place !== e.length || e[a.place++] !== 2)
    return !1;
  var o = getLength(e, a);
  if (o === !1 || e[a.place] & 128)
    return !1;
  var d = e.slice(a.place, o + a.place);
  if (a.place += o, e[a.place++] !== 2)
    return !1;
  var l = getLength(e, a);
  if (l === !1 || e.length !== l + a.place || e[a.place] & 128)
    return !1;
  var _ = e.slice(a.place, l + a.place);
  if (d[0] === 0)
    if (d[1] & 128)
      d = d.slice(1);
    else
      return !1;
  if (_[0] === 0)
    if (_[1] & 128)
      _ = _.slice(1);
    else
      return !1;
  return this.r = new BN$4(d), this.s = new BN$4(_), this.recoveryParam = null, !0;
};
function constructLength(t, e) {
  if (e < 128) {
    t.push(e);
    return;
  }
  var n = 1 + (Math.log(e) / Math.LN2 >>> 3);
  for (t.push(n | 128); --n; )
    t.push(e >>> (n << 3) & 255);
  t.push(e);
}
Signature$2.prototype.toDER = function(e) {
  var n = this.r.toArray(), a = this.s.toArray();
  for (n[0] & 128 && (n = [0].concat(n)), a[0] & 128 && (a = [0].concat(a)), n = rmPadding(n), a = rmPadding(a); !a[0] && !(a[1] & 128); )
    a = a.slice(1);
  var u = [2];
  constructLength(u, n.length), u = u.concat(n), u.push(2), constructLength(u, a.length);
  var o = u.concat(a), d = [48];
  return constructLength(d, o.length), d = d.concat(o), utils$3.encode(d, e);
};
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var t = bnExports$1, e = hmacDrbg, n = utils$l, a = curves$1, u = requireBrorand(), o = n.assert, d = key$1, l = signature$1;
  function _(P) {
    if (!(this instanceof _))
      return new _(P);
    typeof P == "string" && (o(
      Object.prototype.hasOwnProperty.call(a, P),
      "Unknown curve " + P
    ), P = a[P]), P instanceof a.PresetCurve && (P = { curve: P }), this.curve = P.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = P.curve.g, this.g.precompute(P.curve.n.bitLength() + 1), this.hash = P.hash || P.curve.hash;
  }
  return ec = _, _.prototype.keyPair = function(h) {
    return new d(this, h);
  }, _.prototype.keyFromPrivate = function(h, x) {
    return d.fromPrivate(this, h, x);
  }, _.prototype.keyFromPublic = function(h, x) {
    return d.fromPublic(this, h, x);
  }, _.prototype.genKeyPair = function(h) {
    h || (h = {});
    for (var x = new e({
      hash: this.hash,
      pers: h.pers,
      persEnc: h.persEnc || "utf8",
      entropy: h.entropy || u(this.hash.hmacStrength),
      entropyEnc: h.entropy && h.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), C = this.n.byteLength(), D = this.n.sub(new t(2)); ; ) {
      var q = new t(x.generate(C));
      if (!(q.cmp(D) > 0))
        return q.iaddn(1), this.keyFromPrivate(q);
    }
  }, _.prototype._truncateToN = function(h, x, C) {
    var D;
    if (t.isBN(h) || typeof h == "number")
      h = new t(h, 16), D = h.byteLength();
    else if (typeof h == "object")
      D = h.length, h = new t(h, 16);
    else {
      var q = h.toString();
      D = q.length + 1 >>> 1, h = new t(q, 16);
    }
    typeof C != "number" && (C = D * 8);
    var H = C - this.n.bitLength();
    return H > 0 && (h = h.ushrn(H)), !x && h.cmp(this.n) >= 0 ? h.sub(this.n) : h;
  }, _.prototype.sign = function(h, x, C, D) {
    if (typeof C == "object" && (D = C, C = null), D || (D = {}), typeof h != "string" && typeof h != "number" && !t.isBN(h)) {
      o(
        typeof h == "object" && h && typeof h.length == "number",
        "Expected message to be an array-like, a hex string, or a BN instance"
      ), o(h.length >>> 0 === h.length);
      for (var q = 0; q < h.length; q++) o((h[q] & 255) === h[q]);
    }
    x = this.keyFromPrivate(x, C), h = this._truncateToN(h, !1, D.msgBitLength), o(!h.isNeg(), "Can not sign a negative message");
    var H = this.n.byteLength(), Y = x.getPrivate().toArray("be", H), z = h.toArray("be", H);
    o(new t(z).eq(h), "Can not sign message");
    for (var F = new e({
      hash: this.hash,
      entropy: Y,
      nonce: z,
      pers: D.pers,
      persEnc: D.persEnc || "utf8"
    }), X = this.n.sub(new t(1)), ee = 0; ; ee++) {
      var se = D.k ? D.k(ee) : new t(F.generate(this.n.byteLength()));
      if (se = this._truncateToN(se, !0), !(se.cmpn(1) <= 0 || se.cmp(X) >= 0)) {
        var ce = this.g.mul(se);
        if (!ce.isInfinity()) {
          var le = ce.getX(), he = le.umod(this.n);
          if (he.cmpn(0) !== 0) {
            var oe = se.invm(this.n).mul(he.mul(x.getPrivate()).iadd(h));
            if (oe = oe.umod(this.n), oe.cmpn(0) !== 0) {
              var _e = (ce.getY().isOdd() ? 1 : 0) | (le.cmp(he) !== 0 ? 2 : 0);
              return D.canonical && oe.cmp(this.nh) > 0 && (oe = this.n.sub(oe), _e ^= 1), new l({ r: he, s: oe, recoveryParam: _e });
            }
          }
        }
      }
    }
  }, _.prototype.verify = function(h, x, C, D, q) {
    q || (q = {}), h = this._truncateToN(h, !1, q.msgBitLength), C = this.keyFromPublic(C, D), x = new l(x, "hex");
    var H = x.r, Y = x.s;
    if (H.cmpn(1) < 0 || H.cmp(this.n) >= 0 || Y.cmpn(1) < 0 || Y.cmp(this.n) >= 0)
      return !1;
    var z = Y.invm(this.n), F = z.mul(h).umod(this.n), X = z.mul(H).umod(this.n), ee;
    return this.curve._maxwellTrick ? (ee = this.g.jmulAdd(F, C.getPublic(), X), ee.isInfinity() ? !1 : ee.eqXToP(H)) : (ee = this.g.mulAdd(F, C.getPublic(), X), ee.isInfinity() ? !1 : ee.getX().umod(this.n).cmp(H) === 0);
  }, _.prototype.recoverPubKey = function(P, h, x, C) {
    o((3 & x) === x, "The recovery param is more than two bits"), h = new l(h, C);
    var D = this.n, q = new t(P), H = h.r, Y = h.s, z = x & 1, F = x >> 1;
    if (H.cmp(this.curve.p.umod(this.curve.n)) >= 0 && F)
      throw new Error("Unable to find sencond key candinate");
    F ? H = this.curve.pointFromX(H.add(this.curve.n), z) : H = this.curve.pointFromX(H, z);
    var X = h.r.invm(D), ee = D.sub(q).mul(X).umod(D), se = Y.mul(X).umod(D);
    return this.g.mulAdd(ee, H, se);
  }, _.prototype.getKeyRecoveryParam = function(P, h, x, C) {
    if (h = new l(h, C), h.recoveryParam !== null)
      return h.recoveryParam;
    for (var D = 0; D < 4; D++) {
      var q;
      try {
        q = this.recoverPubKey(P, h, D);
      } catch {
        continue;
      }
      if (q.eq(x))
        return D;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var utils$2 = utils$l, assert$2 = utils$2.assert, parseBytes$2 = utils$2.parseBytes, cachedProperty$1 = utils$2.cachedProperty;
function KeyPair$1(t, e) {
  this.eddsa = t, this._secret = parseBytes$2(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = parseBytes$2(e.pub);
}
KeyPair$1.fromPublic = function(e, n) {
  return n instanceof KeyPair$1 ? n : new KeyPair$1(e, { pub: n });
};
KeyPair$1.fromSecret = function(e, n) {
  return n instanceof KeyPair$1 ? n : new KeyPair$1(e, { secret: n });
};
KeyPair$1.prototype.secret = function() {
  return this._secret;
};
cachedProperty$1(KeyPair$1, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$1, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$1, "privBytes", function() {
  var e = this.eddsa, n = this.hash(), a = e.encodingLength - 1, u = n.slice(0, e.encodingLength);
  return u[0] &= 248, u[a] &= 127, u[a] |= 64, u;
});
cachedProperty$1(KeyPair$1, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$1, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$1, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$1.prototype.sign = function(e) {
  return assert$2(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
};
KeyPair$1.prototype.verify = function(e, n) {
  return this.eddsa.verify(e, n, this);
};
KeyPair$1.prototype.getSecret = function(e) {
  return assert$2(this._secret, "KeyPair is public only"), utils$2.encode(this.secret(), e);
};
KeyPair$1.prototype.getPublic = function(e) {
  return utils$2.encode(this.pubBytes(), e);
};
var key = KeyPair$1, BN$3 = bnExports$1, utils$1 = utils$l, assert$1 = utils$1.assert, cachedProperty = utils$1.cachedProperty, parseBytes$1 = utils$1.parseBytes;
function Signature$1(t, e) {
  this.eddsa = t, typeof e != "object" && (e = parseBytes$1(e)), Array.isArray(e) && (assert$1(e.length === t.encodingLength * 2, "Signature has invalid size"), e = {
    R: e.slice(0, t.encodingLength),
    S: e.slice(t.encodingLength)
  }), assert$1(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof BN$3 && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
}
cachedProperty(Signature$1, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$1, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$1, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$1, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
Signature$1.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$1.prototype.toHex = function() {
  return utils$1.encode(this.toBytes(), "hex").toUpperCase();
};
var signature = Signature$1, hash = hash$2, curves = curves$1, utils = utils$l, assert = utils.assert, parseBytes = utils.parseBytes, KeyPair = key, Signature = signature;
function EDDSA(t) {
  if (assert(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
    return new EDDSA(t);
  t = curves[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = hash.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function(e, n) {
  e = parseBytes(e);
  var a = this.keyFromSecret(n), u = this.hashInt(a.messagePrefix(), e), o = this.g.mul(u), d = this.encodePoint(o), l = this.hashInt(d, a.pubBytes(), e).mul(a.priv()), _ = u.add(l).umod(this.curve.n);
  return this.makeSignature({ R: o, S: _, Rencoded: d });
};
EDDSA.prototype.verify = function(e, n, a) {
  if (e = parseBytes(e), n = this.makeSignature(n), n.S().gte(n.eddsa.curve.n) || n.S().isNeg())
    return !1;
  var u = this.keyFromPublic(a), o = this.hashInt(n.Rencoded(), u.pubBytes(), e), d = this.g.mul(n.S()), l = n.R().add(u.pub().mul(o));
  return l.eq(d);
};
EDDSA.prototype.hashInt = function() {
  for (var e = this.hash(), n = 0; n < arguments.length; n++)
    e.update(arguments[n]);
  return utils.intFromLE(e.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function(e) {
  return KeyPair.fromPublic(this, e);
};
EDDSA.prototype.keyFromSecret = function(e) {
  return KeyPair.fromSecret(this, e);
};
EDDSA.prototype.makeSignature = function(e) {
  return e instanceof Signature ? e : new Signature(this, e);
};
EDDSA.prototype.encodePoint = function(e) {
  var n = e.getY().toArray("le", this.encodingLength);
  return n[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, n;
};
EDDSA.prototype.decodePoint = function(e) {
  e = utils.parseBytes(e);
  var n = e.length - 1, a = e.slice(0, n).concat(e[n] & -129), u = (e[n] & 128) !== 0, o = utils.intFromLE(a);
  return this.curve.pointFromY(o, u);
};
EDDSA.prototype.encodeInt = function(e) {
  return e.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function(e) {
  return utils.intFromLE(e);
};
EDDSA.prototype.isPoint = function(e) {
  return e instanceof this.pointClass;
};
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(t) {
    var e = t;
    e.version = require$$0.version, e.utils = utils$l, e.rand = requireBrorand(), e.curve = curve, e.curves = curves$1, e.ec = requireEc(), e.eddsa = eddsa;
  }(elliptic)), elliptic;
}
var asn1$3 = {}, asn1$2 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(t, e) {
      if (t.indexOf) return t.indexOf(e);
      for (var n = 0; n < t.length; n++)
        if (t[n] === e) return n;
      return -1;
    }, Object_keys = function(t) {
      if (Object.keys) return Object.keys(t);
      var e = [];
      for (var n in t) e.push(n);
      return e;
    }, forEach = function(t, e) {
      if (t.forEach) return t.forEach(e);
      for (var n = 0; n < t.length; n++)
        e(t[n], n, t);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(t, e, n) {
          Object.defineProperty(t, e, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: n
          });
        };
      } catch {
        return function(e, n, a) {
          e[n] = a;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(e) {
      if (!(this instanceof Script)) return new Script(e);
      this.code = e;
    };
    Script.prototype.runInContext = function(t) {
      if (!(t instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var e = document.createElement("iframe");
      e.style || (e.style = {}), e.style.display = "none", document.body.appendChild(e);
      var n = e.contentWindow, a = n.eval, u = n.execScript;
      !a && u && (u.call(n, "null"), a = n.eval), forEach(Object_keys(t), function(l) {
        n[l] = t[l];
      }), forEach(globals, function(l) {
        t[l] && (n[l] = t[l]);
      });
      var o = Object_keys(n), d = a.call(n, this.code);
      return forEach(Object_keys(n), function(l) {
        (l in t || indexOf(o, l) === -1) && (t[l] = n[l]);
      }), forEach(globals, function(l) {
        l in t || defineProp(t, l, n[l]);
      }), document.body.removeChild(e), d;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(t) {
      var e = Script.createContext(t), n = this.runInContext(e);
      return t && forEach(Object_keys(e), function(a) {
        t[a] = e[a];
      }), n;
    }, forEach(Object_keys(Script.prototype), function(t) {
      exports[t] = Script[t] = function(e) {
        var n = Script(e);
        return n[t].apply(n, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(t) {
      return t instanceof Context;
    }, exports.createScript = function(t) {
      return exports.Script(t);
    }, exports.createContext = Script.createContext = function(t) {
      var e = new Context();
      return typeof t == "object" && forEach(Object_keys(t), function(n) {
        e[n] = t[n];
      }), e;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(t) {
    var e = requireAsn1(), n = inherits_browserExports, a = t;
    a.define = function(d, l) {
      return new u(d, l);
    };
    function u(o, d) {
      this.name = o, this.body = d, this.decoders = {}, this.encoders = {};
    }
    u.prototype._createNamed = function(d) {
      var l;
      try {
        l = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        l = function(P) {
          this._initNamed(P);
        };
      }
      return n(l, d), l.prototype._initNamed = function(P) {
        d.call(this, P);
      }, new l(this);
    }, u.prototype._getDecoder = function(d) {
      return d = d || "der", this.decoders.hasOwnProperty(d) || (this.decoders[d] = this._createNamed(e.decoders[d])), this.decoders[d];
    }, u.prototype.decode = function(d, l, _) {
      return this._getDecoder(l).decode(d, _);
    }, u.prototype._getEncoder = function(d) {
      return d = d || "der", this.encoders.hasOwnProperty(d) || (this.encoders[d] = this._createNamed(e.encoders[d])), this.encoders[d];
    }, u.prototype.encode = function(d, l, _) {
      return this._getEncoder(l).encode(d, _);
    };
  }(api)), api;
}
var base = {}, reporter = {}, inherits = inherits_browserExports;
function Reporter(t) {
  this._reporterState = {
    obj: null,
    path: [],
    options: t || {},
    errors: []
  };
}
reporter.Reporter = Reporter;
Reporter.prototype.isError = function t(e) {
  return e instanceof ReporterError;
};
Reporter.prototype.save = function t() {
  var e = this._reporterState;
  return { obj: e.obj, pathLen: e.path.length };
};
Reporter.prototype.restore = function t(e) {
  var n = this._reporterState;
  n.obj = e.obj, n.path = n.path.slice(0, e.pathLen);
};
Reporter.prototype.enterKey = function t(e) {
  return this._reporterState.path.push(e);
};
Reporter.prototype.exitKey = function t(e) {
  var n = this._reporterState;
  n.path = n.path.slice(0, e - 1);
};
Reporter.prototype.leaveKey = function t(e, n, a) {
  var u = this._reporterState;
  this.exitKey(e), u.obj !== null && (u.obj[n] = a);
};
Reporter.prototype.path = function t() {
  return this._reporterState.path.join("/");
};
Reporter.prototype.enterObject = function t() {
  var e = this._reporterState, n = e.obj;
  return e.obj = {}, n;
};
Reporter.prototype.leaveObject = function t(e) {
  var n = this._reporterState, a = n.obj;
  return n.obj = e, a;
};
Reporter.prototype.error = function t(e) {
  var n, a = this._reporterState, u = e instanceof ReporterError;
  if (u ? n = e : n = new ReporterError(a.path.map(function(o) {
    return "[" + JSON.stringify(o) + "]";
  }).join(""), e.message || e, e.stack), !a.options.partial)
    throw n;
  return u || a.errors.push(n), n;
};
Reporter.prototype.wrapResult = function t(e) {
  var n = this._reporterState;
  return n.options.partial ? {
    result: this.isError(e) ? null : e,
    errors: n.errors
  } : e;
};
function ReporterError(t, e) {
  this.path = t, this.rethrow(e);
}
inherits(ReporterError, Error);
ReporterError.prototype.rethrow = function t(e) {
  if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError), !this.stack)
    try {
      throw new Error(this.message);
    } catch (n) {
      this.stack = n.stack;
    }
  return this;
};
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var t = inherits_browserExports, e = requireBase().Reporter, n = require$$1$2.Buffer;
  function a(o, d) {
    if (e.call(this, d), !n.isBuffer(o)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = o, this.offset = 0, this.length = o.length;
  }
  t(a, e), buffer.DecoderBuffer = a, a.prototype.save = function() {
    return { offset: this.offset, reporter: e.prototype.save.call(this) };
  }, a.prototype.restore = function(d) {
    var l = new a(this.base);
    return l.offset = d.offset, l.length = this.offset, this.offset = d.offset, e.prototype.restore.call(this, d.reporter), l;
  }, a.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, a.prototype.readUInt8 = function(d) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(d || "DecoderBuffer overrun");
  }, a.prototype.skip = function(d, l) {
    if (!(this.offset + d <= this.length))
      return this.error(l || "DecoderBuffer overrun");
    var _ = new a(this.base);
    return _._reporterState = this._reporterState, _.offset = this.offset, _.length = this.offset + d, this.offset += d, _;
  }, a.prototype.raw = function(d) {
    return this.base.slice(d ? d.offset : this.offset, this.length);
  };
  function u(o, d) {
    if (Array.isArray(o))
      this.length = 0, this.value = o.map(function(l) {
        return l instanceof u || (l = new u(l, d)), this.length += l.length, l;
      }, this);
    else if (typeof o == "number") {
      if (!(0 <= o && o <= 255))
        return d.error("non-byte EncoderBuffer value");
      this.value = o, this.length = 1;
    } else if (typeof o == "string")
      this.value = o, this.length = n.byteLength(o);
    else if (n.isBuffer(o))
      this.value = o, this.length = o.length;
    else
      return d.error("Unsupported type: " + typeof o);
  }
  return buffer.EncoderBuffer = u, u.prototype.join = function(d, l) {
    return d || (d = new n(this.length)), l || (l = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(_) {
      _.join(d, l), l += _.length;
    }) : (typeof this.value == "number" ? d[l] = this.value : typeof this.value == "string" ? d.write(this.value, l) : n.isBuffer(this.value) && this.value.copy(d, l), l += this.length)), d;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var t = requireBase().Reporter, e = requireBase().EncoderBuffer, n = requireBase().DecoderBuffer, a = minimalisticAssert, u = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], o = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(u), d = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function l(P, h) {
    var x = {};
    this._baseState = x, x.enc = P, x.parent = h || null, x.children = null, x.tag = null, x.args = null, x.reverseArgs = null, x.choice = null, x.optional = !1, x.any = !1, x.obj = !1, x.use = null, x.useDecoder = null, x.key = null, x.default = null, x.explicit = null, x.implicit = null, x.contains = null, x.parent || (x.children = [], this._wrap());
  }
  node = l;
  var _ = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return l.prototype.clone = function() {
    var h = this._baseState, x = {};
    _.forEach(function(D) {
      x[D] = h[D];
    });
    var C = new this.constructor(x.parent);
    return C._baseState = x, C;
  }, l.prototype._wrap = function() {
    var h = this._baseState;
    o.forEach(function(x) {
      this[x] = function() {
        var D = new this.constructor(this);
        return h.children.push(D), D[x].apply(D, arguments);
      };
    }, this);
  }, l.prototype._init = function(h) {
    var x = this._baseState;
    a(x.parent === null), h.call(this), x.children = x.children.filter(function(C) {
      return C._baseState.parent === this;
    }, this), a.equal(x.children.length, 1, "Root node can have only one child");
  }, l.prototype._useArgs = function(h) {
    var x = this._baseState, C = h.filter(function(D) {
      return D instanceof this.constructor;
    }, this);
    h = h.filter(function(D) {
      return !(D instanceof this.constructor);
    }, this), C.length !== 0 && (a(x.children === null), x.children = C, C.forEach(function(D) {
      D._baseState.parent = this;
    }, this)), h.length !== 0 && (a(x.args === null), x.args = h, x.reverseArgs = h.map(function(D) {
      if (typeof D != "object" || D.constructor !== Object)
        return D;
      var q = {};
      return Object.keys(D).forEach(function(H) {
        H == (H | 0) && (H |= 0);
        var Y = D[H];
        q[Y] = H;
      }), q;
    }));
  }, d.forEach(function(P) {
    l.prototype[P] = function() {
      var x = this._baseState;
      throw new Error(P + " not implemented for encoding: " + x.enc);
    };
  }), u.forEach(function(P) {
    l.prototype[P] = function() {
      var x = this._baseState, C = Array.prototype.slice.call(arguments);
      return a(x.tag === null), x.tag = P, this._useArgs(C), this;
    };
  }), l.prototype.use = function(h) {
    a(h);
    var x = this._baseState;
    return a(x.use === null), x.use = h, this;
  }, l.prototype.optional = function() {
    var h = this._baseState;
    return h.optional = !0, this;
  }, l.prototype.def = function(h) {
    var x = this._baseState;
    return a(x.default === null), x.default = h, x.optional = !0, this;
  }, l.prototype.explicit = function(h) {
    var x = this._baseState;
    return a(x.explicit === null && x.implicit === null), x.explicit = h, this;
  }, l.prototype.implicit = function(h) {
    var x = this._baseState;
    return a(x.explicit === null && x.implicit === null), x.implicit = h, this;
  }, l.prototype.obj = function() {
    var h = this._baseState, x = Array.prototype.slice.call(arguments);
    return h.obj = !0, x.length !== 0 && this._useArgs(x), this;
  }, l.prototype.key = function(h) {
    var x = this._baseState;
    return a(x.key === null), x.key = h, this;
  }, l.prototype.any = function() {
    var h = this._baseState;
    return h.any = !0, this;
  }, l.prototype.choice = function(h) {
    var x = this._baseState;
    return a(x.choice === null), x.choice = h, this._useArgs(Object.keys(h).map(function(C) {
      return h[C];
    })), this;
  }, l.prototype.contains = function(h) {
    var x = this._baseState;
    return a(x.use === null), x.contains = h, this;
  }, l.prototype._decode = function(h, x) {
    var C = this._baseState;
    if (C.parent === null)
      return h.wrapResult(C.children[0]._decode(h, x));
    var D = C.default, q = !0, H = null;
    if (C.key !== null && (H = h.enterKey(C.key)), C.optional) {
      var Y = null;
      if (C.explicit !== null ? Y = C.explicit : C.implicit !== null ? Y = C.implicit : C.tag !== null && (Y = C.tag), Y === null && !C.any) {
        var z = h.save();
        try {
          C.choice === null ? this._decodeGeneric(C.tag, h, x) : this._decodeChoice(h, x), q = !0;
        } catch {
          q = !1;
        }
        h.restore(z);
      } else if (q = this._peekTag(h, Y, C.any), h.isError(q))
        return q;
    }
    var F;
    if (C.obj && q && (F = h.enterObject()), q) {
      if (C.explicit !== null) {
        var X = this._decodeTag(h, C.explicit);
        if (h.isError(X))
          return X;
        h = X;
      }
      var ee = h.offset;
      if (C.use === null && C.choice === null) {
        if (C.any)
          var z = h.save();
        var se = this._decodeTag(
          h,
          C.implicit !== null ? C.implicit : C.tag,
          C.any
        );
        if (h.isError(se))
          return se;
        C.any ? D = h.raw(z) : h = se;
      }
      if (x && x.track && C.tag !== null && x.track(h.path(), ee, h.length, "tagged"), x && x.track && C.tag !== null && x.track(h.path(), h.offset, h.length, "content"), C.any ? D = D : C.choice === null ? D = this._decodeGeneric(C.tag, h, x) : D = this._decodeChoice(h, x), h.isError(D))
        return D;
      if (!C.any && C.choice === null && C.children !== null && C.children.forEach(function(he) {
        he._decode(h, x);
      }), C.contains && (C.tag === "octstr" || C.tag === "bitstr")) {
        var ce = new n(D);
        D = this._getUse(C.contains, h._reporterState.obj)._decode(ce, x);
      }
    }
    return C.obj && q && (D = h.leaveObject(F)), C.key !== null && (D !== null || q === !0) ? h.leaveKey(H, C.key, D) : H !== null && h.exitKey(H), D;
  }, l.prototype._decodeGeneric = function(h, x, C) {
    var D = this._baseState;
    return h === "seq" || h === "set" ? null : h === "seqof" || h === "setof" ? this._decodeList(x, h, D.args[0], C) : /str$/.test(h) ? this._decodeStr(x, h, C) : h === "objid" && D.args ? this._decodeObjid(x, D.args[0], D.args[1], C) : h === "objid" ? this._decodeObjid(x, null, null, C) : h === "gentime" || h === "utctime" ? this._decodeTime(x, h, C) : h === "null_" ? this._decodeNull(x, C) : h === "bool" ? this._decodeBool(x, C) : h === "objDesc" ? this._decodeStr(x, h, C) : h === "int" || h === "enum" ? this._decodeInt(x, D.args && D.args[0], C) : D.use !== null ? this._getUse(D.use, x._reporterState.obj)._decode(x, C) : x.error("unknown tag: " + h);
  }, l.prototype._getUse = function(h, x) {
    var C = this._baseState;
    return C.useDecoder = this._use(h, x), a(C.useDecoder._baseState.parent === null), C.useDecoder = C.useDecoder._baseState.children[0], C.implicit !== C.useDecoder._baseState.implicit && (C.useDecoder = C.useDecoder.clone(), C.useDecoder._baseState.implicit = C.implicit), C.useDecoder;
  }, l.prototype._decodeChoice = function(h, x) {
    var C = this._baseState, D = null, q = !1;
    return Object.keys(C.choice).some(function(H) {
      var Y = h.save(), z = C.choice[H];
      try {
        var F = z._decode(h, x);
        if (h.isError(F))
          return !1;
        D = { type: H, value: F }, q = !0;
      } catch {
        return h.restore(Y), !1;
      }
      return !0;
    }, this), q ? D : h.error("Choice not matched");
  }, l.prototype._createEncoderBuffer = function(h) {
    return new e(h, this.reporter);
  }, l.prototype._encode = function(h, x, C) {
    var D = this._baseState;
    if (!(D.default !== null && D.default === h)) {
      var q = this._encodeValue(h, x, C);
      if (q !== void 0 && !this._skipDefault(q, x, C))
        return q;
    }
  }, l.prototype._encodeValue = function(h, x, C) {
    var D = this._baseState;
    if (D.parent === null)
      return D.children[0]._encode(h, x || new t());
    var z = null;
    if (this.reporter = x, D.optional && h === void 0)
      if (D.default !== null)
        h = D.default;
      else
        return;
    var q = null, H = !1;
    if (D.any)
      z = this._createEncoderBuffer(h);
    else if (D.choice)
      z = this._encodeChoice(h, x);
    else if (D.contains)
      q = this._getUse(D.contains, C)._encode(h, x), H = !0;
    else if (D.children)
      q = D.children.map(function(ee) {
        if (ee._baseState.tag === "null_")
          return ee._encode(null, x, h);
        if (ee._baseState.key === null)
          return x.error("Child should have a key");
        var se = x.enterKey(ee._baseState.key);
        if (typeof h != "object")
          return x.error("Child expected, but input is not object");
        var ce = ee._encode(h[ee._baseState.key], x, h);
        return x.leaveKey(se), ce;
      }, this).filter(function(ee) {
        return ee;
      }), q = this._createEncoderBuffer(q);
    else if (D.tag === "seqof" || D.tag === "setof") {
      if (!(D.args && D.args.length === 1))
        return x.error("Too many args for : " + D.tag);
      if (!Array.isArray(h))
        return x.error("seqof/setof, but data is not Array");
      var Y = this.clone();
      Y._baseState.implicit = null, q = this._createEncoderBuffer(h.map(function(ee) {
        var se = this._baseState;
        return this._getUse(se.args[0], h)._encode(ee, x);
      }, Y));
    } else D.use !== null ? z = this._getUse(D.use, C)._encode(h, x) : (q = this._encodePrimitive(D.tag, h), H = !0);
    var z;
    if (!D.any && D.choice === null) {
      var F = D.implicit !== null ? D.implicit : D.tag, X = D.implicit === null ? "universal" : "context";
      F === null ? D.use === null && x.error("Tag could be omitted only for .use()") : D.use === null && (z = this._encodeComposite(F, H, X, q));
    }
    return D.explicit !== null && (z = this._encodeComposite(D.explicit, !1, "context", z)), z;
  }, l.prototype._encodeChoice = function(h, x) {
    var C = this._baseState, D = C.choice[h.type];
    return D || a(
      !1,
      h.type + " not found in " + JSON.stringify(Object.keys(C.choice))
    ), D._encode(h.value, x);
  }, l.prototype._encodePrimitive = function(h, x) {
    var C = this._baseState;
    if (/str$/.test(h))
      return this._encodeStr(x, h);
    if (h === "objid" && C.args)
      return this._encodeObjid(x, C.reverseArgs[0], C.args[1]);
    if (h === "objid")
      return this._encodeObjid(x, null, null);
    if (h === "gentime" || h === "utctime")
      return this._encodeTime(x, h);
    if (h === "null_")
      return this._encodeNull();
    if (h === "int" || h === "enum")
      return this._encodeInt(x, C.args && C.reverseArgs[0]);
    if (h === "bool")
      return this._encodeBool(x);
    if (h === "objDesc")
      return this._encodeStr(x, h);
    throw new Error("Unsupported tag: " + h);
  }, l.prototype._isNumstr = function(h) {
    return /^[0-9 ]*$/.test(h);
  }, l.prototype._isPrintstr = function(h) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(h);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(t) {
    var e = t;
    e.Reporter = reporter.Reporter, e.DecoderBuffer = requireBuffer().DecoderBuffer, e.EncoderBuffer = requireBuffer().EncoderBuffer, e.Node = requireNode();
  }(base)), base;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(t) {
    var e = requireConstants();
    t.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, t.tagClassByName = e._reverse(t.tagClass), t.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, t.tagByName = e._reverse(t.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(t) {
    var e = t;
    e._reverse = function(a) {
      var u = {};
      return Object.keys(a).forEach(function(o) {
        (o | 0) == o && (o = o | 0);
        var d = a[o];
        u[d] = o;
      }), u;
    }, e.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var t = inherits_browserExports, e = requireAsn1(), n = e.base, a = e.bignum, u = e.constants.der;
  function o(P) {
    this.enc = "der", this.name = P.name, this.entity = P, this.tree = new d(), this.tree._init(P.body);
  }
  der_1$1 = o, o.prototype.decode = function(h, x) {
    return h instanceof n.DecoderBuffer || (h = new n.DecoderBuffer(h, x)), this.tree._decode(h, x);
  };
  function d(P) {
    n.Node.call(this, "der", P);
  }
  t(d, n.Node), d.prototype._peekTag = function(h, x, C) {
    if (h.isEmpty())
      return !1;
    var D = h.save(), q = l(h, 'Failed to peek tag: "' + x + '"');
    return h.isError(q) ? q : (h.restore(D), q.tag === x || q.tagStr === x || q.tagStr + "of" === x || C);
  }, d.prototype._decodeTag = function(h, x, C) {
    var D = l(
      h,
      'Failed to decode tag of "' + x + '"'
    );
    if (h.isError(D))
      return D;
    var q = _(
      h,
      D.primitive,
      'Failed to get length of "' + x + '"'
    );
    if (h.isError(q))
      return q;
    if (!C && D.tag !== x && D.tagStr !== x && D.tagStr + "of" !== x)
      return h.error('Failed to match tag: "' + x + '"');
    if (D.primitive || q !== null)
      return h.skip(q, 'Failed to match body of: "' + x + '"');
    var H = h.save(), Y = this._skipUntilEnd(
      h,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return h.isError(Y) ? Y : (q = h.offset - H.offset, h.restore(H), h.skip(q, 'Failed to match body of: "' + x + '"'));
  }, d.prototype._skipUntilEnd = function(h, x) {
    for (; ; ) {
      var C = l(h, x);
      if (h.isError(C))
        return C;
      var D = _(h, C.primitive, x);
      if (h.isError(D))
        return D;
      var q;
      if (C.primitive || D !== null ? q = h.skip(D) : q = this._skipUntilEnd(h, x), h.isError(q))
        return q;
      if (C.tagStr === "end")
        break;
    }
  }, d.prototype._decodeList = function(h, x, C, D) {
    for (var q = []; !h.isEmpty(); ) {
      var H = this._peekTag(h, "end");
      if (h.isError(H))
        return H;
      var Y = C.decode(h, "der", D);
      if (h.isError(Y) && H)
        break;
      q.push(Y);
    }
    return q;
  }, d.prototype._decodeStr = function(h, x) {
    if (x === "bitstr") {
      var C = h.readUInt8();
      return h.isError(C) ? C : { unused: C, data: h.raw() };
    } else if (x === "bmpstr") {
      var D = h.raw();
      if (D.length % 2 === 1)
        return h.error("Decoding of string type: bmpstr length mismatch");
      for (var q = "", H = 0; H < D.length / 2; H++)
        q += String.fromCharCode(D.readUInt16BE(H * 2));
      return q;
    } else if (x === "numstr") {
      var Y = h.raw().toString("ascii");
      return this._isNumstr(Y) ? Y : h.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (x === "octstr")
        return h.raw();
      if (x === "objDesc")
        return h.raw();
      if (x === "printstr") {
        var z = h.raw().toString("ascii");
        return this._isPrintstr(z) ? z : h.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(x) ? h.raw().toString() : h.error("Decoding of string type: " + x + " unsupported");
    }
  }, d.prototype._decodeObjid = function(h, x, C) {
    for (var D, q = [], H = 0; !h.isEmpty(); ) {
      var Y = h.readUInt8();
      H <<= 7, H |= Y & 127, Y & 128 || (q.push(H), H = 0);
    }
    Y & 128 && q.push(H);
    var z = q[0] / 40 | 0, F = q[0] % 40;
    if (C ? D = q : D = [z, F].concat(q.slice(1)), x) {
      var X = x[D.join(" ")];
      X === void 0 && (X = x[D.join(".")]), X !== void 0 && (D = X);
    }
    return D;
  }, d.prototype._decodeTime = function(h, x) {
    var C = h.raw().toString();
    if (x === "gentime")
      var D = C.slice(0, 4) | 0, q = C.slice(4, 6) | 0, H = C.slice(6, 8) | 0, Y = C.slice(8, 10) | 0, z = C.slice(10, 12) | 0, F = C.slice(12, 14) | 0;
    else if (x === "utctime") {
      var D = C.slice(0, 2) | 0, q = C.slice(2, 4) | 0, H = C.slice(4, 6) | 0, Y = C.slice(6, 8) | 0, z = C.slice(8, 10) | 0, F = C.slice(10, 12) | 0;
      D < 70 ? D = 2e3 + D : D = 1900 + D;
    } else
      return h.error("Decoding " + x + " time is not supported yet");
    return Date.UTC(D, q - 1, H, Y, z, F, 0);
  }, d.prototype._decodeNull = function(h) {
    return null;
  }, d.prototype._decodeBool = function(h) {
    var x = h.readUInt8();
    return h.isError(x) ? x : x !== 0;
  }, d.prototype._decodeInt = function(h, x) {
    var C = h.raw(), D = new a(C);
    return x && (D = x[D.toString(10)] || D), D;
  }, d.prototype._use = function(h, x) {
    return typeof h == "function" && (h = h(x)), h._getDecoder("der").tree;
  };
  function l(P, h) {
    var x = P.readUInt8(h);
    if (P.isError(x))
      return x;
    var C = u.tagClass[x >> 6], D = (x & 32) === 0;
    if ((x & 31) === 31) {
      var q = x;
      for (x = 0; (q & 128) === 128; ) {
        if (q = P.readUInt8(h), P.isError(q))
          return q;
        x <<= 7, x |= q & 127;
      }
    } else
      x &= 31;
    var H = u.tag[x];
    return {
      cls: C,
      primitive: D,
      tag: x,
      tagStr: H
    };
  }
  function _(P, h, x) {
    var C = P.readUInt8(x);
    if (P.isError(C))
      return C;
    if (!h && C === 128)
      return null;
    if (!(C & 128))
      return C;
    var D = C & 127;
    if (D > 4)
      return P.error("length octect is too long");
    C = 0;
    for (var q = 0; q < D; q++) {
      C <<= 8;
      var H = P.readUInt8(x);
      if (P.isError(H))
        return H;
      C |= H;
    }
    return C;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var t = inherits_browserExports, e = require$$1$2.Buffer, n = requireDer$1();
  function a(u) {
    n.call(this, u), this.enc = "pem";
  }
  return t(a, n), pem$1 = a, a.prototype.decode = function(o, d) {
    for (var l = o.toString().split(/[\r\n]+/g), _ = d.label.toUpperCase(), P = /^-----(BEGIN|END) ([^-]+)-----$/, h = -1, x = -1, C = 0; C < l.length; C++) {
      var D = l[C].match(P);
      if (D !== null && D[2] === _)
        if (h === -1) {
          if (D[1] !== "BEGIN")
            break;
          h = C;
        } else {
          if (D[1] !== "END")
            break;
          x = C;
          break;
        }
    }
    if (h === -1 || x === -1)
      throw new Error("PEM section not found for: " + _);
    var q = l.slice(h + 1, x).join("");
    q.replace(/[^a-z0-9\+\/=]+/gi, "");
    var H = new e(q, "base64");
    return n.prototype.decode.call(this, H, d);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(t) {
    var e = t;
    e.der = requireDer$1(), e.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var t = inherits_browserExports, e = require$$1$2.Buffer, n = requireAsn1(), a = n.base, u = n.constants.der;
  function o(P) {
    this.enc = "der", this.name = P.name, this.entity = P, this.tree = new d(), this.tree._init(P.body);
  }
  der_1 = o, o.prototype.encode = function(h, x) {
    return this.tree._encode(h, x).join();
  };
  function d(P) {
    a.Node.call(this, "der", P);
  }
  t(d, a.Node), d.prototype._encodeComposite = function(h, x, C, D) {
    var q = _(h, x, C, this.reporter);
    if (D.length < 128) {
      var z = new e(2);
      return z[0] = q, z[1] = D.length, this._createEncoderBuffer([z, D]);
    }
    for (var H = 1, Y = D.length; Y >= 256; Y >>= 8)
      H++;
    var z = new e(2 + H);
    z[0] = q, z[1] = 128 | H;
    for (var Y = 1 + H, F = D.length; F > 0; Y--, F >>= 8)
      z[Y] = F & 255;
    return this._createEncoderBuffer([z, D]);
  }, d.prototype._encodeStr = function(h, x) {
    if (x === "bitstr")
      return this._createEncoderBuffer([h.unused | 0, h.data]);
    if (x === "bmpstr") {
      for (var C = new e(h.length * 2), D = 0; D < h.length; D++)
        C.writeUInt16BE(h.charCodeAt(D), D * 2);
      return this._createEncoderBuffer(C);
    } else return x === "numstr" ? this._isNumstr(h) ? this._createEncoderBuffer(h) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : x === "printstr" ? this._isPrintstr(h) ? this._createEncoderBuffer(h) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(x) ? this._createEncoderBuffer(h) : x === "objDesc" ? this._createEncoderBuffer(h) : this.reporter.error("Encoding of string type: " + x + " unsupported");
  }, d.prototype._encodeObjid = function(h, x, C) {
    if (typeof h == "string") {
      if (!x)
        return this.reporter.error("string objid given, but no values map found");
      if (!x.hasOwnProperty(h))
        return this.reporter.error("objid not found in values map");
      h = x[h].split(/[\s\.]+/g);
      for (var D = 0; D < h.length; D++)
        h[D] |= 0;
    } else if (Array.isArray(h)) {
      h = h.slice();
      for (var D = 0; D < h.length; D++)
        h[D] |= 0;
    }
    if (!Array.isArray(h))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(h));
    if (!C) {
      if (h[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      h.splice(0, 2, h[0] * 40 + h[1]);
    }
    for (var q = 0, D = 0; D < h.length; D++) {
      var H = h[D];
      for (q++; H >= 128; H >>= 7)
        q++;
    }
    for (var Y = new e(q), z = Y.length - 1, D = h.length - 1; D >= 0; D--) {
      var H = h[D];
      for (Y[z--] = H & 127; (H >>= 7) > 0; )
        Y[z--] = 128 | H & 127;
    }
    return this._createEncoderBuffer(Y);
  };
  function l(P) {
    return P < 10 ? "0" + P : P;
  }
  d.prototype._encodeTime = function(h, x) {
    var C, D = new Date(h);
    return x === "gentime" ? C = [
      l(D.getFullYear()),
      l(D.getUTCMonth() + 1),
      l(D.getUTCDate()),
      l(D.getUTCHours()),
      l(D.getUTCMinutes()),
      l(D.getUTCSeconds()),
      "Z"
    ].join("") : x === "utctime" ? C = [
      l(D.getFullYear() % 100),
      l(D.getUTCMonth() + 1),
      l(D.getUTCDate()),
      l(D.getUTCHours()),
      l(D.getUTCMinutes()),
      l(D.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + x + " time is not supported yet"), this._encodeStr(C, "octstr");
  }, d.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, d.prototype._encodeInt = function(h, x) {
    if (typeof h == "string") {
      if (!x)
        return this.reporter.error("String int or enum given, but no values map");
      if (!x.hasOwnProperty(h))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(h));
      h = x[h];
    }
    if (typeof h != "number" && !e.isBuffer(h)) {
      var C = h.toArray();
      !h.sign && C[0] & 128 && C.unshift(0), h = new e(C);
    }
    if (e.isBuffer(h)) {
      var D = h.length;
      h.length === 0 && D++;
      var H = new e(D);
      return h.copy(H), h.length === 0 && (H[0] = 0), this._createEncoderBuffer(H);
    }
    if (h < 128)
      return this._createEncoderBuffer(h);
    if (h < 256)
      return this._createEncoderBuffer([0, h]);
    for (var D = 1, q = h; q >= 256; q >>= 8)
      D++;
    for (var H = new Array(D), q = H.length - 1; q >= 0; q--)
      H[q] = h & 255, h >>= 8;
    return H[0] & 128 && H.unshift(0), this._createEncoderBuffer(new e(H));
  }, d.prototype._encodeBool = function(h) {
    return this._createEncoderBuffer(h ? 255 : 0);
  }, d.prototype._use = function(h, x) {
    return typeof h == "function" && (h = h(x)), h._getEncoder("der").tree;
  }, d.prototype._skipDefault = function(h, x, C) {
    var D = this._baseState, q;
    if (D.default === null)
      return !1;
    var H = h.join();
    if (D.defaultBuffer === void 0 && (D.defaultBuffer = this._encodeValue(D.default, x, C).join()), H.length !== D.defaultBuffer.length)
      return !1;
    for (q = 0; q < H.length; q++)
      if (H[q] !== D.defaultBuffer[q])
        return !1;
    return !0;
  };
  function _(P, h, x, C) {
    var D;
    if (P === "seqof" ? P = "seq" : P === "setof" && (P = "set"), u.tagByName.hasOwnProperty(P))
      D = u.tagByName[P];
    else if (typeof P == "number" && (P | 0) === P)
      D = P;
    else
      return C.error("Unknown tag: " + P);
    return D >= 31 ? C.error("Multi-octet tag encoding unsupported") : (h || (D |= 32), D |= u.tagClassByName[x || "universal"] << 6, D);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var t = inherits_browserExports, e = requireDer();
  function n(a) {
    e.call(this, a), this.enc = "pem";
  }
  return t(n, e), pem = n, n.prototype.encode = function(u, o) {
    for (var d = e.prototype.encode.call(this, u), l = d.toString("base64"), _ = ["-----BEGIN " + o.label + "-----"], P = 0; P < l.length; P += 64)
      _.push(l.slice(P, P + 64));
    return _.push("-----END " + o.label + "-----"), _.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(t) {
    var e = t;
    e.der = requireDer(), e.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1;
function requireAsn1() {
  return hasRequiredAsn1 || (hasRequiredAsn1 = 1, function(t) {
    var e = t;
    e.bignum = bnExports$1, e.define = requireApi().define, e.base = requireBase(), e.constants = requireConstants(), e.decoders = requireDecoders(), e.encoders = requireEncoders();
  }(asn1$2)), asn1$2;
}
var asn = requireAsn1(), Time = asn.define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
}), AttributeTypeValue = asn.define("AttributeTypeValue", function() {
  this.seq().obj(
    this.key("type").objid(),
    this.key("value").any()
  );
}), AlgorithmIdentifier$1 = asn.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("parameters").optional(),
    this.key("curve").objid().optional()
  );
}), SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier$1),
    this.key("subjectPublicKey").bitstr()
  );
}), RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
  this.setof(AttributeTypeValue);
}), RDNSequence = asn.define("RDNSequence", function() {
  this.seqof(RelativeDistinguishedName);
}), Name = asn.define("Name", function() {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  });
}), Validity = asn.define("Validity", function() {
  this.seq().obj(
    this.key("notBefore").use(Time),
    this.key("notAfter").use(Time)
  );
}), Extension = asn.define("Extension", function() {
  this.seq().obj(
    this.key("extnID").objid(),
    this.key("critical").bool().def(!1),
    this.key("extnValue").octstr()
  );
}), TBSCertificate = asn.define("TBSCertificate", function() {
  this.seq().obj(
    this.key("version").explicit(0).int().optional(),
    this.key("serialNumber").int(),
    this.key("signature").use(AlgorithmIdentifier$1),
    this.key("issuer").use(Name),
    this.key("validity").use(Validity),
    this.key("subject").use(Name),
    this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
    this.key("issuerUniqueID").implicit(1).bitstr().optional(),
    this.key("subjectUniqueID").implicit(2).bitstr().optional(),
    this.key("extensions").explicit(3).seqof(Extension).optional()
  );
}), X509Certificate = asn.define("X509Certificate", function() {
  this.seq().obj(
    this.key("tbsCertificate").use(TBSCertificate),
    this.key("signatureAlgorithm").use(AlgorithmIdentifier$1),
    this.key("signatureValue").bitstr()
  );
}), certificate = X509Certificate, asn1$1 = requireAsn1();
asn1$3.certificate = certificate;
var RSAPrivateKey = asn1$1.define("RSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("modulus").int(),
    this.key("publicExponent").int(),
    this.key("privateExponent").int(),
    this.key("prime1").int(),
    this.key("prime2").int(),
    this.key("exponent1").int(),
    this.key("exponent2").int(),
    this.key("coefficient").int()
  );
});
asn1$3.RSAPrivateKey = RSAPrivateKey;
var RSAPublicKey = asn1$1.define("RSAPublicKey", function() {
  this.seq().obj(
    this.key("modulus").int(),
    this.key("publicExponent").int()
  );
});
asn1$3.RSAPublicKey = RSAPublicKey;
var AlgorithmIdentifier = asn1$1.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("none").null_().optional(),
    this.key("curve").objid().optional(),
    this.key("params").seq().obj(
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int()
    ).optional()
  );
}), PublicKey = asn1$1.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPublicKey").bitstr()
  );
});
asn1$3.PublicKey = PublicKey;
var PrivateKeyInfo = asn1$1.define("PrivateKeyInfo", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1$1.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").seq().obj(
      this.key("id").objid(),
      this.key("decrypt").seq().obj(
        this.key("kde").seq().obj(
          this.key("id").objid(),
          this.key("kdeparams").seq().obj(
            this.key("salt").octstr(),
            this.key("iters").int()
          )
        ),
        this.key("cipher").seq().obj(
          this.key("algo").objid(),
          this.key("iv").octstr()
        )
      )
    ),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
var DSAPrivateKey = asn1$1.define("DSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("p").int(),
    this.key("q").int(),
    this.key("g").int(),
    this.key("pub_key").int(),
    this.key("priv_key").int()
  );
});
asn1$3.DSAPrivateKey = DSAPrivateKey;
asn1$3.DSAparam = asn1$1.define("DSAparam", function() {
  this.int();
});
var ECParameters = asn1$1.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
}), ECPrivateKey = asn1$1.define("ECPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("privateKey").octstr(),
    this.key("parameters").optional().explicit(0).use(ECParameters),
    this.key("publicKey").optional().explicit(1).bitstr()
  );
});
asn1$3.ECPrivateKey = ECPrivateKey;
asn1$3.signature = asn1$1.define("signature", function() {
  this.seq().obj(
    this.key("r").int(),
    this.key("s").int()
  );
});
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, evp = evp_bytestokey, ciphers$1 = browser$5, Buffer$6 = safeBufferExports$1.Buffer, fixProc$1 = function(t, e) {
  var n = t.toString(), a = n.match(findProc), u;
  if (a) {
    var d = "aes" + a[1], l = Buffer$6.from(a[2], "hex"), _ = Buffer$6.from(a[3].replace(/[\r\n]/g, ""), "base64"), P = evp(e, l.slice(0, 8), parseInt(a[1], 10)).key, h = [], x = ciphers$1.createDecipheriv(d, P, l);
    h.push(x.update(_)), h.push(x.final()), u = Buffer$6.concat(h);
  } else {
    var o = n.match(fullRegex);
    u = Buffer$6.from(o[2].replace(/[\r\n]/g, ""), "base64");
  }
  var C = n.match(startRegex)[1];
  return {
    tag: C,
    data: u
  };
}, asn1 = asn1$3, aesid = require$$1, fixProc = fixProc$1, ciphers = browser$5, compat = browser$7, Buffer$5 = safeBufferExports$1.Buffer;
function decrypt(t, e) {
  var n = t.algorithm.decrypt.kde.kdeparams.salt, a = parseInt(t.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), u = aesid[t.algorithm.decrypt.cipher.algo.join(".")], o = t.algorithm.decrypt.cipher.iv, d = t.subjectPrivateKey, l = parseInt(u.split("-")[1], 10) / 8, _ = compat.pbkdf2Sync(e, n, a, l, "sha1"), P = ciphers.createDecipheriv(u, _, o), h = [];
  return h.push(P.update(d)), h.push(P.final()), Buffer$5.concat(h);
}
function parseKeys$2(t) {
  var e;
  typeof t == "object" && !Buffer$5.isBuffer(t) && (e = t.passphrase, t = t.key), typeof t == "string" && (t = Buffer$5.from(t));
  var n = fixProc(t, e), a = n.tag, u = n.data, o, d;
  switch (a) {
    case "CERTIFICATE":
      d = asn1.certificate.decode(u, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      switch (d || (d = asn1.PublicKey.decode(u, "der")), o = d.algorithm.algorithm.join("."), o) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPublicKey.decode(d.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          return d.subjectPrivateKey = d.subjectPublicKey, {
            type: "ec",
            data: d
          };
        case "1.2.840.10040.4.1":
          return d.algorithm.params.pub_key = asn1.DSAparam.decode(d.subjectPublicKey.data, "der"), {
            type: "dsa",
            data: d.algorithm.params
          };
        default:
          throw new Error("unknown key id " + o);
      }
    case "ENCRYPTED PRIVATE KEY":
      u = asn1.EncryptedPrivateKey.decode(u, "der"), u = decrypt(u, e);
    case "PRIVATE KEY":
      switch (d = asn1.PrivateKey.decode(u, "der"), o = d.algorithm.algorithm.join("."), o) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPrivateKey.decode(d.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: d.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(d.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          return d.algorithm.params.priv_key = asn1.DSAparam.decode(d.subjectPrivateKey, "der"), {
            type: "dsa",
            params: d.algorithm.params
          };
        default:
          throw new Error("unknown key id " + o);
      }
    case "RSA PUBLIC KEY":
      return asn1.RSAPublicKey.decode(u, "der");
    case "RSA PRIVATE KEY":
      return asn1.RSAPrivateKey.decode(u, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: asn1.DSAPrivateKey.decode(u, "der")
      };
    case "EC PRIVATE KEY":
      return u = asn1.ECPrivateKey.decode(u, "der"), {
        curve: u.parameters.value,
        privateKey: u.privateKey
      };
    default:
      throw new Error("unknown key type " + a);
  }
}
parseKeys$2.signature = asn1.signature;
var parseAsn1 = parseKeys$2;
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
sign.exports;
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  var t = safeBufferExports$1.Buffer, e = browser$8, n = browserifyRsa, a = requireElliptic().ec, u = bnExports, o = parseAsn1, d = require$$4, l = 1;
  function _(z, F, X, ee, se) {
    var ce = o(F);
    if (ce.curve) {
      if (ee !== "ecdsa" && ee !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return P(z, ce);
    } else if (ce.type === "dsa") {
      if (ee !== "dsa")
        throw new Error("wrong private key type");
      return h(z, ce, X);
    }
    if (ee !== "rsa" && ee !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (F.padding !== void 0 && F.padding !== l)
      throw new Error("illegal or unsupported padding mode");
    z = t.concat([se, z]);
    for (var le = ce.modulus.byteLength(), he = [0, 1]; z.length + he.length + 1 < le; )
      he.push(255);
    he.push(0);
    for (var oe = -1; ++oe < z.length; )
      he.push(z[oe]);
    var _e = n(he, ce);
    return _e;
  }
  function P(z, F) {
    var X = d[F.curve.join(".")];
    if (!X)
      throw new Error("unknown curve " + F.curve.join("."));
    var ee = new a(X), se = ee.keyFromPrivate(F.privateKey), ce = se.sign(z);
    return t.from(ce.toDER());
  }
  function h(z, F, X) {
    for (var ee = F.params.priv_key, se = F.params.p, ce = F.params.q, le = F.params.g, he = new u(0), oe, _e = D(z, ce).mod(ce), J = !1, w = C(ee, ce, z, X); J === !1; )
      oe = H(ce, w, X), he = Y(le, oe, se, ce), J = oe.invm(ce).imul(_e.add(ee.mul(he))).mod(ce), J.cmpn(0) === 0 && (J = !1, he = new u(0));
    return x(he, J);
  }
  function x(z, F) {
    z = z.toArray(), F = F.toArray(), z[0] & 128 && (z = [0].concat(z)), F[0] & 128 && (F = [0].concat(F));
    var X = z.length + F.length + 4, ee = [
      48,
      X,
      2,
      z.length
    ];
    return ee = ee.concat(z, [2, F.length], F), t.from(ee);
  }
  function C(z, F, X, ee) {
    if (z = t.from(z.toArray()), z.length < F.byteLength()) {
      var se = t.alloc(F.byteLength() - z.length);
      z = t.concat([se, z]);
    }
    var ce = X.length, le = q(X, F), he = t.alloc(ce);
    he.fill(1);
    var oe = t.alloc(ce);
    return oe = e(ee, oe).update(he).update(t.from([0])).update(z).update(le).digest(), he = e(ee, oe).update(he).digest(), oe = e(ee, oe).update(he).update(t.from([1])).update(z).update(le).digest(), he = e(ee, oe).update(he).digest(), { k: oe, v: he };
  }
  function D(z, F) {
    var X = new u(z), ee = (z.length << 3) - F.bitLength();
    return ee > 0 && X.ishrn(ee), X;
  }
  function q(z, F) {
    z = D(z, F), z = z.mod(F);
    var X = t.from(z.toArray());
    if (X.length < F.byteLength()) {
      var ee = t.alloc(F.byteLength() - X.length);
      X = t.concat([ee, X]);
    }
    return X;
  }
  function H(z, F, X) {
    var ee, se;
    do {
      for (ee = t.alloc(0); ee.length * 8 < z.bitLength(); )
        F.v = e(X, F.k).update(F.v).digest(), ee = t.concat([ee, F.v]);
      se = D(ee, z), F.k = e(X, F.k).update(F.v).update(t.from([0])).digest(), F.v = e(X, F.k).update(F.v).digest();
    } while (se.cmp(z) !== -1);
    return se;
  }
  function Y(z, F, X, ee) {
    return z.toRed(u.mont(X)).redPow(F).fromRed().mod(ee);
  }
  return sign.exports = _, sign.exports.getKey = C, sign.exports.makeKey = H, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1;
  hasRequiredVerify = 1;
  var t = safeBufferExports$1.Buffer, e = bnExports, n = requireElliptic().ec, a = parseAsn1, u = require$$4;
  function o(P, h, x, C, D) {
    var q = a(x);
    if (q.type === "ec") {
      if (C !== "ecdsa" && C !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return d(P, h, q);
    } else if (q.type === "dsa") {
      if (C !== "dsa")
        throw new Error("wrong public key type");
      return l(P, h, q);
    }
    if (C !== "rsa" && C !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    h = t.concat([D, h]);
    for (var H = q.modulus.byteLength(), Y = [1], z = 0; h.length + Y.length + 2 < H; )
      Y.push(255), z += 1;
    Y.push(0);
    for (var F = -1; ++F < h.length; )
      Y.push(h[F]);
    Y = t.from(Y);
    var X = e.mont(q.modulus);
    P = new e(P).toRed(X), P = P.redPow(new e(q.publicExponent)), P = t.from(P.fromRed().toArray());
    var ee = z < 8 ? 1 : 0;
    for (H = Math.min(P.length, Y.length), P.length !== Y.length && (ee = 1), F = -1; ++F < H; )
      ee |= P[F] ^ Y[F];
    return ee === 0;
  }
  function d(P, h, x) {
    var C = u[x.data.algorithm.curve.join(".")];
    if (!C)
      throw new Error("unknown curve " + x.data.algorithm.curve.join("."));
    var D = new n(C), q = x.data.subjectPrivateKey.data;
    return D.verify(h, P, q);
  }
  function l(P, h, x) {
    var C = x.data.p, D = x.data.q, q = x.data.g, H = x.data.pub_key, Y = a.signature.decode(P, "der"), z = Y.s, F = Y.r;
    _(z, D), _(F, D);
    var X = e.mont(C), ee = z.invm(D), se = q.toRed(X).redPow(new e(h).mul(ee).mod(D)).fromRed().mul(H.toRed(X).redPow(F.mul(ee).mod(D)).fromRed()).mod(C).mod(D);
    return se.cmp(F) === 0;
  }
  function _(P, h) {
    if (P.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (P.cmp(h) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = o, verify_1;
}
var browser$3, hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$3;
  hasRequiredBrowser$1 = 1;
  var t = safeBufferExports$1.Buffer, e = browser$9, n = readableBrowserExports, a = inherits_browserExports, u = requireSign(), o = requireVerify(), d = require$$6;
  Object.keys(d).forEach(function(x) {
    d[x].id = t.from(d[x].id, "hex"), d[x.toLowerCase()] = d[x];
  });
  function l(x) {
    n.Writable.call(this);
    var C = d[x];
    if (!C)
      throw new Error("Unknown message digest");
    this._hashType = C.hash, this._hash = e(C.hash), this._tag = C.id, this._signType = C.sign;
  }
  a(l, n.Writable), l.prototype._write = function(C, D, q) {
    this._hash.update(C), q();
  }, l.prototype.update = function(C, D) {
    return this._hash.update(typeof C == "string" ? t.from(C, D) : C), this;
  }, l.prototype.sign = function(C, D) {
    this.end();
    var q = this._hash.digest(), H = u(q, C, this._hashType, this._signType, this._tag);
    return D ? H.toString(D) : H;
  };
  function _(x) {
    n.Writable.call(this);
    var C = d[x];
    if (!C)
      throw new Error("Unknown message digest");
    this._hash = e(C.hash), this._tag = C.id, this._signType = C.sign;
  }
  a(_, n.Writable), _.prototype._write = function(C, D, q) {
    this._hash.update(C), q();
  }, _.prototype.update = function(C, D) {
    return this._hash.update(typeof C == "string" ? t.from(C, D) : C), this;
  }, _.prototype.verify = function(C, D, q) {
    var H = typeof D == "string" ? t.from(D, q) : D;
    this.end();
    var Y = this._hash.digest();
    return o(H, Y, C, this._signType, this._tag);
  };
  function P(x) {
    return new l(x);
  }
  function h(x) {
    return new _(x);
  }
  return browser$3 = {
    Sign: P,
    Verify: h,
    createSign: P,
    createVerify: h
  }, browser$3;
}
var browser$2, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser$2;
  hasRequiredBrowser = 1;
  var t = requireElliptic(), e = bnExports$1;
  browser$2 = function(d) {
    return new a(d);
  };
  var n = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  n.p224 = n.secp224r1, n.p256 = n.secp256r1 = n.prime256v1, n.p192 = n.secp192r1 = n.prime192v1, n.p384 = n.secp384r1, n.p521 = n.secp521r1;
  function a(o) {
    this.curveType = n[o], this.curveType || (this.curveType = {
      name: o
    }), this.curve = new t.ec(this.curveType.name), this.keys = void 0;
  }
  a.prototype.generateKeys = function(o, d) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(o, d);
  }, a.prototype.computeSecret = function(o, d, l) {
    d = d || "utf8", Buffer$C.isBuffer(o) || (o = new Buffer$C(o, d));
    var _ = this.curve.keyFromPublic(o).getPublic(), P = _.mul(this.keys.getPrivate()).getX();
    return u(P, l, this.curveType.byteLength);
  }, a.prototype.getPublicKey = function(o, d) {
    var l = this.keys.getPublic(d === "compressed", !0);
    return d === "hybrid" && (l[l.length - 1] % 2 ? l[0] = 7 : l[0] = 6), u(l, o);
  }, a.prototype.getPrivateKey = function(o) {
    return u(this.keys.getPrivate(), o);
  }, a.prototype.setPublicKey = function(o, d) {
    return d = d || "utf8", Buffer$C.isBuffer(o) || (o = new Buffer$C(o, d)), this.keys._importPublic(o), this;
  }, a.prototype.setPrivateKey = function(o, d) {
    d = d || "utf8", Buffer$C.isBuffer(o) || (o = new Buffer$C(o, d));
    var l = new e(o);
    return l = l.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(l), this;
  };
  function u(o, d, l) {
    Array.isArray(o) || (o = o.toArray());
    var _ = new Buffer$C(o);
    if (l && _.length < l) {
      var P = new Buffer$C(l - _.length);
      P.fill(0), _ = Buffer$C.concat([P, _]);
    }
    return d ? _.toString(d) : _;
  }
  return browser$2;
}
var browser$1 = {}, createHash$2 = browser$9, Buffer$4 = safeBufferExports$1.Buffer, mgf$2 = function(t, e) {
  for (var n = Buffer$4.alloc(0), a = 0, u; n.length < e; )
    u = i2ops(a++), n = Buffer$4.concat([n, createHash$2("sha1").update(t).update(u).digest()]);
  return n.slice(0, e);
};
function i2ops(t) {
  var e = Buffer$4.allocUnsafe(4);
  return e.writeUInt32BE(t, 0), e;
}
var xor$2 = function t(e, n) {
  for (var a = e.length, u = -1; ++u < a; )
    e[u] ^= n[u];
  return e;
}, BN$2 = bnExports$1, Buffer$3 = safeBufferExports$1.Buffer;
function withPublic$2(t, e) {
  return Buffer$3.from(t.toRed(BN$2.mont(e.modulus)).redPow(new BN$2(e.publicExponent)).fromRed().toArray());
}
var withPublic_1 = withPublic$2, parseKeys$1 = parseAsn1, randomBytes = browserExports, createHash$1 = browser$9, mgf$1 = mgf$2, xor$1 = xor$2, BN$1 = bnExports$1, withPublic$1 = withPublic_1, crt$1 = browserifyRsa, Buffer$2 = safeBufferExports$1.Buffer, publicEncrypt = function t(e, n, a) {
  var u;
  e.padding ? u = e.padding : a ? u = 1 : u = 4;
  var o = parseKeys$1(e), d;
  if (u === 4)
    d = oaep$1(o, n);
  else if (u === 1)
    d = pkcs1$1(o, n, a);
  else if (u === 3) {
    if (d = new BN$1(n), d.cmp(o.modulus) >= 0)
      throw new Error("data too long for modulus");
  } else
    throw new Error("unknown padding");
  return a ? crt$1(d, o) : withPublic$1(d, o);
};
function oaep$1(t, e) {
  var n = t.modulus.byteLength(), a = e.length, u = createHash$1("sha1").update(Buffer$2.alloc(0)).digest(), o = u.length, d = 2 * o;
  if (a > n - d - 2)
    throw new Error("message too long");
  var l = Buffer$2.alloc(n - a - d - 2), _ = n - o - 1, P = randomBytes(o), h = xor$1(Buffer$2.concat([u, l, Buffer$2.alloc(1, 1), e], _), mgf$1(P, _)), x = xor$1(P, mgf$1(h, o));
  return new BN$1(Buffer$2.concat([Buffer$2.alloc(1), x, h], n));
}
function pkcs1$1(t, e, n) {
  var a = e.length, u = t.modulus.byteLength();
  if (a > u - 11)
    throw new Error("message too long");
  var o;
  return n ? o = Buffer$2.alloc(u - a - 3, 255) : o = nonZero(u - a - 3), new BN$1(Buffer$2.concat([Buffer$2.from([0, n ? 1 : 2]), o, Buffer$2.alloc(1), e], u));
}
function nonZero(t) {
  for (var e = Buffer$2.allocUnsafe(t), n = 0, a = randomBytes(t * 2), u = 0, o; n < t; )
    u === a.length && (a = randomBytes(t * 2), u = 0), o = a[u++], o && (e[n++] = o);
  return e;
}
var parseKeys = parseAsn1, mgf = mgf$2, xor = xor$2, BN = bnExports$1, crt = browserifyRsa, createHash = browser$9, withPublic = withPublic_1, Buffer$1 = safeBufferExports$1.Buffer, privateDecrypt = function t(e, n, a) {
  var u;
  e.padding ? u = e.padding : a ? u = 1 : u = 4;
  var o = parseKeys(e), d = o.modulus.byteLength();
  if (n.length > d || new BN(n).cmp(o.modulus) >= 0)
    throw new Error("decryption error");
  var l;
  a ? l = withPublic(new BN(n), o) : l = crt(n, o);
  var _ = Buffer$1.alloc(d - l.length);
  if (l = Buffer$1.concat([_, l], d), u === 4)
    return oaep(o, l);
  if (u === 1)
    return pkcs1(o, l, a);
  if (u === 3)
    return l;
  throw new Error("unknown padding");
};
function oaep(t, e) {
  var n = t.modulus.byteLength(), a = createHash("sha1").update(Buffer$1.alloc(0)).digest(), u = a.length;
  if (e[0] !== 0)
    throw new Error("decryption error");
  var o = e.slice(1, u + 1), d = e.slice(u + 1), l = xor(o, mgf(d, u)), _ = xor(d, mgf(l, n - u - 1));
  if (compare(a, _.slice(0, u)))
    throw new Error("decryption error");
  for (var P = u; _[P] === 0; )
    P++;
  if (_[P++] !== 1)
    throw new Error("decryption error");
  return _.slice(P);
}
function pkcs1(t, e, n) {
  for (var a = e.slice(0, 2), u = 2, o = 0; e[u++] !== 0; )
    if (u >= e.length) {
      o++;
      break;
    }
  var d = e.slice(2, u - 1);
  if ((a.toString("hex") !== "0002" && !n || a.toString("hex") !== "0001" && n) && o++, d.length < 8 && o++, o)
    throw new Error("decryption error");
  return e.slice(u);
}
function compare(t, e) {
  t = Buffer$1.from(t), e = Buffer$1.from(e);
  var n = 0, a = t.length;
  t.length !== e.length && (n++, a = Math.min(t.length, e.length));
  for (var u = -1; ++u < a; )
    n += t[u] ^ e[u];
  return n;
}
(function(t) {
  t.publicEncrypt = publicEncrypt, t.privateDecrypt = privateDecrypt, t.privateEncrypt = function(n, a) {
    return t.publicEncrypt(n, a, !0);
  }, t.publicDecrypt = function(n, a) {
    return t.privateDecrypt(n, a, !0);
  };
})(browser$1);
var browser = {};
function oldBrowser() {
  throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
}
var safeBuffer = safeBufferExports$1, randombytes = browserExports, Buffer = safeBuffer.Buffer, kBufferMaxLength = safeBuffer.kMaxLength, crypto = commonjsGlobal.crypto || commonjsGlobal.msCrypto, kMaxUint32 = Math.pow(2, 32) - 1;
function assertOffset(t, e) {
  if (typeof t != "number" || t !== t)
    throw new TypeError("offset must be a number");
  if (t > kMaxUint32 || t < 0)
    throw new TypeError("offset must be a uint32");
  if (t > kBufferMaxLength || t > e)
    throw new RangeError("offset out of range");
}
function assertSize(t, e, n) {
  if (typeof t != "number" || t !== t)
    throw new TypeError("size must be a number");
  if (t > kMaxUint32 || t < 0)
    throw new TypeError("size must be a uint32");
  if (t + e > n || t > kBufferMaxLength)
    throw new RangeError("buffer too small");
}
crypto && crypto.getRandomValues || !process$1.browser ? (browser.randomFill = randomFill, browser.randomFillSync = randomFillSync) : (browser.randomFill = oldBrowser, browser.randomFillSync = oldBrowser);
function randomFill(t, e, n, a) {
  if (!Buffer.isBuffer(t) && !(t instanceof commonjsGlobal.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  if (typeof e == "function")
    a = e, e = 0, n = t.length;
  else if (typeof n == "function")
    a = n, n = t.length - e;
  else if (typeof a != "function")
    throw new TypeError('"cb" argument must be a function');
  return assertOffset(e, t.length), assertSize(n, e, t.length), actualFill(t, e, n, a);
}
function actualFill(t, e, n, a) {
  if (process$1.browser) {
    var u = t.buffer, o = new Uint8Array(u, e, n);
    if (crypto.getRandomValues(o), a) {
      process$1.nextTick(function() {
        a(null, t);
      });
      return;
    }
    return t;
  }
  if (a) {
    randombytes(n, function(l, _) {
      if (l)
        return a(l);
      _.copy(t, e), a(null, t);
    });
    return;
  }
  var d = randombytes(n);
  return d.copy(t, e), t;
}
function randomFillSync(t, e, n) {
  if (typeof e > "u" && (e = 0), !Buffer.isBuffer(t) && !(t instanceof commonjsGlobal.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  return assertOffset(e, t.length), n === void 0 && (n = t.length - e), assertSize(n, e, t.length), actualFill(t, e, n);
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = browserExports, cryptoBrowserify.createHash = cryptoBrowserify.Hash = browser$9, cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = browser$8;
  var t = algos, e = Object.keys(t), n = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
  ].concat(e);
  cryptoBrowserify.getHashes = function() {
    return n;
  };
  var a = browser$7;
  cryptoBrowserify.pbkdf2 = a.pbkdf2, cryptoBrowserify.pbkdf2Sync = a.pbkdf2Sync;
  var u = browser$6;
  cryptoBrowserify.Cipher = u.Cipher, cryptoBrowserify.createCipher = u.createCipher, cryptoBrowserify.Cipheriv = u.Cipheriv, cryptoBrowserify.createCipheriv = u.createCipheriv, cryptoBrowserify.Decipher = u.Decipher, cryptoBrowserify.createDecipher = u.createDecipher, cryptoBrowserify.Decipheriv = u.Decipheriv, cryptoBrowserify.createDecipheriv = u.createDecipheriv, cryptoBrowserify.getCiphers = u.getCiphers, cryptoBrowserify.listCiphers = u.listCiphers;
  var o = requireBrowser$2();
  cryptoBrowserify.DiffieHellmanGroup = o.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = o.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = o.getDiffieHellman, cryptoBrowserify.createDiffieHellman = o.createDiffieHellman, cryptoBrowserify.DiffieHellman = o.DiffieHellman;
  var d = requireBrowser$1();
  cryptoBrowserify.createSign = d.createSign, cryptoBrowserify.Sign = d.Sign, cryptoBrowserify.createVerify = d.createVerify, cryptoBrowserify.Verify = d.Verify, cryptoBrowserify.createECDH = requireBrowser();
  var l = browser$1;
  cryptoBrowserify.publicEncrypt = l.publicEncrypt, cryptoBrowserify.privateEncrypt = l.privateEncrypt, cryptoBrowserify.publicDecrypt = l.publicDecrypt, cryptoBrowserify.privateDecrypt = l.privateDecrypt;
  var _ = browser;
  return cryptoBrowserify.randomFill = _.randomFill, cryptoBrowserify.randomFillSync = _.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
var cryptoBrowserifyExports = requireCryptoBrowserify();
class Base64 {
  encode(e, n) {
    return typeof e == "string" ? Buffer$C.from(e, n).toString("base64") : Buffer$C.isBuffer(e) ? e.toString("base64") : Buffer$C.from(e).toString("base64");
  }
  decode(e, n = "utf-8", a = !1) {
    if (Buffer$C.isBuffer(e))
      return e.toString(n);
    const u = Buffer$C.from(e, "base64").toString(n), o = this.encode(u, n) !== e;
    if (a && o)
      throw new Error("Cannot decode malformed value");
    return o ? null : u;
  }
  urlEncode(e, n) {
    return (typeof e == "string" ? this.encode(e, n) : this.encode(e)).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
  }
  urlDecode(e, n = "utf-8", a = !1) {
    if (Buffer$C.isBuffer(e))
      return e.toString(n);
    const u = Buffer$C.from(e, "base64").toString(n), o = this.urlEncode(u, n) !== e;
    if (a && o)
      throw new Error("Cannot urlDecode malformed value");
    return o ? null : u;
  }
}
var secureJsonParse = { exports: {} };
secureJsonParse.exports;
const hasBuffer = typeof Buffer$C < "u", suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/, suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
function _parse(t, e, n) {
  n == null && e !== null && typeof e == "object" && (n = e, e = void 0), hasBuffer && Buffer$C.isBuffer(t) && (t = t.toString()), t && t.charCodeAt(0) === 65279 && (t = t.slice(1));
  const a = JSON.parse(t, e);
  if (a === null || typeof a != "object")
    return a;
  const u = n && n.protoAction || "error", o = n && n.constructorAction || "error";
  if (u === "ignore" && o === "ignore")
    return a;
  if (u !== "ignore" && o !== "ignore") {
    if (suspectProtoRx.test(t) === !1 && suspectConstructorRx.test(t) === !1)
      return a;
  } else if (u !== "ignore" && o === "ignore") {
    if (suspectProtoRx.test(t) === !1)
      return a;
  } else if (suspectConstructorRx.test(t) === !1)
    return a;
  return filter(a, { protoAction: u, constructorAction: o, safe: n && n.safe });
}
function filter(t, { protoAction: e = "error", constructorAction: n = "error", safe: a } = {}) {
  let u = [t];
  for (; u.length; ) {
    const o = u;
    u = [];
    for (const d of o) {
      if (e !== "ignore" && Object.prototype.hasOwnProperty.call(d, "__proto__")) {
        if (a === !0)
          return null;
        if (e === "error")
          throw new SyntaxError("Object contains forbidden prototype property");
        delete d.__proto__;
      }
      if (n !== "ignore" && Object.prototype.hasOwnProperty.call(d, "constructor") && Object.prototype.hasOwnProperty.call(d.constructor, "prototype")) {
        if (a === !0)
          return null;
        if (n === "error")
          throw new SyntaxError("Object contains forbidden prototype property");
        delete d.constructor;
      }
      for (const l in d) {
        const _ = d[l];
        _ && typeof _ == "object" && u.push(_);
      }
    }
  }
  return t;
}
function parse$1(t, e, n) {
  const { stackTraceLimit: a } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse(t, e, n);
  } finally {
    Error.stackTraceLimit = a;
  }
}
function safeParse$1(t, e) {
  const { stackTraceLimit: n } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse(t, e, { safe: !0 });
  } catch {
    return;
  } finally {
    Error.stackTraceLimit = n;
  }
}
secureJsonParse.exports = parse$1;
secureJsonParse.exports.default = parse$1;
var parse_1 = secureJsonParse.exports.parse = parse$1;
secureJsonParse.exports.safeParse = safeParse$1;
secureJsonParse.exports.scan = filter;
secureJsonParse.exports;
var safeStableStringify = { exports: {} };
safeStableStringify.exports;
(function(t, e) {
  const { hasOwnProperty: n } = Object.prototype, a = z();
  a.configure = z, a.stringify = a, a.default = a, e.stringify = a, e.configure = z, t.exports = a;
  const u = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
  function o(F) {
    return F.length < 5e3 && !u.test(F) ? `"${F}"` : JSON.stringify(F);
  }
  function d(F, X) {
    if (F.length > 200 || X)
      return F.sort(X);
    for (let ee = 1; ee < F.length; ee++) {
      const se = F[ee];
      let ce = ee;
      for (; ce !== 0 && F[ce - 1] > se; )
        F[ce] = F[ce - 1], ce--;
      F[ce] = se;
    }
    return F;
  }
  const l = Object.getOwnPropertyDescriptor(
    Object.getPrototypeOf(
      Object.getPrototypeOf(
        new Int8Array()
      )
    ),
    Symbol.toStringTag
  ).get;
  function _(F) {
    return l.call(F) !== void 0 && F.length !== 0;
  }
  function P(F, X, ee) {
    F.length < ee && (ee = F.length);
    const se = X === "," ? "" : " ";
    let ce = `"0":${se}${F[0]}`;
    for (let le = 1; le < ee; le++)
      ce += `${X}"${le}":${se}${F[le]}`;
    return ce;
  }
  function h(F) {
    if (n.call(F, "circularValue")) {
      const X = F.circularValue;
      if (typeof X == "string")
        return `"${X}"`;
      if (X == null)
        return X;
      if (X === Error || X === TypeError)
        return {
          toString() {
            throw new TypeError("Converting circular structure to JSON");
          }
        };
      throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
    }
    return '"[Circular]"';
  }
  function x(F) {
    let X;
    if (n.call(F, "deterministic") && (X = F.deterministic, typeof X != "boolean" && typeof X != "function"))
      throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
    return X === void 0 ? !0 : X;
  }
  function C(F, X) {
    let ee;
    if (n.call(F, X) && (ee = F[X], typeof ee != "boolean"))
      throw new TypeError(`The "${X}" argument must be of type boolean`);
    return ee === void 0 ? !0 : ee;
  }
  function D(F, X) {
    let ee;
    if (n.call(F, X)) {
      if (ee = F[X], typeof ee != "number")
        throw new TypeError(`The "${X}" argument must be of type number`);
      if (!Number.isInteger(ee))
        throw new TypeError(`The "${X}" argument must be an integer`);
      if (ee < 1)
        throw new RangeError(`The "${X}" argument must be >= 1`);
    }
    return ee === void 0 ? 1 / 0 : ee;
  }
  function q(F) {
    return F === 1 ? "1 item" : `${F} items`;
  }
  function H(F) {
    const X = /* @__PURE__ */ new Set();
    for (const ee of F)
      (typeof ee == "string" || typeof ee == "number") && X.add(String(ee));
    return X;
  }
  function Y(F) {
    if (n.call(F, "strict")) {
      const X = F.strict;
      if (typeof X != "boolean")
        throw new TypeError('The "strict" argument must be of type boolean');
      if (X)
        return (ee) => {
          let se = `Object can not safely be stringified. Received type ${typeof ee}`;
          throw typeof ee != "function" && (se += ` (${ee.toString()})`), new Error(se);
        };
    }
  }
  function z(F) {
    F = { ...F };
    const X = Y(F);
    X && (F.bigint === void 0 && (F.bigint = !1), "circularValue" in F || (F.circularValue = Error));
    const ee = h(F), se = C(F, "bigint"), ce = x(F), le = typeof ce == "function" ? ce : void 0, he = D(F, "maximumDepth"), oe = D(F, "maximumBreadth");
    function _e(v, $, S, A, M, p) {
      let B = $[v];
      switch (typeof B == "object" && B !== null && typeof B.toJSON == "function" && (B = B.toJSON(v)), B = A.call($, v, B), typeof B) {
        case "string":
          return o(B);
        case "object": {
          if (B === null)
            return "null";
          if (S.indexOf(B) !== -1)
            return ee;
          let b = "", k = ",";
          const Z = p;
          if (Array.isArray(B)) {
            if (B.length === 0)
              return "[]";
            if (he < S.length + 1)
              return '"[Array]"';
            S.push(B), M !== "" && (p += M, b += `
${p}`, k = `,
${p}`);
            const ie = Math.min(B.length, oe);
            let L = 0;
            for (; L < ie - 1; L++) {
              const ne = _e(String(L), B, S, A, M, p);
              b += ne !== void 0 ? ne : "null", b += k;
            }
            const j = _e(String(L), B, S, A, M, p);
            if (b += j !== void 0 ? j : "null", B.length - 1 > oe) {
              const ne = B.length - oe - 1;
              b += `${k}"... ${q(ne)} not stringified"`;
            }
            return M !== "" && (b += `
${Z}`), S.pop(), `[${b}]`;
          }
          let te = Object.keys(B);
          const V = te.length;
          if (V === 0)
            return "{}";
          if (he < S.length + 1)
            return '"[Object]"';
          let T = "", O = "";
          M !== "" && (p += M, k = `,
${p}`, T = " ");
          const Q = Math.min(V, oe);
          ce && !_(B) && (te = d(te, le)), S.push(B);
          for (let ie = 0; ie < Q; ie++) {
            const L = te[ie], j = _e(L, B, S, A, M, p);
            j !== void 0 && (b += `${O}${o(L)}:${T}${j}`, O = k);
          }
          if (V > oe) {
            const ie = V - oe;
            b += `${O}"...":${T}"${q(ie)} not stringified"`, O = k;
          }
          return M !== "" && O.length > 1 && (b = `
${p}${b}
${Z}`), S.pop(), `{${b}}`;
        }
        case "number":
          return isFinite(B) ? String(B) : X ? X(B) : "null";
        case "boolean":
          return B === !0 ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (se)
            return String(B);
        default:
          return X ? X(B) : void 0;
      }
    }
    function J(v, $, S, A, M, p) {
      switch (typeof $ == "object" && $ !== null && typeof $.toJSON == "function" && ($ = $.toJSON(v)), typeof $) {
        case "string":
          return o($);
        case "object": {
          if ($ === null)
            return "null";
          if (S.indexOf($) !== -1)
            return ee;
          const B = p;
          let b = "", k = ",";
          if (Array.isArray($)) {
            if ($.length === 0)
              return "[]";
            if (he < S.length + 1)
              return '"[Array]"';
            S.push($), M !== "" && (p += M, b += `
${p}`, k = `,
${p}`);
            const V = Math.min($.length, oe);
            let T = 0;
            for (; T < V - 1; T++) {
              const Q = J(String(T), $[T], S, A, M, p);
              b += Q !== void 0 ? Q : "null", b += k;
            }
            const O = J(String(T), $[T], S, A, M, p);
            if (b += O !== void 0 ? O : "null", $.length - 1 > oe) {
              const Q = $.length - oe - 1;
              b += `${k}"... ${q(Q)} not stringified"`;
            }
            return M !== "" && (b += `
${B}`), S.pop(), `[${b}]`;
          }
          S.push($);
          let Z = "";
          M !== "" && (p += M, k = `,
${p}`, Z = " ");
          let te = "";
          for (const V of A) {
            const T = J(V, $[V], S, A, M, p);
            T !== void 0 && (b += `${te}${o(V)}:${Z}${T}`, te = k);
          }
          return M !== "" && te.length > 1 && (b = `
${p}${b}
${B}`), S.pop(), `{${b}}`;
        }
        case "number":
          return isFinite($) ? String($) : X ? X($) : "null";
        case "boolean":
          return $ === !0 ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (se)
            return String($);
        default:
          return X ? X($) : void 0;
      }
    }
    function w(v, $, S, A, M) {
      switch (typeof $) {
        case "string":
          return o($);
        case "object": {
          if ($ === null)
            return "null";
          if (typeof $.toJSON == "function") {
            if ($ = $.toJSON(v), typeof $ != "object")
              return w(v, $, S, A, M);
            if ($ === null)
              return "null";
          }
          if (S.indexOf($) !== -1)
            return ee;
          const p = M;
          if (Array.isArray($)) {
            if ($.length === 0)
              return "[]";
            if (he < S.length + 1)
              return '"[Array]"';
            S.push($), M += A;
            let T = `
${M}`;
            const O = `,
${M}`, Q = Math.min($.length, oe);
            let ie = 0;
            for (; ie < Q - 1; ie++) {
              const j = w(String(ie), $[ie], S, A, M);
              T += j !== void 0 ? j : "null", T += O;
            }
            const L = w(String(ie), $[ie], S, A, M);
            if (T += L !== void 0 ? L : "null", $.length - 1 > oe) {
              const j = $.length - oe - 1;
              T += `${O}"... ${q(j)} not stringified"`;
            }
            return T += `
${p}`, S.pop(), `[${T}]`;
          }
          let B = Object.keys($);
          const b = B.length;
          if (b === 0)
            return "{}";
          if (he < S.length + 1)
            return '"[Object]"';
          M += A;
          const k = `,
${M}`;
          let Z = "", te = "", V = Math.min(b, oe);
          _($) && (Z += P($, k, oe), B = B.slice($.length), V -= $.length, te = k), ce && (B = d(B, le)), S.push($);
          for (let T = 0; T < V; T++) {
            const O = B[T], Q = w(O, $[O], S, A, M);
            Q !== void 0 && (Z += `${te}${o(O)}: ${Q}`, te = k);
          }
          if (b > oe) {
            const T = b - oe;
            Z += `${te}"...": "${q(T)} not stringified"`, te = k;
          }
          return te !== "" && (Z = `
${M}${Z}
${p}`), S.pop(), `{${Z}}`;
        }
        case "number":
          return isFinite($) ? String($) : X ? X($) : "null";
        case "boolean":
          return $ === !0 ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (se)
            return String($);
        default:
          return X ? X($) : void 0;
      }
    }
    function m(v, $, S) {
      switch (typeof $) {
        case "string":
          return o($);
        case "object": {
          if ($ === null)
            return "null";
          if (typeof $.toJSON == "function") {
            if ($ = $.toJSON(v), typeof $ != "object")
              return m(v, $, S);
            if ($ === null)
              return "null";
          }
          if (S.indexOf($) !== -1)
            return ee;
          let A = "";
          const M = $.length !== void 0;
          if (M && Array.isArray($)) {
            if ($.length === 0)
              return "[]";
            if (he < S.length + 1)
              return '"[Array]"';
            S.push($);
            const Z = Math.min($.length, oe);
            let te = 0;
            for (; te < Z - 1; te++) {
              const T = m(String(te), $[te], S);
              A += T !== void 0 ? T : "null", A += ",";
            }
            const V = m(String(te), $[te], S);
            if (A += V !== void 0 ? V : "null", $.length - 1 > oe) {
              const T = $.length - oe - 1;
              A += `,"... ${q(T)} not stringified"`;
            }
            return S.pop(), `[${A}]`;
          }
          let p = Object.keys($);
          const B = p.length;
          if (B === 0)
            return "{}";
          if (he < S.length + 1)
            return '"[Object]"';
          let b = "", k = Math.min(B, oe);
          M && _($) && (A += P($, ",", oe), p = p.slice($.length), k -= $.length, b = ","), ce && (p = d(p, le)), S.push($);
          for (let Z = 0; Z < k; Z++) {
            const te = p[Z], V = m(te, $[te], S);
            V !== void 0 && (A += `${b}${o(te)}:${V}`, b = ",");
          }
          if (B > oe) {
            const Z = B - oe;
            A += `${b}"...":"${q(Z)} not stringified"`;
          }
          return S.pop(), `{${A}}`;
        }
        case "number":
          return isFinite($) ? String($) : X ? X($) : "null";
        case "boolean":
          return $ === !0 ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (se)
            return String($);
        default:
          return X ? X($) : void 0;
      }
    }
    function c(v, $, S) {
      if (arguments.length > 1) {
        let A = "";
        if (typeof S == "number" ? A = " ".repeat(Math.min(S, 10)) : typeof S == "string" && (A = S.slice(0, 10)), $ != null) {
          if (typeof $ == "function")
            return _e("", { "": v }, [], $, A, "");
          if (Array.isArray($))
            return J("", v, [], H($), A, "");
        }
        if (A.length !== 0)
          return w("", v, [], A, "");
      }
      return m("", v, []);
    }
    return c;
  }
})(safeStableStringify, safeStableStringify.exports);
var safeStableStringifyExports = safeStableStringify.exports;
const cjsModule = /* @__PURE__ */ getDefaultExportFromCjs$1(safeStableStringifyExports), configure = cjsModule.configure;
var RGX = /^(-?(?:\d+)?\.?\d+) *(m(?:illiseconds?|s(?:ecs?)?))?(s(?:ec(?:onds?|s)?)?)?(m(?:in(?:utes?|s)?)?)?(h(?:ours?|rs?)?)?(d(?:ays?)?)?(w(?:eeks?|ks?)?)?(y(?:ears?|rs?)?)?$/, SEC = 1e3, MIN = SEC * 60, HOUR = MIN * 60, DAY = HOUR * 24, YEAR = DAY * 365.25;
function parse(t) {
  var e, n = t.toLowerCase().match(RGX);
  if (n != null && (e = parseFloat(n[1])))
    return n[3] != null ? e * SEC : n[4] != null ? e * MIN : n[5] != null ? e * HOUR : n[6] != null ? e * DAY : n[7] != null ? e * DAY * 7 : n[8] != null ? e * YEAR : e;
}
const textEncoder = new TextEncoder();
function toUint8Array(t) {
  if (typeof t == "string")
    return textEncoder.encode(t);
  if (typeof SharedArrayBuffer < "u" && t instanceof SharedArrayBuffer)
    return new Uint8Array(t);
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (Array.isArray(t))
    return Uint8Array.from(t);
  const e = typeof t[Symbol.toPrimitive] == "function" ? t[Symbol.toPrimitive]("string") : t.valueOf();
  return textEncoder.encode(String(e));
}
function safeEqual(t, e) {
  if (typeof t == "string" && typeof e == "string") {
    const o = textEncoder.encode(t), d = textEncoder.encode(e), l = o.length, _ = new Uint8Array(l);
    _.set(o.subarray(0, l));
    const P = new Uint8Array(l);
    P.set(d.subarray(0, l));
    let h = 0;
    for (let x = 0; x < l; x++)
      h |= _[x] ^ P[x];
    return h === 0 && d.length === l;
  }
  const n = toUint8Array(t), a = toUint8Array(e);
  if (n.length !== a.length)
    return !1;
  let u = 0;
  for (const [o, d] of n.entries())
    u |= d ^ a[o];
  return u === 0;
}
const base64 = new Base64(), getRandomString = (t) => {
  const e = (t + 1) * 6, n = cryptoBrowserifyExports.randomBytes(Math.ceil(e / 8));
  return Buffer$C.from(n.buffer).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "").slice(0, t);
};
function safeParse(t, e) {
  return parse_1(t, e, {
    protoAction: "remove",
    constructorAction: "remove"
  });
}
const stringify = configure({
  bigint: !1,
  circularValue: void 0,
  deterministic: !1
});
function jsonStringifyReplacer(t) {
  return function(e, n) {
    const a = t ? t.call(this, e, n) : n;
    return typeof a == "bigint" ? a.toString() : a;
  };
}
function safeStringify(t, e, n) {
  return stringify(t, jsonStringifyReplacer(e), n);
}
const parseMs = (t) => {
  if (typeof t == "number")
    return t;
  const e = parse(t);
  if (e === void 0)
    throw new Error(`Invalid duration expression "${t}"`);
  return e;
}, json = {
  safeParse,
  safeStringify
};
var Ir, Hr, Kr;
class MessageBuilder {
  constructor() {
    ir(this, Ir);
  }
  /**
   * Builds a message by encoding expiry date and purpose inside it.
   */
  build(e, n, a) {
    const u = Dr(this, Ir, Hr).call(this, n);
    return json.safeStringify({ message: e, purpose: a, expiryDate: u });
  }
  /**
   * Verifies the message for expiry and purpose.
   */
  verify(e, n) {
    const a = json.safeParse(e);
    return typeof a != "object" || !a || !a.message || a.purpose !== n || Dr(this, Ir, Kr).call(this, a) ? null : a.message;
  }
}
Ir = new WeakSet(), Hr = function(e) {
  if (!e)
    return;
  const n = parseMs(e);
  return new Date(Date.now() + n);
}, /**
 * Returns a boolean telling, if message has been expired or not
 */
Kr = function(e) {
  if (!e.expiryDate)
    return !1;
  const n = new Date(e.expiryDate);
  return Number.isNaN(n.getTime()) || n < /* @__PURE__ */ new Date();
};
var Cr;
class Hmac {
  constructor(e) {
    ir(this, Cr);
    Br(this, Cr, e);
  }
  /**
   * Generate the hmac
   */
  generate(e) {
    return base64.urlEncode(cryptoBrowserifyExports.createHmac("sha256", Uint8Array.from(tr(this, Cr))).update(e).digest());
  }
  /**
   * Compare raw value against an existing hmac
   */
  compare(e, n) {
    return safeEqual(this.generate(e), n);
  }
}
Cr = new WeakMap();
var Ar, Tr;
class MessageVerifier {
  constructor(e) {
    /**
     * The key for signing and encrypting values. It is derived
     * from the user provided secret.
     */
    ir(this, Ar);
    /**
     * Use `dot` as a separator for joining encrypted value, iv and the
     * hmac hash. The idea is borrowed from JWT's in which each part
     * of the payload is concatenated with a dot.
     */
    ir(this, Tr, ".");
    Br(this, Ar, cryptoBrowserifyExports.createHash("sha256").update(e).digest());
  }
  /**
   * Sign a given piece of value using the app secret. A wide range of
   * data types are supported. See [@nhtio/serialization](https://serialization.nht.io/quickstart.html#supported-data-types) for more information
   * on the supported data types.
   *
   * You can optionally define a purpose for which the value was signed and
   * mentioning a different purpose/no purpose during unsign will fail.
   */
  sign(e, n, a) {
    if (e == null)
      throw new RuntimeException(`Cannot sign "${e}" value`);
    if (!canSerialize(e))
      throw new y(e);
    const u = base64.urlEncode(new MessageBuilder().build(e, n, a));
    return `${u}${tr(this, Tr)}${new Hmac(tr(this, Ar)).generate(u)}`;
  }
  /**
   * Unsign a previously signed value with an optional purpose
   */
  unsign(e, n) {
    if (typeof e != "string")
      return null;
    const [a, u] = e.split(tr(this, Tr));
    if (!a || !u)
      return null;
    const o = base64.urlDecode(a, void 0, !1);
    return o && new Hmac(tr(this, Ar)).compare(a, u) ? new MessageBuilder().verify(o, n) : null;
  }
  /**
   * Checks if the value can be encoded
   */
  encodable(e) {
    return canSerialize(e);
  }
  /**
   * Checks if the value can be encoded
   */
  static encodable(e) {
    return canSerialize(e);
  }
}
Ar = new WeakMap(), Tr = new WeakMap();
var Rr, nr, Mr, kr, Gr;
const Lr = class Lr {
  constructor(e) {
    ir(this, kr);
    ir(this, Rr);
    /**
     * The key for signing and encrypting values. It is derived
     * from the user provided secret.
     */
    ir(this, nr);
    /**
     * Use `dot` as a separator for joining encrypted value, iv and the
     * hmac hash. The idea is borrowed from JWTs.
     */
    ir(this, Mr, ".");
    /**
     * Reference to the instance of message verifier for signing
     * and verifying values.
     */
    qr(this, "verifier");
    /**
     * Reference to base64 object for base64 encoding/decoding values
     */
    qr(this, "base64", base64);
    const n = e.secret && typeof e.secret == "object" && "release" in e.secret ? e.secret.release() : e.secret;
    Br(this, Rr, { algorithm: "aes-256-cbc", ...e }), Dr(this, kr, Gr).call(this, n), Br(this, nr, cryptoBrowserifyExports.createHash("sha256").update(n).digest()), this.verifier = new MessageVerifier(n);
  }
  /**
   * The algorithm in use
   */
  get algorithm() {
    return tr(this, Rr).algorithm;
  }
  /**
   * Encrypt a given piece of value using the app secret. A wide range of
   * data types are supported. See [@nhtio/serialization](https://serialization.nht.io/quickstart.html#supported-data-types) for more information
   * on the supported data types.
   *
   * You can optionally define a purpose for which the value was encrypted and
   * mentioning a different purpose/no purpose during decrypt will fail.
   * @param payload - The value to encrypt
   * @param expiresIn - The time to live for the value. It can be a number or a string
   * @param purpose - The purpose for which the value was encrypted
   */
  encrypt(e, n, a) {
    e = Buffer$C.from(serialize(e)).toString("base64");
    const u = getRandomString(16), o = cryptoBrowserifyExports.createCipheriv(this.algorithm, Uint8Array.from(tr(this, nr)), u), d = new MessageBuilder().build(e, n, a), l = Buffer$C.concat([
      Uint8Array.from(o.update(d, "utf-8")),
      Uint8Array.from(o.final())
    ]), _ = `${this.base64.urlEncode(l)}${tr(this, Mr)}${this.base64.urlEncode(
      u
    )}`;
    return `${_}${tr(this, Mr)}${new Hmac(tr(this, nr)).generate(_)}`;
  }
  /**
   * Decrypt value and verify it against a purpose
   */
  decrypt(e, n) {
    if (typeof e != "string")
      return null;
    const [a, u, o] = e.split(tr(this, Mr));
    if (!a || !u || !o)
      return null;
    const d = this.base64.urlDecode(a, "base64");
    if (!d)
      return null;
    const l = this.base64.urlDecode(u);
    if (!l || !new Hmac(tr(this, nr)).compare(
      `${a}${tr(this, Mr)}${u}`,
      o
    ))
      return null;
    try {
      const P = cryptoBrowserifyExports.createDecipheriv(this.algorithm, Uint8Array.from(tr(this, nr)), l), h = P.update(d, "base64", "utf8") + P.final("utf8"), x = new MessageBuilder().verify(h, n);
      if (!x || typeof x != "string")
        return null;
      const C = Uint8Array.from(Buffer$C.from(x, "base64"));
      return deserialize(C);
    } catch {
      return null;
    }
  }
  /**
   * Create a children instance with different secret key
   */
  child(e) {
    return new Lr({ ...tr(this, Rr), ...e });
  }
  /**
   * Checks if the value can be encoded
   */
  encodable(e) {
    return canSerialize(e);
  }
  /**
   * Checks if the value can be encoded
   */
  static encodable(e) {
    return canSerialize(e);
  }
};
Rr = new WeakMap(), nr = new WeakMap(), Mr = new WeakMap(), kr = new WeakSet(), /**
 * Validates the app secret
 */
Gr = function(e) {
  if (typeof e != "string")
    throw new E_MISSING_APP_KEY();
  if (e.length < 16)
    throw new E_INSECURE_APP_KEY();
};
let Encryption = Lr;
const REDACTED = "[redacted]";
var Pr, ar;
const Fr = class Fr {
  constructor(e, n) {
    /** The secret value */
    ir(this, Pr);
    ir(this, ar);
    Br(this, Pr, e), Br(this, ar, n || REDACTED);
  }
  toJSON() {
    return tr(this, ar);
  }
  valueOf() {
    return tr(this, ar);
  }
  toLocaleString() {
    return tr(this, ar);
  }
  toString() {
    return tr(this, ar);
  }
  /**
   * Returns the original value
   */
  release() {
    return tr(this, Pr);
  }
  /**
   * Transform the original value and create a new
   * secret from it.
   */
  map(e) {
    return new Fr(e(tr(this, Pr)));
  }
};
Pr = new WeakMap(), ar = new WeakMap();
let Secret = Fr;
const version = "1.20250425.0";
export {
  Encryption,
  Secret,
  rt as errors,
  version
};
//# sourceMappingURL=index.mjs.map
