var nu = Object.defineProperty;
var iu = Object.getPrototypeOf;
var su = Reflect.get;
var Ya = (e) => {
  throw TypeError(e);
};
var ou = (e, t, v) => t in e ? nu(e, t, { enumerable: !0, configurable: !0, writable: !0, value: v }) : e[t] = v;
var Ta = (e, t, v) => ou(e, typeof t != "symbol" ? t + "" : t, v), Wa = (e, t, v) => t.has(e) || Ya("Cannot " + v);
var fo = (e, t, v) => (Wa(e, t, "read from private field"), v ? v.call(e) : t.get(e)), Xo = (e, t, v) => t.has(e) ? Ya("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, v), Jo = (e, t, v, w) => (Wa(e, t, "write to private field"), w ? w.call(e, v) : t.set(e, v), v), Oo = (e, t, v) => (Wa(e, t, "access private method"), v);
var Ja = (e, t, v) => su(iu(e), v, t);
import { t as gu } from "./types-CBFnAS2P.mjs";
import { M as MissingEncryptionKey, A as AlreadyInitializedInContextError, U as UnsupportedEnvironmentError, R as RequestTimeoutError } from "./errors-Cqo3rABf.mjs";
import { e as vu } from "./errors-Cqo3rABf.mjs";
const isTabEnvironment = () => typeof window < "u" && typeof window.navigator < "u" && typeof window.navigator.userAgent < "u", isWorkerEnvironment = () => typeof ServiceWorkerGlobalScope < "u" && self instanceof ServiceWorkerGlobalScope, isSsrEnvironment = () => typeof process < "u" && typeof process.versions < "u" && !!process.versions.node, isSafari = () => typeof window < "u" && typeof window.navigator < "u" && window.navigator.userAgent.includes("Safari") && !window.navigator.userAgent.includes("Chrome");
function isGlobalObject(e) {
  return typeof e == "object" && e !== null && "Math" in e;
}
const getGlobal = () => {
  const t = [
    typeof window < "u" ? window : void 0,
    typeof self < "u" ? self : void 0,
    typeof global < "u" ? global : void 0
  ].filter((v) => isGlobalObject(v));
  if (t.length === 0)
    throw new Error("No global object found");
  return t[0];
}, makeRandomId = (e) => {
  const t = getGlobal(), v = new Uint8Array(e);
  if (typeof t.crypto < "u" && typeof t.crypto.getRandomValues == "function")
    t.crypto.getRandomValues(v);
  else
    for (let w = 0; w < e; w++)
      v[w] = Math.floor(Math.random() * 256);
  return Array.from(v).map((w) => w.toString(16).padStart(2, "0")).join("");
}, FOR_SWARM = Symbol("nhtio.swarm"), FOR_LOGGER = Symbol("nhtio.swarm.logger"), FOR_ENCRYPTION = Symbol("nhtio.swarm.logger"), LogLevelStyles = {
  EMERG: (e) => [
    `%c${e}`,
    "color: white; background: #FF0000; font-weight: bold; padding: 2px 6px; border-radius: 2px"
  ],
  ALERT: (e) => [
    `%c${e}`,
    "color: white; background: #FF5555; font-weight: bold; padding: 2px 6px; border-radius: 2px"
  ],
  CRIT: (e) => [
    `%c${e}`,
    "color: white; background: #FF6F00; font-weight: bold; padding: 2px 6px; border-radius: 2px"
  ],
  ERROR: (e) => [
    `%c${e}`,
    "color: black; background: #FFA500; font-weight: bold; padding: 2px 6px; border-radius: 2px"
  ],
  WARNING: (e) => [
    `%c${e}`,
    "color: black; background: #FFD700; font-weight: bold; padding: 2px 6px; border-radius: 2px"
  ],
  NOTICE: (e) => [
    `%c${e}`,
    "color: black; background: #00CED1; font-weight: bold; padding: 2px 6px; border-radius: 2px"
  ],
  INFO: (e) => [
    `%c${e}`,
    "color: white; background: #1E90FF; font-weight: normal; padding: 2px 6px; border-radius: 2px"
  ],
  DEBUG: (e) => [`%c${e}`, "color: #AAAAAA; font-style: italic; padding: 2px 6px"]
};
var LogLevelValues = /* @__PURE__ */ ((e) => (e[e.EMERG = 0] = "EMERG", e[e.ALERT = 1] = "ALERT", e[e.CRIT = 2] = "CRIT", e[e.ERROR = 3] = "ERROR", e[e.WARNING = 4] = "WARNING", e[e.NOTICE = 5] = "NOTICE", e[e.INFO = 6] = "INFO", e[e.DEBUG = 7] = "DEBUG", e))(LogLevelValues || {});
const EnvironmentStyles = {
  BROWSER: (e) => [
    `%c${e}`,
    "color: white; background: #3949AB; font-weight: bold; padding: 2px 6px; border-radius: 2px"
  ],
  WORKER: (e) => [
    `%c${e}`,
    "color: white; background: #5E35B1; font-weight: bold; padding: 2px 6px; border-radius: 2px"
  ],
  SSR: (e) => [
    `%c${e}`,
    "color: white; background: #607D8B; font-weight: bold; padding: 2px 6px; border-radius: 2px"
  ],
  UNKNOWN: (e) => [
    `%c${e}`,
    "color: black; background: #E0E0E0; font-weight: bold; font-style: italic; padding: 2px 6px; border-radius: 2px"
  ]
};
var LogLevelConsoleMethods = /* @__PURE__ */ ((e) => (e.EMERG = "error", e.ALERT = "error", e.CRIT = "error", e.ERROR = "error", e.WARNING = "warn", e.NOTICE = "info", e.INFO = "info", e.DEBUG = "debug", e))(LogLevelConsoleMethods || {}), Na, La, Da, ja, Ca, xa, Qo, Xa, ea;
class Logger {
  constructor(t = 3) {
    Xo(this, Qo);
    Xo(this, Na);
    Xo(this, La);
    Xo(this, Da);
    Xo(this, ja);
    Xo(this, Ca);
    Xo(this, xa);
    Jo(this, xa, t), Jo(this, Na, isTabEnvironment()), Jo(this, La, isWorkerEnvironment()), Jo(this, Da, isSsrEnvironment()), Jo(this, ja, isSafari());
  }
  get level() {
    return LogLevelValues[fo(this, xa)];
  }
  set level(t) {
    Jo(this, xa, LogLevelValues[t.toUpperCase()]);
  }
  EMERG(...t) {
    Oo(this, Qo, ea).call(this, "EMERG", ...t);
  }
  ALERT(...t) {
    Oo(this, Qo, ea).call(this, "ALERT", ...t);
  }
  CRIT(...t) {
    Oo(this, Qo, ea).call(this, "CRIT", ...t);
  }
  ERROR(...t) {
    Oo(this, Qo, ea).call(this, "ERROR", ...t);
  }
  WARNING(...t) {
    Oo(this, Qo, ea).call(this, "WARNING", ...t);
  }
  NOTICE(...t) {
    Oo(this, Qo, ea).call(this, "NOTICE", ...t);
  }
  INFO(...t) {
    Oo(this, Qo, ea).call(this, "INFO", ...t);
  }
  DEBUG(...t) {
    Oo(this, Qo, ea).call(this, "DEBUG", ...t);
  }
  emerg(...t) {
    Oo(this, Qo, ea).call(this, "EMERG", ...t);
  }
  alert(...t) {
    Oo(this, Qo, ea).call(this, "ALERT", ...t);
  }
  crit(...t) {
    Oo(this, Qo, ea).call(this, "CRIT", ...t);
  }
  error(...t) {
    Oo(this, Qo, ea).call(this, "ERROR", ...t);
  }
  warning(...t) {
    Oo(this, Qo, ea).call(this, "WARNING", ...t);
  }
  notice(...t) {
    Oo(this, Qo, ea).call(this, "NOTICE", ...t);
  }
  info(...t) {
    Oo(this, Qo, ea).call(this, "INFO", ...t);
  }
  debug(...t) {
    Oo(this, Qo, ea).call(this, "DEBUG", ...t);
  }
}
Na = new WeakMap(), La = new WeakMap(), Da = new WeakMap(), ja = new WeakMap(), Ca = new WeakMap(), xa = new WeakMap(), Qo = new WeakSet(), Xa = function() {
  let t;
  return fo(this, Na) ? t = "BROWSER" : fo(this, La) ? t = "WORKER" : fo(this, Da) ? t = "SSR" : t = "UNKNOWN", EnvironmentStyles[t](t);
}, ea = function(t, ...v) {
  t = t.toUpperCase();
  const w = LogLevelValues[t], T = LogLevelValues[fo(this, xa)];
  if (w > T) return;
  const [x, C] = Oo(this, Qo, Xa).call(this), [D, Y] = LogLevelStyles[t](t), L = [
    `${x}${D}${fo(this, Ca) ? `%c ${fo(this, Ca)}` : ""}`,
    C,
    Y
  ];
  for (fo(this, Ca) && L.push("color: inherit"), L.push(...v); L[L.length - 1] === void 0; ) L.pop();
  fo(this, ja) || fo(this, Da) ? console[LogLevelConsoleMethods[t]](...L) : (console.groupCollapsed(...L), console.debug(new Error("stack").stack.split(`
`).slice(3).join(`
`)), console.groupEnd());
};
const getLogLevel = () => {
  const e = getGlobal();
  return typeof e.SWARM_LOG_LEVEL == "string" && e.SWARM_LOG_LEVEL.toUpperCase() in LogLevelValues ? e.SWARM_LOG_LEVEL : 3;
}, getLogger = () => {
  const e = getGlobal();
  if (typeof e[FOR_LOGGER] < "u" && e[FOR_LOGGER] instanceof Logger)
    return e[FOR_LOGGER];
  const t = getLogLevel(), v = LogLevelValues[t], w = new Logger(v);
  return e[FOR_LOGGER] = w, w;
}, setLogLevel = (e) => {
  const t = getGlobal(), v = getLogger();
  t.SWARM_LOG_LEVEL = e.toUpperCase(), v.level = e;
};
var tinyEmitter = { exports: {} };
tinyEmitter.exports;
function E$2() {
}
E$2.prototype = {
  on: function(e, t, v) {
    var w = this.e || (this.e = {});
    return (w[e] || (w[e] = [])).push({
      fn: t,
      ctx: v
    }), this;
  },
  once: function(e, t, v) {
    var w = this;
    function T() {
      w.off(e, T), t.apply(v, arguments);
    }
    return T._ = t, this.on(e, T, v);
  },
  emit: function(e) {
    var t = [].slice.call(arguments, 1), v = ((this.e || (this.e = {}))[e] || []).slice(), w = 0, T = v.length;
    for (w; w < T; w++)
      v[w].fn.apply(v[w].ctx, t);
    return this;
  },
  off: function(e, t) {
    var v = this.e || (this.e = {}), w = v[e], T = [];
    if (w && t)
      for (var x = 0, C = w.length; x < C; x++)
        w[x].fn !== t && w[x].fn._ !== t && T.push(w[x]);
    return T.length ? v[e] = T : delete v[e], this;
  }
};
tinyEmitter.exports = E$2;
var TinyEmitter = tinyEmitter.exports.TinyEmitter = E$2;
tinyEmitter.exports;
class TypedEventEmitter extends TinyEmitter {
  /**
   * Subscribe to an event with a typed listener.
   */
  on(t, v, w) {
    return super.on(t, v, w), this;
  }
  /**
   * Subscribe once to an event.
   */
  once(t, v, w) {
    return super.once(t, v, w), this;
  }
  /**
   * Emit an event, enforcing that the args match Events[E].
   */
  emit(t, ...v) {
    return super.emit(t, ...v), this;
  }
  /**
   * Remove a listener.
   */
  off(t, v) {
    return super.off(t, v), this;
  }
}
function isPromise(e) {
  return e && typeof e.then == "function";
}
Promise.resolve(!1);
var PROMISE_RESOLVED_TRUE = Promise.resolve(!0), PROMISE_RESOLVED_VOID = Promise.resolve();
function sleep(e, t) {
  return e || (e = 0), new Promise(function(v) {
    return setTimeout(function() {
      return v(t);
    }, e);
  });
}
function randomInt(e, t) {
  return Math.floor(Math.random() * (t - e + 1) + e);
}
function randomToken() {
  return Math.random().toString(36).substring(2);
}
var lastMs = 0;
function microSeconds$4() {
  var e = Date.now() * 1e3;
  return e <= lastMs && (e = lastMs + 1), lastMs = e, e;
}
function supportsWebLockAPI() {
  return typeof navigator < "u" && typeof navigator.locks < "u" && typeof navigator.locks.request == "function";
}
var microSeconds$3 = microSeconds$4, type$4 = "native";
function create$3(e) {
  var t = {
    time: microSeconds$4(),
    messagesCallback: null,
    bc: new BroadcastChannel(e),
    subFns: []
    // subscriberFunctions
  };
  return t.bc.onmessage = function(v) {
    t.messagesCallback && t.messagesCallback(v.data);
  }, t;
}
function close$3(e) {
  e.bc.close(), e.subFns = [];
}
function postMessage$3(e, t) {
  try {
    return e.bc.postMessage(t, !1), PROMISE_RESOLVED_VOID;
  } catch (v) {
    return Promise.reject(v);
  }
}
function onMessage$3(e, t) {
  e.messagesCallback = t;
}
function canBeUsed$3() {
  if (typeof globalThis < "u" && globalThis.Deno && globalThis.Deno.args)
    return !0;
  if ((typeof window < "u" || typeof self < "u") && typeof BroadcastChannel == "function") {
    if (BroadcastChannel._pubkey)
      throw new Error("BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill");
    return !0;
  } else
    return !1;
}
function averageResponseTime$3() {
  return 150;
}
var NativeMethod = {
  create: create$3,
  close: close$3,
  onMessage: onMessage$3,
  postMessage: postMessage$3,
  canBeUsed: canBeUsed$3,
  type: type$4,
  averageResponseTime: averageResponseTime$3,
  microSeconds: microSeconds$3
};
class ObliviousSet {
  constructor(t) {
    Ta(this, "ttl");
    Ta(this, "map", /* @__PURE__ */ new Map());
    /**
     * Creating calls to setTimeout() is expensive,
     * so we only do that if there is not timeout already open.
     */
    Ta(this, "_to", !1);
    this.ttl = t;
  }
  has(t) {
    return this.map.has(t);
  }
  add(t) {
    this.map.set(t, now$1()), this._to || (this._to = !0, setTimeout(() => {
      this._to = !1, removeTooOldValues(this);
    }, 0));
  }
  clear() {
    this.map.clear();
  }
}
function removeTooOldValues(e) {
  const t = now$1() - e.ttl, v = e.map[Symbol.iterator]();
  for (; ; ) {
    const w = v.next().value;
    if (!w)
      return;
    const T = w[0];
    if (w[1] < t)
      e.map.delete(T);
    else
      return;
  }
}
function now$1() {
  return Date.now();
}
function fillOptionsWithDefaults$1() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = JSON.parse(JSON.stringify(e));
  return typeof t.webWorkerSupport > "u" && (t.webWorkerSupport = !0), t.idb || (t.idb = {}), t.idb.ttl || (t.idb.ttl = 1e3 * 45), t.idb.fallbackInterval || (t.idb.fallbackInterval = 150), e.idb && typeof e.idb.onclose == "function" && (t.idb.onclose = e.idb.onclose), t.localstorage || (t.localstorage = {}), t.localstorage.removeTimeout || (t.localstorage.removeTimeout = 1e3 * 60), e.methods && (t.methods = e.methods), t.node || (t.node = {}), t.node.ttl || (t.node.ttl = 1e3 * 60 * 2), t.node.maxParallelWrites || (t.node.maxParallelWrites = 2048), typeof t.node.useFastPath > "u" && (t.node.useFastPath = !0), t;
}
var microSeconds$2 = microSeconds$4, DB_PREFIX = "pubkey.broadcast-channel-0-", OBJECT_STORE_ID = "messages", TRANSACTION_SETTINGS = {
  durability: "relaxed"
}, type$3 = "idb";
function getIdb() {
  if (typeof indexedDB < "u") return indexedDB;
  if (typeof window < "u") {
    if (typeof window.mozIndexedDB < "u") return window.mozIndexedDB;
    if (typeof window.webkitIndexedDB < "u") return window.webkitIndexedDB;
    if (typeof window.msIndexedDB < "u") return window.msIndexedDB;
  }
  return !1;
}
function commitIndexedDBTransaction(e) {
  e.commit && e.commit();
}
function createDatabase(e) {
  var t = getIdb(), v = DB_PREFIX + e, w = t.open(v);
  return w.onupgradeneeded = function(T) {
    var x = T.target.result;
    x.createObjectStore(OBJECT_STORE_ID, {
      keyPath: "id",
      autoIncrement: !0
    });
  }, new Promise(function(T, x) {
    w.onerror = function(C) {
      return x(C);
    }, w.onsuccess = function() {
      T(w.result);
    };
  });
}
function writeMessage(e, t, v) {
  var w = Date.now(), T = {
    uuid: t,
    time: w,
    data: v
  }, x = e.transaction([OBJECT_STORE_ID], "readwrite", TRANSACTION_SETTINGS);
  return new Promise(function(C, D) {
    x.oncomplete = function() {
      return C();
    }, x.onerror = function(L) {
      return D(L);
    };
    var Y = x.objectStore(OBJECT_STORE_ID);
    Y.add(T), commitIndexedDBTransaction(x);
  });
}
function getMessagesHigherThan(e, t) {
  var v = e.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS), w = v.objectStore(OBJECT_STORE_ID), T = [], x = IDBKeyRange.bound(t + 1, 1 / 0);
  if (w.getAll) {
    var C = w.getAll(x);
    return new Promise(function(Y, L) {
      C.onerror = function(q) {
        return L(q);
      }, C.onsuccess = function(q) {
        Y(q.target.result);
      };
    });
  }
  function D() {
    try {
      return x = IDBKeyRange.bound(t + 1, 1 / 0), w.openCursor(x);
    } catch {
      return w.openCursor();
    }
  }
  return new Promise(function(Y, L) {
    var q = D();
    q.onerror = function(N) {
      return L(N);
    }, q.onsuccess = function(N) {
      var F = N.target.result;
      F ? F.value.id < t + 1 ? F.continue(t + 1) : (T.push(F.value), F.continue()) : (commitIndexedDBTransaction(v), Y(T));
    };
  });
}
function removeMessagesById(e, t) {
  if (e.closed)
    return Promise.resolve([]);
  var v = e.db.transaction(OBJECT_STORE_ID, "readwrite", TRANSACTION_SETTINGS), w = v.objectStore(OBJECT_STORE_ID);
  return Promise.all(t.map(function(T) {
    var x = w.delete(T);
    return new Promise(function(C) {
      x.onsuccess = function() {
        return C();
      };
    });
  }));
}
function getOldMessages(e, t) {
  var v = Date.now() - t, w = e.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS), T = w.objectStore(OBJECT_STORE_ID), x = [];
  return new Promise(function(C) {
    T.openCursor().onsuccess = function(D) {
      var Y = D.target.result;
      if (Y) {
        var L = Y.value;
        L.time < v ? (x.push(L), Y.continue()) : (commitIndexedDBTransaction(w), C(x));
      } else
        C(x);
    };
  });
}
function cleanOldMessages(e) {
  return getOldMessages(e.db, e.options.idb.ttl).then(function(t) {
    return removeMessagesById(e, t.map(function(v) {
      return v.id;
    }));
  });
}
function create$2(e, t) {
  return t = fillOptionsWithDefaults$1(t), createDatabase(e).then(function(v) {
    var w = {
      closed: !1,
      lastCursorId: 0,
      channelName: e,
      options: t,
      uuid: randomToken(),
      /**
       * emittedMessagesIds
       * contains all messages that have been emitted before
       * @type {ObliviousSet}
       */
      eMIs: new ObliviousSet(t.idb.ttl * 2),
      // ensures we do not read messages in parallel
      writeBlockPromise: PROMISE_RESOLVED_VOID,
      messagesCallback: null,
      readQueuePromises: [],
      db: v
    };
    return v.onclose = function() {
      w.closed = !0, t.idb.onclose && t.idb.onclose();
    }, _readLoop(w), w;
  });
}
function _readLoop(e) {
  e.closed || readNewMessages(e).then(function() {
    return sleep(e.options.idb.fallbackInterval);
  }).then(function() {
    return _readLoop(e);
  });
}
function _filterMessage(e, t) {
  return !(e.uuid === t.uuid || t.eMIs.has(e.id) || e.data.time < t.messagesCallbackTime);
}
function readNewMessages(e) {
  return e.closed || !e.messagesCallback ? PROMISE_RESOLVED_VOID : getMessagesHigherThan(e.db, e.lastCursorId).then(function(t) {
    var v = t.filter(function(w) {
      return !!w;
    }).map(function(w) {
      return w.id > e.lastCursorId && (e.lastCursorId = w.id), w;
    }).filter(function(w) {
      return _filterMessage(w, e);
    }).sort(function(w, T) {
      return w.time - T.time;
    });
    return v.forEach(function(w) {
      e.messagesCallback && (e.eMIs.add(w.id), e.messagesCallback(w.data));
    }), PROMISE_RESOLVED_VOID;
  });
}
function close$2(e) {
  e.closed = !0, e.db.close();
}
function postMessage$2(e, t) {
  return e.writeBlockPromise = e.writeBlockPromise.then(function() {
    return writeMessage(e.db, e.uuid, t);
  }).then(function() {
    randomInt(0, 10) === 0 && cleanOldMessages(e);
  }), e.writeBlockPromise;
}
function onMessage$2(e, t, v) {
  e.messagesCallbackTime = v, e.messagesCallback = t, readNewMessages(e);
}
function canBeUsed$2() {
  return !!getIdb();
}
function averageResponseTime$2(e) {
  return e.idb.fallbackInterval * 2;
}
var IndexedDBMethod = {
  create: create$2,
  close: close$2,
  onMessage: onMessage$2,
  postMessage: postMessage$2,
  canBeUsed: canBeUsed$2,
  type: type$3,
  averageResponseTime: averageResponseTime$2,
  microSeconds: microSeconds$2
}, microSeconds$1 = microSeconds$4, KEY_PREFIX = "pubkey.broadcastChannel-", type$2 = "localstorage";
function getLocalStorage() {
  var e;
  if (typeof window > "u") return null;
  try {
    e = window.localStorage, e = window["ie8-eventlistener/storage"] || window.localStorage;
  } catch {
  }
  return e;
}
function storageKey(e) {
  return KEY_PREFIX + e;
}
function postMessage$1(e, t) {
  return new Promise(function(v) {
    sleep().then(function() {
      var w = storageKey(e.channelName), T = {
        token: randomToken(),
        time: Date.now(),
        data: t,
        uuid: e.uuid
      }, x = JSON.stringify(T);
      getLocalStorage().setItem(w, x);
      var C = document.createEvent("Event");
      C.initEvent("storage", !0, !0), C.key = w, C.newValue = x, window.dispatchEvent(C), v();
    });
  });
}
function addStorageEventListener(e, t) {
  var v = storageKey(e), w = function(x) {
    x.key === v && t(JSON.parse(x.newValue));
  };
  return window.addEventListener("storage", w), w;
}
function removeStorageEventListener(e) {
  window.removeEventListener("storage", e);
}
function create$1(e, t) {
  if (t = fillOptionsWithDefaults$1(t), !canBeUsed$1())
    throw new Error("BroadcastChannel: localstorage cannot be used");
  var v = randomToken(), w = new ObliviousSet(t.localstorage.removeTimeout), T = {
    channelName: e,
    uuid: v,
    eMIs: w
    // emittedMessagesIds
  };
  return T.listener = addStorageEventListener(e, function(x) {
    T.messagesCallback && x.uuid !== v && (!x.token || w.has(x.token) || x.data.time && x.data.time < T.messagesCallbackTime || (w.add(x.token), T.messagesCallback(x.data)));
  }), T;
}
function close$1(e) {
  removeStorageEventListener(e.listener);
}
function onMessage$1(e, t, v) {
  e.messagesCallbackTime = v, e.messagesCallback = t;
}
function canBeUsed$1() {
  var e = getLocalStorage();
  if (!e) return !1;
  try {
    var t = "__broadcastchannel_check";
    e.setItem(t, "works"), e.removeItem(t);
  } catch {
    return !1;
  }
  return !0;
}
function averageResponseTime$1() {
  var e = 120, t = navigator.userAgent.toLowerCase();
  return t.includes("safari") && !t.includes("chrome") ? e * 2 : e;
}
var LocalstorageMethod = {
  create: create$1,
  close: close$1,
  onMessage: onMessage$1,
  postMessage: postMessage$1,
  canBeUsed: canBeUsed$1,
  type: type$2,
  averageResponseTime: averageResponseTime$1,
  microSeconds: microSeconds$1
}, microSeconds = microSeconds$4, type$1 = "simulate", SIMULATE_CHANNELS = /* @__PURE__ */ new Set();
function create(e) {
  var t = {
    time: microSeconds(),
    name: e,
    messagesCallback: null
  };
  return SIMULATE_CHANNELS.add(t), t;
}
function close(e) {
  SIMULATE_CHANNELS.delete(e);
}
var SIMULATE_DELAY_TIME = 5;
function postMessage(e, t) {
  return new Promise(function(v) {
    return setTimeout(function() {
      var w = Array.from(SIMULATE_CHANNELS);
      w.forEach(function(T) {
        T.name === e.name && // has same name
        T !== e && T.messagesCallback && // has subscribers
        T.time < t.time && T.messagesCallback(t);
      }), v();
    }, SIMULATE_DELAY_TIME);
  });
}
function onMessage(e, t) {
  e.messagesCallback = t;
}
function canBeUsed() {
  return !0;
}
function averageResponseTime() {
  return SIMULATE_DELAY_TIME;
}
var SimulateMethod = {
  create,
  close,
  onMessage,
  postMessage,
  canBeUsed,
  type: type$1,
  averageResponseTime,
  microSeconds
}, METHODS = [
  NativeMethod,
  // fastest
  IndexedDBMethod,
  LocalstorageMethod
];
function chooseMethod(e) {
  var t = [].concat(e.methods, METHODS).filter(Boolean);
  if (e.type) {
    if (e.type === "simulate")
      return SimulateMethod;
    var v = t.find(function(T) {
      return T.type === e.type;
    });
    if (v) return v;
    throw new Error("method-type " + e.type + " not found");
  }
  e.webWorkerSupport || (t = t.filter(function(T) {
    return T.type !== "idb";
  }));
  var w = t.find(function(T) {
    return T.canBeUsed();
  });
  if (w)
    return w;
  throw new Error("No usable method found in " + JSON.stringify(METHODS.map(function(T) {
    return T.type;
  })));
}
var OPEN_BROADCAST_CHANNELS = /* @__PURE__ */ new Set(), lastId = 0, BroadcastChannel$1 = function(t, v) {
  this.id = lastId++, OPEN_BROADCAST_CHANNELS.add(this), this.name = t, ENFORCED_OPTIONS && (v = ENFORCED_OPTIONS), this.options = fillOptionsWithDefaults$1(v), this.method = chooseMethod(this.options), this._iL = !1, this._onML = null, this._addEL = {
    message: [],
    internal: []
  }, this._uMP = /* @__PURE__ */ new Set(), this._befC = [], this._prepP = null, _prepareChannel(this);
};
BroadcastChannel$1._pubkey = !0;
var ENFORCED_OPTIONS;
BroadcastChannel$1.prototype = {
  postMessage: function(t) {
    if (this.closed)
      throw new Error("BroadcastChannel.postMessage(): Cannot post message after channel has closed " + /**
       * In the past when this error appeared, it was really hard to debug.
       * So now we log the msg together with the error so it at least
       * gives some clue about where in your application this happens.
       */
      JSON.stringify(t));
    return _post(this, "message", t);
  },
  postInternal: function(t) {
    return _post(this, "internal", t);
  },
  set onmessage(e) {
    var t = this.method.microSeconds(), v = {
      time: t,
      fn: e
    };
    _removeListenerObject(this, "message", this._onML), e && typeof e == "function" ? (this._onML = v, _addListenerObject(this, "message", v)) : this._onML = null;
  },
  addEventListener: function(t, v) {
    var w = this.method.microSeconds(), T = {
      time: w,
      fn: v
    };
    _addListenerObject(this, t, T);
  },
  removeEventListener: function(t, v) {
    var w = this._addEL[t].find(function(T) {
      return T.fn === v;
    });
    _removeListenerObject(this, t, w);
  },
  close: function() {
    var t = this;
    if (!this.closed) {
      OPEN_BROADCAST_CHANNELS.delete(this), this.closed = !0;
      var v = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;
      return this._onML = null, this._addEL.message = [], v.then(function() {
        return Promise.all(Array.from(t._uMP));
      }).then(function() {
        return Promise.all(t._befC.map(function(w) {
          return w();
        }));
      }).then(function() {
        return t.method.close(t._state);
      });
    }
  },
  get type() {
    return this.method.type;
  },
  get isClosed() {
    return this.closed;
  }
};
function _post(e, t, v) {
  var w = e.method.microSeconds(), T = {
    time: w,
    type: t,
    data: v
  }, x = e._prepP ? e._prepP : PROMISE_RESOLVED_VOID;
  return x.then(function() {
    var C = e.method.postMessage(e._state, T);
    return e._uMP.add(C), C.catch().then(function() {
      return e._uMP.delete(C);
    }), C;
  });
}
function _prepareChannel(e) {
  var t = e.method.create(e.name, e.options);
  isPromise(t) ? (e._prepP = t, t.then(function(v) {
    e._state = v;
  })) : e._state = t;
}
function _hasMessageListeners(e) {
  return e._addEL.message.length > 0 || e._addEL.internal.length > 0;
}
function _addListenerObject(e, t, v) {
  e._addEL[t].push(v), _startListening(e);
}
function _removeListenerObject(e, t, v) {
  e._addEL[t] = e._addEL[t].filter(function(w) {
    return w !== v;
  }), _stopListening(e);
}
function _startListening(e) {
  if (!e._iL && _hasMessageListeners(e)) {
    var t = function(T) {
      e._addEL[T.type].forEach(function(x) {
        T.time >= x.time && x.fn(T.data);
      });
    }, v = e.method.microSeconds();
    e._prepP ? e._prepP.then(function() {
      e._iL = !0, e.method.onMessage(e._state, t, v);
    }) : (e._iL = !0, e.method.onMessage(e._state, t, v));
  }
}
function _stopListening(e) {
  if (e._iL && !_hasMessageListeners(e)) {
    e._iL = !1;
    var t = e.method.microSeconds();
    e.method.onMessage(e._state, null, t);
  }
}
function addBrowser(e) {
  if (typeof WorkerGlobalScope == "function" && self instanceof WorkerGlobalScope) {
    var t = self.close.bind(self);
    self.close = function() {
      return e(), t();
    };
  } else {
    if (typeof window.addEventListener != "function")
      return;
    window.addEventListener("beforeunload", function() {
      e();
    }, !0), window.addEventListener("unload", function() {
      e();
    }, !0);
  }
}
function addNode(e) {
  process.on("exit", function() {
    return e();
  }), process.on("beforeExit", function() {
    return e().then(function() {
      return process.exit();
    });
  }), process.on("SIGINT", function() {
    return e().then(function() {
      return process.exit();
    });
  }), process.on("uncaughtException", function(t) {
    return e().then(function() {
      console.trace(t), process.exit(101);
    });
  });
}
var isNode = Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]", USE_METHOD = isNode ? addNode : addBrowser, LISTENERS = /* @__PURE__ */ new Set(), startedListening = !1;
function startListening() {
  startedListening || (startedListening = !0, USE_METHOD(runAll));
}
function add(e) {
  if (startListening(), typeof e != "function")
    throw new Error("Listener is no function");
  LISTENERS.add(e);
  var t = {
    remove: function() {
      return LISTENERS.delete(e);
    },
    run: function() {
      return LISTENERS.delete(e), e();
    }
  };
  return t;
}
function runAll() {
  var e = [];
  return LISTENERS.forEach(function(t) {
    e.push(t()), LISTENERS.delete(t);
  }), Promise.all(e);
}
function sendLeaderMessage(e, t) {
  var v = {
    context: "leader",
    action: t,
    token: e.token
  };
  return e.broadcastChannel.postInternal(v);
}
function beLeader(e) {
  e.isLeader = !0, e._hasLeader = !0;
  var t = add(function() {
    return e.die();
  });
  e._unl.push(t);
  var v = function(T) {
    T.context === "leader" && T.action === "apply" && sendLeaderMessage(e, "tell"), T.context === "leader" && T.action === "tell" && !e._dpLC && (e._dpLC = !0, e._dpL(), sendLeaderMessage(e, "tell"));
  };
  return e.broadcastChannel.addEventListener("internal", v), e._lstns.push(v), sendLeaderMessage(e, "tell");
}
var LeaderElectionWebLock = function(t, v) {
  var w = this;
  this.broadcastChannel = t, t._befC.push(function() {
    return w.die();
  }), this._options = v, this.isLeader = !1, this.isDead = !1, this.token = randomToken(), this._lstns = [], this._unl = [], this._dpL = function() {
  }, this._dpLC = !1, this._wKMC = {}, this.lN = "pubkey-bc||" + t.method.type + "||" + t.name;
};
LeaderElectionWebLock.prototype = {
  hasLeader: function() {
    var t = this;
    return navigator.locks.query().then(function(v) {
      var w = v.held ? v.held.filter(function(T) {
        return T.name === t.lN;
      }) : [];
      return !!(w && w.length > 0);
    });
  },
  awaitLeadership: function() {
    var t = this;
    if (!this._wLMP) {
      this._wKMC.c = new AbortController();
      var v = new Promise(function(w, T) {
        t._wKMC.res = w, t._wKMC.rej = T;
      });
      this._wLMP = new Promise(function(w) {
        navigator.locks.request(t.lN, {
          signal: t._wKMC.c.signal
        }, function() {
          return t._wKMC.c = void 0, beLeader(t), w(), v;
        }).catch(function() {
        });
      });
    }
    return this._wLMP;
  },
  set onduplicate(e) {
  },
  die: function() {
    var t = this;
    return this._lstns.forEach(function(v) {
      return t.broadcastChannel.removeEventListener("internal", v);
    }), this._lstns = [], this._unl.forEach(function(v) {
      return v.remove();
    }), this._unl = [], this.isLeader && (this.isLeader = !1), this.isDead = !0, this._wKMC.res && this._wKMC.res(), this._wKMC.c && this._wKMC.c.abort("LeaderElectionWebLock.die() called"), sendLeaderMessage(this, "death");
  }
};
var LeaderElection = function(t, v) {
  var w = this;
  this.broadcastChannel = t, this._options = v, this.isLeader = !1, this._hasLeader = !1, this.isDead = !1, this.token = randomToken(), this._aplQ = PROMISE_RESOLVED_VOID, this._aplQC = 0, this._unl = [], this._lstns = [], this._dpL = function() {
  }, this._dpLC = !1;
  var T = function(C) {
    C.context === "leader" && (C.action === "death" && (w._hasLeader = !1), C.action === "tell" && (w._hasLeader = !0));
  };
  this.broadcastChannel.addEventListener("internal", T), this._lstns.push(T);
};
LeaderElection.prototype = {
  hasLeader: function() {
    return Promise.resolve(this._hasLeader);
  },
  /**
   * Returns true if the instance is leader,
   * false if not.
   * @async
   */
  applyOnce: function(t) {
    var v = this;
    if (this.isLeader)
      return sleep(0, !0);
    if (this.isDead)
      return sleep(0, !1);
    if (this._aplQC > 1)
      return this._aplQ;
    var w = function() {
      if (v.isLeader)
        return PROMISE_RESOLVED_TRUE;
      var x = !1, C, D = new Promise(function(q) {
        C = function() {
          x = !0, q();
        };
      }), Y = function(N) {
        N.context === "leader" && N.token != v.token && (N.action === "apply" && N.token > v.token && C(), N.action === "tell" && (C(), v._hasLeader = !0));
      };
      v.broadcastChannel.addEventListener("internal", Y);
      var L = t ? v._options.responseTime * 4 : v._options.responseTime;
      return sendLeaderMessage(v, "apply").then(function() {
        return Promise.race([sleep(L), D.then(function() {
          return Promise.reject(new Error());
        })]);
      }).then(function() {
        return sendLeaderMessage(v, "apply");
      }).then(function() {
        return Promise.race([sleep(L), D.then(function() {
          return Promise.reject(new Error());
        })]);
      }).catch(function() {
      }).then(function() {
        return v.broadcastChannel.removeEventListener("internal", Y), x ? !1 : beLeader(v).then(function() {
          return !0;
        });
      });
    };
    return this._aplQC = this._aplQC + 1, this._aplQ = this._aplQ.then(function() {
      return w();
    }).then(function() {
      v._aplQC = v._aplQC - 1;
    }), this._aplQ.then(function() {
      return v.isLeader;
    });
  },
  awaitLeadership: function() {
    return this._aLP || (this._aLP = _awaitLeadershipOnce(this)), this._aLP;
  },
  set onduplicate(e) {
    this._dpL = e;
  },
  die: function() {
    var t = this;
    return this._lstns.forEach(function(v) {
      return t.broadcastChannel.removeEventListener("internal", v);
    }), this._lstns = [], this._unl.forEach(function(v) {
      return v.remove();
    }), this._unl = [], this.isLeader && (this._hasLeader = !1, this.isLeader = !1), this.isDead = !0, sendLeaderMessage(this, "death");
  }
};
function _awaitLeadershipOnce(e) {
  return e.isLeader ? PROMISE_RESOLVED_VOID : new Promise(function(t) {
    var v = !1;
    function w() {
      v || (v = !0, e.broadcastChannel.removeEventListener("internal", x), t(!0));
    }
    e.applyOnce().then(function() {
      e.isLeader && w();
    });
    var T = function() {
      return sleep(e._options.fallbackInterval).then(function() {
        if (!(e.isDead || v))
          if (e.isLeader)
            w();
          else
            return e.applyOnce(!0).then(function() {
              e.isLeader ? w() : T();
            });
      });
    };
    T();
    var x = function(D) {
      D.context === "leader" && D.action === "death" && (e._hasLeader = !1, e.applyOnce().then(function() {
        e.isLeader && w();
      }));
    };
    e.broadcastChannel.addEventListener("internal", x), e._lstns.push(x);
  });
}
function fillOptionsWithDefaults(e, t) {
  return e || (e = {}), e = JSON.parse(JSON.stringify(e)), e.fallbackInterval || (e.fallbackInterval = 3e3), e.responseTime || (e.responseTime = t.method.averageResponseTime(t.options)), e;
}
function createLeaderElection(e, t) {
  if (e._leaderElector)
    throw new Error("BroadcastChannel already has a leader-elector");
  t = fillOptionsWithDefaults(t, e);
  var v = supportsWebLockAPI() ? new LeaderElectionWebLock(e, t) : new LeaderElection(e, t);
  return e._befC.push(function() {
    return v.die();
  }), e._leaderElector = v, v;
}
var d$1 = Object.defineProperty, f$2 = (e) => {
  throw TypeError(e);
}, p$1 = (e, t, v) => t in e ? d$1(e, t, { enumerable: !0, configurable: !0, writable: !0, value: v }) : e[t] = v, h = (e, t, v) => p$1(e, typeof t != "symbol" ? t + "" : t, v), b$1 = (e, t, v) => t.has(e) || f$2("Cannot " + v), n$1 = (e, t, v) => (b$1(e, t, "read from private field"), v ? v.call(e) : t.get(e)), l$2 = (e, t, v) => t.has(e) ? f$2("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, v), E$1 = (e, t, v, w) => (b$1(e, t, "write to private field"), w ? w.call(e, v) : t.set(e, v), v);
const u$1 = class extends TypeError {
  constructor(t, v, w) {
    const T = w ? { cause: w.cause } : {};
    super(v, T), h(this, "$__name"), h(this, "$__message");
    const x = this.constructor;
    if (Object.setPrototypeOf(this, x), this.$__name = t, this.$__message = v, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, x), typeof this.stack != "string" && Object.defineProperty(this, "stack", {
      value: "",
      writable: !0,
      enumerable: !1,
      configurable: !0
    }), this.stack && w && w.trim && w.trim > 0) {
      const C = this.stack.split(`
`);
      C.splice(0, w.trim), this.stack = C.join(`
`);
    }
    Object.defineProperty(this, "name", {
      get: () => this.$__name,
      enumerable: !0,
      configurable: !1
    }), Object.defineProperty(this, "message", {
      get: () => this.$__message,
      enumerable: !0,
      configurable: !1
    });
  }
  /** @private */
  get name() {
    return this.$__name;
  }
  /** @private */
  get message() {
    return this.$__message;
  }
  /** @private */
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  /** @private */
  toString() {
    return `${this.name}: ${this.message}`;
  }
  /** @private */
  [Symbol.toPrimitive](t) {
    switch (t) {
      case "string":
        return this.toString();
      default:
        return !0;
    }
  }
  /** @private */
  static [Symbol.hasInstance](t) {
    if (typeof t == "object" && t !== null || typeof t == "function") {
      const v = Object.getPrototypeOf(t);
      return v.name === this.name || v === this;
    }
    return !1;
  }
}, A$1 = (e, t, v) => e ? [
  v,
  e.details ? e.details.map((w) => w.message).join(" and ") : e.message
].filter((w) => typeof w == "string").join(" ") : t;
let y$1 = class extends u$1 {
  /** @private */
  constructor(t) {
    const v = A$1(
      t,
      "Cannot serialize this value",
      "Cannot serialize this value:"
    );
    super("E_PAYLOAD_UNSERIALIZABLE", v);
  }
}, O$1 = class extends u$1 {
  /** @private */
  constructor(t) {
    const v = `Encoding rule "${t}" conflicts with default serialization rules.`;
    super("E_RULE_CONFLICT", v);
  }
};
var i$2, a;
class U extends u$1 {
  /** @private */
  constructor(t) {
    super("E_VALUE_UNSERIALIZABLE", "Encountered an unserializable value"), l$2(this, i$2), l$2(this, a), E$1(this, i$2, typeof t), E$1(this, a, ""), Object.defineProperty(this, "kind", {
      get: () => n$1(this, i$2),
      enumerable: !0,
      configurable: !1
    }), Object.defineProperty(this, "inspection", {
      get: () => n$1(this, a),
      enumerable: !0,
      configurable: !1
    });
  }
  /* v8 ignore next 6 */
  /**
   * The result of the `typeof` operator on the value that caused the error.
   */
  get kind() {
    return n$1(this, i$2);
  }
  /* v8 ignore next 6 */
  /**
   * The result of the `inspect` function on the value that caused the error.
   */
  get inspection() {
    return n$1(this, a);
  }
}
i$2 = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new WeakMap();
var o$1;
let S$1 = class extends u$1 {
  /** @private */
  constructor(t, v) {
    super("E_VALUE_UNDESERIALIZABLE", "Encountered a value which cannot be deserialized", { cause: v }), l$2(this, o$1), E$1(this, o$1, t.key || "unknown"), Object.defineProperty(this, "kind", {
      get: () => n$1(this, o$1),
      enumerable: !0,
      configurable: !1
    });
  }
  /* v8 ignore next 7 */
  /**
   * The structured data key that caused the error.
   * @remarks This is used to identify the type of the value that caused the error.
   */
  get kind() {
    return n$1(this, o$1) || "unknown";
  }
};
o$1 = /* @__PURE__ */ new WeakMap();
let I$1 = class extends u$1 {
  /** @private */
  constructor(t) {
    super("E_VALUE_UNPARSEABLE", "Encountered a value which cannot be parsed in order to be deserialized", { cause: t });
  }
};
var c$1;
let R$1 = class extends u$1 {
  /** @private */
  constructor(t) {
    const v = `Value was serialized with version ${t}, but the current version is 1.20250425.1`;
    super("E_VALUE_FROM_FUTURE_VERSION", v), l$2(this, c$1), E$1(this, c$1, t), Object.defineProperty(this, "version", {
      get: () => n$1(this, c$1),
      enumerable: !0,
      configurable: !1
    }), Object.defineProperty(this, "current", {
      get: () => "1.20250425.1",
      enumerable: !0,
      configurable: !1
    });
  }
  /* v8 ignore next 6 */
  /**
   * The version that caused the error.
   */
  get version() {
    return n$1(this, c$1);
  }
  /* v8 ignore next 6 */
  /**
   * The current version of the library.
   */
  get current() {
    return "1.20250425.1";
  }
};
c$1 = /* @__PURE__ */ new WeakMap();
const P$1 = (e) => new Error(
  `Value was serialized with version ${e}, but the current version is 1.20250425.1`
);
class LuxonError extends Error {
}
class InvalidDateTimeError extends LuxonError {
  constructor(t) {
    super(`Invalid DateTime: ${t.toMessage()}`);
  }
}
class InvalidIntervalError extends LuxonError {
  constructor(t) {
    super(`Invalid Interval: ${t.toMessage()}`);
  }
}
class InvalidDurationError extends LuxonError {
  constructor(t) {
    super(`Invalid Duration: ${t.toMessage()}`);
  }
}
class ConflictingSpecificationError extends LuxonError {
}
class InvalidUnitError extends LuxonError {
  constructor(t) {
    super(`Invalid unit ${t}`);
  }
}
class InvalidArgumentError extends LuxonError {
}
class ZoneIsAbstractError extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
}
const n = "numeric", s$1 = "short", l$1 = "long", DATE_SHORT = {
  year: n,
  month: n,
  day: n
}, DATE_MED = {
  year: n,
  month: s$1,
  day: n
}, DATE_MED_WITH_WEEKDAY = {
  year: n,
  month: s$1,
  day: n,
  weekday: s$1
}, DATE_FULL = {
  year: n,
  month: l$1,
  day: n
}, DATE_HUGE = {
  year: n,
  month: l$1,
  day: n,
  weekday: l$1
}, TIME_SIMPLE = {
  hour: n,
  minute: n
}, TIME_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n
}, TIME_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s$1
}, TIME_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l$1
}, TIME_24_SIMPLE = {
  hour: n,
  minute: n,
  hourCycle: "h23"
}, TIME_24_WITH_SECONDS = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23"
}, TIME_24_WITH_SHORT_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: s$1
}, TIME_24_WITH_LONG_OFFSET = {
  hour: n,
  minute: n,
  second: n,
  hourCycle: "h23",
  timeZoneName: l$1
}, DATETIME_SHORT = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n
}, DATETIME_SHORT_WITH_SECONDS = {
  year: n,
  month: n,
  day: n,
  hour: n,
  minute: n,
  second: n
}, DATETIME_MED = {
  year: n,
  month: s$1,
  day: n,
  hour: n,
  minute: n
}, DATETIME_MED_WITH_SECONDS = {
  year: n,
  month: s$1,
  day: n,
  hour: n,
  minute: n,
  second: n
}, DATETIME_MED_WITH_WEEKDAY = {
  year: n,
  month: s$1,
  day: n,
  weekday: s$1,
  hour: n,
  minute: n
}, DATETIME_FULL = {
  year: n,
  month: l$1,
  day: n,
  hour: n,
  minute: n,
  timeZoneName: s$1
}, DATETIME_FULL_WITH_SECONDS = {
  year: n,
  month: l$1,
  day: n,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: s$1
}, DATETIME_HUGE = {
  year: n,
  month: l$1,
  day: n,
  weekday: l$1,
  hour: n,
  minute: n,
  timeZoneName: l$1
}, DATETIME_HUGE_WITH_SECONDS = {
  year: n,
  month: l$1,
  day: n,
  weekday: l$1,
  hour: n,
  minute: n,
  second: n,
  timeZoneName: l$1
};
class Zone {
  /**
   * The type of zone
   * @abstract
   * @type {string}
   */
  get type() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The name of this zone.
   * @abstract
   * @type {string}
   */
  get name() {
    throw new ZoneIsAbstractError();
  }
  /**
   * The IANA name of this zone.
   * Defaults to `name` if not overwritten by a subclass.
   * @abstract
   * @type {string}
   */
  get ianaName() {
    return this.name;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year.
   * @abstract
   * @type {boolean}
   */
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(t, v) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Returns the offset's value as a string
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(t, v) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @abstract
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(t) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is equal to another zone
   * @abstract
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(t) {
    throw new ZoneIsAbstractError();
  }
  /**
   * Return whether this Zone is valid.
   * @abstract
   * @type {boolean}
   */
  get isValid() {
    throw new ZoneIsAbstractError();
  }
}
let singleton$1 = null;
class SystemZone extends Zone {
  /**
   * Get a singleton instance of the local zone
   * @return {SystemZone}
   */
  static get instance() {
    return singleton$1 === null && (singleton$1 = new SystemZone()), singleton$1;
  }
  /** @override **/
  get type() {
    return "system";
  }
  /** @override **/
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName(t, { format: v, locale: w }) {
    return parseZoneInfo(t, v, w);
  }
  /** @override **/
  formatOffset(t, v) {
    return formatOffset(this.offset(t), v);
  }
  /** @override **/
  offset(t) {
    return -new Date(t).getTimezoneOffset();
  }
  /** @override **/
  equals(t) {
    return t.type === "system";
  }
  /** @override **/
  get isValid() {
    return !0;
  }
}
const dtfCache = /* @__PURE__ */ new Map();
function makeDTF(e) {
  let t = dtfCache.get(e);
  return t === void 0 && (t = new Intl.DateTimeFormat("en-US", {
    hour12: !1,
    timeZone: e,
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    era: "short"
  }), dtfCache.set(e, t)), t;
}
const typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(e, t) {
  const v = e.format(t).replace(/\u200E/g, ""), w = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(v), [, T, x, C, D, Y, L, q] = w;
  return [C, T, x, D, Y, L, q];
}
function partsOffset(e, t) {
  const v = e.formatToParts(t), w = [];
  for (let T = 0; T < v.length; T++) {
    const { type: x, value: C } = v[T], D = typeToPos[x];
    x === "era" ? w[D] = C : isUndefined$1(D) || (w[D] = parseInt(C, 10));
  }
  return w;
}
const ianaZoneCache = /* @__PURE__ */ new Map();
class IANAZone extends Zone {
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(t) {
    let v = ianaZoneCache.get(t);
    return v === void 0 && ianaZoneCache.set(t, v = new IANAZone(t)), v;
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache.clear(), dtfCache.clear();
  }
  /**
   * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated For backward compatibility, this forwards to isValidZone, better use `isValidZone()` directly instead.
   * @return {boolean}
   */
  static isValidSpecifier(t) {
    return this.isValidZone(t);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(t) {
    if (!t)
      return !1;
    try {
      return new Intl.DateTimeFormat("en-US", { timeZone: t }).format(), !0;
    } catch {
      return !1;
    }
  }
  constructor(t) {
    super(), this.zoneName = t, this.valid = IANAZone.isValidZone(t);
  }
  /**
   * The type of zone. `iana` for all instances of `IANAZone`.
   * @override
   * @type {string}
   */
  get type() {
    return "iana";
  }
  /**
   * The name of this zone (i.e. the IANA zone name).
   * @override
   * @type {string}
   */
  get name() {
    return this.zoneName;
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year:
   * Always returns false for all IANA zones.
   * @override
   * @type {boolean}
   */
  get isUniversal() {
    return !1;
  }
  /**
   * Returns the offset's common name (such as EST) at the specified timestamp
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the name
   * @param {Object} opts - Options to affect the format
   * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
   * @param {string} opts.locale - What locale to return the offset name in.
   * @return {string}
   */
  offsetName(t, { format: v, locale: w }) {
    return parseZoneInfo(t, v, w, this.name);
  }
  /**
   * Returns the offset's value as a string
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(t, v) {
    return formatOffset(this.offset(t), v);
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @override
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(t) {
    if (!this.valid) return NaN;
    const v = new Date(t);
    if (isNaN(v)) return NaN;
    const w = makeDTF(this.name);
    let [T, x, C, D, Y, L, q] = w.formatToParts ? partsOffset(w, v) : hackyOffset(w, v);
    D === "BC" && (T = -Math.abs(T) + 1);
    const F = objToLocalTS({
      year: T,
      month: x,
      day: C,
      hour: Y === 24 ? 0 : Y,
      minute: L,
      second: q,
      millisecond: 0
    });
    let ae = +v;
    const he = ae % 1e3;
    return ae -= he >= 0 ? he : 1e3 + he, (F - ae) / (60 * 1e3);
  }
  /**
   * Return whether this Zone is equal to another zone
   * @override
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(t) {
    return t.type === "iana" && t.name === this.name;
  }
  /**
   * Return whether this Zone is valid.
   * @override
   * @type {boolean}
   */
  get isValid() {
    return this.valid;
  }
}
let intlLFCache = {};
function getCachedLF(e, t = {}) {
  const v = JSON.stringify([e, t]);
  let w = intlLFCache[v];
  return w || (w = new Intl.ListFormat(e, t), intlLFCache[v] = w), w;
}
const intlDTCache = /* @__PURE__ */ new Map();
function getCachedDTF(e, t = {}) {
  const v = JSON.stringify([e, t]);
  let w = intlDTCache.get(v);
  return w === void 0 && (w = new Intl.DateTimeFormat(e, t), intlDTCache.set(v, w)), w;
}
const intlNumCache = /* @__PURE__ */ new Map();
function getCachedINF(e, t = {}) {
  const v = JSON.stringify([e, t]);
  let w = intlNumCache.get(v);
  return w === void 0 && (w = new Intl.NumberFormat(e, t), intlNumCache.set(v, w)), w;
}
const intlRelCache = /* @__PURE__ */ new Map();
function getCachedRTF(e, t = {}) {
  const { base: v, ...w } = t, T = JSON.stringify([e, w]);
  let x = intlRelCache.get(T);
  return x === void 0 && (x = new Intl.RelativeTimeFormat(e, t), intlRelCache.set(T, x)), x;
}
let sysLocaleCache = null;
function systemLocale() {
  return sysLocaleCache || (sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale, sysLocaleCache);
}
const intlResolvedOptionsCache = /* @__PURE__ */ new Map();
function getCachedIntResolvedOptions(e) {
  let t = intlResolvedOptionsCache.get(e);
  return t === void 0 && (t = new Intl.DateTimeFormat(e).resolvedOptions(), intlResolvedOptionsCache.set(e, t)), t;
}
const weekInfoCache = /* @__PURE__ */ new Map();
function getCachedWeekInfo(e) {
  let t = weekInfoCache.get(e);
  if (!t) {
    const v = new Intl.Locale(e);
    t = "getWeekInfo" in v ? v.getWeekInfo() : v.weekInfo, "minimalDays" in t || (t = { ...fallbackWeekSettings, ...t }), weekInfoCache.set(e, t);
  }
  return t;
}
function parseLocaleString(e) {
  const t = e.indexOf("-x-");
  t !== -1 && (e = e.substring(0, t));
  const v = e.indexOf("-u-");
  if (v === -1)
    return [e];
  {
    let w, T;
    try {
      w = getCachedDTF(e).resolvedOptions(), T = e;
    } catch {
      const Y = e.substring(0, v);
      w = getCachedDTF(Y).resolvedOptions(), T = Y;
    }
    const { numberingSystem: x, calendar: C } = w;
    return [T, x, C];
  }
}
function intlConfigString(e, t, v) {
  return (v || t) && (e.includes("-u-") || (e += "-u"), v && (e += `-ca-${v}`), t && (e += `-nu-${t}`)), e;
}
function mapMonths(e) {
  const t = [];
  for (let v = 1; v <= 12; v++) {
    const w = DateTime.utc(2009, v, 1);
    t.push(e(w));
  }
  return t;
}
function mapWeekdays(e) {
  const t = [];
  for (let v = 1; v <= 7; v++) {
    const w = DateTime.utc(2016, 11, 13 + v);
    t.push(e(w));
  }
  return t;
}
function listStuff(e, t, v, w) {
  const T = e.listingMode();
  return T === "error" ? null : T === "en" ? v(t) : w(t);
}
function supportsFastNumbers(e) {
  return e.numberingSystem && e.numberingSystem !== "latn" ? !1 : e.numberingSystem === "latn" || !e.locale || e.locale.startsWith("en") || getCachedIntResolvedOptions(e.locale).numberingSystem === "latn";
}
class PolyNumberFormatter {
  constructor(t, v, w) {
    this.padTo = w.padTo || 0, this.floor = w.floor || !1;
    const { padTo: T, floor: x, ...C } = w;
    if (!v || Object.keys(C).length > 0) {
      const D = { useGrouping: !1, ...w };
      w.padTo > 0 && (D.minimumIntegerDigits = w.padTo), this.inf = getCachedINF(t, D);
    }
  }
  format(t) {
    if (this.inf) {
      const v = this.floor ? Math.floor(t) : t;
      return this.inf.format(v);
    } else {
      const v = this.floor ? Math.floor(t) : roundTo(t, 3);
      return padStart(v, this.padTo);
    }
  }
}
class PolyDateFormatter {
  constructor(t, v, w) {
    this.opts = w, this.originalZone = void 0;
    let T;
    if (this.opts.timeZone)
      this.dt = t;
    else if (t.zone.type === "fixed") {
      const C = -1 * (t.offset / 60), D = C >= 0 ? `Etc/GMT+${C}` : `Etc/GMT${C}`;
      t.offset !== 0 && IANAZone.create(D).valid ? (T = D, this.dt = t) : (T = "UTC", this.dt = t.offset === 0 ? t : t.setZone("UTC").plus({ minutes: t.offset }), this.originalZone = t.zone);
    } else t.zone.type === "system" ? this.dt = t : t.zone.type === "iana" ? (this.dt = t, T = t.zone.name) : (T = "UTC", this.dt = t.setZone("UTC").plus({ minutes: t.offset }), this.originalZone = t.zone);
    const x = { ...this.opts };
    x.timeZone = x.timeZone || T, this.dtf = getCachedDTF(v, x);
  }
  format() {
    return this.originalZone ? this.formatToParts().map(({ value: t }) => t).join("") : this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const t = this.dtf.formatToParts(this.dt.toJSDate());
    return this.originalZone ? t.map((v) => {
      if (v.type === "timeZoneName") {
        const w = this.originalZone.offsetName(this.dt.ts, {
          locale: this.dt.locale,
          format: this.opts.timeZoneName
        });
        return {
          ...v,
          value: w
        };
      } else
        return v;
    }) : t;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class PolyRelFormatter {
  constructor(t, v, w) {
    this.opts = { style: "long", ...w }, !v && hasRelative() && (this.rtf = getCachedRTF(t, w));
  }
  format(t, v) {
    return this.rtf ? this.rtf.format(t, v) : formatRelativeTime(v, t, this.opts.numeric, this.opts.style !== "long");
  }
  formatToParts(t, v) {
    return this.rtf ? this.rtf.formatToParts(t, v) : [];
  }
}
const fallbackWeekSettings = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};
class Locale {
  static fromOpts(t) {
    return Locale.create(
      t.locale,
      t.numberingSystem,
      t.outputCalendar,
      t.weekSettings,
      t.defaultToEN
    );
  }
  static create(t, v, w, T, x = !1) {
    const C = t || Settings.defaultLocale, D = C || (x ? "en-US" : systemLocale()), Y = v || Settings.defaultNumberingSystem, L = w || Settings.defaultOutputCalendar, q = validateWeekSettings(T) || Settings.defaultWeekSettings;
    return new Locale(D, Y, L, q, C);
  }
  static resetCache() {
    sysLocaleCache = null, intlDTCache.clear(), intlNumCache.clear(), intlRelCache.clear(), intlResolvedOptionsCache.clear(), weekInfoCache.clear();
  }
  static fromObject({ locale: t, numberingSystem: v, outputCalendar: w, weekSettings: T } = {}) {
    return Locale.create(t, v, w, T);
  }
  constructor(t, v, w, T, x) {
    const [C, D, Y] = parseLocaleString(t);
    this.locale = C, this.numberingSystem = v || D || null, this.outputCalendar = w || Y || null, this.weekSettings = T, this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = x, this.fastNumbersCached = null;
  }
  get fastNumbers() {
    return this.fastNumbersCached == null && (this.fastNumbersCached = supportsFastNumbers(this)), this.fastNumbersCached;
  }
  listingMode() {
    const t = this.isEnglish(), v = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return t && v ? "en" : "intl";
  }
  clone(t) {
    return !t || Object.getOwnPropertyNames(t).length === 0 ? this : Locale.create(
      t.locale || this.specifiedLocale,
      t.numberingSystem || this.numberingSystem,
      t.outputCalendar || this.outputCalendar,
      validateWeekSettings(t.weekSettings) || this.weekSettings,
      t.defaultToEN || !1
    );
  }
  redefaultToEN(t = {}) {
    return this.clone({ ...t, defaultToEN: !0 });
  }
  redefaultToSystem(t = {}) {
    return this.clone({ ...t, defaultToEN: !1 });
  }
  months(t, v = !1) {
    return listStuff(this, t, months, () => {
      const w = v ? { month: t, day: "numeric" } : { month: t }, T = v ? "format" : "standalone";
      return this.monthsCache[T][t] || (this.monthsCache[T][t] = mapMonths((x) => this.extract(x, w, "month"))), this.monthsCache[T][t];
    });
  }
  weekdays(t, v = !1) {
    return listStuff(this, t, weekdays, () => {
      const w = v ? { weekday: t, year: "numeric", month: "long", day: "numeric" } : { weekday: t }, T = v ? "format" : "standalone";
      return this.weekdaysCache[T][t] || (this.weekdaysCache[T][t] = mapWeekdays(
        (x) => this.extract(x, w, "weekday")
      )), this.weekdaysCache[T][t];
    });
  }
  meridiems() {
    return listStuff(
      this,
      void 0,
      () => meridiems,
      () => {
        if (!this.meridiemCache) {
          const t = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
            (v) => this.extract(v, t, "dayperiod")
          );
        }
        return this.meridiemCache;
      }
    );
  }
  eras(t) {
    return listStuff(this, t, eras, () => {
      const v = { era: t };
      return this.eraCache[t] || (this.eraCache[t] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
        (w) => this.extract(w, v, "era")
      )), this.eraCache[t];
    });
  }
  extract(t, v, w) {
    const T = this.dtFormatter(t, v), x = T.formatToParts(), C = x.find((D) => D.type.toLowerCase() === w);
    return C ? C.value : null;
  }
  numberFormatter(t = {}) {
    return new PolyNumberFormatter(this.intl, t.forceSimple || this.fastNumbers, t);
  }
  dtFormatter(t, v = {}) {
    return new PolyDateFormatter(t, this.intl, v);
  }
  relFormatter(t = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), t);
  }
  listFormatter(t = {}) {
    return getCachedLF(this.intl, t);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || getCachedIntResolvedOptions(this.intl).locale.startsWith("en-us");
  }
  getWeekSettings() {
    return this.weekSettings ? this.weekSettings : hasLocaleWeekInfo() ? getCachedWeekInfo(this.locale) : fallbackWeekSettings;
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(t) {
    return this.locale === t.locale && this.numberingSystem === t.numberingSystem && this.outputCalendar === t.outputCalendar;
  }
  toString() {
    return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;
  }
}
let singleton = null;
class FixedOffsetZone extends Zone {
  /**
   * Get a singleton instance of UTC
   * @return {FixedOffsetZone}
   */
  static get utcInstance() {
    return singleton === null && (singleton = new FixedOffsetZone(0)), singleton;
  }
  /**
   * Get an instance with a specified offset
   * @param {number} offset - The offset in minutes
   * @return {FixedOffsetZone}
   */
  static instance(t) {
    return t === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(t);
  }
  /**
   * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
   * @param {string} s - The offset string to parse
   * @example FixedOffsetZone.parseSpecifier("UTC+6")
   * @example FixedOffsetZone.parseSpecifier("UTC+06")
   * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
   * @return {FixedOffsetZone}
   */
  static parseSpecifier(t) {
    if (t) {
      const v = t.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (v)
        return new FixedOffsetZone(signedOffset(v[1], v[2]));
    }
    return null;
  }
  constructor(t) {
    super(), this.fixed = t;
  }
  /**
   * The type of zone. `fixed` for all instances of `FixedOffsetZone`.
   * @override
   * @type {string}
   */
  get type() {
    return "fixed";
  }
  /**
   * The name of this zone.
   * All fixed zones' names always start with "UTC" (plus optional offset)
   * @override
   * @type {string}
   */
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  /**
   * The IANA name of this zone, i.e. `Etc/UTC` or `Etc/GMT+/-nn`
   *
   * @override
   * @type {string}
   */
  get ianaName() {
    return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
  }
  /**
   * Returns the offset's common name at the specified timestamp.
   *
   * For fixed offset zones this equals to the zone name.
   * @override
   */
  offsetName() {
    return this.name;
  }
  /**
   * Returns the offset's value as a string
   * @override
   * @param {number} ts - Epoch milliseconds for which to get the offset
   * @param {string} format - What style of offset to return.
   *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
   * @return {string}
   */
  formatOffset(t, v) {
    return formatOffset(this.fixed, v);
  }
  /**
   * Returns whether the offset is known to be fixed for the whole year:
   * Always returns true for all fixed offset zones.
   * @override
   * @type {boolean}
   */
  get isUniversal() {
    return !0;
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   *
   * For fixed offset zones, this is constant and does not depend on a timestamp.
   * @override
   * @return {number}
   */
  offset() {
    return this.fixed;
  }
  /**
   * Return whether this Zone is equal to another zone (i.e. also fixed and same offset)
   * @override
   * @param {Zone} otherZone - the zone to compare
   * @return {boolean}
   */
  equals(t) {
    return t.type === "fixed" && t.fixed === this.fixed;
  }
  /**
   * Return whether this Zone is valid:
   * All fixed offset zones are valid.
   * @override
   * @type {boolean}
   */
  get isValid() {
    return !0;
  }
}
class InvalidZone extends Zone {
  constructor(t) {
    super(), this.zoneName = t;
  }
  /** @override **/
  get type() {
    return "invalid";
  }
  /** @override **/
  get name() {
    return this.zoneName;
  }
  /** @override **/
  get isUniversal() {
    return !1;
  }
  /** @override **/
  offsetName() {
    return null;
  }
  /** @override **/
  formatOffset() {
    return "";
  }
  /** @override **/
  offset() {
    return NaN;
  }
  /** @override **/
  equals() {
    return !1;
  }
  /** @override **/
  get isValid() {
    return !1;
  }
}
function normalizeZone(e, t) {
  if (isUndefined$1(e) || e === null)
    return t;
  if (e instanceof Zone)
    return e;
  if (isString$1(e)) {
    const v = e.toLowerCase();
    return v === "default" ? t : v === "local" || v === "system" ? SystemZone.instance : v === "utc" || v === "gmt" ? FixedOffsetZone.utcInstance : FixedOffsetZone.parseSpecifier(v) || IANAZone.create(e);
  } else return isNumber$1(e) ? FixedOffsetZone.instance(e) : typeof e == "object" && "offset" in e && typeof e.offset == "function" ? e : new InvalidZone(e);
}
const numberingSystems = {
  arab: "[٠-٩]",
  arabext: "[۰-۹]",
  bali: "[᭐-᭙]",
  beng: "[০-৯]",
  deva: "[०-९]",
  fullwide: "[０-９]",
  gujr: "[૦-૯]",
  hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
  khmr: "[០-៩]",
  knda: "[೦-೯]",
  laoo: "[໐-໙]",
  limb: "[᥆-᥏]",
  mlym: "[൦-൯]",
  mong: "[᠐-᠙]",
  mymr: "[၀-၉]",
  orya: "[୦-୯]",
  tamldec: "[௦-௯]",
  telu: "[౦-౯]",
  thai: "[๐-๙]",
  tibt: "[༠-༩]",
  latn: "\\d"
}, numberingSystemsUTF16 = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881]
}, hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(e) {
  let t = parseInt(e, 10);
  if (isNaN(t)) {
    t = "";
    for (let v = 0; v < e.length; v++) {
      const w = e.charCodeAt(v);
      if (e[v].search(numberingSystems.hanidec) !== -1)
        t += hanidecChars.indexOf(e[v]);
      else
        for (const T in numberingSystemsUTF16) {
          const [x, C] = numberingSystemsUTF16[T];
          w >= x && w <= C && (t += w - x);
        }
    }
    return parseInt(t, 10);
  } else
    return t;
}
const digitRegexCache = /* @__PURE__ */ new Map();
function resetDigitRegexCache() {
  digitRegexCache.clear();
}
function digitRegex({ numberingSystem: e }, t = "") {
  const v = e || "latn";
  let w = digitRegexCache.get(v);
  w === void 0 && (w = /* @__PURE__ */ new Map(), digitRegexCache.set(v, w));
  let T = w.get(t);
  return T === void 0 && (T = new RegExp(`${numberingSystems[v]}${t}`), w.set(t, T)), T;
}
let now = () => Date.now(), defaultZone = "system", defaultLocale = null, defaultNumberingSystem = null, defaultOutputCalendar = null, twoDigitCutoffYear = 60, throwOnInvalid, defaultWeekSettings = null;
class Settings {
  /**
   * Get the callback for returning the current timestamp.
   * @type {function}
   */
  static get now() {
    return now;
  }
  /**
   * Set the callback for returning the current timestamp.
   * The function should return a number, which will be interpreted as an Epoch millisecond count
   * @type {function}
   * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
   * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
   */
  static set now(t) {
    now = t;
  }
  /**
   * Set the default time zone to create DateTimes in. Does not affect existing instances.
   * Use the value "system" to reset this value to the system's time zone.
   * @type {string}
   */
  static set defaultZone(t) {
    defaultZone = t;
  }
  /**
   * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
   * The default value is the system's time zone (the one set on the machine that runs this code).
   * @type {Zone}
   */
  static get defaultZone() {
    return normalizeZone(defaultZone, SystemZone.instance);
  }
  /**
   * Get the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultLocale() {
    return defaultLocale;
  }
  /**
   * Set the default locale to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultLocale(t) {
    defaultLocale = t;
  }
  /**
   * Get the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultNumberingSystem() {
    return defaultNumberingSystem;
  }
  /**
   * Set the default numbering system to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultNumberingSystem(t) {
    defaultNumberingSystem = t;
  }
  /**
   * Get the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static get defaultOutputCalendar() {
    return defaultOutputCalendar;
  }
  /**
   * Set the default output calendar to create DateTimes with. Does not affect existing instances.
   * @type {string}
   */
  static set defaultOutputCalendar(t) {
    defaultOutputCalendar = t;
  }
  /**
   * @typedef {Object} WeekSettings
   * @property {number} firstDay
   * @property {number} minimalDays
   * @property {number[]} weekend
   */
  /**
   * @return {WeekSettings|null}
   */
  static get defaultWeekSettings() {
    return defaultWeekSettings;
  }
  /**
   * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
   * how many days are required in the first week of a year.
   * Does not affect existing instances.
   *
   * @param {WeekSettings|null} weekSettings
   */
  static set defaultWeekSettings(t) {
    defaultWeekSettings = validateWeekSettings(t);
  }
  /**
   * Get the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
   * @type {number}
   */
  static get twoDigitCutoffYear() {
    return twoDigitCutoffYear;
  }
  /**
   * Set the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
   * @type {number}
   * @example Settings.twoDigitCutoffYear = 0 // all 'yy' are interpreted as 20th century
   * @example Settings.twoDigitCutoffYear = 99 // all 'yy' are interpreted as 21st century
   * @example Settings.twoDigitCutoffYear = 50 // '49' -> 2049; '50' -> 1950
   * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
   * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
   */
  static set twoDigitCutoffYear(t) {
    twoDigitCutoffYear = t % 100;
  }
  /**
   * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static get throwOnInvalid() {
    return throwOnInvalid;
  }
  /**
   * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
   * @type {boolean}
   */
  static set throwOnInvalid(t) {
    throwOnInvalid = t;
  }
  /**
   * Reset Luxon's global caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCaches() {
    Locale.resetCache(), IANAZone.resetCache(), DateTime.resetCache(), resetDigitRegexCache();
  }
}
class Invalid {
  constructor(t, v) {
    this.reason = t, this.explanation = v;
  }
  toMessage() {
    return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason;
  }
}
const nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(e, t) {
  return new Invalid(
    "unit out of range",
    `you specified ${t} (of type ${typeof t}) as a ${e}, which is invalid`
  );
}
function dayOfWeek(e, t, v) {
  const w = new Date(Date.UTC(e, t - 1, v));
  e < 100 && e >= 0 && w.setUTCFullYear(w.getUTCFullYear() - 1900);
  const T = w.getUTCDay();
  return T === 0 ? 7 : T;
}
function computeOrdinal(e, t, v) {
  return v + (isLeapYear(e) ? leapLadder : nonLeapLadder)[t - 1];
}
function uncomputeOrdinal(e, t) {
  const v = isLeapYear(e) ? leapLadder : nonLeapLadder, w = v.findIndex((x) => x < t), T = t - v[w];
  return { month: w + 1, day: T };
}
function isoWeekdayToLocal(e, t) {
  return (e - t + 7) % 7 + 1;
}
function gregorianToWeek(e, t = 4, v = 1) {
  const { year: w, month: T, day: x } = e, C = computeOrdinal(w, T, x), D = isoWeekdayToLocal(dayOfWeek(w, T, x), v);
  let Y = Math.floor((C - D + 14 - t) / 7), L;
  return Y < 1 ? (L = w - 1, Y = weeksInWeekYear(L, t, v)) : Y > weeksInWeekYear(w, t, v) ? (L = w + 1, Y = 1) : L = w, { weekYear: L, weekNumber: Y, weekday: D, ...timeObject(e) };
}
function weekToGregorian(e, t = 4, v = 1) {
  const { weekYear: w, weekNumber: T, weekday: x } = e, C = isoWeekdayToLocal(dayOfWeek(w, 1, t), v), D = daysInYear(w);
  let Y = T * 7 + x - C - 7 + t, L;
  Y < 1 ? (L = w - 1, Y += daysInYear(L)) : Y > D ? (L = w + 1, Y -= daysInYear(w)) : L = w;
  const { month: q, day: N } = uncomputeOrdinal(L, Y);
  return { year: L, month: q, day: N, ...timeObject(e) };
}
function gregorianToOrdinal(e) {
  const { year: t, month: v, day: w } = e, T = computeOrdinal(t, v, w);
  return { year: t, ordinal: T, ...timeObject(e) };
}
function ordinalToGregorian(e) {
  const { year: t, ordinal: v } = e, { month: w, day: T } = uncomputeOrdinal(t, v);
  return { year: t, month: w, day: T, ...timeObject(e) };
}
function usesLocalWeekValues(e, t) {
  if (!isUndefined$1(e.localWeekday) || !isUndefined$1(e.localWeekNumber) || !isUndefined$1(e.localWeekYear)) {
    if (!isUndefined$1(e.weekday) || !isUndefined$1(e.weekNumber) || !isUndefined$1(e.weekYear))
      throw new ConflictingSpecificationError(
        "Cannot mix locale-based week fields with ISO-based week fields"
      );
    return isUndefined$1(e.localWeekday) || (e.weekday = e.localWeekday), isUndefined$1(e.localWeekNumber) || (e.weekNumber = e.localWeekNumber), isUndefined$1(e.localWeekYear) || (e.weekYear = e.localWeekYear), delete e.localWeekday, delete e.localWeekNumber, delete e.localWeekYear, {
      minDaysInFirstWeek: t.getMinDaysInFirstWeek(),
      startOfWeek: t.getStartOfWeek()
    };
  } else
    return { minDaysInFirstWeek: 4, startOfWeek: 1 };
}
function hasInvalidWeekData(e, t = 4, v = 1) {
  const w = isInteger(e.weekYear), T = integerBetween(
    e.weekNumber,
    1,
    weeksInWeekYear(e.weekYear, t, v)
  ), x = integerBetween(e.weekday, 1, 7);
  return w ? T ? x ? !1 : unitOutOfRange("weekday", e.weekday) : unitOutOfRange("week", e.weekNumber) : unitOutOfRange("weekYear", e.weekYear);
}
function hasInvalidOrdinalData(e) {
  const t = isInteger(e.year), v = integerBetween(e.ordinal, 1, daysInYear(e.year));
  return t ? v ? !1 : unitOutOfRange("ordinal", e.ordinal) : unitOutOfRange("year", e.year);
}
function hasInvalidGregorianData(e) {
  const t = isInteger(e.year), v = integerBetween(e.month, 1, 12), w = integerBetween(e.day, 1, daysInMonth(e.year, e.month));
  return t ? v ? w ? !1 : unitOutOfRange("day", e.day) : unitOutOfRange("month", e.month) : unitOutOfRange("year", e.year);
}
function hasInvalidTimeData(e) {
  const { hour: t, minute: v, second: w, millisecond: T } = e, x = integerBetween(t, 0, 23) || t === 24 && v === 0 && w === 0 && T === 0, C = integerBetween(v, 0, 59), D = integerBetween(w, 0, 59), Y = integerBetween(T, 0, 999);
  return x ? C ? D ? Y ? !1 : unitOutOfRange("millisecond", T) : unitOutOfRange("second", w) : unitOutOfRange("minute", v) : unitOutOfRange("hour", t);
}
function isUndefined$1(e) {
  return typeof e > "u";
}
function isNumber$1(e) {
  return typeof e == "number";
}
function isInteger(e) {
  return typeof e == "number" && e % 1 === 0;
}
function isString$1(e) {
  return typeof e == "string";
}
function isDate$1(e) {
  return Object.prototype.toString.call(e) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl < "u" && !!Intl.RelativeTimeFormat;
  } catch {
    return !1;
  }
}
function hasLocaleWeekInfo() {
  try {
    return typeof Intl < "u" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch {
    return !1;
  }
}
function maybeArray(e) {
  return Array.isArray(e) ? e : [e];
}
function bestBy(e, t, v) {
  if (e.length !== 0)
    return e.reduce((w, T) => {
      const x = [t(T), T];
      return w && v(w[0], x[0]) === w[0] ? w : x;
    }, null)[1];
}
function pick(e, t) {
  return t.reduce((v, w) => (v[w] = e[w], v), {});
}
function hasOwnProperty$1(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function validateWeekSettings(e) {
  if (e == null)
    return null;
  if (typeof e != "object")
    throw new InvalidArgumentError("Week settings must be an object");
  if (!integerBetween(e.firstDay, 1, 7) || !integerBetween(e.minimalDays, 1, 7) || !Array.isArray(e.weekend) || e.weekend.some((t) => !integerBetween(t, 1, 7)))
    throw new InvalidArgumentError("Invalid week settings");
  return {
    firstDay: e.firstDay,
    minimalDays: e.minimalDays,
    weekend: Array.from(e.weekend)
  };
}
function integerBetween(e, t, v) {
  return isInteger(e) && e >= t && e <= v;
}
function floorMod(e, t) {
  return e - t * Math.floor(e / t);
}
function padStart(e, t = 2) {
  const v = e < 0;
  let w;
  return v ? w = "-" + ("" + -e).padStart(t, "0") : w = ("" + e).padStart(t, "0"), w;
}
function parseInteger(e) {
  if (!(isUndefined$1(e) || e === null || e === ""))
    return parseInt(e, 10);
}
function parseFloating(e) {
  if (!(isUndefined$1(e) || e === null || e === ""))
    return parseFloat(e);
}
function parseMillis(e) {
  if (!(isUndefined$1(e) || e === null || e === "")) {
    const t = parseFloat("0." + e) * 1e3;
    return Math.floor(t);
  }
}
function roundTo(e, t, v = !1) {
  const w = 10 ** t;
  return (v ? Math.trunc : Math.round)(e * w) / w;
}
function isLeapYear(e) {
  return e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0);
}
function daysInYear(e) {
  return isLeapYear(e) ? 366 : 365;
}
function daysInMonth(e, t) {
  const v = floorMod(t - 1, 12) + 1, w = e + (t - v) / 12;
  return v === 2 ? isLeapYear(w) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][v - 1];
}
function objToLocalTS(e) {
  let t = Date.UTC(
    e.year,
    e.month - 1,
    e.day,
    e.hour,
    e.minute,
    e.second,
    e.millisecond
  );
  return e.year < 100 && e.year >= 0 && (t = new Date(t), t.setUTCFullYear(e.year, e.month - 1, e.day)), +t;
}
function firstWeekOffset(e, t, v) {
  return -isoWeekdayToLocal(dayOfWeek(e, 1, t), v) + t - 1;
}
function weeksInWeekYear(e, t = 4, v = 1) {
  const w = firstWeekOffset(e, t, v), T = firstWeekOffset(e + 1, t, v);
  return (daysInYear(e) - w + T) / 7;
}
function untruncateYear(e) {
  return e > 99 ? e : e > Settings.twoDigitCutoffYear ? 1900 + e : 2e3 + e;
}
function parseZoneInfo(e, t, v, w = null) {
  const T = new Date(e), x = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit"
  };
  w && (x.timeZone = w);
  const C = { timeZoneName: t, ...x }, D = new Intl.DateTimeFormat(v, C).formatToParts(T).find((Y) => Y.type.toLowerCase() === "timezonename");
  return D ? D.value : null;
}
function signedOffset(e, t) {
  let v = parseInt(e, 10);
  Number.isNaN(v) && (v = 0);
  const w = parseInt(t, 10) || 0, T = v < 0 || Object.is(v, -0) ? -w : w;
  return v * 60 + T;
}
function asNumber(e) {
  const t = Number(e);
  if (typeof e == "boolean" || e === "" || Number.isNaN(t))
    throw new InvalidArgumentError(`Invalid unit value ${e}`);
  return t;
}
function normalizeObject(e, t) {
  const v = {};
  for (const w in e)
    if (hasOwnProperty$1(e, w)) {
      const T = e[w];
      if (T == null) continue;
      v[t(w)] = asNumber(T);
    }
  return v;
}
function formatOffset(e, t) {
  const v = Math.trunc(Math.abs(e / 60)), w = Math.trunc(Math.abs(e % 60)), T = e >= 0 ? "+" : "-";
  switch (t) {
    case "short":
      return `${T}${padStart(v, 2)}:${padStart(w, 2)}`;
    case "narrow":
      return `${T}${v}${w > 0 ? `:${w}` : ""}`;
    case "techie":
      return `${T}${padStart(v, 2)}${padStart(w, 2)}`;
    default:
      throw new RangeError(`Value format ${t} is out of range for property format`);
  }
}
function timeObject(e) {
  return pick(e, ["hour", "minute", "second", "millisecond"]);
}
const monthsLong = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
], monthsShort = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
], monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(e) {
  switch (e) {
    case "narrow":
      return [...monthsNarrow];
    case "short":
      return [...monthsShort];
    case "long":
      return [...monthsLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const weekdaysLong = [
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
], weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(e) {
  switch (e) {
    case "narrow":
      return [...weekdaysNarrow];
    case "short":
      return [...weekdaysShort];
    case "long":
      return [...weekdaysLong];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const meridiems = ["AM", "PM"], erasLong = ["Before Christ", "Anno Domini"], erasShort = ["BC", "AD"], erasNarrow = ["B", "A"];
function eras(e) {
  switch (e) {
    case "narrow":
      return [...erasNarrow];
    case "short":
      return [...erasShort];
    case "long":
      return [...erasLong];
    default:
      return null;
  }
}
function meridiemForDateTime(e) {
  return meridiems[e.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(e, t) {
  return weekdays(t)[e.weekday - 1];
}
function monthForDateTime(e, t) {
  return months(t)[e.month - 1];
}
function eraForDateTime(e, t) {
  return eras(t)[e.year < 0 ? 0 : 1];
}
function formatRelativeTime(e, t, v = "always", w = !1) {
  const T = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."]
  }, x = ["hours", "minutes", "seconds"].indexOf(e) === -1;
  if (v === "auto" && x) {
    const N = e === "days";
    switch (t) {
      case 1:
        return N ? "tomorrow" : `next ${T[e][0]}`;
      case -1:
        return N ? "yesterday" : `last ${T[e][0]}`;
      case 0:
        return N ? "today" : `this ${T[e][0]}`;
    }
  }
  const C = Object.is(t, -0) || t < 0, D = Math.abs(t), Y = D === 1, L = T[e], q = w ? Y ? L[1] : L[2] || L[1] : Y ? T[e][0] : e;
  return C ? `${D} ${q} ago` : `in ${D} ${q}`;
}
function stringifyTokens(e, t) {
  let v = "";
  for (const w of e)
    w.literal ? v += w.val : v += t(w.val);
  return v;
}
const macroTokenToFormatOpts = {
  D: DATE_SHORT,
  DD: DATE_MED,
  DDD: DATE_FULL,
  DDDD: DATE_HUGE,
  t: TIME_SIMPLE,
  tt: TIME_WITH_SECONDS,
  ttt: TIME_WITH_SHORT_OFFSET,
  tttt: TIME_WITH_LONG_OFFSET,
  T: TIME_24_SIMPLE,
  TT: TIME_24_WITH_SECONDS,
  TTT: TIME_24_WITH_SHORT_OFFSET,
  TTTT: TIME_24_WITH_LONG_OFFSET,
  f: DATETIME_SHORT,
  ff: DATETIME_MED,
  fff: DATETIME_FULL,
  ffff: DATETIME_HUGE,
  F: DATETIME_SHORT_WITH_SECONDS,
  FF: DATETIME_MED_WITH_SECONDS,
  FFF: DATETIME_FULL_WITH_SECONDS,
  FFFF: DATETIME_HUGE_WITH_SECONDS
};
class Formatter {
  static create(t, v = {}) {
    return new Formatter(t, v);
  }
  static parseFormat(t) {
    let v = null, w = "", T = !1;
    const x = [];
    for (let C = 0; C < t.length; C++) {
      const D = t.charAt(C);
      D === "'" ? (w.length > 0 && x.push({ literal: T || /^\s+$/.test(w), val: w }), v = null, w = "", T = !T) : T || D === v ? w += D : (w.length > 0 && x.push({ literal: /^\s+$/.test(w), val: w }), w = D, v = D);
    }
    return w.length > 0 && x.push({ literal: T || /^\s+$/.test(w), val: w }), x;
  }
  static macroTokenToFormatOpts(t) {
    return macroTokenToFormatOpts[t];
  }
  constructor(t, v) {
    this.opts = v, this.loc = t, this.systemLoc = null;
  }
  formatWithSystemDefault(t, v) {
    return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(t, { ...this.opts, ...v }).format();
  }
  dtFormatter(t, v = {}) {
    return this.loc.dtFormatter(t, { ...this.opts, ...v });
  }
  formatDateTime(t, v) {
    return this.dtFormatter(t, v).format();
  }
  formatDateTimeParts(t, v) {
    return this.dtFormatter(t, v).formatToParts();
  }
  formatInterval(t, v) {
    return this.dtFormatter(t.start, v).dtf.formatRange(t.start.toJSDate(), t.end.toJSDate());
  }
  resolvedOptions(t, v) {
    return this.dtFormatter(t, v).resolvedOptions();
  }
  num(t, v = 0) {
    if (this.opts.forceSimple)
      return padStart(t, v);
    const w = { ...this.opts };
    return v > 0 && (w.padTo = v), this.loc.numberFormatter(w).format(t);
  }
  formatDateTimeFromString(t, v) {
    const w = this.loc.listingMode() === "en", T = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", x = (ae, he) => this.loc.extract(t, ae, he), C = (ae) => t.isOffsetFixed && t.offset === 0 && ae.allowZ ? "Z" : t.isValid ? t.zone.formatOffset(t.ts, ae.format) : "", D = () => w ? meridiemForDateTime(t) : x({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), Y = (ae, he) => w ? monthForDateTime(t, ae) : x(he ? { month: ae } : { month: ae, day: "numeric" }, "month"), L = (ae, he) => w ? weekdayForDateTime(t, ae) : x(
      he ? { weekday: ae } : { weekday: ae, month: "long", day: "numeric" },
      "weekday"
    ), q = (ae) => {
      const he = Formatter.macroTokenToFormatOpts(ae);
      return he ? this.formatWithSystemDefault(t, he) : ae;
    }, N = (ae) => w ? eraForDateTime(t, ae) : x({ era: ae }, "era"), F = (ae) => {
      switch (ae) {
        case "S":
          return this.num(t.millisecond);
        case "u":
        case "SSS":
          return this.num(t.millisecond, 3);
        case "s":
          return this.num(t.second);
        case "ss":
          return this.num(t.second, 2);
        case "uu":
          return this.num(Math.floor(t.millisecond / 10), 2);
        case "uuu":
          return this.num(Math.floor(t.millisecond / 100));
        case "m":
          return this.num(t.minute);
        case "mm":
          return this.num(t.minute, 2);
        case "h":
          return this.num(t.hour % 12 === 0 ? 12 : t.hour % 12);
        case "hh":
          return this.num(t.hour % 12 === 0 ? 12 : t.hour % 12, 2);
        case "H":
          return this.num(t.hour);
        case "HH":
          return this.num(t.hour, 2);
        case "Z":
          return C({ format: "narrow", allowZ: this.opts.allowZ });
        case "ZZ":
          return C({ format: "short", allowZ: this.opts.allowZ });
        case "ZZZ":
          return C({ format: "techie", allowZ: this.opts.allowZ });
        case "ZZZZ":
          return t.zone.offsetName(t.ts, { format: "short", locale: this.loc.locale });
        case "ZZZZZ":
          return t.zone.offsetName(t.ts, { format: "long", locale: this.loc.locale });
        case "z":
          return t.zoneName;
        case "a":
          return D();
        case "d":
          return T ? x({ day: "numeric" }, "day") : this.num(t.day);
        case "dd":
          return T ? x({ day: "2-digit" }, "day") : this.num(t.day, 2);
        case "c":
          return this.num(t.weekday);
        case "ccc":
          return L("short", !0);
        case "cccc":
          return L("long", !0);
        case "ccccc":
          return L("narrow", !0);
        case "E":
          return this.num(t.weekday);
        case "EEE":
          return L("short", !1);
        case "EEEE":
          return L("long", !1);
        case "EEEEE":
          return L("narrow", !1);
        case "L":
          return T ? x({ month: "numeric", day: "numeric" }, "month") : this.num(t.month);
        case "LL":
          return T ? x({ month: "2-digit", day: "numeric" }, "month") : this.num(t.month, 2);
        case "LLL":
          return Y("short", !0);
        case "LLLL":
          return Y("long", !0);
        case "LLLLL":
          return Y("narrow", !0);
        case "M":
          return T ? x({ month: "numeric" }, "month") : this.num(t.month);
        case "MM":
          return T ? x({ month: "2-digit" }, "month") : this.num(t.month, 2);
        case "MMM":
          return Y("short", !1);
        case "MMMM":
          return Y("long", !1);
        case "MMMMM":
          return Y("narrow", !1);
        case "y":
          return T ? x({ year: "numeric" }, "year") : this.num(t.year);
        case "yy":
          return T ? x({ year: "2-digit" }, "year") : this.num(t.year.toString().slice(-2), 2);
        case "yyyy":
          return T ? x({ year: "numeric" }, "year") : this.num(t.year, 4);
        case "yyyyyy":
          return T ? x({ year: "numeric" }, "year") : this.num(t.year, 6);
        case "G":
          return N("short");
        case "GG":
          return N("long");
        case "GGGGG":
          return N("narrow");
        case "kk":
          return this.num(t.weekYear.toString().slice(-2), 2);
        case "kkkk":
          return this.num(t.weekYear, 4);
        case "W":
          return this.num(t.weekNumber);
        case "WW":
          return this.num(t.weekNumber, 2);
        case "n":
          return this.num(t.localWeekNumber);
        case "nn":
          return this.num(t.localWeekNumber, 2);
        case "ii":
          return this.num(t.localWeekYear.toString().slice(-2), 2);
        case "iiii":
          return this.num(t.localWeekYear, 4);
        case "o":
          return this.num(t.ordinal);
        case "ooo":
          return this.num(t.ordinal, 3);
        case "q":
          return this.num(t.quarter);
        case "qq":
          return this.num(t.quarter, 2);
        case "X":
          return this.num(Math.floor(t.ts / 1e3));
        case "x":
          return this.num(t.ts);
        default:
          return q(ae);
      }
    };
    return stringifyTokens(Formatter.parseFormat(v), F);
  }
  formatDurationFromString(t, v) {
    const w = (Y) => {
      switch (Y[0]) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
          return "hour";
        case "d":
          return "day";
        case "w":
          return "week";
        case "M":
          return "month";
        case "y":
          return "year";
        default:
          return null;
      }
    }, T = (Y) => (L) => {
      const q = w(L);
      return q ? this.num(Y.get(q), L.length) : L;
    }, x = Formatter.parseFormat(v), C = x.reduce(
      (Y, { literal: L, val: q }) => L ? Y : Y.concat(q),
      []
    ), D = t.shiftTo(...C.map(w).filter((Y) => Y));
    return stringifyTokens(x, T(D));
  }
}
const ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function combineRegexes(...e) {
  const t = e.reduce((v, w) => v + w.source, "");
  return RegExp(`^${t}$`);
}
function combineExtractors(...e) {
  return (t) => e.reduce(
    ([v, w, T], x) => {
      const [C, D, Y] = x(t, T);
      return [{ ...v, ...C }, D || w, Y];
    },
    [{}, null, 1]
  ).slice(0, 2);
}
function parse$2(e, ...t) {
  if (e == null)
    return [null, null];
  for (const [v, w] of t) {
    const T = v.exec(e);
    if (T)
      return w(T);
  }
  return [null, null];
}
function simpleParse(...e) {
  return (t, v) => {
    const w = {};
    let T;
    for (T = 0; T < e.length; T++)
      w[e[T]] = parseInteger(t[v + T]);
    return [w, null, v + T];
  };
}
const offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`, isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`), isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`), isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/, isoOrdinalRegex = /(\d{4})-?(\d{3})/, extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay"), extractISOOrdinalData = simpleParse("year", "ordinal"), sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/, sqlTimeRegex = RegExp(
  `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
), sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
function int(e, t, v) {
  const w = e[t];
  return isUndefined$1(w) ? v : parseInteger(w);
}
function extractISOYmd(e, t) {
  return [{
    year: int(e, t),
    month: int(e, t + 1, 1),
    day: int(e, t + 2, 1)
  }, null, t + 3];
}
function extractISOTime(e, t) {
  return [{
    hours: int(e, t, 0),
    minutes: int(e, t + 1, 0),
    seconds: int(e, t + 2, 0),
    milliseconds: parseMillis(e[t + 3])
  }, null, t + 4];
}
function extractISOOffset(e, t) {
  const v = !e[t] && !e[t + 1], w = signedOffset(e[t + 1], e[t + 2]), T = v ? null : FixedOffsetZone.instance(w);
  return [{}, T, t + 3];
}
function extractIANAZone(e, t) {
  const v = e[t] ? IANAZone.create(e[t]) : null;
  return [{}, v, t + 1];
}
const isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`), isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(e) {
  const [t, v, w, T, x, C, D, Y, L] = e, q = t[0] === "-", N = Y && Y[0] === "-", F = (ae, he = !1) => ae !== void 0 && (he || ae && q) ? -ae : ae;
  return [
    {
      years: F(parseFloating(v)),
      months: F(parseFloating(w)),
      weeks: F(parseFloating(T)),
      days: F(parseFloating(x)),
      hours: F(parseFloating(C)),
      minutes: F(parseFloating(D)),
      seconds: F(parseFloating(Y), Y === "-0"),
      milliseconds: F(parseMillis(L), N)
    }
  ];
}
const obsOffsets = {
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function fromStrings(e, t, v, w, T, x, C) {
  const D = {
    year: t.length === 2 ? untruncateYear(parseInteger(t)) : parseInteger(t),
    month: monthsShort.indexOf(v) + 1,
    day: parseInteger(w),
    hour: parseInteger(T),
    minute: parseInteger(x)
  };
  return C && (D.second = parseInteger(C)), e && (D.weekday = e.length > 3 ? weekdaysLong.indexOf(e) + 1 : weekdaysShort.indexOf(e) + 1), D;
}
const rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(e) {
  const [
    ,
    t,
    v,
    w,
    T,
    x,
    C,
    D,
    Y,
    L,
    q,
    N
  ] = e, F = fromStrings(t, T, w, v, x, C, D);
  let ae;
  return Y ? ae = obsOffsets[Y] : L ? ae = 0 : ae = signedOffset(q, N), [F, new FixedOffsetZone(ae)];
}
function preprocessRFC2822(e) {
  return e.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
}
const rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(e) {
  const [, t, v, w, T, x, C, D] = e;
  return [fromStrings(t, T, w, v, x, C, D), FixedOffsetZone.utcInstance];
}
function extractASCII(e) {
  const [, t, v, w, T, x, C, D] = e;
  return [fromStrings(t, D, v, w, T, x, C), FixedOffsetZone.utcInstance];
}
const isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex), isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex), isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex), isoTimeCombinedRegex = combineRegexes(isoTimeRegex), extractISOYmdTimeAndOffset = combineExtractors(
  extractISOYmd,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
), extractISOWeekTimeAndOffset = combineExtractors(
  extractISOWeekData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
), extractISOOrdinalDateAndTime = combineExtractors(
  extractISOOrdinalData,
  extractISOTime,
  extractISOOffset,
  extractIANAZone
), extractISOTimeAndOffset = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseISODate(e) {
  return parse$2(
    e,
    [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
    [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
    [isoTimeCombinedRegex, extractISOTimeAndOffset]
  );
}
function parseRFC2822Date(e) {
  return parse$2(preprocessRFC2822(e), [rfc2822, extractRFC2822]);
}
function parseHTTPDate(e) {
  return parse$2(
    e,
    [rfc1123, extractRFC1123Or850],
    [rfc850, extractRFC1123Or850],
    [ascii, extractASCII]
  );
}
function parseISODuration(e) {
  return parse$2(e, [isoDuration, extractISODuration]);
}
const extractISOTimeOnly = combineExtractors(extractISOTime);
function parseISOTimeOnly(e) {
  return parse$2(e, [isoTimeOnly, extractISOTimeOnly]);
}
const sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex), sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex), extractISOTimeOffsetAndIANAZone = combineExtractors(
  extractISOTime,
  extractISOOffset,
  extractIANAZone
);
function parseSQL(e) {
  return parse$2(
    e,
    [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
    [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
  );
}
const INVALID$2 = "Invalid Duration", lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
}, casualMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: 52,
    days: 365,
    hours: 365 * 24,
    minutes: 365 * 24 * 60,
    seconds: 365 * 24 * 60 * 60,
    milliseconds: 365 * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: 13,
    days: 91,
    hours: 91 * 24,
    minutes: 91 * 24 * 60,
    seconds: 91 * 24 * 60 * 60,
    milliseconds: 91 * 24 * 60 * 60 * 1e3
  },
  months: {
    weeks: 4,
    days: 30,
    hours: 30 * 24,
    minutes: 30 * 24 * 60,
    seconds: 30 * 24 * 60 * 60,
    milliseconds: 30 * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
}, daysInYearAccurate = 146097 / 400, daysInMonthAccurate = 146097 / 4800, accurateMatrix = {
  years: {
    quarters: 4,
    months: 12,
    weeks: daysInYearAccurate / 7,
    days: daysInYearAccurate,
    hours: daysInYearAccurate * 24,
    minutes: daysInYearAccurate * 24 * 60,
    seconds: daysInYearAccurate * 24 * 60 * 60,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
  },
  quarters: {
    months: 3,
    weeks: daysInYearAccurate / 28,
    days: daysInYearAccurate / 4,
    hours: daysInYearAccurate * 24 / 4,
    minutes: daysInYearAccurate * 24 * 60 / 4,
    seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
    milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
  },
  months: {
    weeks: daysInMonthAccurate / 7,
    days: daysInMonthAccurate,
    hours: daysInMonthAccurate * 24,
    minutes: daysInMonthAccurate * 24 * 60,
    seconds: daysInMonthAccurate * 24 * 60 * 60,
    milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
  },
  ...lowOrderMatrix
}, orderedUnits$1 = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
], reverseUnits = orderedUnits$1.slice(0).reverse();
function clone$1(e, t, v = !1) {
  const w = {
    values: v ? t.values : { ...e.values, ...t.values || {} },
    loc: e.loc.clone(t.loc),
    conversionAccuracy: t.conversionAccuracy || e.conversionAccuracy,
    matrix: t.matrix || e.matrix
  };
  return new Duration(w);
}
function durationToMillis(e, t) {
  let v = t.milliseconds ?? 0;
  for (const w of reverseUnits.slice(1))
    t[w] && (v += t[w] * e[w].milliseconds);
  return v;
}
function normalizeValues(e, t) {
  const v = durationToMillis(e, t) < 0 ? -1 : 1;
  orderedUnits$1.reduceRight((w, T) => {
    if (isUndefined$1(t[T]))
      return w;
    if (w) {
      const x = t[w] * v, C = e[T][w], D = Math.floor(x / C);
      t[T] += D * v, t[w] -= D * C * v;
    }
    return T;
  }, null), orderedUnits$1.reduce((w, T) => {
    if (isUndefined$1(t[T]))
      return w;
    if (w) {
      const x = t[w] % 1;
      t[w] -= x, t[T] += x * e[w][T];
    }
    return T;
  }, null);
}
function removeZeroes(e) {
  const t = {};
  for (const [v, w] of Object.entries(e))
    w !== 0 && (t[v] = w);
  return t;
}
class Duration {
  /**
   * @private
   */
  constructor(t) {
    const v = t.conversionAccuracy === "longterm" || !1;
    let w = v ? accurateMatrix : casualMatrix;
    t.matrix && (w = t.matrix), this.values = t.values, this.loc = t.loc || Locale.create(), this.conversionAccuracy = v ? "longterm" : "casual", this.invalid = t.invalid || null, this.matrix = w, this.isLuxonDuration = !0;
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} count of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(t, v) {
    return Duration.fromObject({ milliseconds: t }, v);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(t, v = {}) {
    if (t == null || typeof t != "object")
      throw new InvalidArgumentError(
        `Duration.fromObject: argument expected to be an object, got ${t === null ? "null" : typeof t}`
      );
    return new Duration({
      values: normalizeObject(t, Duration.normalizeUnit),
      loc: Locale.fromObject(v),
      conversionAccuracy: v.conversionAccuracy,
      matrix: v.matrix
    });
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(t) {
    if (isNumber$1(t))
      return Duration.fromMillis(t);
    if (Duration.isDuration(t))
      return t;
    if (typeof t == "object")
      return Duration.fromObject(t);
    throw new InvalidArgumentError(
      `Unknown duration argument ${t} of type ${typeof t}`
    );
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(t, v) {
    const [w] = parseISODuration(t);
    return w ? Duration.fromObject(w, v) : Duration.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`);
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(t, v) {
    const [w] = parseISOTimeOnly(t);
    return w ? Duration.fromObject(w, v) : Duration.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`);
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(t, v = null) {
    if (!t)
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    const w = t instanceof Invalid ? t : new Invalid(t, v);
    if (Settings.throwOnInvalid)
      throw new InvalidDurationError(w);
    return new Duration({ invalid: w });
  }
  /**
   * @private
   */
  static normalizeUnit(t) {
    const v = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[t && t.toLowerCase()];
    if (!v) throw new InvalidUnitError(t);
    return v;
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDuration(t) {
    return t && t.isLuxonDuration || !1;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(t, v = {}) {
    const w = {
      ...v,
      floor: v.round !== !1 && v.floor !== !1
    };
    return this.isValid ? Formatter.create(this.loc, w).formatDurationFromString(this, t) : INVALID$2;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
   * @example
   * ```js
   * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
   * ```
   */
  toHuman(t = {}) {
    if (!this.isValid) return INVALID$2;
    const v = orderedUnits$1.map((w) => {
      const T = this.values[w];
      return isUndefined$1(T) ? null : this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...t, unit: w.slice(0, -1) }).format(T);
    }).filter((w) => w);
    return this.loc.listFormatter({ type: "conjunction", style: t.listStyle || "narrow", ...t }).format(v);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    return this.isValid ? { ...this.values } : {};
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid) return null;
    let t = "P";
    return this.years !== 0 && (t += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (t += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (t += this.weeks + "W"), this.days !== 0 && (t += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (t += "T"), this.hours !== 0 && (t += this.hours + "H"), this.minutes !== 0 && (t += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (t += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S"), t === "P" && (t += "T0S"), t;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(t = {}) {
    if (!this.isValid) return null;
    const v = this.toMillis();
    return v < 0 || v >= 864e5 ? null : (t = {
      suppressMilliseconds: !1,
      suppressSeconds: !1,
      includePrefix: !1,
      format: "extended",
      ...t,
      includeOffset: !1
    }, DateTime.fromMillis(v, { zone: "UTC" }).toISOTime(t));
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns a string representation of this Duration appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `Duration { values: ${JSON.stringify(this.values)} }` : `Duration { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns an milliseconds value of this Duration.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? durationToMillis(this.matrix, this.values) : NaN;
  }
  /**
   * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(t) {
    if (!this.isValid) return this;
    const v = Duration.fromDurationLike(t), w = {};
    for (const T of orderedUnits$1)
      (hasOwnProperty$1(v.values, T) || hasOwnProperty$1(this.values, T)) && (w[T] = v.get(T) + this.get(T));
    return clone$1(this, { values: w }, !0);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(t) {
    if (!this.isValid) return this;
    const v = Duration.fromDurationLike(t);
    return this.plus(v.negate());
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(t) {
    if (!this.isValid) return this;
    const v = {};
    for (const w of Object.keys(this.values))
      v[w] = asNumber(t(this.values[w], w));
    return clone$1(this, { values: v }, !0);
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(t) {
    return this[Duration.normalizeUnit(t)];
  }
  /**
   * "Set" the values of specified units. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(t) {
    if (!this.isValid) return this;
    const v = { ...this.values, ...normalizeObject(t, Duration.normalizeUnit) };
    return clone$1(this, { values: v });
  }
  /**
   * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale: t, numberingSystem: v, conversionAccuracy: w, matrix: T } = {}) {
    const C = { loc: this.loc.clone({ locale: t, numberingSystem: v }), matrix: T, conversionAccuracy: w };
    return clone$1(this, C);
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(t) {
    return this.isValid ? this.shiftTo(t).get(t) : NaN;
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see third example)
   * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid) return this;
    const t = this.toObject();
    return normalizeValues(this.matrix, t), clone$1(this, { values: t }, !0);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid) return this;
    const t = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone$1(this, { values: t }, !0);
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...t) {
    if (!this.isValid) return this;
    if (t.length === 0)
      return this;
    t = t.map((C) => Duration.normalizeUnit(C));
    const v = {}, w = {}, T = this.toObject();
    let x;
    for (const C of orderedUnits$1)
      if (t.indexOf(C) >= 0) {
        x = C;
        let D = 0;
        for (const L in w)
          D += this.matrix[L][C] * w[L], w[L] = 0;
        isNumber$1(T[C]) && (D += T[C]);
        const Y = Math.trunc(D);
        v[C] = Y, w[C] = (D * 1e3 - Y * 1e3) / 1e3;
      } else isNumber$1(T[C]) && (w[C] = T[C]);
    for (const C in w)
      w[C] !== 0 && (v[x] += C === x ? w[C] : w[C] / this.matrix[x][C]);
    return normalizeValues(this.matrix, v), clone$1(this, { values: v }, !0);
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    return this.isValid ? this.shiftTo(
      "years",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ) : this;
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid) return this;
    const t = {};
    for (const v of Object.keys(this.values))
      t[v] = this.values[v] === 0 ? 0 : -this.values[v];
    return clone$1(this, { values: t }, !0);
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(t) {
    if (!this.isValid || !t.isValid || !this.loc.equals(t.loc))
      return !1;
    function v(w, T) {
      return w === void 0 || w === 0 ? T === void 0 || T === 0 : w === T;
    }
    for (const w of orderedUnits$1)
      if (!v(this.values[w], t.values[w]))
        return !1;
    return !0;
  }
}
const INVALID$1 = "Invalid Interval";
function validateStartEnd(e, t) {
  return !e || !e.isValid ? Interval.invalid("missing or invalid start") : !t || !t.isValid ? Interval.invalid("missing or invalid end") : t < e ? Interval.invalid(
    "end before start",
    `The end of an interval must be after its start, but you had start=${e.toISO()} and end=${t.toISO()}`
  ) : null;
}
class Interval {
  /**
   * @private
   */
  constructor(t) {
    this.s = t.start, this.e = t.end, this.invalid = t.invalid || null, this.isLuxonInterval = !0;
  }
  /**
   * Create an invalid Interval.
   * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Interval}
   */
  static invalid(t, v = null) {
    if (!t)
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    const w = t instanceof Invalid ? t : new Invalid(t, v);
    if (Settings.throwOnInvalid)
      throw new InvalidIntervalError(w);
    return new Interval({ invalid: w });
  }
  /**
   * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
   * @param {DateTime|Date|Object} start
   * @param {DateTime|Date|Object} end
   * @return {Interval}
   */
  static fromDateTimes(t, v) {
    const w = friendlyDateTime(t), T = friendlyDateTime(v), x = validateStartEnd(w, T);
    return x ?? new Interval({
      start: w,
      end: T
    });
  }
  /**
   * Create an Interval from a start DateTime and a Duration to extend to.
   * @param {DateTime|Date|Object} start
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static after(t, v) {
    const w = Duration.fromDurationLike(v), T = friendlyDateTime(t);
    return Interval.fromDateTimes(T, T.plus(w));
  }
  /**
   * Create an Interval from an end DateTime and a Duration to extend backwards to.
   * @param {DateTime|Date|Object} end
   * @param {Duration|Object|number} duration - the length of the Interval.
   * @return {Interval}
   */
  static before(t, v) {
    const w = Duration.fromDurationLike(v), T = friendlyDateTime(t);
    return Interval.fromDateTimes(T.minus(w), T);
  }
  /**
   * Create an Interval from an ISO 8601 string.
   * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
   * @param {string} text - the ISO string to parse
   * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {Interval}
   */
  static fromISO(t, v) {
    const [w, T] = (t || "").split("/", 2);
    if (w && T) {
      let x, C;
      try {
        x = DateTime.fromISO(w, v), C = x.isValid;
      } catch {
        C = !1;
      }
      let D, Y;
      try {
        D = DateTime.fromISO(T, v), Y = D.isValid;
      } catch {
        Y = !1;
      }
      if (C && Y)
        return Interval.fromDateTimes(x, D);
      if (C) {
        const L = Duration.fromISO(T, v);
        if (L.isValid)
          return Interval.after(x, L);
      } else if (Y) {
        const L = Duration.fromISO(w, v);
        if (L.isValid)
          return Interval.before(D, L);
      }
    }
    return Interval.invalid("unparsable", `the input "${t}" can't be parsed as ISO 8601`);
  }
  /**
   * Check if an object is an Interval. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isInterval(t) {
    return t && t.isLuxonInterval || !1;
  }
  /**
   * Returns the start of the Interval
   * @type {DateTime}
   */
  get start() {
    return this.isValid ? this.s : null;
  }
  /**
   * Returns the end of the Interval
   * @type {DateTime}
   */
  get end() {
    return this.isValid ? this.e : null;
  }
  /**
   * Returns the last DateTime included in the interval (since end is not part of the interval)
   * @type {DateTime}
   */
  get lastDateTime() {
    return this.isValid && this.e ? this.e.minus(1) : null;
  }
  /**
   * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
   * @type {boolean}
   */
  get isValid() {
    return this.invalidReason === null;
  }
  /**
   * Returns an error code if this Interval is invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Returns the length of the Interval in the specified unit.
   * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
   * @return {number}
   */
  length(t = "milliseconds") {
    return this.isValid ? this.toDuration(t).get(t) : NaN;
  }
  /**
   * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
   * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
   * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
   * @param {string} [unit='milliseconds'] - the unit of time to count.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
   * @return {number}
   */
  count(t = "milliseconds", v) {
    if (!this.isValid) return NaN;
    const w = this.start.startOf(t, v);
    let T;
    return v != null && v.useLocaleWeeks ? T = this.end.reconfigure({ locale: w.locale }) : T = this.end, T = T.startOf(t, v), Math.floor(T.diff(w, t).get(t)) + (T.valueOf() !== this.end.valueOf());
  }
  /**
   * Returns whether this Interval's start and end are both in the same unit of time
   * @param {string} unit - the unit of time to check sameness on
   * @return {boolean}
   */
  hasSame(t) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, t) : !1;
  }
  /**
   * Return whether this Interval has the same start and end DateTimes.
   * @return {boolean}
   */
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  /**
   * Return whether this Interval's start is after the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isAfter(t) {
    return this.isValid ? this.s > t : !1;
  }
  /**
   * Return whether this Interval's end is before the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  isBefore(t) {
    return this.isValid ? this.e <= t : !1;
  }
  /**
   * Return whether this Interval contains the specified DateTime.
   * @param {DateTime} dateTime
   * @return {boolean}
   */
  contains(t) {
    return this.isValid ? this.s <= t && this.e > t : !1;
  }
  /**
   * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
   * @param {Object} values - the values to set
   * @param {DateTime} values.start - the starting DateTime
   * @param {DateTime} values.end - the ending DateTime
   * @return {Interval}
   */
  set({ start: t, end: v } = {}) {
    return this.isValid ? Interval.fromDateTimes(t || this.s, v || this.e) : this;
  }
  /**
   * Split this Interval at each of the specified DateTimes
   * @param {...DateTime} dateTimes - the unit of time to count.
   * @return {Array}
   */
  splitAt(...t) {
    if (!this.isValid) return [];
    const v = t.map(friendlyDateTime).filter((C) => this.contains(C)).sort((C, D) => C.toMillis() - D.toMillis()), w = [];
    let { s: T } = this, x = 0;
    for (; T < this.e; ) {
      const C = v[x] || this.e, D = +C > +this.e ? this.e : C;
      w.push(Interval.fromDateTimes(T, D)), T = D, x += 1;
    }
    return w;
  }
  /**
   * Split this Interval into smaller Intervals, each of the specified length.
   * Left over time is grouped into a smaller interval
   * @param {Duration|Object|number} duration - The length of each resulting interval.
   * @return {Array}
   */
  splitBy(t) {
    const v = Duration.fromDurationLike(t);
    if (!this.isValid || !v.isValid || v.as("milliseconds") === 0)
      return [];
    let { s: w } = this, T = 1, x;
    const C = [];
    for (; w < this.e; ) {
      const D = this.start.plus(v.mapUnits((Y) => Y * T));
      x = +D > +this.e ? this.e : D, C.push(Interval.fromDateTimes(w, x)), w = x, T += 1;
    }
    return C;
  }
  /**
   * Split this Interval into the specified number of smaller intervals.
   * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
   * @return {Array}
   */
  divideEqually(t) {
    return this.isValid ? this.splitBy(this.length() / t).slice(0, t) : [];
  }
  /**
   * Return whether this Interval overlaps with the specified Interval
   * @param {Interval} other
   * @return {boolean}
   */
  overlaps(t) {
    return this.e > t.s && this.s < t.e;
  }
  /**
   * Return whether this Interval's end is adjacent to the specified Interval's start.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsStart(t) {
    return this.isValid ? +this.e == +t.s : !1;
  }
  /**
   * Return whether this Interval's start is adjacent to the specified Interval's end.
   * @param {Interval} other
   * @return {boolean}
   */
  abutsEnd(t) {
    return this.isValid ? +t.e == +this.s : !1;
  }
  /**
   * Returns true if this Interval fully contains the specified Interval, specifically if the intersect (of this Interval and the other Interval) is equal to the other Interval; false otherwise.
   * @param {Interval} other
   * @return {boolean}
   */
  engulfs(t) {
    return this.isValid ? this.s <= t.s && this.e >= t.e : !1;
  }
  /**
   * Return whether this Interval has the same start and end as the specified Interval.
   * @param {Interval} other
   * @return {boolean}
   */
  equals(t) {
    return !this.isValid || !t.isValid ? !1 : this.s.equals(t.s) && this.e.equals(t.e);
  }
  /**
   * Return an Interval representing the intersection of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
   * Returns null if the intersection is empty, meaning, the intervals don't intersect.
   * @param {Interval} other
   * @return {Interval}
   */
  intersection(t) {
    if (!this.isValid) return this;
    const v = this.s > t.s ? this.s : t.s, w = this.e < t.e ? this.e : t.e;
    return v >= w ? null : Interval.fromDateTimes(v, w);
  }
  /**
   * Return an Interval representing the union of this Interval and the specified Interval.
   * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
   * @param {Interval} other
   * @return {Interval}
   */
  union(t) {
    if (!this.isValid) return this;
    const v = this.s < t.s ? this.s : t.s, w = this.e > t.e ? this.e : t.e;
    return Interval.fromDateTimes(v, w);
  }
  /**
   * Merge an array of Intervals into an equivalent minimal set of Intervals.
   * Combines overlapping and adjacent Intervals.
   * The resulting array will contain the Intervals in ascending order, that is, starting with the earliest Interval
   * and ending with the latest.
   *
   * @param {Array} intervals
   * @return {Array}
   */
  static merge(t) {
    const [v, w] = t.sort((T, x) => T.s - x.s).reduce(
      ([T, x], C) => x ? x.overlaps(C) || x.abutsStart(C) ? [T, x.union(C)] : [T.concat([x]), C] : [T, C],
      [[], null]
    );
    return w && v.push(w), v;
  }
  /**
   * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
   * @param {Array} intervals
   * @return {Array}
   */
  static xor(t) {
    let v = null, w = 0;
    const T = [], x = t.map((Y) => [
      { time: Y.s, type: "s" },
      { time: Y.e, type: "e" }
    ]), C = Array.prototype.concat(...x), D = C.sort((Y, L) => Y.time - L.time);
    for (const Y of D)
      w += Y.type === "s" ? 1 : -1, w === 1 ? v = Y.time : (v && +v != +Y.time && T.push(Interval.fromDateTimes(v, Y.time)), v = null);
    return Interval.merge(T);
  }
  /**
   * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
   * @param {...Interval} intervals
   * @return {Array}
   */
  difference(...t) {
    return Interval.xor([this].concat(t)).map((v) => this.intersection(v)).filter((v) => v && !v.isEmpty());
  }
  /**
   * Returns a string representation of this Interval appropriate for debugging.
   * @return {string}
   */
  toString() {
    return this.isValid ? `[${this.s.toISO()} – ${this.e.toISO()})` : INVALID$1;
  }
  /**
   * Returns a string representation of this Interval appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }` : `Interval { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns a localized string representing this Interval. Accepts the same options as the
   * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
   * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
   * is browser-specific, but in general it will return an appropriate representation of the
   * Interval in the assigned locale. Defaults to the system's locale if no locale has been
   * specified.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
   * Intl.DateTimeFormat constructor options.
   * @param {Object} opts - Options to override the configuration of the start DateTime.
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
   * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
   * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
   * @return {string}
   */
  toLocaleString(t = DATE_SHORT, v = {}) {
    return this.isValid ? Formatter.create(this.s.loc.clone(v), t).formatInterval(this) : INVALID$1;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Interval.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISO(t) {
    return this.isValid ? `${this.s.toISO(t)}/${this.e.toISO(t)}` : INVALID$1;
  }
  /**
   * Returns an ISO 8601-compliant string representation of date of this Interval.
   * The time components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @return {string}
   */
  toISODate() {
    return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : INVALID$1;
  }
  /**
   * Returns an ISO 8601-compliant string representation of time of this Interval.
   * The date components are ignored.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
   * @param {Object} opts - The same options as {@link DateTime#toISO}
   * @return {string}
   */
  toISOTime(t) {
    return this.isValid ? `${this.s.toISOTime(t)}/${this.e.toISOTime(t)}` : INVALID$1;
  }
  /**
   * Returns a string representation of this Interval formatted according to the specified format
   * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
   * formatting tool.
   * @param {string} dateFormat - The format string. This string formats the start and end time.
   * See {@link DateTime#toFormat} for details.
   * @param {Object} opts - Options.
   * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
   * representations.
   * @return {string}
   */
  toFormat(t, { separator: v = " – " } = {}) {
    return this.isValid ? `${this.s.toFormat(t)}${v}${this.e.toFormat(t)}` : INVALID$1;
  }
  /**
   * Return a Duration representing the time spanned by this interval.
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
   * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
   * @return {Duration}
   */
  toDuration(t, v) {
    return this.isValid ? this.e.diff(this.s, t, v) : Duration.invalid(this.invalidReason);
  }
  /**
   * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
   * @param {function} mapFn
   * @return {Interval}
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
   * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
   */
  mapEndpoints(t) {
    return Interval.fromDateTimes(t(this.s), t(this.e));
  }
}
class Info {
  /**
   * Return whether the specified zone contains a DST.
   * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
   * @return {boolean}
   */
  static hasDST(t = Settings.defaultZone) {
    const v = DateTime.now().setZone(t).set({ month: 12 });
    return !t.isUniversal && v.offset !== v.set({ month: 6 }).offset;
  }
  /**
   * Return whether the specified zone is a valid IANA specifier.
   * @param {string} zone - Zone to check
   * @return {boolean}
   */
  static isValidIANAZone(t) {
    return IANAZone.isValidZone(t);
  }
  /**
   * Converts the input into a {@link Zone} instance.
   *
   * * If `input` is already a Zone instance, it is returned unchanged.
   * * If `input` is a string containing a valid time zone name, a Zone instance
   *   with that name is returned.
   * * If `input` is a string that doesn't refer to a known time zone, a Zone
   *   instance with {@link Zone#isValid} == false is returned.
   * * If `input is a number, a Zone instance with the specified fixed offset
   *   in minutes is returned.
   * * If `input` is `null` or `undefined`, the default zone is returned.
   * @param {string|Zone|number} [input] - the value to be converted
   * @return {Zone}
   */
  static normalizeZone(t) {
    return normalizeZone(t, Settings.defaultZone);
  }
  /**
   * Get the weekday on which the week starts according to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
   */
  static getStartOfWeek({ locale: t = null, locObj: v = null } = {}) {
    return (v || Locale.create(t)).getStartOfWeek();
  }
  /**
   * Get the minimum number of days necessary in a week before it is considered part of the next year according
   * to the given locale.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number}
   */
  static getMinimumDaysInFirstWeek({ locale: t = null, locObj: v = null } = {}) {
    return (v || Locale.create(t)).getMinDaysInFirstWeek();
  }
  /**
   * Get the weekdays, which are considered the weekend according to the given locale
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
   */
  static getWeekendWeekdays({ locale: t = null, locObj: v = null } = {}) {
    return (v || Locale.create(t)).getWeekendDays().slice();
  }
  /**
   * Return an array of standalone month names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @example Info.months()[0] //=> 'January'
   * @example Info.months('short')[0] //=> 'Jan'
   * @example Info.months('numeric')[0] //=> '1'
   * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
   * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
   * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
   * @return {Array}
   */
  static months(t = "long", { locale: v = null, numberingSystem: w = null, locObj: T = null, outputCalendar: x = "gregory" } = {}) {
    return (T || Locale.create(v, w, x)).months(t);
  }
  /**
   * Return an array of format month names.
   * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
   * changes the string.
   * See {@link Info#months}
   * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @param {string} [opts.outputCalendar='gregory'] - the calendar
   * @return {Array}
   */
  static monthsFormat(t = "long", { locale: v = null, numberingSystem: w = null, locObj: T = null, outputCalendar: x = "gregory" } = {}) {
    return (T || Locale.create(v, w, x)).months(t, !0);
  }
  /**
   * Return an array of standalone week names.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @example Info.weekdays()[0] //=> 'Monday'
   * @example Info.weekdays('short')[0] //=> 'Mon'
   * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
   * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
   * @return {Array}
   */
  static weekdays(t = "long", { locale: v = null, numberingSystem: w = null, locObj: T = null } = {}) {
    return (T || Locale.create(v, w, null)).weekdays(t);
  }
  /**
   * Return an array of format week names.
   * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
   * changes the string.
   * See {@link Info#weekdays}
   * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale=null] - the locale code
   * @param {string} [opts.numberingSystem=null] - the numbering system
   * @param {string} [opts.locObj=null] - an existing locale object to use
   * @return {Array}
   */
  static weekdaysFormat(t = "long", { locale: v = null, numberingSystem: w = null, locObj: T = null } = {}) {
    return (T || Locale.create(v, w, null)).weekdays(t, !0);
  }
  /**
   * Return an array of meridiems.
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.meridiems() //=> [ 'AM', 'PM' ]
   * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
   * @return {Array}
   */
  static meridiems({ locale: t = null } = {}) {
    return Locale.create(t).meridiems();
  }
  /**
   * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
   * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
   * @param {Object} opts - options
   * @param {string} [opts.locale] - the locale code
   * @example Info.eras() //=> [ 'BC', 'AD' ]
   * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
   * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
   * @return {Array}
   */
  static eras(t = "short", { locale: v = null } = {}) {
    return Locale.create(v, null, "gregory").eras(t);
  }
  /**
   * Return the set of available features in this environment.
   * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
   * Keys:
   * * `relative`: whether this environment supports relative time formatting
   * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
   * @example Info.features() //=> { relative: false, localeWeek: true }
   * @return {Object}
   */
  static features() {
    return { relative: hasRelative(), localeWeek: hasLocaleWeekInfo() };
  }
}
function dayDiff(e, t) {
  const v = (T) => T.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), w = v(t) - v(e);
  return Math.floor(Duration.fromMillis(w).as("days"));
}
function highOrderDiffs(e, t, v) {
  const w = [
    ["years", (Y, L) => L.year - Y.year],
    ["quarters", (Y, L) => L.quarter - Y.quarter + (L.year - Y.year) * 4],
    ["months", (Y, L) => L.month - Y.month + (L.year - Y.year) * 12],
    [
      "weeks",
      (Y, L) => {
        const q = dayDiff(Y, L);
        return (q - q % 7) / 7;
      }
    ],
    ["days", dayDiff]
  ], T = {}, x = e;
  let C, D;
  for (const [Y, L] of w)
    v.indexOf(Y) >= 0 && (C = Y, T[Y] = L(e, t), D = x.plus(T), D > t ? (T[Y]--, e = x.plus(T), e > t && (D = e, T[Y]--, e = x.plus(T))) : e = D);
  return [e, T, D, C];
}
function diff(e, t, v, w) {
  let [T, x, C, D] = highOrderDiffs(e, t, v);
  const Y = t - T, L = v.filter(
    (N) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(N) >= 0
  );
  L.length === 0 && (C < t && (C = T.plus({ [D]: 1 })), C !== T && (x[D] = (x[D] || 0) + Y / (C - T)));
  const q = Duration.fromObject(x, w);
  return L.length > 0 ? Duration.fromMillis(Y, w).shiftTo(...L).plus(q) : q;
}
const MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(e, t = (v) => v) {
  return { regex: e, deser: ([v]) => t(parseDigits(v)) };
}
const NBSP = " ", spaceOrNBSP = `[ ${NBSP}]`, spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
function fixListRegex(e) {
  return e.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
}
function stripInsensitivities(e) {
  return e.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
}
function oneOf(e, t) {
  return e === null ? null : {
    regex: RegExp(e.map(fixListRegex).join("|")),
    deser: ([v]) => e.findIndex((w) => stripInsensitivities(v) === stripInsensitivities(w)) + t
  };
}
function offset(e, t) {
  return { regex: e, deser: ([, v, w]) => signedOffset(v, w), groups: t };
}
function simple(e) {
  return { regex: e, deser: ([t]) => t };
}
function escapeToken(e) {
  return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(e, t) {
  const v = digitRegex(t), w = digitRegex(t, "{2}"), T = digitRegex(t, "{3}"), x = digitRegex(t, "{4}"), C = digitRegex(t, "{6}"), D = digitRegex(t, "{1,2}"), Y = digitRegex(t, "{1,3}"), L = digitRegex(t, "{1,6}"), q = digitRegex(t, "{1,9}"), N = digitRegex(t, "{2,4}"), F = digitRegex(t, "{4,6}"), ae = (br) => ({ regex: RegExp(escapeToken(br.val)), deser: ([rt]) => rt, literal: !0 }), tt = ((br) => {
    if (e.literal)
      return ae(br);
    switch (br.val) {
      case "G":
        return oneOf(t.eras("short"), 0);
      case "GG":
        return oneOf(t.eras("long"), 0);
      case "y":
        return intUnit(L);
      case "yy":
        return intUnit(N, untruncateYear);
      case "yyyy":
        return intUnit(x);
      case "yyyyy":
        return intUnit(F);
      case "yyyyyy":
        return intUnit(C);
      case "M":
        return intUnit(D);
      case "MM":
        return intUnit(w);
      case "MMM":
        return oneOf(t.months("short", !0), 1);
      case "MMMM":
        return oneOf(t.months("long", !0), 1);
      case "L":
        return intUnit(D);
      case "LL":
        return intUnit(w);
      case "LLL":
        return oneOf(t.months("short", !1), 1);
      case "LLLL":
        return oneOf(t.months("long", !1), 1);
      case "d":
        return intUnit(D);
      case "dd":
        return intUnit(w);
      case "o":
        return intUnit(Y);
      case "ooo":
        return intUnit(T);
      case "HH":
        return intUnit(w);
      case "H":
        return intUnit(D);
      case "hh":
        return intUnit(w);
      case "h":
        return intUnit(D);
      case "mm":
        return intUnit(w);
      case "m":
        return intUnit(D);
      case "q":
        return intUnit(D);
      case "qq":
        return intUnit(w);
      case "s":
        return intUnit(D);
      case "ss":
        return intUnit(w);
      case "S":
        return intUnit(Y);
      case "SSS":
        return intUnit(T);
      case "u":
        return simple(q);
      case "uu":
        return simple(D);
      case "uuu":
        return intUnit(v);
      case "a":
        return oneOf(t.meridiems(), 0);
      case "kkkk":
        return intUnit(x);
      case "kk":
        return intUnit(N, untruncateYear);
      case "W":
        return intUnit(D);
      case "WW":
        return intUnit(w);
      case "E":
      case "c":
        return intUnit(v);
      case "EEE":
        return oneOf(t.weekdays("short", !1), 1);
      case "EEEE":
        return oneOf(t.weekdays("long", !1), 1);
      case "ccc":
        return oneOf(t.weekdays("short", !0), 1);
      case "cccc":
        return oneOf(t.weekdays("long", !0), 1);
      case "Z":
      case "ZZ":
        return offset(new RegExp(`([+-]${D.source})(?::(${w.source}))?`), 2);
      case "ZZZ":
        return offset(new RegExp(`([+-]${D.source})(${w.source})?`), 2);
      case "z":
        return simple(/[a-z_+-/]{1,256}?/i);
      case " ":
        return simple(/[^\S\n\r]/);
      default:
        return ae(br);
    }
  })(e) || {
    invalidReason: MISSING_FTP
  };
  return tt.token = e, tt;
}
const partTypeStyleToTokenVal = {
  year: {
    "2-digit": "yy",
    numeric: "yyyyy"
  },
  month: {
    numeric: "M",
    "2-digit": "MM",
    short: "MMM",
    long: "MMMM"
  },
  day: {
    numeric: "d",
    "2-digit": "dd"
  },
  weekday: {
    short: "EEE",
    long: "EEEE"
  },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: {
    numeric: "h",
    "2-digit": "hh"
  },
  hour24: {
    numeric: "H",
    "2-digit": "HH"
  },
  minute: {
    numeric: "m",
    "2-digit": "mm"
  },
  second: {
    numeric: "s",
    "2-digit": "ss"
  },
  timeZoneName: {
    long: "ZZZZZ",
    short: "ZZZ"
  }
};
function tokenForPart(e, t, v) {
  const { type: w, value: T } = e;
  if (w === "literal") {
    const Y = /^\s+$/.test(T);
    return {
      literal: !Y,
      val: Y ? " " : T
    };
  }
  const x = t[w];
  let C = w;
  w === "hour" && (t.hour12 != null ? C = t.hour12 ? "hour12" : "hour24" : t.hourCycle != null ? t.hourCycle === "h11" || t.hourCycle === "h12" ? C = "hour12" : C = "hour24" : C = v.hour12 ? "hour12" : "hour24");
  let D = partTypeStyleToTokenVal[C];
  if (typeof D == "object" && (D = D[x]), D)
    return {
      literal: !1,
      val: D
    };
}
function buildRegex(e) {
  return [`^${e.map((v) => v.regex).reduce((v, w) => `${v}(${w.source})`, "")}$`, e];
}
function match(e, t, v) {
  const w = e.match(t);
  if (w) {
    const T = {};
    let x = 1;
    for (const C in v)
      if (hasOwnProperty$1(v, C)) {
        const D = v[C], Y = D.groups ? D.groups + 1 : 1;
        !D.literal && D.token && (T[D.token.val[0]] = D.deser(w.slice(x, x + Y))), x += Y;
      }
    return [w, T];
  } else
    return [w, {}];
}
function dateTimeFromMatches(e) {
  const t = (x) => {
    switch (x) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let v = null, w;
  return isUndefined$1(e.z) || (v = IANAZone.create(e.z)), isUndefined$1(e.Z) || (v || (v = new FixedOffsetZone(e.Z)), w = e.Z), isUndefined$1(e.q) || (e.M = (e.q - 1) * 3 + 1), isUndefined$1(e.h) || (e.h < 12 && e.a === 1 ? e.h += 12 : e.h === 12 && e.a === 0 && (e.h = 0)), e.G === 0 && e.y && (e.y = -e.y), isUndefined$1(e.u) || (e.S = parseMillis(e.u)), [Object.keys(e).reduce((x, C) => {
    const D = t(C);
    return D && (x[D] = e[C]), x;
  }, {}), v, w];
}
let dummyDateTimeCache = null;
function getDummyDateTime() {
  return dummyDateTimeCache || (dummyDateTimeCache = DateTime.fromMillis(1555555555555)), dummyDateTimeCache;
}
function maybeExpandMacroToken(e, t) {
  if (e.literal)
    return e;
  const v = Formatter.macroTokenToFormatOpts(e.val), w = formatOptsToTokens(v, t);
  return w == null || w.includes(void 0) ? e : w;
}
function expandMacroTokens(e, t) {
  return Array.prototype.concat(...e.map((v) => maybeExpandMacroToken(v, t)));
}
class TokenParser {
  constructor(t, v) {
    if (this.locale = t, this.format = v, this.tokens = expandMacroTokens(Formatter.parseFormat(v), t), this.units = this.tokens.map((w) => unitForToken(w, t)), this.disqualifyingUnit = this.units.find((w) => w.invalidReason), !this.disqualifyingUnit) {
      const [w, T] = buildRegex(this.units);
      this.regex = RegExp(w, "i"), this.handlers = T;
    }
  }
  explainFromTokens(t) {
    if (this.isValid) {
      const [v, w] = match(t, this.regex, this.handlers), [T, x, C] = w ? dateTimeFromMatches(w) : [null, null, void 0];
      if (hasOwnProperty$1(w, "a") && hasOwnProperty$1(w, "H"))
        throw new ConflictingSpecificationError(
          "Can't include meridiem when specifying 24-hour format"
        );
      return {
        input: t,
        tokens: this.tokens,
        regex: this.regex,
        rawMatches: v,
        matches: w,
        result: T,
        zone: x,
        specificOffset: C
      };
    } else
      return { input: t, tokens: this.tokens, invalidReason: this.invalidReason };
  }
  get isValid() {
    return !this.disqualifyingUnit;
  }
  get invalidReason() {
    return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;
  }
}
function explainFromTokens(e, t, v) {
  return new TokenParser(e, v).explainFromTokens(t);
}
function parseFromTokens(e, t, v) {
  const { result: w, zone: T, specificOffset: x, invalidReason: C } = explainFromTokens(e, t, v);
  return [w, T, x, C];
}
function formatOptsToTokens(e, t) {
  if (!e)
    return null;
  const w = Formatter.create(t, e).dtFormatter(getDummyDateTime()), T = w.formatToParts(), x = w.resolvedOptions();
  return T.map((C) => tokenForPart(C, e, x));
}
const INVALID = "Invalid DateTime", MAX_DATE = 864e13;
function unsupportedZone(e) {
  return new Invalid("unsupported zone", `the zone "${e.name}" is not supported`);
}
function possiblyCachedWeekData(e) {
  return e.weekData === null && (e.weekData = gregorianToWeek(e.c)), e.weekData;
}
function possiblyCachedLocalWeekData(e) {
  return e.localWeekData === null && (e.localWeekData = gregorianToWeek(
    e.c,
    e.loc.getMinDaysInFirstWeek(),
    e.loc.getStartOfWeek()
  )), e.localWeekData;
}
function clone(e, t) {
  const v = {
    ts: e.ts,
    zone: e.zone,
    c: e.c,
    o: e.o,
    loc: e.loc,
    invalid: e.invalid
  };
  return new DateTime({ ...v, ...t, old: v });
}
function fixOffset(e, t, v) {
  let w = e - t * 60 * 1e3;
  const T = v.offset(w);
  if (t === T)
    return [w, t];
  w -= (T - t) * 60 * 1e3;
  const x = v.offset(w);
  return T === x ? [w, T] : [e - Math.min(T, x) * 60 * 1e3, Math.max(T, x)];
}
function tsToObj(e, t) {
  e += t * 60 * 1e3;
  const v = new Date(e);
  return {
    year: v.getUTCFullYear(),
    month: v.getUTCMonth() + 1,
    day: v.getUTCDate(),
    hour: v.getUTCHours(),
    minute: v.getUTCMinutes(),
    second: v.getUTCSeconds(),
    millisecond: v.getUTCMilliseconds()
  };
}
function objToTS(e, t, v) {
  return fixOffset(objToLocalTS(e), t, v);
}
function adjustTime(e, t) {
  const v = e.o, w = e.c.year + Math.trunc(t.years), T = e.c.month + Math.trunc(t.months) + Math.trunc(t.quarters) * 3, x = {
    ...e.c,
    year: w,
    month: T,
    day: Math.min(e.c.day, daysInMonth(w, T)) + Math.trunc(t.days) + Math.trunc(t.weeks) * 7
  }, C = Duration.fromObject({
    years: t.years - Math.trunc(t.years),
    quarters: t.quarters - Math.trunc(t.quarters),
    months: t.months - Math.trunc(t.months),
    weeks: t.weeks - Math.trunc(t.weeks),
    days: t.days - Math.trunc(t.days),
    hours: t.hours,
    minutes: t.minutes,
    seconds: t.seconds,
    milliseconds: t.milliseconds
  }).as("milliseconds"), D = objToLocalTS(x);
  let [Y, L] = fixOffset(D, v, e.zone);
  return C !== 0 && (Y += C, L = e.zone.offset(Y)), { ts: Y, o: L };
}
function parseDataToDateTime(e, t, v, w, T, x) {
  const { setZone: C, zone: D } = v;
  if (e && Object.keys(e).length !== 0 || t) {
    const Y = t || D, L = DateTime.fromObject(e, {
      ...v,
      zone: Y,
      specificOffset: x
    });
    return C ? L : L.setZone(D);
  } else
    return DateTime.invalid(
      new Invalid("unparsable", `the input "${T}" can't be parsed as ${w}`)
    );
}
function toTechFormat(e, t, v = !0) {
  return e.isValid ? Formatter.create(Locale.create("en-US"), {
    allowZ: v,
    forceSimple: !0
  }).formatDateTimeFromString(e, t) : null;
}
function toISODate(e, t) {
  const v = e.c.year > 9999 || e.c.year < 0;
  let w = "";
  return v && e.c.year >= 0 && (w += "+"), w += padStart(e.c.year, v ? 6 : 4), t ? (w += "-", w += padStart(e.c.month), w += "-", w += padStart(e.c.day)) : (w += padStart(e.c.month), w += padStart(e.c.day)), w;
}
function toISOTime(e, t, v, w, T, x) {
  let C = padStart(e.c.hour);
  return t ? (C += ":", C += padStart(e.c.minute), (e.c.millisecond !== 0 || e.c.second !== 0 || !v) && (C += ":")) : C += padStart(e.c.minute), (e.c.millisecond !== 0 || e.c.second !== 0 || !v) && (C += padStart(e.c.second), (e.c.millisecond !== 0 || !w) && (C += ".", C += padStart(e.c.millisecond, 3))), T && (e.isOffsetFixed && e.offset === 0 && !x ? C += "Z" : e.o < 0 ? (C += "-", C += padStart(Math.trunc(-e.o / 60)), C += ":", C += padStart(Math.trunc(-e.o % 60))) : (C += "+", C += padStart(Math.trunc(e.o / 60)), C += ":", C += padStart(Math.trunc(e.o % 60)))), x && (C += "[" + e.zone.ianaName + "]"), C;
}
const defaultUnitValues = {
  month: 1,
  day: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, defaultWeekUnitValues = {
  weekNumber: 1,
  weekday: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, defaultOrdinalUnitValues = {
  ordinal: 1,
  hour: 0,
  minute: 0,
  second: 0,
  millisecond: 0
}, orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"], orderedWeekUnits = [
  "weekYear",
  "weekNumber",
  "weekday",
  "hour",
  "minute",
  "second",
  "millisecond"
], orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(e) {
  const t = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal"
  }[e.toLowerCase()];
  if (!t) throw new InvalidUnitError(e);
  return t;
}
function normalizeUnitWithLocalWeeks(e) {
  switch (e.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return normalizeUnit(e);
  }
}
function guessOffsetForZone(e) {
  if (zoneOffsetTs === void 0 && (zoneOffsetTs = Settings.now()), e.type !== "iana")
    return e.offset(zoneOffsetTs);
  const t = e.name;
  let v = zoneOffsetGuessCache.get(t);
  return v === void 0 && (v = e.offset(zoneOffsetTs), zoneOffsetGuessCache.set(t, v)), v;
}
function quickDT(e, t) {
  const v = normalizeZone(t.zone, Settings.defaultZone);
  if (!v.isValid)
    return DateTime.invalid(unsupportedZone(v));
  const w = Locale.fromObject(t);
  let T, x;
  if (isUndefined$1(e.year))
    T = Settings.now();
  else {
    for (const Y of orderedUnits)
      isUndefined$1(e[Y]) && (e[Y] = defaultUnitValues[Y]);
    const C = hasInvalidGregorianData(e) || hasInvalidTimeData(e);
    if (C)
      return DateTime.invalid(C);
    const D = guessOffsetForZone(v);
    [T, x] = objToTS(e, D, v);
  }
  return new DateTime({ ts: T, zone: v, loc: w, o: x });
}
function diffRelative(e, t, v) {
  const w = isUndefined$1(v.round) ? !0 : v.round, T = (C, D) => (C = roundTo(C, w || v.calendary ? 0 : 2, !0), t.loc.clone(v).relFormatter(v).format(C, D)), x = (C) => v.calendary ? t.hasSame(e, C) ? 0 : t.startOf(C).diff(e.startOf(C), C).get(C) : t.diff(e, C).get(C);
  if (v.unit)
    return T(x(v.unit), v.unit);
  for (const C of v.units) {
    const D = x(C);
    if (Math.abs(D) >= 1)
      return T(D, C);
  }
  return T(e > t ? -0 : 0, v.units[v.units.length - 1]);
}
function lastOpts(e) {
  let t = {}, v;
  return e.length > 0 && typeof e[e.length - 1] == "object" ? (t = e[e.length - 1], v = Array.from(e).slice(0, e.length - 1)) : v = Array.from(e), [t, v];
}
let zoneOffsetTs;
const zoneOffsetGuessCache = /* @__PURE__ */ new Map();
class DateTime {
  /**
   * @access private
   */
  constructor(t) {
    const v = t.zone || Settings.defaultZone;
    let w = t.invalid || (Number.isNaN(t.ts) ? new Invalid("invalid input") : null) || (v.isValid ? null : unsupportedZone(v));
    this.ts = isUndefined$1(t.ts) ? Settings.now() : t.ts;
    let T = null, x = null;
    if (!w)
      if (t.old && t.old.ts === this.ts && t.old.zone.equals(v))
        [T, x] = [t.old.c, t.old.o];
      else {
        const D = isNumber$1(t.o) && !t.old ? t.o : v.offset(this.ts);
        T = tsToObj(this.ts, D), w = Number.isNaN(T.year) ? new Invalid("invalid input") : null, T = w ? null : T, x = w ? null : D;
      }
    this._zone = v, this.loc = t.loc || Locale.create(), this.invalid = w, this.weekData = null, this.localWeekData = null, this.c = T, this.o = x, this.isLuxonDateTime = !0;
  }
  // CONSTRUCT
  /**
   * Create a DateTime for the current instant, in the system's time zone.
   *
   * Use Settings to override these default values if needed.
   * @example DateTime.now().toISO() //~> now in the ISO format
   * @return {DateTime}
   */
  static now() {
    return new DateTime({});
  }
  /**
   * Create a local DateTime
   * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month, 1-indexed
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @example DateTime.local()                                  //~> now
   * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
   * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
   * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
   * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
   * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
   * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
   * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
   * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
   * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
   * @return {DateTime}
   */
  static local() {
    const [t, v] = lastOpts(arguments), [w, T, x, C, D, Y, L] = v;
    return quickDT({ year: w, month: T, day: x, hour: C, minute: D, second: Y, millisecond: L }, t);
  }
  /**
   * Create a DateTime in UTC
   * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
   * @param {number} [month=1] - The month, 1-indexed
   * @param {number} [day=1] - The day of the month
   * @param {number} [hour=0] - The hour of the day, in 24-hour time
   * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
   * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
   * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
   * @param {Object} options - configuration options for the DateTime
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @param {string} [options.weekSettings] - the week settings to set on the resulting DateTime instance
   * @example DateTime.utc()                                              //~> now
   * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
   * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
   * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
   * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
   * @return {DateTime}
   */
  static utc() {
    const [t, v] = lastOpts(arguments), [w, T, x, C, D, Y, L] = v;
    return t.zone = FixedOffsetZone.utcInstance, quickDT({ year: w, month: T, day: x, hour: C, minute: D, second: Y, millisecond: L }, t);
  }
  /**
   * Create a DateTime from a JavaScript Date object. Uses the default zone.
   * @param {Date} date - a JavaScript Date object
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @return {DateTime}
   */
  static fromJSDate(t, v = {}) {
    const w = isDate$1(t) ? t.valueOf() : NaN;
    if (Number.isNaN(w))
      return DateTime.invalid("invalid input");
    const T = normalizeZone(v.zone, Settings.defaultZone);
    return T.isValid ? new DateTime({
      ts: w,
      zone: T,
      loc: Locale.fromObject(v)
    }) : DateTime.invalid(unsupportedZone(T));
  }
  /**
   * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} milliseconds - a number of milliseconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromMillis(t, v = {}) {
    if (isNumber$1(t))
      return t < -MAX_DATE || t > MAX_DATE ? DateTime.invalid("Timestamp out of range") : new DateTime({
        ts: t,
        zone: normalizeZone(v.zone, Settings.defaultZone),
        loc: Locale.fromObject(v)
      });
    throw new InvalidArgumentError(
      `fromMillis requires a numerical input, but received a ${typeof t} with value ${t}`
    );
  }
  /**
   * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
   * @param {number} seconds - a number of seconds since 1970 UTC
   * @param {Object} options - configuration options for the DateTime
   * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
   * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
   * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromSeconds(t, v = {}) {
    if (isNumber$1(t))
      return new DateTime({
        ts: t * 1e3,
        zone: normalizeZone(v.zone, Settings.defaultZone),
        loc: Locale.fromObject(v)
      });
    throw new InvalidArgumentError("fromSeconds requires a numerical input");
  }
  /**
   * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.year - a year, such as 1987
   * @param {number} obj.month - a month, 1-12
   * @param {number} obj.day - a day of the month, 1-31, depending on the month
   * @param {number} obj.ordinal - day of the year, 1-365 or 366
   * @param {number} obj.weekYear - an ISO week year
   * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
   * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
   * @param {number} obj.localWeekYear - a week year, according to the locale
   * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
   * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
   * @param {number} obj.hour - hour of the day, 0-23
   * @param {number} obj.minute - minute of the hour, 0-59
   * @param {number} obj.second - second of the minute, 0-59
   * @param {number} obj.millisecond - millisecond of the second, 0-999
   * @param {Object} opts - options for creating this DateTime
   * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
   * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
   * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
   * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
   * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
   * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
   * @return {DateTime}
   */
  static fromObject(t, v = {}) {
    t = t || {};
    const w = normalizeZone(v.zone, Settings.defaultZone);
    if (!w.isValid)
      return DateTime.invalid(unsupportedZone(w));
    const T = Locale.fromObject(v), x = normalizeObject(t, normalizeUnitWithLocalWeeks), { minDaysInFirstWeek: C, startOfWeek: D } = usesLocalWeekValues(x, T), Y = Settings.now(), L = isUndefined$1(v.specificOffset) ? w.offset(Y) : v.specificOffset, q = !isUndefined$1(x.ordinal), N = !isUndefined$1(x.year), F = !isUndefined$1(x.month) || !isUndefined$1(x.day), ae = N || F, he = x.weekYear || x.weekNumber;
    if ((ae || q) && he)
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (F && q)
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    const tt = he || x.weekday && !ae;
    let br, rt, dr = tsToObj(Y, L);
    tt ? (br = orderedWeekUnits, rt = defaultWeekUnitValues, dr = gregorianToWeek(dr, C, D)) : q ? (br = orderedOrdinalUnits, rt = defaultOrdinalUnitValues, dr = gregorianToOrdinal(dr)) : (br = orderedUnits, rt = defaultUnitValues);
    let _r = !1;
    for (const Hi of br) {
      const pr = x[Hi];
      isUndefined$1(pr) ? _r ? x[Hi] = rt[Hi] : x[Hi] = dr[Hi] : _r = !0;
    }
    const Bi = tt ? hasInvalidWeekData(x, C, D) : q ? hasInvalidOrdinalData(x) : hasInvalidGregorianData(x), qi = Bi || hasInvalidTimeData(x);
    if (qi)
      return DateTime.invalid(qi);
    const Wi = tt ? weekToGregorian(x, C, D) : q ? ordinalToGregorian(x) : x, [Vi, Ti] = objToTS(Wi, L, w), Li = new DateTime({
      ts: Vi,
      zone: w,
      o: Ti,
      loc: T
    });
    return x.weekday && ae && t.weekday !== Li.weekday ? DateTime.invalid(
      "mismatched weekday",
      `you can't specify both a weekday of ${x.weekday} and a date of ${Li.toISO()}`
    ) : Li.isValid ? Li : DateTime.invalid(Li.invalid);
  }
  /**
   * Create a DateTime from an ISO 8601 string
   * @param {string} text - the ISO string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
   * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
   * @param {string} [opts.weekSettings] - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromISO('2016-05-25T09:08:34.123')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
   * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
   * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
   * @example DateTime.fromISO('2016-W05-4')
   * @return {DateTime}
   */
  static fromISO(t, v = {}) {
    const [w, T] = parseISODate(t);
    return parseDataToDateTime(w, T, v, "ISO 8601", t);
  }
  /**
   * Create a DateTime from an RFC 2822 string
   * @param {string} text - the RFC 2822 string
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
   * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
   * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
   * @return {DateTime}
   */
  static fromRFC2822(t, v = {}) {
    const [w, T] = parseRFC2822Date(t);
    return parseDataToDateTime(w, T, v, "RFC 2822", t);
  }
  /**
   * Create a DateTime from an HTTP header date
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @param {string} text - the HTTP header date
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
   * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
   * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
   * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
   * @return {DateTime}
   */
  static fromHTTP(t, v = {}) {
    const [w, T] = parseHTTPDate(t);
    return parseDataToDateTime(w, T, v, "HTTP", v);
  }
  /**
   * Create a DateTime from an input string and format string.
   * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @return {DateTime}
   */
  static fromFormat(t, v, w = {}) {
    if (isUndefined$1(t) || isUndefined$1(v))
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    const { locale: T = null, numberingSystem: x = null } = w, C = Locale.fromOpts({
      locale: T,
      numberingSystem: x,
      defaultToEN: !0
    }), [D, Y, L, q] = parseFromTokens(C, t, v);
    return q ? DateTime.invalid(q) : parseDataToDateTime(D, Y, w, `format ${v}`, t, L);
  }
  /**
   * @deprecated use fromFormat instead
   */
  static fromString(t, v, w = {}) {
    return DateTime.fromFormat(t, v, w);
  }
  /**
   * Create a DateTime from a SQL date, time, or datetime
   * Defaults to en-US if no locale has been specified, regardless of the system's locale
   * @param {string} text - the string to parse
   * @param {Object} opts - options to affect the creation
   * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
   * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
   * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
   * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
   * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
   * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
   * @example DateTime.fromSQL('2017-05-15')
   * @example DateTime.fromSQL('2017-05-15 09:12:34')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
   * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
   * @example DateTime.fromSQL('09:12:34.342')
   * @return {DateTime}
   */
  static fromSQL(t, v = {}) {
    const [w, T] = parseSQL(t);
    return parseDataToDateTime(w, T, v, "SQL", t);
  }
  /**
   * Create an invalid DateTime.
   * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {DateTime}
   */
  static invalid(t, v = null) {
    if (!t)
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    const w = t instanceof Invalid ? t : new Invalid(t, v);
    if (Settings.throwOnInvalid)
      throw new InvalidDateTimeError(w);
    return new DateTime({ invalid: w });
  }
  /**
   * Check if an object is an instance of DateTime. Works across context boundaries
   * @param {object} o
   * @return {boolean}
   */
  static isDateTime(t) {
    return t && t.isLuxonDateTime || !1;
  }
  /**
   * Produce the format string for a set of options
   * @param formatOpts
   * @param localeOpts
   * @returns {string}
   */
  static parseFormatForOpts(t, v = {}) {
    const w = formatOptsToTokens(t, Locale.fromObject(v));
    return w ? w.map((T) => T ? T.val : null).join("") : null;
  }
  /**
   * Produce the the fully expanded format token for the locale
   * Does NOT quote characters, so quoted tokens will not round trip correctly
   * @param fmt
   * @param localeOpts
   * @returns {string}
   */
  static expandFormat(t, v = {}) {
    return expandMacroTokens(Formatter.parseFormat(t), Locale.fromObject(v)).map((T) => T.val).join("");
  }
  static resetCache() {
    zoneOffsetTs = void 0, zoneOffsetGuessCache.clear();
  }
  // INFO
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
   * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
   * @return {number}
   */
  get(t) {
    return this[t];
  }
  /**
   * Returns whether the DateTime is valid. Invalid DateTimes occur when:
   * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
   * * The DateTime was created by an operation on another invalid date
   * @type {boolean}
   */
  get isValid() {
    return this.invalid === null;
  }
  /**
   * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  /**
   * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  /**
   * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
   *
   * @type {string}
   */
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  /**
   * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
   *
   * @type {string}
   */
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  /**
   * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
   *
   * @type {string}
   */
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  /**
   * Get the time zone associated with this DateTime.
   * @type {Zone}
   */
  get zone() {
    return this._zone;
  }
  /**
   * Get the name of the time zone.
   * @type {string}
   */
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  /**
   * Get the year
   * @example DateTime.local(2017, 5, 25).year //=> 2017
   * @type {number}
   */
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  /**
   * Get the quarter
   * @example DateTime.local(2017, 5, 25).quarter //=> 2
   * @type {number}
   */
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  /**
   * Get the month (1-12).
   * @example DateTime.local(2017, 5, 25).month //=> 5
   * @type {number}
   */
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  /**
   * Get the day of the month (1-30ish).
   * @example DateTime.local(2017, 5, 25).day //=> 25
   * @type {number}
   */
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  /**
   * Get the hour of the day (0-23).
   * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
   * @type {number}
   */
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  /**
   * Get the minute of the hour (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
   * @type {number}
   */
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  /**
   * Get the second of the minute (0-59).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
   * @type {number}
   */
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  /**
   * Get the millisecond of the second (0-999).
   * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
   * @type {number}
   */
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  /**
   * Get the week year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
   * @type {number}
   */
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  /**
   * Get the week number of the week year (1-52ish).
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
   * @type {number}
   */
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the day of the week.
   * 1 is Monday and 7 is Sunday
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2014, 11, 31).weekday //=> 4
   * @type {number}
   */
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  /**
   * Returns true if this date is on a weekend according to the locale, false otherwise
   * @returns {boolean}
   */
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  /**
   * Get the day of the week according to the locale.
   * 1 is the first day of the week and 7 is the last day of the week.
   * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
   * @returns {number}
   */
  get localWeekday() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
  }
  /**
   * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
   * because the week can start on different days of the week (see localWeekday) and because a different number of days
   * is required for a week to count as the first week of a year.
   * @returns {number}
   */
  get localWeekNumber() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
  }
  /**
   * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
   * differently, see localWeekNumber.
   * @returns {number}
   */
  get localWeekYear() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
  }
  /**
   * Get the ordinal (meaning the day of the year)
   * @example DateTime.local(2017, 5, 25).ordinal //=> 145
   * @type {number|DateTime}
   */
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  /**
   * Get the human readable short month name, such as 'Oct'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
   * @type {string}
   */
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable long month name, such as 'October'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).monthLong //=> October
   * @type {string}
   */
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  /**
   * Get the human readable short weekday, such as 'Mon'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
   * @type {string}
   */
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the human readable long weekday, such as 'Monday'.
   * Defaults to the system's locale if no locale has been specified
   * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
   * @type {string}
   */
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  /**
   * Get the UTC offset of this DateTime in minutes
   * @example DateTime.now().offset //=> -240
   * @example DateTime.utc().offset //=> 0
   * @type {number}
   */
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  /**
   * Get the short human name for the zone's current offset, for example "EST" or "EDT".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameShort() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "short",
      locale: this.locale
    }) : null;
  }
  /**
   * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
   * Defaults to the system's locale if no locale has been specified
   * @type {string}
   */
  get offsetNameLong() {
    return this.isValid ? this.zone.offsetName(this.ts, {
      format: "long",
      locale: this.locale
    }) : null;
  }
  /**
   * Get whether this zone's offset ever changes, as in a DST.
   * @type {boolean}
   */
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  /**
   * Get whether the DateTime is in a DST.
   * @type {boolean}
   */
  get isInDST() {
    return this.isOffsetFixed ? !1 : this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
  }
  /**
   * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
   * in this DateTime's zone. During DST changes local time can be ambiguous, for example
   * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
   * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
   * @returns {DateTime[]}
   */
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed)
      return [this];
    const t = 864e5, v = 6e4, w = objToLocalTS(this.c), T = this.zone.offset(w - t), x = this.zone.offset(w + t), C = this.zone.offset(w - T * v), D = this.zone.offset(w - x * v);
    if (C === D)
      return [this];
    const Y = w - C * v, L = w - D * v, q = tsToObj(Y, C), N = tsToObj(L, D);
    return q.hour === N.hour && q.minute === N.minute && q.second === N.second && q.millisecond === N.millisecond ? [clone(this, { ts: Y }), clone(this, { ts: L })] : [this];
  }
  /**
   * Returns true if this DateTime is in a leap year, false otherwise
   * @example DateTime.local(2016).isInLeapYear //=> true
   * @example DateTime.local(2013).isInLeapYear //=> false
   * @type {boolean}
   */
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  /**
   * Returns the number of days in this DateTime's month
   * @example DateTime.local(2016, 2).daysInMonth //=> 29
   * @example DateTime.local(2016, 3).daysInMonth //=> 31
   * @type {number}
   */
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  /**
   * Returns the number of days in this DateTime's year
   * @example DateTime.local(2016).daysInYear //=> 366
   * @example DateTime.local(2013).daysInYear //=> 365
   * @type {number}
   */
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's year
   * @see https://en.wikipedia.org/wiki/ISO_week_date
   * @example DateTime.local(2004).weeksInWeekYear //=> 53
   * @example DateTime.local(2013).weeksInWeekYear //=> 52
   * @type {number}
   */
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  /**
   * Returns the number of weeks in this DateTime's local week year
   * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
   * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
   * @type {number}
   */
  get weeksInLocalWeekYear() {
    return this.isValid ? weeksInWeekYear(
      this.localWeekYear,
      this.loc.getMinDaysInFirstWeek(),
      this.loc.getStartOfWeek()
    ) : NaN;
  }
  /**
   * Returns the resolved Intl options for this DateTime.
   * This is useful in understanding the behavior of formatting methods
   * @param {Object} opts - the same options as toLocaleString
   * @return {Object}
   */
  resolvedLocaleOptions(t = {}) {
    const { locale: v, numberingSystem: w, calendar: T } = Formatter.create(
      this.loc.clone(t),
      t
    ).resolvedOptions(this);
    return { locale: v, numberingSystem: w, outputCalendar: T };
  }
  // TRANSFORM
  /**
   * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
   *
   * Equivalent to {@link DateTime#setZone}('utc')
   * @param {number} [offset=0] - optionally, an offset from UTC in minutes
   * @param {Object} [opts={}] - options to pass to `setZone()`
   * @return {DateTime}
   */
  toUTC(t = 0, v = {}) {
    return this.setZone(FixedOffsetZone.instance(t), v);
  }
  /**
   * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
   *
   * Equivalent to `setZone('local')`
   * @return {DateTime}
   */
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  /**
   * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
   *
   * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
   * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
   * @param {Object} opts - options
   * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
   * @return {DateTime}
   */
  setZone(t, { keepLocalTime: v = !1, keepCalendarTime: w = !1 } = {}) {
    if (t = normalizeZone(t, Settings.defaultZone), t.equals(this.zone))
      return this;
    if (t.isValid) {
      let T = this.ts;
      if (v || w) {
        const x = t.offset(this.ts), C = this.toObject();
        [T] = objToTS(C, x, t);
      }
      return clone(this, { ts: T, zone: t });
    } else
      return DateTime.invalid(unsupportedZone(t));
  }
  /**
   * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
   * @param {Object} properties - the properties to set
   * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
   * @return {DateTime}
   */
  reconfigure({ locale: t, numberingSystem: v, outputCalendar: w } = {}) {
    const T = this.loc.clone({ locale: t, numberingSystem: v, outputCalendar: w });
    return clone(this, { loc: T });
  }
  /**
   * "Set" the locale. Returns a newly-constructed DateTime.
   * Just a convenient alias for reconfigure({ locale })
   * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
   * @return {DateTime}
   */
  setLocale(t) {
    return this.reconfigure({ locale: t });
  }
  /**
   * "Set" the values of specified units. Returns a newly-constructed DateTime.
   * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
   *
   * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
   * They cannot be mixed with ISO-week units like `weekday`.
   * @param {Object} values - a mapping of units to numbers
   * @example dt.set({ year: 2017 })
   * @example dt.set({ hour: 8, minute: 30 })
   * @example dt.set({ weekday: 5 })
   * @example dt.set({ year: 2005, ordinal: 234 })
   * @return {DateTime}
   */
  set(t) {
    if (!this.isValid) return this;
    const v = normalizeObject(t, normalizeUnitWithLocalWeeks), { minDaysInFirstWeek: w, startOfWeek: T } = usesLocalWeekValues(v, this.loc), x = !isUndefined$1(v.weekYear) || !isUndefined$1(v.weekNumber) || !isUndefined$1(v.weekday), C = !isUndefined$1(v.ordinal), D = !isUndefined$1(v.year), Y = !isUndefined$1(v.month) || !isUndefined$1(v.day), L = D || Y, q = v.weekYear || v.weekNumber;
    if ((L || C) && q)
      throw new ConflictingSpecificationError(
        "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
      );
    if (Y && C)
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    let N;
    x ? N = weekToGregorian(
      { ...gregorianToWeek(this.c, w, T), ...v },
      w,
      T
    ) : isUndefined$1(v.ordinal) ? (N = { ...this.toObject(), ...v }, isUndefined$1(v.day) && (N.day = Math.min(daysInMonth(N.year, N.month), N.day))) : N = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...v });
    const [F, ae] = objToTS(N, this.o, this.zone);
    return clone(this, { ts: F, o: ae });
  }
  /**
   * Add a period of time to this DateTime and return the resulting DateTime
   *
   * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
   * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   * @example DateTime.now().plus(123) //~> in 123 milliseconds
   * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
   * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
   * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
   * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
   * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
   * @return {DateTime}
   */
  plus(t) {
    if (!this.isValid) return this;
    const v = Duration.fromDurationLike(t);
    return clone(this, adjustTime(this, v));
  }
  /**
   * Subtract a period of time to this DateTime and return the resulting DateTime
   * See {@link DateTime#plus}
   * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
   @return {DateTime}
   */
  minus(t) {
    if (!this.isValid) return this;
    const v = Duration.fromDurationLike(t).negate();
    return clone(this, adjustTime(this, v));
  }
  /**
   * "Set" this DateTime to the beginning of a unit of time.
   * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
   * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
   * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
   * @return {DateTime}
   */
  startOf(t, { useLocaleWeeks: v = !1 } = {}) {
    if (!this.isValid) return this;
    const w = {}, T = Duration.normalizeUnit(t);
    switch (T) {
      case "years":
        w.month = 1;
      case "quarters":
      case "months":
        w.day = 1;
      case "weeks":
      case "days":
        w.hour = 0;
      case "hours":
        w.minute = 0;
      case "minutes":
        w.second = 0;
      case "seconds":
        w.millisecond = 0;
        break;
    }
    if (T === "weeks")
      if (v) {
        const x = this.loc.getStartOfWeek(), { weekday: C } = this;
        C < x && (w.weekNumber = this.weekNumber - 1), w.weekday = x;
      } else
        w.weekday = 1;
    if (T === "quarters") {
      const x = Math.ceil(this.month / 3);
      w.month = (x - 1) * 3 + 1;
    }
    return this.set(w);
  }
  /**
   * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
   * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
   * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
   * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
   * @return {DateTime}
   */
  endOf(t, v) {
    return this.isValid ? this.plus({ [t]: 1 }).startOf(t, v).minus(1) : this;
  }
  // OUTPUT
  /**
   * Returns a string representation of this DateTime formatted according to the specified format string.
   * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
   * Defaults to en-US if no locale has been specified, regardless of the system's locale.
   * @param {string} fmt - the format string
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
   * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
   * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
   * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
   * @return {string}
   */
  toFormat(t, v = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(v)).formatDateTimeFromString(this, t) : INVALID;
  }
  /**
   * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
   * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
   * of the DateTime in the assigned locale.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
   * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
   * @param {Object} opts - opts to override the configuration options on this DateTime
   * @example DateTime.now().toLocaleString(); //=> 4/20/2017
   * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
   * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
   * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
   * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
   * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
   * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
   * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
   * @return {string}
   */
  toLocaleString(t = DATE_SHORT, v = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(v), t).formatDateTime(this) : INVALID;
  }
  /**
   * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
   * Defaults to the system's locale if no locale has been specified
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
   * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
   * @example DateTime.now().toLocaleParts(); //=> [
   *                                   //=>   { type: 'day', value: '25' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'month', value: '05' },
   *                                   //=>   { type: 'literal', value: '/' },
   *                                   //=>   { type: 'year', value: '1982' }
   *                                   //=> ]
   */
  toLocaleParts(t = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(t), t).formatDateTimeParts(this) : [];
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
   * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
   * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
   * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
   * @return {string|null}
   */
  toISO({
    format: t = "extended",
    suppressSeconds: v = !1,
    suppressMilliseconds: w = !1,
    includeOffset: T = !0,
    extendedZone: x = !1
  } = {}) {
    if (!this.isValid)
      return null;
    const C = t === "extended";
    let D = toISODate(this, C);
    return D += "T", D += toISOTime(this, C, v, w, T, x), D;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's date component
   * @param {Object} opts - options
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
   * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
   * @return {string|null}
   */
  toISODate({ format: t = "extended" } = {}) {
    return this.isValid ? toISODate(this, t === "extended") : null;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's week date
   * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
   * @return {string}
   */
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  /**
   * Returns an ISO 8601-compliant string representation of this DateTime's time component
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
   * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
   * @return {string}
   */
  toISOTime({
    suppressMilliseconds: t = !1,
    suppressSeconds: v = !1,
    includeOffset: w = !0,
    includePrefix: T = !1,
    extendedZone: x = !1,
    format: C = "extended"
  } = {}) {
    return this.isValid ? (T ? "T" : "") + toISOTime(
      this,
      C === "extended",
      v,
      t,
      w,
      x
    ) : null;
  }
  /**
   * Returns an RFC 2822-compatible string representation of this DateTime
   * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
   * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
   * @return {string}
   */
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
   * Specifically, the string conforms to RFC 1123.
   * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
   * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
   * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
   * @return {string}
   */
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Date
   * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
   * @return {string|null}
   */
  toSQLDate() {
    return this.isValid ? toISODate(this, !0) : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL Time
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc().toSQL() //=> '05:15:16.345'
   * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
   * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
   * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
   * @return {string}
   */
  toSQLTime({ includeOffset: t = !0, includeZone: v = !1, includeOffsetSpace: w = !0 } = {}) {
    let T = "HH:mm:ss.SSS";
    return (v || t) && (w && (T += " "), v ? T += "z" : t && (T += "ZZ")), toTechFormat(this, T, !0);
  }
  /**
   * Returns a string representation of this DateTime appropriate for use in SQL DateTime
   * @param {Object} opts - options
   * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
   * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
   * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
   * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
   * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
   * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
   * @return {string}
   */
  toSQL(t = {}) {
    return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(t)}` : null;
  }
  /**
   * Returns a string representation of this DateTime appropriate for debugging
   * @return {string}
   */
  toString() {
    return this.isValid ? this.toISO() : INVALID;
  }
  /**
   * Returns a string representation of this DateTime appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.isValid ? `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }` : `DateTime { Invalid, reason: ${this.invalidReason} }`;
  }
  /**
   * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * Returns the epoch milliseconds of this DateTime.
   * @return {number}
   */
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  /**
   * Returns the epoch seconds (including milliseconds in the fractional part) of this DateTime.
   * @return {number}
   */
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  /**
   * Returns the epoch seconds (as a whole number) of this DateTime.
   * @return {number}
   */
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  /**
   * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns a BSON serializable equivalent to this DateTime.
   * @return {Date}
   */
  toBSON() {
    return this.toJSDate();
  }
  /**
   * Returns a JavaScript object with this DateTime's year, month, day, and so on.
   * @param opts - options for generating the object
   * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
   * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
   * @return {Object}
   */
  toObject(t = {}) {
    if (!this.isValid) return {};
    const v = { ...this.c };
    return t.includeConfig && (v.outputCalendar = this.outputCalendar, v.numberingSystem = this.loc.numberingSystem, v.locale = this.loc.locale), v;
  }
  /**
   * Returns a JavaScript Date equivalent to this DateTime.
   * @return {Date}
   */
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  // COMPARE
  /**
   * Return the difference between two DateTimes as a Duration.
   * @param {DateTime} otherDateTime - the DateTime to compare this one to
   * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @example
   * var i1 = DateTime.fromISO('1982-05-25T09:45'),
   *     i2 = DateTime.fromISO('1983-10-14T10:30');
   * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
   * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
   * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
   * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
   * @return {Duration}
   */
  diff(t, v = "milliseconds", w = {}) {
    if (!this.isValid || !t.isValid)
      return Duration.invalid("created by diffing an invalid DateTime");
    const T = { locale: this.locale, numberingSystem: this.numberingSystem, ...w }, x = maybeArray(v).map(Duration.normalizeUnit), C = t.valueOf() > this.valueOf(), D = C ? this : t, Y = C ? t : this, L = diff(D, Y, x, T);
    return C ? L.negate() : L;
  }
  /**
   * Return the difference between this DateTime and right now.
   * See {@link DateTime#diff}
   * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
   * @param {Object} opts - options that affect the creation of the Duration
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  diffNow(t = "milliseconds", v = {}) {
    return this.diff(DateTime.now(), t, v);
  }
  /**
   * Return an Interval spanning between this DateTime and another DateTime
   * @param {DateTime} otherDateTime - the other end point of the Interval
   * @return {Interval|DateTime}
   */
  until(t) {
    return this.isValid ? Interval.fromDateTimes(this, t) : this;
  }
  /**
   * Return whether this DateTime is in the same unit of time as another DateTime.
   * Higher-order units must also be identical for this function to return `true`.
   * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
   * @param {DateTime} otherDateTime - the other DateTime
   * @param {string} unit - the unit of time to check sameness on
   * @param {Object} opts - options
   * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
   * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
   * @return {boolean}
   */
  hasSame(t, v, w) {
    if (!this.isValid) return !1;
    const T = t.valueOf(), x = this.setZone(t.zone, { keepLocalTime: !0 });
    return x.startOf(v, w) <= T && T <= x.endOf(v, w);
  }
  /**
   * Equality check
   * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
   * To compare just the millisecond values, use `+dt1 === +dt2`.
   * @param {DateTime} other - the other DateTime
   * @return {boolean}
   */
  equals(t) {
    return this.isValid && t.isValid && this.valueOf() === t.valueOf() && this.zone.equals(t.zone) && this.loc.equals(t.loc);
  }
  /**
   * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
   * platform supports Intl.RelativeTimeFormat. Rounds down by default.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
   * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
   * @param {boolean} [options.round=true] - whether to round the numbers in the output.
   * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
   * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
   * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
   * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
   * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
   * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
   */
  toRelative(t = {}) {
    if (!this.isValid) return null;
    const v = t.base || DateTime.fromObject({}, { zone: this.zone }), w = t.padding ? this < v ? -t.padding : t.padding : 0;
    let T = ["years", "months", "days", "hours", "minutes", "seconds"], x = t.unit;
    return Array.isArray(t.unit) && (T = t.unit, x = void 0), diffRelative(v, this.plus(w), {
      ...t,
      numeric: "always",
      units: T,
      unit: x
    });
  }
  /**
   * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
   * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
   * @param {Object} options - options that affect the output
   * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
   * @param {string} options.locale - override the locale of this DateTime
   * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
   * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
   * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
   * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
   * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
   */
  toRelativeCalendar(t = {}) {
    return this.isValid ? diffRelative(t.base || DateTime.fromObject({}, { zone: this.zone }), this, {
      ...t,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: !0
    }) : null;
  }
  /**
   * Return the min of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
   * @return {DateTime} the min DateTime, or undefined if called with no argument
   */
  static min(...t) {
    if (!t.every(DateTime.isDateTime))
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    return bestBy(t, (v) => v.valueOf(), Math.min);
  }
  /**
   * Return the max of several date times
   * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
   * @return {DateTime} the max DateTime, or undefined if called with no argument
   */
  static max(...t) {
    if (!t.every(DateTime.isDateTime))
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    return bestBy(t, (v) => v.valueOf(), Math.max);
  }
  // MISC
  /**
   * Explain how a string would be parsed by fromFormat()
   * @param {string} text - the string to parse
   * @param {string} fmt - the format the string is expected to be in (see description)
   * @param {Object} options - options taken by fromFormat()
   * @return {Object}
   */
  static fromFormatExplain(t, v, w = {}) {
    const { locale: T = null, numberingSystem: x = null } = w, C = Locale.fromOpts({
      locale: T,
      numberingSystem: x,
      defaultToEN: !0
    });
    return explainFromTokens(C, t, v);
  }
  /**
   * @deprecated use fromFormatExplain instead
   */
  static fromStringExplain(t, v, w = {}) {
    return DateTime.fromFormatExplain(t, v, w);
  }
  /**
   * Build a parser for `fmt` using the given locale. This parser can be passed
   * to {@link DateTime.fromFormatParser} to a parse a date in this format. This
   * can be used to optimize cases where many dates need to be parsed in a
   * specific format.
   *
   * @param {String} fmt - the format the string is expected to be in (see
   * description)
   * @param {Object} options - options used to set locale and numberingSystem
   * for parser
   * @returns {TokenParser} - opaque object to be used
   */
  static buildFormatParser(t, v = {}) {
    const { locale: w = null, numberingSystem: T = null } = v, x = Locale.fromOpts({
      locale: w,
      numberingSystem: T,
      defaultToEN: !0
    });
    return new TokenParser(x, t);
  }
  /**
   * Create a DateTime from an input string and format parser.
   *
   * The format parser must have been created with the same locale as this call.
   *
   * @param {String} text - the string to parse
   * @param {TokenParser} formatParser - parser from {@link DateTime.buildFormatParser}
   * @param {Object} opts - options taken by fromFormat()
   * @returns {DateTime}
   */
  static fromFormatParser(t, v, w = {}) {
    if (isUndefined$1(t) || isUndefined$1(v))
      throw new InvalidArgumentError(
        "fromFormatParser requires an input string and a format parser"
      );
    const { locale: T = null, numberingSystem: x = null } = w, C = Locale.fromOpts({
      locale: T,
      numberingSystem: x,
      defaultToEN: !0
    });
    if (!C.equals(v.locale))
      throw new InvalidArgumentError(
        `fromFormatParser called with a locale of ${C}, but the format parser was created for ${v.locale}`
      );
    const { result: D, zone: Y, specificOffset: L, invalidReason: q } = v.explainFromTokens(t);
    return q ? DateTime.invalid(q) : parseDataToDateTime(
      D,
      Y,
      w,
      `format ${v.format}`,
      t,
      L
    );
  }
  // FORMAT PRESETS
  /**
   * {@link DateTime#toLocaleString} format like 10/14/1983
   * @type {Object}
   */
  static get DATE_SHORT() {
    return DATE_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED() {
    return DATE_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
   * @type {Object}
   */
  static get DATE_MED_WITH_WEEKDAY() {
    return DATE_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983'
   * @type {Object}
   */
  static get DATE_FULL() {
    return DATE_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
   * @type {Object}
   */
  static get DATE_HUGE() {
    return DATE_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_SIMPLE() {
    return TIME_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SECONDS() {
    return TIME_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_SHORT_OFFSET() {
    return TIME_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get TIME_WITH_LONG_OFFSET() {
    return TIME_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_SIMPLE() {
    return TIME_24_SIMPLE;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SECONDS() {
    return TIME_24_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_SHORT_OFFSET() {
    return TIME_24_WITH_SHORT_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
   * @type {Object}
   */
  static get TIME_24_WITH_LONG_OFFSET() {
    return TIME_24_WITH_LONG_OFFSET;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT() {
    return DATETIME_SHORT;
  }
  /**
   * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_SHORT_WITH_SECONDS() {
    return DATETIME_SHORT_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED() {
    return DATETIME_MED;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_SECONDS() {
    return DATETIME_MED_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_MED_WITH_WEEKDAY() {
    return DATETIME_MED_WITH_WEEKDAY;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL() {
    return DATETIME_FULL;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_FULL_WITH_SECONDS() {
    return DATETIME_FULL_WITH_SECONDS;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE() {
    return DATETIME_HUGE;
  }
  /**
   * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
   * @type {Object}
   */
  static get DATETIME_HUGE_WITH_SECONDS() {
    return DATETIME_HUGE_WITH_SECONDS;
  }
}
function friendlyDateTime(e) {
  if (DateTime.isDateTime(e))
    return e;
  if (e && e.valueOf && isNumber$1(e.valueOf()))
    return DateTime.fromJSDate(e);
  if (e && typeof e == "object")
    return DateTime.fromObject(e);
  throw new InvalidArgumentError(
    `Unknown datetime argument: ${e}, of type ${typeof e}`
  );
}
var Qe = (e) => {
  throw TypeError(e);
}, Ie = (e, t, v) => t.has(e) || Qe("Cannot " + v), fe = (e, t, v) => (Ie(e, t, "read from private field"), v ? v.call(e) : t.get(e)), ke = (e, t, v) => t.has(e) ? Qe("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, v), et = (e, t, v, w) => (Ie(e, t, "write to private field"), w ? w.call(e, v) : t.set(e, v), v), G$1 = (e, t, v) => (Ie(e, t, "access private method"), v);
const Ot = -1, Re = 0, ce = 1, ve = 2, Fe = 3, Me = 4, Ue = 5, qe = 6, jt = 7, It = 8, st = typeof self == "object" ? self : globalThis, $r = (e, t) => {
  const v = (T, x) => (e.set(x, T), T), w = (T) => {
    if (e.has(T))
      return e.get(T);
    const [x, C] = t[T];
    switch (x) {
      case Re:
      case Ot:
        return v(C, T);
      case ce: {
        const D = v([], T);
        for (const Y of C)
          D.push(w(Y));
        return D;
      }
      case ve: {
        const D = v({}, T);
        for (const [Y, L] of C)
          D[w(Y)] = w(L);
        return D;
      }
      case Fe:
        return v(new Date(C), T);
      case Me: {
        const { source: D, flags: Y } = C;
        return v(new RegExp(D, Y), T);
      }
      case Ue: {
        const D = v(/* @__PURE__ */ new Map(), T);
        for (const [Y, L] of C)
          D.set(w(Y), w(L));
        return D;
      }
      case qe: {
        const D = v(/* @__PURE__ */ new Set(), T);
        for (const Y of C)
          D.add(w(Y));
        return D;
      }
      case jt: {
        const { name: D, message: Y } = C;
        return v(new st[D](Y), T);
      }
      case It:
        return v(BigInt(C), T);
      case "BigInt":
        return v(Object(BigInt(C)), T);
      case "ArrayBuffer":
        return v(new Uint8Array(C).buffer, C);
      case "DataView": {
        const { buffer: D } = new Uint8Array(C);
        return v(new DataView(D), C);
      }
    }
    return v(new st[x](C), T);
  };
  return w;
}, wr = (e) => $r(/* @__PURE__ */ new Map(), e)(0), re = "", { toString: Er } = {}, { keys: Rr$1 } = Object, oe = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [Re, t];
  const v = Er.call(e).slice(8, -1);
  switch (v) {
    case "Array":
      return [ce, re];
    case "Object":
      return [ve, re];
    case "Date":
      return [Fe, re];
    case "RegExp":
      return [Me, re];
    case "Map":
      return [Ue, re];
    case "Set":
      return [qe, re];
    case "DataView":
      return [ce, v];
  }
  return v.includes("Array") ? [ce, v] : v.includes("Error") ? [jt, v] : [ve, v];
}, me = ([e, t]) => e === Re && (t === "function" || t === "symbol"), xr = (e, t, v, w) => {
  const T = (C, D) => {
    const Y = w.push(C) - 1;
    return v.set(D, Y), Y;
  }, x = (C) => {
    if (v.has(C))
      return v.get(C);
    let [D, Y] = oe(C);
    switch (D) {
      case Re: {
        let q = C;
        switch (Y) {
          case "bigint":
            D = It, q = C.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + Y);
            q = null;
            break;
          case "undefined":
            return T([Ot], C);
        }
        return T([D, q], C);
      }
      case ce: {
        if (Y) {
          let F = C;
          return Y === "DataView" ? F = new Uint8Array(C.buffer) : Y === "ArrayBuffer" && (F = new Uint8Array(C)), T([Y, [...F]], C);
        }
        const q = [], N = T([D, q], C);
        for (const F of C)
          q.push(x(F));
        return N;
      }
      case ve: {
        if (Y)
          switch (Y) {
            case "BigInt":
              return T([Y, C.toString()], C);
            case "Boolean":
            case "Number":
            case "String":
              return T([Y, C.valueOf()], C);
          }
        if (t && "toJSON" in C)
          return x(C.toJSON());
        const q = [], N = T([D, q], C);
        for (const F of Rr$1(C))
          (e || !me(oe(C[F]))) && q.push([x(F), x(C[F])]);
        return N;
      }
      case Fe:
        return T([D, C.toISOString()], C);
      case Me: {
        const { source: q, flags: N } = C;
        return T([D, { source: q, flags: N }], C);
      }
      case Ue: {
        const q = [], N = T([D, q], C);
        for (const [F, ae] of C)
          (e || !(me(oe(F)) || me(oe(ae)))) && q.push([x(F), x(ae)]);
        return N;
      }
      case qe: {
        const q = [], N = T([D, q], C);
        for (const F of C)
          (e || !me(oe(F))) && q.push(x(F));
        return N;
      }
    }
    const { message: L } = C;
    return T([D, { name: Y, message: L }], C);
  };
  return x;
}, Sr = (e, { json: t, lossy: v } = {}) => {
  const w = [];
  return xr(!(t || v), !!t, /* @__PURE__ */ new Map(), w)(e), w;
}, W$6 = (e) => {
  const t = Sr(e), v = JSON.stringify(t);
  return Uint8Array.from(v, (w) => w.charCodeAt(0));
}, H = (e) => {
  const t = Array.from(e).map((v) => String.fromCharCode(v)).join("");
  try {
    const v = JSON.parse(t);
    return wr(v);
  } catch (v) {
    throw new I$1(v instanceof Error ? v : void 0);
  }
};
function Ar$1(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var _e = { exports: {} };
_e.exports;
(function(e, t) {
  (function(v, w) {
    e.exports = w();
  })(self, () => {
    return v = { 7629: (T, x, C) => {
      const D = C(375), Y = C(8571), L = C(9474), q = C(1687), N = C(8652), F = C(8160), ae = C(3292), he = C(6354), tt = C(8901), br = C(9708), rt = C(6914), dr = C(2294), _r = C(6133), Bi = C(1152), qi = C(8863), Wi = C(2036), Vi = { Base: class {
        constructor(Ti) {
          this.type = Ti, this.$_root = null, this._definition = {}, this._reset();
        }
        _reset() {
          this._ids = new dr.Ids(), this._preferences = null, this._refs = new _r.Manager(), this._cache = null, this._valids = null, this._invalids = null, this._flags = {}, this._rules = [], this._singleRules = /* @__PURE__ */ new Map(), this.$_terms = {}, this.$_temp = { ruleset: null, whens: {} };
        }
        describe() {
          return D(typeof br.describe == "function", "Manifest functionality disabled"), br.describe(this);
        }
        allow(...Ti) {
          return F.verifyFlat(Ti, "allow"), this._values(Ti, "_valids");
        }
        alter(Ti) {
          D(Ti && typeof Ti == "object" && !Array.isArray(Ti), "Invalid targets argument"), D(!this._inRuleset(), "Cannot set alterations inside a ruleset");
          const Li = this.clone();
          Li.$_terms.alterations = Li.$_terms.alterations || [];
          for (const Hi in Ti) {
            const pr = Ti[Hi];
            D(typeof pr == "function", "Alteration adjuster for", Hi, "must be a function"), Li.$_terms.alterations.push({ target: Hi, adjuster: pr });
          }
          return Li.$_temp.ruleset = !1, Li;
        }
        artifact(Ti) {
          return D(Ti !== void 0, "Artifact cannot be undefined"), D(!this._cache, "Cannot set an artifact with a rule cache"), this.$_setFlag("artifact", Ti);
        }
        cast(Ti) {
          return D(Ti === !1 || typeof Ti == "string", "Invalid to value"), D(Ti === !1 || this._definition.cast[Ti], "Type", this.type, "does not support casting to", Ti), this.$_setFlag("cast", Ti === !1 ? void 0 : Ti);
        }
        default(Ti, Li) {
          return this._default("default", Ti, Li);
        }
        description(Ti) {
          return D(Ti && typeof Ti == "string", "Description must be a non-empty string"), this.$_setFlag("description", Ti);
        }
        empty(Ti) {
          const Li = this.clone();
          return Ti !== void 0 && (Ti = Li.$_compile(Ti, { override: !1 })), Li.$_setFlag("empty", Ti, { clone: !1 });
        }
        error(Ti) {
          return D(Ti, "Missing error"), D(Ti instanceof Error || typeof Ti == "function", "Must provide a valid Error object or a function"), this.$_setFlag("error", Ti);
        }
        example(Ti, Li = {}) {
          return D(Ti !== void 0, "Missing example"), F.assertOptions(Li, ["override"]), this._inner("examples", Ti, { single: !0, override: Li.override });
        }
        external(Ti, Li) {
          return typeof Ti == "object" && (D(!Li, "Cannot combine options with description"), Li = Ti.description, Ti = Ti.method), D(typeof Ti == "function", "Method must be a function"), D(Li === void 0 || Li && typeof Li == "string", "Description must be a non-empty string"), this._inner("externals", { method: Ti, description: Li }, { single: !0 });
        }
        failover(Ti, Li) {
          return this._default("failover", Ti, Li);
        }
        forbidden() {
          return this.presence("forbidden");
        }
        id(Ti) {
          return Ti ? (D(typeof Ti == "string", "id must be a non-empty string"), D(/^[^\.]+$/.test(Ti), "id cannot contain period character"), this.$_setFlag("id", Ti)) : this.$_setFlag("id", void 0);
        }
        invalid(...Ti) {
          return this._values(Ti, "_invalids");
        }
        label(Ti) {
          return D(Ti && typeof Ti == "string", "Label name must be a non-empty string"), this.$_setFlag("label", Ti);
        }
        meta(Ti) {
          return D(Ti !== void 0, "Meta cannot be undefined"), this._inner("metas", Ti, { single: !0 });
        }
        note(...Ti) {
          D(Ti.length, "Missing notes");
          for (const Li of Ti) D(Li && typeof Li == "string", "Notes must be non-empty strings");
          return this._inner("notes", Ti);
        }
        only(Ti = !0) {
          return D(typeof Ti == "boolean", "Invalid mode:", Ti), this.$_setFlag("only", Ti);
        }
        optional() {
          return this.presence("optional");
        }
        prefs(Ti) {
          D(Ti, "Missing preferences"), D(Ti.context === void 0, "Cannot override context"), D(Ti.externals === void 0, "Cannot override externals"), D(Ti.warnings === void 0, "Cannot override warnings"), D(Ti.debug === void 0, "Cannot override debug"), F.checkPreferences(Ti);
          const Li = this.clone();
          return Li._preferences = F.preferences(Li._preferences, Ti), Li;
        }
        presence(Ti) {
          return D(["optional", "required", "forbidden"].includes(Ti), "Unknown presence mode", Ti), this.$_setFlag("presence", Ti);
        }
        raw(Ti = !0) {
          return this.$_setFlag("result", Ti ? "raw" : void 0);
        }
        result(Ti) {
          return D(["raw", "strip"].includes(Ti), "Unknown result mode", Ti), this.$_setFlag("result", Ti);
        }
        required() {
          return this.presence("required");
        }
        strict(Ti) {
          const Li = this.clone(), Hi = Ti !== void 0 && !Ti;
          return Li._preferences = F.preferences(Li._preferences, { convert: Hi }), Li;
        }
        strip(Ti = !0) {
          return this.$_setFlag("result", Ti ? "strip" : void 0);
        }
        tag(...Ti) {
          D(Ti.length, "Missing tags");
          for (const Li of Ti) D(Li && typeof Li == "string", "Tags must be non-empty strings");
          return this._inner("tags", Ti);
        }
        unit(Ti) {
          return D(Ti && typeof Ti == "string", "Unit name must be a non-empty string"), this.$_setFlag("unit", Ti);
        }
        valid(...Ti) {
          F.verifyFlat(Ti, "valid");
          const Li = this.allow(...Ti);
          return Li.$_setFlag("only", !!Li._valids, { clone: !1 }), Li;
        }
        when(Ti, Li) {
          const Hi = this.clone();
          Hi.$_terms.whens || (Hi.$_terms.whens = []);
          const pr = ae.when(Hi, Ti, Li);
          if (!["any", "link"].includes(Hi.type)) {
            const Di = pr.is ? [pr] : pr.switch;
            for (const z of Di) D(!z.then || z.then.type === "any" || z.then.type === Hi.type, "Cannot combine", Hi.type, "with", z.then && z.then.type), D(!z.otherwise || z.otherwise.type === "any" || z.otherwise.type === Hi.type, "Cannot combine", Hi.type, "with", z.otherwise && z.otherwise.type);
          }
          return Hi.$_terms.whens.push(pr), Hi.$_mutateRebuild();
        }
        cache(Ti) {
          D(!this._inRuleset(), "Cannot set caching inside a ruleset"), D(!this._cache, "Cannot override schema cache"), D(this._flags.artifact === void 0, "Cannot cache a rule with an artifact");
          const Li = this.clone();
          return Li._cache = Ti || N.provider.provision(), Li.$_temp.ruleset = !1, Li;
        }
        clone() {
          const Ti = Object.create(Object.getPrototypeOf(this));
          return this._assign(Ti);
        }
        concat(Ti) {
          D(F.isSchema(Ti), "Invalid schema object"), D(this.type === "any" || Ti.type === "any" || Ti.type === this.type, "Cannot merge type", this.type, "with another type:", Ti.type), D(!this._inRuleset(), "Cannot concatenate onto a schema with open ruleset"), D(!Ti._inRuleset(), "Cannot concatenate a schema with open ruleset");
          let Li = this.clone();
          if (this.type === "any" && Ti.type !== "any") {
            const Hi = Ti.clone();
            for (const pr of Object.keys(Li)) pr !== "type" && (Hi[pr] = Li[pr]);
            Li = Hi;
          }
          Li._ids.concat(Ti._ids), Li._refs.register(Ti, _r.toSibling), Li._preferences = Li._preferences ? F.preferences(Li._preferences, Ti._preferences) : Ti._preferences, Li._valids = Wi.merge(Li._valids, Ti._valids, Ti._invalids), Li._invalids = Wi.merge(Li._invalids, Ti._invalids, Ti._valids);
          for (const Hi of Ti._singleRules.keys()) Li._singleRules.has(Hi) && (Li._rules = Li._rules.filter((pr) => pr.keep || pr.name !== Hi), Li._singleRules.delete(Hi));
          for (const Hi of Ti._rules) Ti._definition.rules[Hi.method].multi || Li._singleRules.set(Hi.name, Hi), Li._rules.push(Hi);
          if (Li._flags.empty && Ti._flags.empty) {
            Li._flags.empty = Li._flags.empty.concat(Ti._flags.empty);
            const Hi = Object.assign({}, Ti._flags);
            delete Hi.empty, q(Li._flags, Hi);
          } else if (Ti._flags.empty) {
            Li._flags.empty = Ti._flags.empty;
            const Hi = Object.assign({}, Ti._flags);
            delete Hi.empty, q(Li._flags, Hi);
          } else q(Li._flags, Ti._flags);
          for (const Hi in Ti.$_terms) {
            const pr = Ti.$_terms[Hi];
            pr ? Li.$_terms[Hi] ? Li.$_terms[Hi] = Li.$_terms[Hi].concat(pr) : Li.$_terms[Hi] = pr.slice() : Li.$_terms[Hi] || (Li.$_terms[Hi] = pr);
          }
          return this.$_root._tracer && this.$_root._tracer._combine(Li, [this, Ti]), Li.$_mutateRebuild();
        }
        extend(Ti) {
          return D(!Ti.base, "Cannot extend type with another base"), tt.type(this, Ti);
        }
        extract(Ti) {
          return Ti = Array.isArray(Ti) ? Ti : Ti.split("."), this._ids.reach(Ti);
        }
        fork(Ti, Li) {
          D(!this._inRuleset(), "Cannot fork inside a ruleset");
          let Hi = this;
          for (let pr of [].concat(Ti)) pr = Array.isArray(pr) ? pr : pr.split("."), Hi = Hi._ids.fork(pr, Li, Hi);
          return Hi.$_temp.ruleset = !1, Hi;
        }
        rule(Ti) {
          const Li = this._definition;
          F.assertOptions(Ti, Object.keys(Li.modifiers)), D(this.$_temp.ruleset !== !1, "Cannot apply rules to empty ruleset or the last rule added does not support rule properties");
          const Hi = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;
          D(Hi >= 0 && Hi < this._rules.length, "Cannot apply rules to empty ruleset");
          const pr = this.clone();
          for (let Di = Hi; Di < pr._rules.length; ++Di) {
            const z = pr._rules[Di], gr = Y(z);
            for (const vr in Ti) Li.modifiers[vr](gr, Ti[vr]), D(gr.name === z.name, "Cannot change rule name");
            pr._rules[Di] = gr, pr._singleRules.get(gr.name) === z && pr._singleRules.set(gr.name, gr);
          }
          return pr.$_temp.ruleset = !1, pr.$_mutateRebuild();
        }
        get ruleset() {
          D(!this._inRuleset(), "Cannot start a new ruleset without closing the previous one");
          const Ti = this.clone();
          return Ti.$_temp.ruleset = Ti._rules.length, Ti;
        }
        get $() {
          return this.ruleset;
        }
        tailor(Ti) {
          Ti = [].concat(Ti), D(!this._inRuleset(), "Cannot tailor inside a ruleset");
          let Li = this;
          if (this.$_terms.alterations) for (const { target: Hi, adjuster: pr } of this.$_terms.alterations) Ti.includes(Hi) && (Li = pr(Li), D(F.isSchema(Li), "Alteration adjuster for", Hi, "failed to return a schema object"));
          return Li = Li.$_modify({ each: (Hi) => Hi.tailor(Ti), ref: !1 }), Li.$_temp.ruleset = !1, Li.$_mutateRebuild();
        }
        tracer() {
          return Bi.location ? Bi.location(this) : this;
        }
        validate(Ti, Li) {
          return qi.entry(Ti, this, Li);
        }
        validateAsync(Ti, Li) {
          return qi.entryAsync(Ti, this, Li);
        }
        $_addRule(Ti) {
          typeof Ti == "string" && (Ti = { name: Ti }), D(Ti && typeof Ti == "object", "Invalid options"), D(Ti.name && typeof Ti.name == "string", "Invalid rule name");
          for (const z in Ti) D(z[0] !== "_", "Cannot set private rule properties");
          const Li = Object.assign({}, Ti);
          Li._resolve = [], Li.method = Li.method || Li.name;
          const Hi = this._definition.rules[Li.method], pr = Li.args;
          D(Hi, "Unknown rule", Li.method);
          const Di = this.clone();
          if (pr) {
            D(Object.keys(pr).length === 1 || Object.keys(pr).length === this._definition.rules[Li.name].args.length, "Invalid rule definition for", this.type, Li.name);
            for (const z in pr) {
              let gr = pr[z];
              if (Hi.argsByName) {
                const vr = Hi.argsByName.get(z);
                if (vr.ref && F.isResolvable(gr)) Li._resolve.push(z), Di.$_mutateRegister(gr);
                else if (vr.normalize && (gr = vr.normalize(gr), pr[z] = gr), vr.assert) {
                  const Oi = F.validateArg(gr, z, vr);
                  D(!Oi, Oi, "or reference");
                }
              }
              gr !== void 0 ? pr[z] = gr : delete pr[z];
            }
          }
          return Hi.multi || (Di._ruleRemove(Li.name, { clone: !1 }), Di._singleRules.set(Li.name, Li)), Di.$_temp.ruleset === !1 && (Di.$_temp.ruleset = null), Hi.priority ? Di._rules.unshift(Li) : Di._rules.push(Li), Di;
        }
        $_compile(Ti, Li) {
          return ae.schema(this.$_root, Ti, Li);
        }
        $_createError(Ti, Li, Hi, pr, Di, z = {}) {
          const gr = z.flags !== !1 ? this._flags : {}, vr = z.messages ? rt.merge(this._definition.messages, z.messages) : this._definition.messages;
          return new he.Report(Ti, Li, Hi, gr, vr, pr, Di);
        }
        $_getFlag(Ti) {
          return this._flags[Ti];
        }
        $_getRule(Ti) {
          return this._singleRules.get(Ti);
        }
        $_mapLabels(Ti) {
          return Ti = Array.isArray(Ti) ? Ti : Ti.split("."), this._ids.labels(Ti);
        }
        $_match(Ti, Li, Hi, pr) {
          (Hi = Object.assign({}, Hi)).abortEarly = !0, Hi._externals = !1, Li.snapshot();
          const Di = !qi.validate(Ti, this, Li, Hi, pr).errors;
          return Li.restore(), Di;
        }
        $_modify(Ti) {
          return F.assertOptions(Ti, ["each", "once", "ref", "schema"]), dr.schema(this, Ti) || this;
        }
        $_mutateRebuild() {
          return D(!this._inRuleset(), "Cannot add this rule inside a ruleset"), this._refs.reset(), this._ids.reset(), this.$_modify({ each: (Ti, { source: Li, name: Hi, path: pr, key: Di }) => {
            const z = this._definition[Li][Hi] && this._definition[Li][Hi].register;
            z !== !1 && this.$_mutateRegister(Ti, { family: z, key: Di });
          } }), this._definition.rebuild && this._definition.rebuild(this), this.$_temp.ruleset = !1, this;
        }
        $_mutateRegister(Ti, { family: Li, key: Hi } = {}) {
          this._refs.register(Ti, Li), this._ids.register(Ti, { key: Hi });
        }
        $_property(Ti) {
          return this._definition.properties[Ti];
        }
        $_reach(Ti) {
          return this._ids.reach(Ti);
        }
        $_rootReferences() {
          return this._refs.roots();
        }
        $_setFlag(Ti, Li, Hi = {}) {
          D(Ti[0] === "_" || !this._inRuleset(), "Cannot set flag inside a ruleset");
          const pr = this._definition.flags[Ti] || {};
          if (L(Li, pr.default) && (Li = void 0), L(Li, this._flags[Ti])) return this;
          const Di = Hi.clone !== !1 ? this.clone() : this;
          return Li !== void 0 ? (Di._flags[Ti] = Li, Di.$_mutateRegister(Li)) : delete Di._flags[Ti], Ti[0] !== "_" && (Di.$_temp.ruleset = !1), Di;
        }
        $_parent(Ti, ...Li) {
          return this[Ti][F.symbols.parent].call(this, ...Li);
        }
        $_validate(Ti, Li, Hi) {
          return qi.validate(Ti, this, Li, Hi);
        }
        _assign(Ti) {
          Ti.type = this.type, Ti.$_root = this.$_root, Ti.$_temp = Object.assign({}, this.$_temp), Ti.$_temp.whens = {}, Ti._ids = this._ids.clone(), Ti._preferences = this._preferences, Ti._valids = this._valids && this._valids.clone(), Ti._invalids = this._invalids && this._invalids.clone(), Ti._rules = this._rules.slice(), Ti._singleRules = Y(this._singleRules, { shallow: !0 }), Ti._refs = this._refs.clone(), Ti._flags = Object.assign({}, this._flags), Ti._cache = null, Ti.$_terms = {};
          for (const Li in this.$_terms) Ti.$_terms[Li] = this.$_terms[Li] ? this.$_terms[Li].slice() : null;
          Ti.$_super = {};
          for (const Li in this.$_super) Ti.$_super[Li] = this._super[Li].bind(Ti);
          return Ti;
        }
        _bare() {
          const Ti = this.clone();
          Ti._reset();
          const Li = Ti._definition.terms;
          for (const Hi in Li) {
            const pr = Li[Hi];
            Ti.$_terms[Hi] = pr.init;
          }
          return Ti.$_mutateRebuild();
        }
        _default(Ti, Li, Hi = {}) {
          return F.assertOptions(Hi, "literal"), D(Li !== void 0, "Missing", Ti, "value"), D(typeof Li == "function" || !Hi.literal, "Only function value supports literal option"), typeof Li == "function" && Hi.literal && (Li = { [F.symbols.literal]: !0, literal: Li }), this.$_setFlag(Ti, Li);
        }
        _generate(Ti, Li, Hi) {
          if (!this.$_terms.whens) return { schema: this };
          const pr = [], Di = [];
          for (let vr = 0; vr < this.$_terms.whens.length; ++vr) {
            const Oi = this.$_terms.whens[vr];
            if (Oi.concat) {
              pr.push(Oi.concat), Di.push(`${vr}.concat`);
              continue;
            }
            const Mi = Oi.ref ? Oi.ref.resolve(Ti, Li, Hi) : Ti, ki = Oi.is ? [Oi] : Oi.switch, yr = Di.length;
            for (let xi = 0; xi < ki.length; ++xi) {
              const { is: Si, then: Ci, otherwise: Ki } = ki[xi], Yi = `${vr}${Oi.switch ? "." + xi : ""}`;
              if (Si.$_match(Mi, Li.nest(Si, `${Yi}.is`), Hi)) {
                if (Ci) {
                  const Qi = Li.localize([...Li.path, `${Yi}.then`], Li.ancestors, Li.schemas), { schema: Zi, id: Ni } = Ci._generate(Ti, Qi, Hi);
                  pr.push(Zi), Di.push(`${Yi}.then${Ni ? `(${Ni})` : ""}`);
                  break;
                }
              } else if (Ki) {
                const Qi = Li.localize([...Li.path, `${Yi}.otherwise`], Li.ancestors, Li.schemas), { schema: Zi, id: Ni } = Ki._generate(Ti, Qi, Hi);
                pr.push(Zi), Di.push(`${Yi}.otherwise${Ni ? `(${Ni})` : ""}`);
                break;
              }
            }
            if (Oi.break && Di.length > yr) break;
          }
          const z = Di.join(", ");
          if (Li.mainstay.tracer.debug(Li, "rule", "when", z), !z) return { schema: this };
          if (!Li.mainstay.tracer.active && this.$_temp.whens[z]) return { schema: this.$_temp.whens[z], id: z };
          let gr = this;
          this._definition.generate && (gr = this._definition.generate(this, Ti, Li, Hi));
          for (const vr of pr) gr = gr.concat(vr);
          return this.$_root._tracer && this.$_root._tracer._combine(gr, [this, ...pr]), this.$_temp.whens[z] = gr, { schema: gr, id: z };
        }
        _inner(Ti, Li, Hi = {}) {
          D(!this._inRuleset(), `Cannot set ${Ti} inside a ruleset`);
          const pr = this.clone();
          return pr.$_terms[Ti] && !Hi.override || (pr.$_terms[Ti] = []), Hi.single ? pr.$_terms[Ti].push(Li) : pr.$_terms[Ti].push(...Li), pr.$_temp.ruleset = !1, pr;
        }
        _inRuleset() {
          return this.$_temp.ruleset !== null && this.$_temp.ruleset !== !1;
        }
        _ruleRemove(Ti, Li = {}) {
          if (!this._singleRules.has(Ti)) return this;
          const Hi = Li.clone !== !1 ? this.clone() : this;
          Hi._singleRules.delete(Ti);
          const pr = [];
          for (let Di = 0; Di < Hi._rules.length; ++Di) {
            const z = Hi._rules[Di];
            z.name !== Ti || z.keep ? pr.push(z) : Hi._inRuleset() && Di < Hi.$_temp.ruleset && --Hi.$_temp.ruleset;
          }
          return Hi._rules = pr, Hi;
        }
        _values(Ti, Li) {
          F.verifyFlat(Ti, Li.slice(1, -1));
          const Hi = this.clone(), pr = Ti[0] === F.symbols.override;
          if (pr && (Ti = Ti.slice(1)), !Hi[Li] && Ti.length ? Hi[Li] = new Wi() : pr && (Hi[Li] = Ti.length ? new Wi() : null, Hi.$_mutateRebuild()), !Hi[Li]) return Hi;
          pr && Hi[Li].override();
          for (const Di of Ti) {
            D(Di !== void 0, "Cannot call allow/valid/invalid with undefined"), D(Di !== F.symbols.override, "Override must be the first value");
            const z = Li === "_invalids" ? "_valids" : "_invalids";
            Hi[z] && (Hi[z].remove(Di), Hi[z].length || (D(Li === "_valids" || !Hi._flags.only, "Setting invalid value", Di, "leaves schema rejecting all values due to previous valid rule"), Hi[z] = null)), Hi[Li].add(Di, Hi._refs);
          }
          return Hi;
        }
      } };
      Vi.Base.prototype[F.symbols.any] = { version: F.version, compile: ae.compile, root: "$_root" }, Vi.Base.prototype.isImmutable = !0, Vi.Base.prototype.deny = Vi.Base.prototype.invalid, Vi.Base.prototype.disallow = Vi.Base.prototype.invalid, Vi.Base.prototype.equal = Vi.Base.prototype.valid, Vi.Base.prototype.exist = Vi.Base.prototype.required, Vi.Base.prototype.not = Vi.Base.prototype.invalid, Vi.Base.prototype.options = Vi.Base.prototype.prefs, Vi.Base.prototype.preferences = Vi.Base.prototype.prefs, T.exports = new Vi.Base();
    }, 8652: (T, x, C) => {
      const D = C(375), Y = C(8571), L = C(8160), q = { max: 1e3, supported: /* @__PURE__ */ new Set(["undefined", "boolean", "number", "string"]) };
      x.provider = { provision: (N) => new q.Cache(N) }, q.Cache = class {
        constructor(N = {}) {
          L.assertOptions(N, ["max"]), D(N.max === void 0 || N.max && N.max > 0 && isFinite(N.max), "Invalid max cache size"), this._max = N.max || q.max, this._map = /* @__PURE__ */ new Map(), this._list = new q.List();
        }
        get length() {
          return this._map.size;
        }
        set(N, F) {
          if (N !== null && !q.supported.has(typeof N)) return;
          let ae = this._map.get(N);
          if (ae) return ae.value = F, void this._list.first(ae);
          ae = this._list.unshift({ key: N, value: F }), this._map.set(N, ae), this._compact();
        }
        get(N) {
          const F = this._map.get(N);
          if (F) return this._list.first(F), Y(F.value);
        }
        _compact() {
          if (this._map.size > this._max) {
            const N = this._list.pop();
            this._map.delete(N.key);
          }
        }
      }, q.List = class {
        constructor() {
          this.tail = null, this.head = null;
        }
        unshift(N) {
          return N.next = null, N.prev = this.head, this.head && (this.head.next = N), this.head = N, this.tail || (this.tail = N), N;
        }
        first(N) {
          N !== this.head && (this._remove(N), this.unshift(N));
        }
        pop() {
          return this._remove(this.tail);
        }
        _remove(N) {
          const { next: F, prev: ae } = N;
          return F.prev = ae, ae && (ae.next = F), N === this.tail && (this.tail = F), N.prev = null, N.next = null, N;
        }
      };
    }, 8160: (T, x, C) => {
      const D = C(375), Y = C(7916), L = C(5934);
      let q, N;
      const F = { isoDate: /^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/ };
      x.version = L.version, x.defaults = { abortEarly: !0, allowUnknown: !1, artifacts: !1, cache: !0, context: null, convert: !0, dateFormat: "iso", errors: { escapeHtml: !1, label: "path", language: null, render: !0, stack: !1, wrap: { label: '"', array: "[]" } }, externals: !0, messages: {}, nonEnumerables: !1, noDefaults: !1, presence: "optional", skipFunctions: !1, stripUnknown: !1, warnings: !1 }, x.symbols = { any: Symbol.for("@hapi/joi/schema"), arraySingle: Symbol("arraySingle"), deepDefault: Symbol("deepDefault"), errors: Symbol("errors"), literal: Symbol("literal"), override: Symbol("override"), parent: Symbol("parent"), prefs: Symbol("prefs"), ref: Symbol("ref"), template: Symbol("template"), values: Symbol("values") }, x.assertOptions = function(ae, he, tt = "Options") {
        D(ae && typeof ae == "object" && !Array.isArray(ae), "Options must be of type object");
        const br = Object.keys(ae).filter((rt) => !he.includes(rt));
        D(br.length === 0, `${tt} contain unknown keys: ${br}`);
      }, x.checkPreferences = function(ae) {
        N = N || C(3378);
        const he = N.preferences.validate(ae);
        if (he.error) throw new Y([he.error.details[0].message]);
      }, x.compare = function(ae, he, tt) {
        switch (tt) {
          case "=":
            return ae === he;
          case ">":
            return ae > he;
          case "<":
            return ae < he;
          case ">=":
            return ae >= he;
          case "<=":
            return ae <= he;
        }
      }, x.default = function(ae, he) {
        return ae === void 0 ? he : ae;
      }, x.isIsoDate = function(ae) {
        return F.isoDate.test(ae);
      }, x.isNumber = function(ae) {
        return typeof ae == "number" && !isNaN(ae);
      }, x.isResolvable = function(ae) {
        return !!ae && (ae[x.symbols.ref] || ae[x.symbols.template]);
      }, x.isSchema = function(ae, he = {}) {
        const tt = ae && ae[x.symbols.any];
        return !!tt && (D(he.legacy || tt.version === x.version, "Cannot mix different versions of joi schemas"), !0);
      }, x.isValues = function(ae) {
        return ae[x.symbols.values];
      }, x.limit = function(ae) {
        return Number.isSafeInteger(ae) && ae >= 0;
      }, x.preferences = function(ae, he) {
        q = q || C(6914), ae = ae || {}, he = he || {};
        const tt = Object.assign({}, ae, he);
        return he.errors && ae.errors && (tt.errors = Object.assign({}, ae.errors, he.errors), tt.errors.wrap = Object.assign({}, ae.errors.wrap, he.errors.wrap)), he.messages && (tt.messages = q.compile(he.messages, ae.messages)), delete tt[x.symbols.prefs], tt;
      }, x.tryWithPath = function(ae, he, tt = {}) {
        try {
          return ae();
        } catch (br) {
          throw br.path !== void 0 ? br.path = he + "." + br.path : br.path = he, tt.append && (br.message = `${br.message} (${br.path})`), br;
        }
      }, x.validateArg = function(ae, he, { assert: tt, message: br }) {
        if (x.isSchema(tt)) {
          const rt = tt.validate(ae);
          return rt.error ? rt.error.message : void 0;
        }
        if (!tt(ae)) return he ? `${he} ${br}` : br;
      }, x.verifyFlat = function(ae, he) {
        for (const tt of ae) D(!Array.isArray(tt), "Method no longer accepts array arguments:", he);
      };
    }, 3292: (T, x, C) => {
      const D = C(375), Y = C(8160), L = C(6133), q = {};
      x.schema = function(N, F, ae = {}) {
        Y.assertOptions(ae, ["appendPath", "override"]);
        try {
          return q.schema(N, F, ae);
        } catch (he) {
          throw ae.appendPath && he.path !== void 0 && (he.message = `${he.message} (${he.path})`), he;
        }
      }, q.schema = function(N, F, ae) {
        D(F !== void 0, "Invalid undefined schema"), Array.isArray(F) && (D(F.length, "Invalid empty array schema"), F.length === 1 && (F = F[0]));
        const he = (tt, ...br) => ae.override !== !1 ? tt.valid(N.override, ...br) : tt.valid(...br);
        if (q.simple(F)) return he(N, F);
        if (typeof F == "function") return N.custom(F);
        if (D(typeof F == "object", "Invalid schema content:", typeof F), Y.isResolvable(F)) return he(N, F);
        if (Y.isSchema(F)) return F;
        if (Array.isArray(F)) {
          for (const tt of F) if (!q.simple(tt)) return N.alternatives().try(...F);
          return he(N, ...F);
        }
        return F instanceof RegExp ? N.string().regex(F) : F instanceof Date ? he(N.date(), F) : (D(Object.getPrototypeOf(F) === Object.getPrototypeOf({}), "Schema can only contain plain objects"), N.object().keys(F));
      }, x.ref = function(N, F) {
        return L.isRef(N) ? N : L.create(N, F);
      }, x.compile = function(N, F, ae = {}) {
        Y.assertOptions(ae, ["legacy"]);
        const he = F && F[Y.symbols.any];
        if (he) return D(ae.legacy || he.version === Y.version, "Cannot mix different versions of joi schemas:", he.version, Y.version), F;
        if (typeof F != "object" || !ae.legacy) return x.schema(N, F, { appendPath: !0 });
        const tt = q.walk(F);
        return tt ? tt.compile(tt.root, F) : x.schema(N, F, { appendPath: !0 });
      }, q.walk = function(N) {
        if (typeof N != "object") return null;
        if (Array.isArray(N)) {
          for (const ae of N) {
            const he = q.walk(ae);
            if (he) return he;
          }
          return null;
        }
        const F = N[Y.symbols.any];
        if (F) return { root: N[F.root], compile: F.compile };
        D(Object.getPrototypeOf(N) === Object.getPrototypeOf({}), "Schema can only contain plain objects");
        for (const ae in N) {
          const he = q.walk(N[ae]);
          if (he) return he;
        }
        return null;
      }, q.simple = function(N) {
        return N === null || ["boolean", "string", "number"].includes(typeof N);
      }, x.when = function(N, F, ae) {
        if (ae === void 0 && (D(F && typeof F == "object", "Missing options"), ae = F, F = L.create(".")), Array.isArray(ae) && (ae = { switch: ae }), Y.assertOptions(ae, ["is", "not", "then", "otherwise", "switch", "break"]), Y.isSchema(F)) return D(ae.is === void 0, '"is" can not be used with a schema condition'), D(ae.not === void 0, '"not" can not be used with a schema condition'), D(ae.switch === void 0, '"switch" can not be used with a schema condition'), q.condition(N, { is: F, then: ae.then, otherwise: ae.otherwise, break: ae.break });
        if (D(L.isRef(F) || typeof F == "string", "Invalid condition:", F), D(ae.not === void 0 || ae.is === void 0, 'Cannot combine "is" with "not"'), ae.switch === void 0) {
          let tt = ae;
          ae.not !== void 0 && (tt = { is: ae.not, then: ae.otherwise, otherwise: ae.then, break: ae.break });
          let br = tt.is !== void 0 ? N.$_compile(tt.is) : N.$_root.invalid(null, !1, 0, "").required();
          return D(tt.then !== void 0 || tt.otherwise !== void 0, 'options must have at least one of "then", "otherwise", or "switch"'), D(tt.break === void 0 || tt.then === void 0 || tt.otherwise === void 0, "Cannot specify then, otherwise, and break all together"), ae.is === void 0 || L.isRef(ae.is) || Y.isSchema(ae.is) || (br = br.required()), q.condition(N, { ref: x.ref(F), is: br, then: tt.then, otherwise: tt.otherwise, break: tt.break });
        }
        D(Array.isArray(ae.switch), '"switch" must be an array'), D(ae.is === void 0, 'Cannot combine "switch" with "is"'), D(ae.not === void 0, 'Cannot combine "switch" with "not"'), D(ae.then === void 0, 'Cannot combine "switch" with "then"');
        const he = { ref: x.ref(F), switch: [], break: ae.break };
        for (let tt = 0; tt < ae.switch.length; ++tt) {
          const br = ae.switch[tt], rt = tt === ae.switch.length - 1;
          Y.assertOptions(br, rt ? ["is", "then", "otherwise"] : ["is", "then"]), D(br.is !== void 0, 'Switch statement missing "is"'), D(br.then !== void 0, 'Switch statement missing "then"');
          const dr = { is: N.$_compile(br.is), then: N.$_compile(br.then) };
          if (L.isRef(br.is) || Y.isSchema(br.is) || (dr.is = dr.is.required()), rt) {
            D(ae.otherwise === void 0 || br.otherwise === void 0, 'Cannot specify "otherwise" inside and outside a "switch"');
            const _r = ae.otherwise !== void 0 ? ae.otherwise : br.otherwise;
            _r !== void 0 && (D(he.break === void 0, "Cannot specify both otherwise and break"), dr.otherwise = N.$_compile(_r));
          }
          he.switch.push(dr);
        }
        return he;
      }, q.condition = function(N, F) {
        for (const ae of ["then", "otherwise"]) F[ae] === void 0 ? delete F[ae] : F[ae] = N.$_compile(F[ae]);
        return F;
      };
    }, 6354: (T, x, C) => {
      const D = C(5688), Y = C(8160), L = C(3328);
      x.Report = class {
        constructor(q, N, F, ae, he, tt, br) {
          if (this.code = q, this.flags = ae, this.messages = he, this.path = tt.path, this.prefs = br, this.state = tt, this.value = N, this.message = null, this.template = null, this.local = F || {}, this.local.label = x.label(this.flags, this.state, this.prefs, this.messages), this.value === void 0 || this.local.hasOwnProperty("value") || (this.local.value = this.value), this.path.length) {
            const rt = this.path[this.path.length - 1];
            typeof rt != "object" && (this.local.key = rt);
          }
        }
        _setTemplate(q) {
          if (this.template = q, !this.flags.label && this.path.length === 0) {
            const N = this._template(this.template, "root");
            N && (this.local.label = N);
          }
        }
        toString() {
          if (this.message) return this.message;
          const q = this.code;
          if (!this.prefs.errors.render) return this.code;
          const N = this._template(this.template) || this._template(this.prefs.messages) || this._template(this.messages);
          return N === void 0 ? `Error code "${q}" is not defined, your custom type is missing the correct messages definition` : (this.message = N.render(this.value, this.state, this.prefs, this.local, { errors: this.prefs.errors, messages: [this.prefs.messages, this.messages] }), this.prefs.errors.label || (this.message = this.message.replace(/^"" /, "").trim()), this.message);
        }
        _template(q, N) {
          return x.template(this.value, q, N || this.code, this.state, this.prefs);
        }
      }, x.path = function(q) {
        let N = "";
        for (const F of q) typeof F != "object" && (typeof F == "string" ? (N && (N += "."), N += F) : N += `[${F}]`);
        return N;
      }, x.template = function(q, N, F, ae, he) {
        if (!N) return;
        if (L.isTemplate(N)) return F !== "root" ? N : null;
        let tt = he.errors.language;
        if (Y.isResolvable(tt) && (tt = tt.resolve(q, ae, he)), tt && N[tt]) {
          if (N[tt][F] !== void 0) return N[tt][F];
          if (N[tt]["*"] !== void 0) return N[tt]["*"];
        }
        return N[F] ? N[F] : N["*"];
      }, x.label = function(q, N, F, ae) {
        if (!F.errors.label) return "";
        if (q.label) return q.label;
        let he = N.path;
        return F.errors.label === "key" && N.path.length > 1 && (he = N.path.slice(-1)), x.path(he) || x.template(null, F.messages, "root", N, F) || ae && x.template(null, ae, "root", N, F) || "value";
      }, x.process = function(q, N, F) {
        if (!q) return null;
        const { override: ae, message: he, details: tt } = x.details(q);
        if (ae) return ae;
        if (F.errors.stack) return new x.ValidationError(he, tt, N);
        const br = Error.stackTraceLimit;
        Error.stackTraceLimit = 0;
        const rt = new x.ValidationError(he, tt, N);
        return Error.stackTraceLimit = br, rt;
      }, x.details = function(q, N = {}) {
        let F = [];
        const ae = [];
        for (const he of q) {
          if (he instanceof Error) {
            if (N.override !== !1) return { override: he };
            const br = he.toString();
            F.push(br), ae.push({ message: br, type: "override", context: { error: he } });
            continue;
          }
          const tt = he.toString();
          F.push(tt), ae.push({ message: tt, path: he.path.filter((br) => typeof br != "object"), type: he.code, context: he.local });
        }
        return F.length > 1 && (F = [...new Set(F)]), { message: F.join(". "), details: ae };
      }, x.ValidationError = class extends Error {
        constructor(q, N, F) {
          super(q), this._original = F, this.details = N;
        }
        static isError(q) {
          return q instanceof x.ValidationError;
        }
      }, x.ValidationError.prototype.isJoi = !0, x.ValidationError.prototype.name = "ValidationError", x.ValidationError.prototype.annotate = D.error;
    }, 8901: (T, x, C) => {
      const D = C(375), Y = C(8571), L = C(8160), q = C(6914), N = {};
      x.type = function(F, ae) {
        const he = Object.getPrototypeOf(F), tt = Y(he), br = F._assign(Object.create(tt)), rt = Object.assign({}, ae);
        delete rt.base, tt._definition = rt;
        const dr = he._definition || {};
        rt.messages = q.merge(dr.messages, rt.messages), rt.properties = Object.assign({}, dr.properties, rt.properties), br.type = rt.type, rt.flags = Object.assign({}, dr.flags, rt.flags);
        const _r = Object.assign({}, dr.terms);
        if (rt.terms) for (const Vi in rt.terms) {
          const Ti = rt.terms[Vi];
          D(br.$_terms[Vi] === void 0, "Invalid term override for", rt.type, Vi), br.$_terms[Vi] = Ti.init, _r[Vi] = Ti;
        }
        rt.terms = _r, rt.args || (rt.args = dr.args), rt.prepare = N.prepare(rt.prepare, dr.prepare), rt.coerce && (typeof rt.coerce == "function" && (rt.coerce = { method: rt.coerce }), rt.coerce.from && !Array.isArray(rt.coerce.from) && (rt.coerce = { method: rt.coerce.method, from: [].concat(rt.coerce.from) })), rt.coerce = N.coerce(rt.coerce, dr.coerce), rt.validate = N.validate(rt.validate, dr.validate);
        const Bi = Object.assign({}, dr.rules);
        if (rt.rules) for (const Vi in rt.rules) {
          const Ti = rt.rules[Vi];
          D(typeof Ti == "object", "Invalid rule definition for", rt.type, Vi);
          let Li = Ti.method;
          if (Li === void 0 && (Li = function() {
            return this.$_addRule(Vi);
          }), Li && (D(!tt[Vi], "Rule conflict in", rt.type, Vi), tt[Vi] = Li), D(!Bi[Vi], "Rule conflict in", rt.type, Vi), Bi[Vi] = Ti, Ti.alias) {
            const Hi = [].concat(Ti.alias);
            for (const pr of Hi) tt[pr] = Ti.method;
          }
          Ti.args && (Ti.argsByName = /* @__PURE__ */ new Map(), Ti.args = Ti.args.map((Hi) => (typeof Hi == "string" && (Hi = { name: Hi }), D(!Ti.argsByName.has(Hi.name), "Duplicated argument name", Hi.name), L.isSchema(Hi.assert) && (Hi.assert = Hi.assert.strict().label(Hi.name)), Ti.argsByName.set(Hi.name, Hi), Hi)));
        }
        rt.rules = Bi;
        const qi = Object.assign({}, dr.modifiers);
        if (rt.modifiers) for (const Vi in rt.modifiers) {
          D(!tt[Vi], "Rule conflict in", rt.type, Vi);
          const Ti = rt.modifiers[Vi];
          D(typeof Ti == "function", "Invalid modifier definition for", rt.type, Vi);
          const Li = function(Hi) {
            return this.rule({ [Vi]: Hi });
          };
          tt[Vi] = Li, qi[Vi] = Ti;
        }
        if (rt.modifiers = qi, rt.overrides) {
          tt._super = he, br.$_super = {};
          for (const Vi in rt.overrides) D(he[Vi], "Cannot override missing", Vi), rt.overrides[Vi][L.symbols.parent] = he[Vi], br.$_super[Vi] = he[Vi].bind(br);
          Object.assign(tt, rt.overrides);
        }
        rt.cast = Object.assign({}, dr.cast, rt.cast);
        const Wi = Object.assign({}, dr.manifest, rt.manifest);
        return Wi.build = N.build(rt.manifest && rt.manifest.build, dr.manifest && dr.manifest.build), rt.manifest = Wi, rt.rebuild = N.rebuild(rt.rebuild, dr.rebuild), br;
      }, N.build = function(F, ae) {
        return F && ae ? function(he, tt) {
          return ae(F(he, tt), tt);
        } : F || ae;
      }, N.coerce = function(F, ae) {
        return F && ae ? { from: F.from && ae.from ? [.../* @__PURE__ */ new Set([...F.from, ...ae.from])] : null, method(he, tt) {
          let br;
          if ((!ae.from || ae.from.includes(typeof he)) && (br = ae.method(he, tt), br)) {
            if (br.errors || br.value === void 0) return br;
            he = br.value;
          }
          if (!F.from || F.from.includes(typeof he)) {
            const rt = F.method(he, tt);
            if (rt) return rt;
          }
          return br;
        } } : F || ae;
      }, N.prepare = function(F, ae) {
        return F && ae ? function(he, tt) {
          const br = F(he, tt);
          if (br) {
            if (br.errors || br.value === void 0) return br;
            he = br.value;
          }
          return ae(he, tt) || br;
        } : F || ae;
      }, N.rebuild = function(F, ae) {
        return F && ae ? function(he) {
          ae(he), F(he);
        } : F || ae;
      }, N.validate = function(F, ae) {
        return F && ae ? function(he, tt) {
          const br = ae(he, tt);
          if (br) {
            if (br.errors && (!Array.isArray(br.errors) || br.errors.length)) return br;
            he = br.value;
          }
          return F(he, tt) || br;
        } : F || ae;
      };
    }, 5107: (T, x, C) => {
      const D = C(375), Y = C(8571), L = C(8652), q = C(8160), N = C(3292), F = C(6354), ae = C(8901), he = C(9708), tt = C(6133), br = C(3328), rt = C(1152);
      let dr;
      const _r = { types: { alternatives: C(4946), any: C(8068), array: C(546), boolean: C(4937), date: C(7500), function: C(390), link: C(8785), number: C(3832), object: C(8966), string: C(7417), symbol: C(8826) }, aliases: { alt: "alternatives", bool: "boolean", func: "function" }, root: function() {
        const Bi = { _types: new Set(Object.keys(_r.types)) };
        for (const qi of Bi._types) Bi[qi] = function(...Wi) {
          return D(!Wi.length || ["alternatives", "link", "object"].includes(qi), "The", qi, "type does not allow arguments"), _r.generate(this, _r.types[qi], Wi);
        };
        for (const qi of ["allow", "custom", "disallow", "equal", "exist", "forbidden", "invalid", "not", "only", "optional", "options", "prefs", "preferences", "required", "strip", "valid", "when"]) Bi[qi] = function(...Wi) {
          return this.any()[qi](...Wi);
        };
        Object.assign(Bi, _r.methods);
        for (const qi in _r.aliases) {
          const Wi = _r.aliases[qi];
          Bi[qi] = Bi[Wi];
        }
        return Bi.x = Bi.expression, rt.setup && rt.setup(Bi), Bi;
      } };
      _r.methods = { ValidationError: F.ValidationError, version: q.version, cache: L.provider, assert(Bi, qi, ...Wi) {
        _r.assert(Bi, qi, !0, Wi);
      }, attempt: (Bi, qi, ...Wi) => _r.assert(Bi, qi, !1, Wi), build(Bi) {
        return D(typeof he.build == "function", "Manifest functionality disabled"), he.build(this, Bi);
      }, checkPreferences(Bi) {
        q.checkPreferences(Bi);
      }, compile(Bi, qi) {
        return N.compile(this, Bi, qi);
      }, defaults(Bi) {
        D(typeof Bi == "function", "modifier must be a function");
        const qi = Object.assign({}, this);
        for (const Wi of qi._types) {
          const Vi = Bi(qi[Wi]());
          D(q.isSchema(Vi), "modifier must return a valid schema object"), qi[Wi] = function(...Ti) {
            return _r.generate(this, Vi, Ti);
          };
        }
        return qi;
      }, expression: (...Bi) => new br(...Bi), extend(...Bi) {
        q.verifyFlat(Bi, "extend"), dr = dr || C(3378), D(Bi.length, "You need to provide at least one extension"), this.assert(Bi, dr.extensions);
        const qi = Object.assign({}, this);
        qi._types = new Set(qi._types);
        for (let Wi of Bi) {
          typeof Wi == "function" && (Wi = Wi(qi)), this.assert(Wi, dr.extension);
          const Vi = _r.expandExtension(Wi, qi);
          for (const Ti of Vi) {
            D(qi[Ti.type] === void 0 || qi._types.has(Ti.type), "Cannot override name", Ti.type);
            const Li = Ti.base || this.any(), Hi = ae.type(Li, Ti);
            qi._types.add(Ti.type), qi[Ti.type] = function(...pr) {
              return _r.generate(this, Hi, pr);
            };
          }
        }
        return qi;
      }, isError: F.ValidationError.isError, isExpression: br.isTemplate, isRef: tt.isRef, isSchema: q.isSchema, in: (...Bi) => tt.in(...Bi), override: q.symbols.override, ref: (...Bi) => tt.create(...Bi), types() {
        const Bi = {};
        for (const qi of this._types) Bi[qi] = this[qi]();
        for (const qi in _r.aliases) Bi[qi] = this[qi]();
        return Bi;
      } }, _r.assert = function(Bi, qi, Wi, Vi) {
        const Ti = Vi[0] instanceof Error || typeof Vi[0] == "string" ? Vi[0] : null, Li = Ti !== null ? Vi[1] : Vi[0], Hi = qi.validate(Bi, q.preferences({ errors: { stack: !0 } }, Li || {}));
        let pr = Hi.error;
        if (!pr) return Hi.value;
        if (Ti instanceof Error) throw Ti;
        const Di = Wi && typeof pr.annotate == "function" ? pr.annotate() : pr.message;
        throw pr instanceof F.ValidationError == 0 && (pr = Y(pr)), pr.message = Ti ? `${Ti} ${Di}` : Di, pr;
      }, _r.generate = function(Bi, qi, Wi) {
        return D(Bi, "Must be invoked on a Joi instance."), qi.$_root = Bi, qi._definition.args && Wi.length ? qi._definition.args(qi, ...Wi) : qi;
      }, _r.expandExtension = function(Bi, qi) {
        if (typeof Bi.type == "string") return [Bi];
        const Wi = [];
        for (const Vi of qi._types) if (Bi.type.test(Vi)) {
          const Ti = Object.assign({}, Bi);
          Ti.type = Vi, Ti.base = qi[Vi](), Wi.push(Ti);
        }
        return Wi;
      }, T.exports = _r.root();
    }, 6914: (T, x, C) => {
      const D = C(375), Y = C(8571), L = C(3328);
      x.compile = function(q, N) {
        if (typeof q == "string") return D(!N, "Cannot set single message string"), new L(q);
        if (L.isTemplate(q)) return D(!N, "Cannot set single message template"), q;
        D(typeof q == "object" && !Array.isArray(q), "Invalid message options"), N = N ? Y(N) : {};
        for (let F in q) {
          const ae = q[F];
          if (F === "root" || L.isTemplate(ae)) {
            N[F] = ae;
            continue;
          }
          if (typeof ae == "string") {
            N[F] = new L(ae);
            continue;
          }
          D(typeof ae == "object" && !Array.isArray(ae), "Invalid message for", F);
          const he = F;
          for (F in N[he] = N[he] || {}, ae) {
            const tt = ae[F];
            F === "root" || L.isTemplate(tt) ? N[he][F] = tt : (D(typeof tt == "string", "Invalid message for", F, "in", he), N[he][F] = new L(tt));
          }
        }
        return N;
      }, x.decompile = function(q) {
        const N = {};
        for (let F in q) {
          const ae = q[F];
          if (F === "root") {
            N.root = ae;
            continue;
          }
          if (L.isTemplate(ae)) {
            N[F] = ae.describe({ compact: !0 });
            continue;
          }
          const he = F;
          for (F in N[he] = {}, ae) {
            const tt = ae[F];
            F !== "root" ? N[he][F] = tt.describe({ compact: !0 }) : N[he].root = tt;
          }
        }
        return N;
      }, x.merge = function(q, N) {
        if (!q) return x.compile(N);
        if (!N) return q;
        if (typeof N == "string") return new L(N);
        if (L.isTemplate(N)) return N;
        const F = Y(q);
        for (let ae in N) {
          const he = N[ae];
          if (ae === "root" || L.isTemplate(he)) {
            F[ae] = he;
            continue;
          }
          if (typeof he == "string") {
            F[ae] = new L(he);
            continue;
          }
          D(typeof he == "object" && !Array.isArray(he), "Invalid message for", ae);
          const tt = ae;
          for (ae in F[tt] = F[tt] || {}, he) {
            const br = he[ae];
            ae === "root" || L.isTemplate(br) ? F[tt][ae] = br : (D(typeof br == "string", "Invalid message for", ae, "in", tt), F[tt][ae] = new L(br));
          }
        }
        return F;
      };
    }, 2294: (T, x, C) => {
      const D = C(375), Y = C(8160), L = C(6133), q = {};
      x.Ids = q.Ids = class {
        constructor() {
          this._byId = /* @__PURE__ */ new Map(), this._byKey = /* @__PURE__ */ new Map(), this._schemaChain = !1;
        }
        clone() {
          const N = new q.Ids();
          return N._byId = new Map(this._byId), N._byKey = new Map(this._byKey), N._schemaChain = this._schemaChain, N;
        }
        concat(N) {
          N._schemaChain && (this._schemaChain = !0);
          for (const [F, ae] of N._byId.entries()) D(!this._byKey.has(F), "Schema id conflicts with existing key:", F), this._byId.set(F, ae);
          for (const [F, ae] of N._byKey.entries()) D(!this._byId.has(F), "Schema key conflicts with existing id:", F), this._byKey.set(F, ae);
        }
        fork(N, F, ae) {
          const he = this._collect(N);
          he.push({ schema: ae });
          const tt = he.shift();
          let br = { id: tt.id, schema: F(tt.schema) };
          D(Y.isSchema(br.schema), "adjuster function failed to return a joi schema type");
          for (const rt of he) br = { id: rt.id, schema: q.fork(rt.schema, br.id, br.schema) };
          return br.schema;
        }
        labels(N, F = []) {
          const ae = N[0], he = this._get(ae);
          if (!he) return [...F, ...N].join(".");
          const tt = N.slice(1);
          return F = [...F, he.schema._flags.label || ae], tt.length ? he.schema._ids.labels(tt, F) : F.join(".");
        }
        reach(N, F = []) {
          const ae = N[0], he = this._get(ae);
          D(he, "Schema does not contain path", [...F, ...N].join("."));
          const tt = N.slice(1);
          return tt.length ? he.schema._ids.reach(tt, [...F, ae]) : he.schema;
        }
        register(N, { key: F } = {}) {
          if (!N || !Y.isSchema(N)) return;
          (N.$_property("schemaChain") || N._ids._schemaChain) && (this._schemaChain = !0);
          const ae = N._flags.id;
          if (ae) {
            const he = this._byId.get(ae);
            D(!he || he.schema === N, "Cannot add different schemas with the same id:", ae), D(!this._byKey.has(ae), "Schema id conflicts with existing key:", ae), this._byId.set(ae, { schema: N, id: ae });
          }
          F && (D(!this._byKey.has(F), "Schema already contains key:", F), D(!this._byId.has(F), "Schema key conflicts with existing id:", F), this._byKey.set(F, { schema: N, id: F }));
        }
        reset() {
          this._byId = /* @__PURE__ */ new Map(), this._byKey = /* @__PURE__ */ new Map(), this._schemaChain = !1;
        }
        _collect(N, F = [], ae = []) {
          const he = N[0], tt = this._get(he);
          D(tt, "Schema does not contain path", [...F, ...N].join(".")), ae = [tt, ...ae];
          const br = N.slice(1);
          return br.length ? tt.schema._ids._collect(br, [...F, he], ae) : ae;
        }
        _get(N) {
          return this._byId.get(N) || this._byKey.get(N);
        }
      }, q.fork = function(N, F, ae) {
        const he = x.schema(N, { each: (tt, { key: br }) => {
          if (F === (tt._flags.id || br)) return ae;
        }, ref: !1 });
        return he ? he.$_mutateRebuild() : N;
      }, x.schema = function(N, F) {
        let ae;
        for (const he in N._flags) {
          if (he[0] === "_") continue;
          const tt = q.scan(N._flags[he], { source: "flags", name: he }, F);
          tt !== void 0 && (ae = ae || N.clone(), ae._flags[he] = tt);
        }
        for (let he = 0; he < N._rules.length; ++he) {
          const tt = N._rules[he], br = q.scan(tt.args, { source: "rules", name: tt.name }, F);
          if (br !== void 0) {
            ae = ae || N.clone();
            const rt = Object.assign({}, tt);
            rt.args = br, ae._rules[he] = rt, ae._singleRules.get(tt.name) === tt && ae._singleRules.set(tt.name, rt);
          }
        }
        for (const he in N.$_terms) {
          if (he[0] === "_") continue;
          const tt = q.scan(N.$_terms[he], { source: "terms", name: he }, F);
          tt !== void 0 && (ae = ae || N.clone(), ae.$_terms[he] = tt);
        }
        return ae;
      }, q.scan = function(N, F, ae, he, tt) {
        const br = he || [];
        if (N === null || typeof N != "object") return;
        let rt;
        if (Array.isArray(N)) {
          for (let dr = 0; dr < N.length; ++dr) {
            const _r = F.source === "terms" && F.name === "keys" && N[dr].key, Bi = q.scan(N[dr], F, ae, [dr, ...br], _r);
            Bi !== void 0 && (rt = rt || N.slice(), rt[dr] = Bi);
          }
          return rt;
        }
        if (ae.schema !== !1 && Y.isSchema(N) || ae.ref !== !1 && L.isRef(N)) {
          const dr = ae.each(N, { ...F, path: br, key: tt });
          return dr === N ? void 0 : dr;
        }
        for (const dr in N) {
          if (dr[0] === "_") continue;
          const _r = q.scan(N[dr], F, ae, [dr, ...br], tt);
          _r !== void 0 && (rt = rt || Object.assign({}, N), rt[dr] = _r);
        }
        return rt;
      };
    }, 6133: (T, x, C) => {
      const D = C(375), Y = C(8571), L = C(9621), q = C(8160);
      let N;
      const F = { symbol: Symbol("ref"), defaults: { adjust: null, in: !1, iterables: null, map: null, separator: ".", type: "value" } };
      x.create = function(ae, he = {}) {
        D(typeof ae == "string", "Invalid reference key:", ae), q.assertOptions(he, ["adjust", "ancestor", "in", "iterables", "map", "prefix", "render", "separator"]), D(!he.prefix || typeof he.prefix == "object", "options.prefix must be of type object");
        const tt = Object.assign({}, F.defaults, he);
        delete tt.prefix;
        const br = tt.separator, rt = F.context(ae, br, he.prefix);
        if (tt.type = rt.type, ae = rt.key, tt.type === "value") if (rt.root && (D(!br || ae[0] !== br, "Cannot specify relative path with root prefix"), tt.ancestor = "root", ae || (ae = null)), br && br === ae) ae = null, tt.ancestor = 0;
        else if (tt.ancestor !== void 0) D(!br || !ae || ae[0] !== br, "Cannot combine prefix with ancestor option");
        else {
          const [dr, _r] = F.ancestor(ae, br);
          _r && (ae = ae.slice(_r)) === "" && (ae = null), tt.ancestor = dr;
        }
        return tt.path = br ? ae === null ? [] : ae.split(br) : [ae], new F.Ref(tt);
      }, x.in = function(ae, he = {}) {
        return x.create(ae, { ...he, in: !0 });
      }, x.isRef = function(ae) {
        return !!ae && !!ae[q.symbols.ref];
      }, F.Ref = class {
        constructor(ae) {
          D(typeof ae == "object", "Invalid reference construction"), q.assertOptions(ae, ["adjust", "ancestor", "in", "iterables", "map", "path", "render", "separator", "type", "depth", "key", "root", "display"]), D([!1, void 0].includes(ae.separator) || typeof ae.separator == "string" && ae.separator.length === 1, "Invalid separator"), D(!ae.adjust || typeof ae.adjust == "function", "options.adjust must be a function"), D(!ae.map || Array.isArray(ae.map), "options.map must be an array"), D(!ae.map || !ae.adjust, "Cannot set both map and adjust options"), Object.assign(this, F.defaults, ae), D(this.type === "value" || this.ancestor === void 0, "Non-value references cannot reference ancestors"), Array.isArray(this.map) && (this.map = new Map(this.map)), this.depth = this.path.length, this.key = this.path.length ? this.path.join(this.separator) : null, this.root = this.path[0], this.updateDisplay();
        }
        resolve(ae, he, tt, br, rt = {}) {
          return D(!this.in || rt.in, "Invalid in() reference usage"), this.type === "global" ? this._resolve(tt.context, he, rt) : this.type === "local" ? this._resolve(br, he, rt) : this.ancestor ? this.ancestor === "root" ? this._resolve(he.ancestors[he.ancestors.length - 1], he, rt) : (D(this.ancestor <= he.ancestors.length, "Invalid reference exceeds the schema root:", this.display), this._resolve(he.ancestors[this.ancestor - 1], he, rt)) : this._resolve(ae, he, rt);
        }
        _resolve(ae, he, tt) {
          let br;
          if (this.type === "value" && he.mainstay.shadow && tt.shadow !== !1 && (br = he.mainstay.shadow.get(this.absolute(he))), br === void 0 && (br = L(ae, this.path, { iterables: this.iterables, functions: !0 })), this.adjust && (br = this.adjust(br)), this.map) {
            const rt = this.map.get(br);
            rt !== void 0 && (br = rt);
          }
          return he.mainstay && he.mainstay.tracer.resolve(he, this, br), br;
        }
        toString() {
          return this.display;
        }
        absolute(ae) {
          return [...ae.path.slice(0, -this.ancestor), ...this.path];
        }
        clone() {
          return new F.Ref(this);
        }
        describe() {
          const ae = { path: this.path };
          this.type !== "value" && (ae.type = this.type), this.separator !== "." && (ae.separator = this.separator), this.type === "value" && this.ancestor !== 1 && (ae.ancestor = this.ancestor), this.map && (ae.map = [...this.map]);
          for (const he of ["adjust", "iterables", "render"]) this[he] !== null && this[he] !== void 0 && (ae[he] = this[he]);
          return this.in !== !1 && (ae.in = !0), { ref: ae };
        }
        updateDisplay() {
          const ae = this.key !== null ? this.key : "";
          if (this.type !== "value") return void (this.display = `ref:${this.type}:${ae}`);
          if (!this.separator) return void (this.display = `ref:${ae}`);
          if (!this.ancestor) return void (this.display = `ref:${this.separator}${ae}`);
          if (this.ancestor === "root") return void (this.display = `ref:root:${ae}`);
          if (this.ancestor === 1) return void (this.display = `ref:${ae || ".."}`);
          const he = new Array(this.ancestor + 1).fill(this.separator).join("");
          this.display = `ref:${he}${ae || ""}`;
        }
      }, F.Ref.prototype[q.symbols.ref] = !0, x.build = function(ae) {
        return (ae = Object.assign({}, F.defaults, ae)).type === "value" && ae.ancestor === void 0 && (ae.ancestor = 1), new F.Ref(ae);
      }, F.context = function(ae, he, tt = {}) {
        if (ae = ae.trim(), tt) {
          const br = tt.global === void 0 ? "$" : tt.global;
          if (br !== he && ae.startsWith(br)) return { key: ae.slice(br.length), type: "global" };
          const rt = tt.local === void 0 ? "#" : tt.local;
          if (rt !== he && ae.startsWith(rt)) return { key: ae.slice(rt.length), type: "local" };
          const dr = tt.root === void 0 ? "/" : tt.root;
          if (dr !== he && ae.startsWith(dr)) return { key: ae.slice(dr.length), type: "value", root: !0 };
        }
        return { key: ae, type: "value" };
      }, F.ancestor = function(ae, he) {
        if (!he) return [1, 0];
        if (ae[0] !== he) return [1, 0];
        if (ae[1] !== he) return [0, 1];
        let tt = 2;
        for (; ae[tt] === he; ) ++tt;
        return [tt - 1, tt];
      }, x.toSibling = 0, x.toParent = 1, x.Manager = class {
        constructor() {
          this.refs = [];
        }
        register(ae, he) {
          if (ae) if (he = he === void 0 ? x.toParent : he, Array.isArray(ae)) for (const tt of ae) this.register(tt, he);
          else if (q.isSchema(ae)) for (const tt of ae._refs.refs) tt.ancestor - he >= 0 && this.refs.push({ ancestor: tt.ancestor - he, root: tt.root });
          else x.isRef(ae) && ae.type === "value" && ae.ancestor - he >= 0 && this.refs.push({ ancestor: ae.ancestor - he, root: ae.root }), N = N || C(3328), N.isTemplate(ae) && this.register(ae.refs(), he);
        }
        get length() {
          return this.refs.length;
        }
        clone() {
          const ae = new x.Manager();
          return ae.refs = Y(this.refs), ae;
        }
        reset() {
          this.refs = [];
        }
        roots() {
          return this.refs.filter((ae) => !ae.ancestor).map((ae) => ae.root);
        }
      };
    }, 3378: (T, x, C) => {
      const D = C(5107), Y = {};
      Y.wrap = D.string().min(1).max(2).allow(!1), x.preferences = D.object({ allowUnknown: D.boolean(), abortEarly: D.boolean(), artifacts: D.boolean(), cache: D.boolean(), context: D.object(), convert: D.boolean(), dateFormat: D.valid("date", "iso", "string", "time", "utc"), debug: D.boolean(), errors: { escapeHtml: D.boolean(), label: D.valid("path", "key", !1), language: [D.string(), D.object().ref()], render: D.boolean(), stack: D.boolean(), wrap: { label: Y.wrap, array: Y.wrap, string: Y.wrap } }, externals: D.boolean(), messages: D.object(), noDefaults: D.boolean(), nonEnumerables: D.boolean(), presence: D.valid("required", "optional", "forbidden"), skipFunctions: D.boolean(), stripUnknown: D.object({ arrays: D.boolean(), objects: D.boolean() }).or("arrays", "objects").allow(!0, !1), warnings: D.boolean() }).strict(), Y.nameRx = /^[a-zA-Z0-9]\w*$/, Y.rule = D.object({ alias: D.array().items(D.string().pattern(Y.nameRx)).single(), args: D.array().items(D.string(), D.object({ name: D.string().pattern(Y.nameRx).required(), ref: D.boolean(), assert: D.alternatives([D.function(), D.object().schema()]).conditional("ref", { is: !0, then: D.required() }), normalize: D.function(), message: D.string().when("assert", { is: D.function(), then: D.required() }) })), convert: D.boolean(), manifest: D.boolean(), method: D.function().allow(!1), multi: D.boolean(), validate: D.function() }), x.extension = D.object({ type: D.alternatives([D.string(), D.object().regex()]).required(), args: D.function(), cast: D.object().pattern(Y.nameRx, D.object({ from: D.function().maxArity(1).required(), to: D.function().minArity(1).maxArity(2).required() })), base: D.object().schema().when("type", { is: D.object().regex(), then: D.forbidden() }), coerce: [D.function().maxArity(3), D.object({ method: D.function().maxArity(3).required(), from: D.array().items(D.string()).single() })], flags: D.object().pattern(Y.nameRx, D.object({ setter: D.string(), default: D.any() })), manifest: { build: D.function().arity(2) }, messages: [D.object(), D.string()], modifiers: D.object().pattern(Y.nameRx, D.function().minArity(1).maxArity(2)), overrides: D.object().pattern(Y.nameRx, D.function()), prepare: D.function().maxArity(3), rebuild: D.function().arity(1), rules: D.object().pattern(Y.nameRx, Y.rule), terms: D.object().pattern(Y.nameRx, D.object({ init: D.array().allow(null).required(), manifest: D.object().pattern(/.+/, [D.valid("schema", "single"), D.object({ mapped: D.object({ from: D.string().required(), to: D.string().required() }).required() })]) })), validate: D.function().maxArity(3) }).strict(), x.extensions = D.array().items(D.object(), D.function().arity(1)).strict(), Y.desc = { buffer: D.object({ buffer: D.string() }), func: D.object({ function: D.function().required(), options: { literal: !0 } }), override: D.object({ override: !0 }), ref: D.object({ ref: D.object({ type: D.valid("value", "global", "local"), path: D.array().required(), separator: D.string().length(1).allow(!1), ancestor: D.number().min(0).integer().allow("root"), map: D.array().items(D.array().length(2)).min(1), adjust: D.function(), iterables: D.boolean(), in: D.boolean(), render: D.boolean() }).required() }), regex: D.object({ regex: D.string().min(3) }), special: D.object({ special: D.valid("deep").required() }), template: D.object({ template: D.string().required(), options: D.object() }), value: D.object({ value: D.alternatives([D.object(), D.array()]).required() }) }, Y.desc.entity = D.alternatives([D.array().items(D.link("...")), D.boolean(), D.function(), D.number(), D.string(), Y.desc.buffer, Y.desc.func, Y.desc.ref, Y.desc.regex, Y.desc.special, Y.desc.template, Y.desc.value, D.link("/")]), Y.desc.values = D.array().items(null, D.boolean(), D.function(), D.number().allow(1 / 0, -1 / 0), D.string().allow(""), D.symbol(), Y.desc.buffer, Y.desc.func, Y.desc.override, Y.desc.ref, Y.desc.regex, Y.desc.template, Y.desc.value), Y.desc.messages = D.object().pattern(/.+/, [D.string(), Y.desc.template, D.object().pattern(/.+/, [D.string(), Y.desc.template])]), x.description = D.object({ type: D.string().required(), flags: D.object({ cast: D.string(), default: D.any(), description: D.string(), empty: D.link("/"), failover: Y.desc.entity, id: D.string(), label: D.string(), only: !0, presence: ["optional", "required", "forbidden"], result: ["raw", "strip"], strip: D.boolean(), unit: D.string() }).unknown(), preferences: { allowUnknown: D.boolean(), abortEarly: D.boolean(), artifacts: D.boolean(), cache: D.boolean(), convert: D.boolean(), dateFormat: ["date", "iso", "string", "time", "utc"], errors: { escapeHtml: D.boolean(), label: ["path", "key"], language: [D.string(), Y.desc.ref], wrap: { label: Y.wrap, array: Y.wrap } }, externals: D.boolean(), messages: Y.desc.messages, noDefaults: D.boolean(), nonEnumerables: D.boolean(), presence: ["required", "optional", "forbidden"], skipFunctions: D.boolean(), stripUnknown: D.object({ arrays: D.boolean(), objects: D.boolean() }).or("arrays", "objects").allow(!0, !1), warnings: D.boolean() }, allow: Y.desc.values, invalid: Y.desc.values, rules: D.array().min(1).items({ name: D.string().required(), args: D.object().min(1), keep: D.boolean(), message: [D.string(), Y.desc.messages], warn: D.boolean() }), keys: D.object().pattern(/.*/, D.link("/")), link: Y.desc.ref }).pattern(/^[a-z]\w*$/, D.any());
    }, 493: (T, x, C) => {
      const D = C(8571), Y = C(9621), L = C(8160), q = { value: Symbol("value") };
      T.exports = q.State = class {
        constructor(N, F, ae) {
          this.path = N, this.ancestors = F, this.mainstay = ae.mainstay, this.schemas = ae.schemas, this.debug = null;
        }
        localize(N, F = null, ae = null) {
          const he = new q.State(N, F, this);
          return ae && he.schemas && (he.schemas = [q.schemas(ae), ...he.schemas]), he;
        }
        nest(N, F) {
          const ae = new q.State(this.path, this.ancestors, this);
          return ae.schemas = ae.schemas && [q.schemas(N), ...ae.schemas], ae.debug = F, ae;
        }
        shadow(N, F) {
          this.mainstay.shadow = this.mainstay.shadow || new q.Shadow(), this.mainstay.shadow.set(this.path, N, F);
        }
        snapshot() {
          this.mainstay.shadow && (this._snapshot = D(this.mainstay.shadow.node(this.path))), this.mainstay.snapshot();
        }
        restore() {
          this.mainstay.shadow && (this.mainstay.shadow.override(this.path, this._snapshot), this._snapshot = void 0), this.mainstay.restore();
        }
        commit() {
          this.mainstay.shadow && (this.mainstay.shadow.override(this.path, this._snapshot), this._snapshot = void 0), this.mainstay.commit();
        }
      }, q.schemas = function(N) {
        return L.isSchema(N) ? { schema: N } : N;
      }, q.Shadow = class {
        constructor() {
          this._values = null;
        }
        set(N, F, ae) {
          if (!N.length || ae === "strip" && typeof N[N.length - 1] == "number") return;
          this._values = this._values || /* @__PURE__ */ new Map();
          let he = this._values;
          for (let tt = 0; tt < N.length; ++tt) {
            const br = N[tt];
            let rt = he.get(br);
            rt || (rt = /* @__PURE__ */ new Map(), he.set(br, rt)), he = rt;
          }
          he[q.value] = F;
        }
        get(N) {
          const F = this.node(N);
          if (F) return F[q.value];
        }
        node(N) {
          if (this._values) return Y(this._values, N, { iterables: !0 });
        }
        override(N, F) {
          if (!this._values) return;
          const ae = N.slice(0, -1), he = N[N.length - 1], tt = Y(this._values, ae, { iterables: !0 });
          F ? tt.set(he, F) : tt && tt.delete(he);
        }
      };
    }, 3328: (T, x, C) => {
      const D = C(375), Y = C(8571), L = C(5277), q = C(1447), N = C(8160), F = C(6354), ae = C(6133), he = { symbol: Symbol("template"), opens: new Array(1e3).join("\0"), closes: new Array(1e3).join(""), dateFormat: { date: Date.prototype.toDateString, iso: Date.prototype.toISOString, string: Date.prototype.toString, time: Date.prototype.toTimeString, utc: Date.prototype.toUTCString } };
      T.exports = he.Template = class {
        constructor(tt, br) {
          if (D(typeof tt == "string", "Template source must be a string"), D(!tt.includes("\0") && !tt.includes(""), "Template source cannot contain reserved control characters"), this.source = tt, this.rendered = tt, this._template = null, br) {
            const { functions: rt, ...dr } = br;
            this._settings = Object.keys(dr).length ? Y(dr) : void 0, this._functions = rt, this._functions && (D(Object.keys(this._functions).every((_r) => typeof _r == "string"), "Functions keys must be strings"), D(Object.values(this._functions).every((_r) => typeof _r == "function"), "Functions values must be functions"));
          } else this._settings = void 0, this._functions = void 0;
          this._parse();
        }
        _parse() {
          if (!this.source.includes("{")) return;
          const tt = he.encode(this.source), br = he.split(tt);
          let rt = !1;
          const dr = [], _r = br.shift();
          _r && dr.push(_r);
          for (const Bi of br) {
            const qi = Bi[0] !== "{", Wi = qi ? "}" : "}}", Vi = Bi.indexOf(Wi);
            if (Vi === -1 || Bi[1] === "{") {
              dr.push(`{${he.decode(Bi)}`);
              continue;
            }
            let Ti = Bi.slice(qi ? 0 : 1, Vi);
            const Li = Ti[0] === ":";
            Li && (Ti = Ti.slice(1));
            const Hi = this._ref(he.decode(Ti), { raw: qi, wrapped: Li });
            dr.push(Hi), typeof Hi != "string" && (rt = !0);
            const pr = Bi.slice(Vi + Wi.length);
            pr && dr.push(he.decode(pr));
          }
          rt ? this._template = dr : this.rendered = dr.join("");
        }
        static date(tt, br) {
          return he.dateFormat[br.dateFormat].call(tt);
        }
        describe(tt = {}) {
          if (!this._settings && tt.compact) return this.source;
          const br = { template: this.source };
          return this._settings && (br.options = this._settings), this._functions && (br.functions = this._functions), br;
        }
        static build(tt) {
          return new he.Template(tt.template, tt.options || tt.functions ? { ...tt.options, functions: tt.functions } : void 0);
        }
        isDynamic() {
          return !!this._template;
        }
        static isTemplate(tt) {
          return !!tt && !!tt[N.symbols.template];
        }
        refs() {
          if (!this._template) return;
          const tt = [];
          for (const br of this._template) typeof br != "string" && tt.push(...br.refs);
          return tt;
        }
        resolve(tt, br, rt, dr) {
          return this._template && this._template.length === 1 ? this._part(this._template[0], tt, br, rt, dr, {}) : this.render(tt, br, rt, dr);
        }
        _part(tt, ...br) {
          return tt.ref ? tt.ref.resolve(...br) : tt.formula.evaluate(br);
        }
        render(tt, br, rt, dr, _r = {}) {
          if (!this.isDynamic()) return this.rendered;
          const Bi = [];
          for (const qi of this._template) if (typeof qi == "string") Bi.push(qi);
          else {
            const Wi = this._part(qi, tt, br, rt, dr, _r), Vi = he.stringify(Wi, tt, br, rt, dr, _r);
            if (Vi !== void 0) {
              const Ti = qi.raw || (_r.errors && _r.errors.escapeHtml) === !1 ? Vi : L(Vi);
              Bi.push(he.wrap(Ti, qi.wrapped && rt.errors.wrap.label));
            }
          }
          return Bi.join("");
        }
        _ref(tt, { raw: br, wrapped: rt }) {
          const dr = [], _r = (qi) => {
            const Wi = ae.create(qi, this._settings);
            return dr.push(Wi), (Vi) => {
              const Ti = Wi.resolve(...Vi);
              return Ti !== void 0 ? Ti : null;
            };
          };
          try {
            const qi = this._functions ? { ...he.functions, ...this._functions } : he.functions;
            var Bi = new q.Parser(tt, { reference: _r, functions: qi, constants: he.constants });
          } catch (qi) {
            throw qi.message = `Invalid template variable "${tt}" fails due to: ${qi.message}`, qi;
          }
          if (Bi.single) {
            if (Bi.single.type === "reference") {
              const qi = dr[0];
              return { ref: qi, raw: br, refs: dr, wrapped: rt || qi.type === "local" && qi.key === "label" };
            }
            return he.stringify(Bi.single.value);
          }
          return { formula: Bi, raw: br, refs: dr };
        }
        toString() {
          return this.source;
        }
      }, he.Template.prototype[N.symbols.template] = !0, he.Template.prototype.isImmutable = !0, he.encode = function(tt) {
        return tt.replace(/\\(\{+)/g, (br, rt) => he.opens.slice(0, rt.length)).replace(/\\(\}+)/g, (br, rt) => he.closes.slice(0, rt.length));
      }, he.decode = function(tt) {
        return tt.replace(/\u0000/g, "{").replace(/\u0001/g, "}");
      }, he.split = function(tt) {
        const br = [];
        let rt = "";
        for (let dr = 0; dr < tt.length; ++dr) {
          const _r = tt[dr];
          if (_r === "{") {
            let Bi = "";
            for (; dr + 1 < tt.length && tt[dr + 1] === "{"; ) Bi += "{", ++dr;
            br.push(rt), rt = Bi;
          } else rt += _r;
        }
        return br.push(rt), br;
      }, he.wrap = function(tt, br) {
        return br ? br.length === 1 ? `${br}${tt}${br}` : `${br[0]}${tt}${br[1]}` : tt;
      }, he.stringify = function(tt, br, rt, dr, _r, Bi = {}) {
        const qi = typeof tt, Wi = dr && dr.errors && dr.errors.wrap || {};
        let Vi = !1;
        if (ae.isRef(tt) && tt.render && (Vi = tt.in, tt = tt.resolve(br, rt, dr, _r, { in: tt.in, ...Bi })), tt === null) return "null";
        if (qi === "string") return he.wrap(tt, Bi.arrayItems && Wi.string);
        if (qi === "number" || qi === "function" || qi === "symbol") return tt.toString();
        if (qi !== "object") return JSON.stringify(tt);
        if (tt instanceof Date) return he.Template.date(tt, dr);
        if (tt instanceof Map) {
          const Li = [];
          for (const [Hi, pr] of tt.entries()) Li.push(`${Hi.toString()} -> ${pr.toString()}`);
          tt = Li;
        }
        if (!Array.isArray(tt)) return tt.toString();
        const Ti = [];
        for (const Li of tt) Ti.push(he.stringify(Li, br, rt, dr, _r, { arrayItems: !0, ...Bi }));
        return he.wrap(Ti.join(", "), !Vi && Wi.array);
      }, he.constants = { true: !0, false: !1, null: null, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5 }, he.functions = { if: (tt, br, rt) => tt ? br : rt, length: (tt) => typeof tt == "string" ? tt.length : tt && typeof tt == "object" ? Array.isArray(tt) ? tt.length : Object.keys(tt).length : null, msg(tt) {
        const [br, rt, dr, _r, Bi] = this, qi = Bi.messages;
        if (!qi) return "";
        const Wi = F.template(br, qi[0], tt, rt, dr) || F.template(br, qi[1], tt, rt, dr);
        return Wi ? Wi.render(br, rt, dr, _r, Bi) : "";
      }, number: (tt) => typeof tt == "number" ? tt : typeof tt == "string" ? parseFloat(tt) : typeof tt == "boolean" ? tt ? 1 : 0 : tt instanceof Date ? tt.getTime() : null };
    }, 4946: (T, x, C) => {
      const D = C(375), Y = C(1687), L = C(8068), q = C(8160), N = C(3292), F = C(6354), ae = C(6133), he = {};
      T.exports = L.extend({ type: "alternatives", flags: { match: { default: "any" } }, terms: { matches: { init: [], register: ae.toSibling } }, args: (tt, ...br) => br.length === 1 && Array.isArray(br[0]) ? tt.try(...br[0]) : tt.try(...br), validate(tt, br) {
        const { schema: rt, error: dr, state: _r, prefs: Bi } = br;
        if (rt._flags.match) {
          const Wi = [], Vi = [];
          for (let Li = 0; Li < rt.$_terms.matches.length; ++Li) {
            const Hi = rt.$_terms.matches[Li], pr = _r.nest(Hi.schema, `match.${Li}`);
            pr.snapshot();
            const Di = Hi.schema.$_validate(tt, pr, Bi);
            Di.errors ? (Vi.push(Di.errors), pr.restore()) : (Wi.push(Di.value), pr.commit());
          }
          if (Wi.length === 0) return { errors: dr("alternatives.any", { details: Vi.map((Li) => F.details(Li, { override: !1 })) }) };
          if (rt._flags.match === "one") return Wi.length === 1 ? { value: Wi[0] } : { errors: dr("alternatives.one") };
          if (Wi.length !== rt.$_terms.matches.length) return { errors: dr("alternatives.all", { details: Vi.map((Li) => F.details(Li, { override: !1 })) }) };
          const Ti = (Li) => Li.$_terms.matches.some((Hi) => Hi.schema.type === "object" || Hi.schema.type === "alternatives" && Ti(Hi.schema));
          return Ti(rt) ? { value: Wi.reduce((Li, Hi) => Y(Li, Hi, { mergeArrays: !1 })) } : { value: Wi[Wi.length - 1] };
        }
        const qi = [];
        for (let Wi = 0; Wi < rt.$_terms.matches.length; ++Wi) {
          const Vi = rt.$_terms.matches[Wi];
          if (Vi.schema) {
            const Hi = _r.nest(Vi.schema, `match.${Wi}`);
            Hi.snapshot();
            const pr = Vi.schema.$_validate(tt, Hi, Bi);
            if (!pr.errors) return Hi.commit(), pr;
            Hi.restore(), qi.push({ schema: Vi.schema, reports: pr.errors });
            continue;
          }
          const Ti = Vi.ref ? Vi.ref.resolve(tt, _r, Bi) : tt, Li = Vi.is ? [Vi] : Vi.switch;
          for (let Hi = 0; Hi < Li.length; ++Hi) {
            const pr = Li[Hi], { is: Di, then: z, otherwise: gr } = pr, vr = `match.${Wi}${Vi.switch ? "." + Hi : ""}`;
            if (Di.$_match(Ti, _r.nest(Di, `${vr}.is`), Bi)) {
              if (z) return z.$_validate(tt, _r.nest(z, `${vr}.then`), Bi);
            } else if (gr) return gr.$_validate(tt, _r.nest(gr, `${vr}.otherwise`), Bi);
          }
        }
        return he.errors(qi, br);
      }, rules: { conditional: { method(tt, br) {
        D(!this._flags._endedSwitch, "Unreachable condition"), D(!this._flags.match, "Cannot combine match mode", this._flags.match, "with conditional rule"), D(br.break === void 0, "Cannot use break option with alternatives conditional");
        const rt = this.clone(), dr = N.when(rt, tt, br), _r = dr.is ? [dr] : dr.switch;
        for (const Bi of _r) if (Bi.then && Bi.otherwise) {
          rt.$_setFlag("_endedSwitch", !0, { clone: !1 });
          break;
        }
        return rt.$_terms.matches.push(dr), rt.$_mutateRebuild();
      } }, match: { method(tt) {
        if (D(["any", "one", "all"].includes(tt), "Invalid alternatives match mode", tt), tt !== "any") for (const br of this.$_terms.matches) D(br.schema, "Cannot combine match mode", tt, "with conditional rules");
        return this.$_setFlag("match", tt);
      } }, try: { method(...tt) {
        D(tt.length, "Missing alternative schemas"), q.verifyFlat(tt, "try"), D(!this._flags._endedSwitch, "Unreachable condition");
        const br = this.clone();
        for (const rt of tt) br.$_terms.matches.push({ schema: br.$_compile(rt) });
        return br.$_mutateRebuild();
      } } }, overrides: { label(tt) {
        return this.$_parent("label", tt).$_modify({ each: (br, rt) => rt.path[0] !== "is" && typeof br._flags.label != "string" ? br.label(tt) : void 0, ref: !1 });
      } }, rebuild(tt) {
        tt.$_modify({ each: (br) => {
          q.isSchema(br) && br.type === "array" && tt.$_setFlag("_arrayItems", !0, { clone: !1 });
        } });
      }, manifest: { build(tt, br) {
        if (br.matches) for (const rt of br.matches) {
          const { schema: dr, ref: _r, is: Bi, not: qi, then: Wi, otherwise: Vi } = rt;
          tt = dr ? tt.try(dr) : _r ? tt.conditional(_r, { is: Bi, then: Wi, not: qi, otherwise: Vi, switch: rt.switch }) : tt.conditional(Bi, { then: Wi, otherwise: Vi });
        }
        return tt;
      } }, messages: { "alternatives.all": "{{#label}} does not match all of the required types", "alternatives.any": "{{#label}} does not match any of the allowed types", "alternatives.match": "{{#label}} does not match any of the allowed types", "alternatives.one": "{{#label}} matches more than one allowed type", "alternatives.types": "{{#label}} must be one of {{#types}}" } }), he.errors = function(tt, { error: br, state: rt }) {
        if (!tt.length) return { errors: br("alternatives.any") };
        if (tt.length === 1) return { errors: tt[0].reports };
        const dr = /* @__PURE__ */ new Set(), _r = [];
        for (const { reports: Bi, schema: qi } of tt) {
          if (Bi.length > 1) return he.unmatched(tt, br);
          const Wi = Bi[0];
          if (Wi instanceof F.Report == 0) return he.unmatched(tt, br);
          if (Wi.state.path.length !== rt.path.length) {
            _r.push({ type: qi.type, report: Wi });
            continue;
          }
          if (Wi.code === "any.only") {
            for (const Li of Wi.local.valids) dr.add(Li);
            continue;
          }
          const [Vi, Ti] = Wi.code.split(".");
          Ti !== "base" ? _r.push({ type: qi.type, report: Wi }) : Wi.code === "object.base" ? dr.add(Wi.local.type) : dr.add(Vi);
        }
        return _r.length ? _r.length === 1 ? { errors: _r[0].report } : he.unmatched(tt, br) : { errors: br("alternatives.types", { types: [...dr] }) };
      }, he.unmatched = function(tt, br) {
        const rt = [];
        for (const dr of tt) rt.push(...dr.reports);
        return { errors: br("alternatives.match", F.details(rt, { override: !1 })) };
      };
    }, 8068: (T, x, C) => {
      const D = C(375), Y = C(7629), L = C(8160), q = C(6914);
      T.exports = Y.extend({ type: "any", flags: { only: { default: !1 } }, terms: { alterations: { init: null }, examples: { init: null }, externals: { init: null }, metas: { init: [] }, notes: { init: [] }, shared: { init: null }, tags: { init: [] }, whens: { init: null } }, rules: { custom: { method(N, F) {
        return D(typeof N == "function", "Method must be a function"), D(F === void 0 || F && typeof F == "string", "Description must be a non-empty string"), this.$_addRule({ name: "custom", args: { method: N, description: F } });
      }, validate(N, F, { method: ae }) {
        try {
          return ae(N, F);
        } catch (he) {
          return F.error("any.custom", { error: he });
        }
      }, args: ["method", "description"], multi: !0 }, messages: { method(N) {
        return this.prefs({ messages: N });
      } }, shared: { method(N) {
        D(L.isSchema(N) && N._flags.id, "Schema must be a schema with an id");
        const F = this.clone();
        return F.$_terms.shared = F.$_terms.shared || [], F.$_terms.shared.push(N), F.$_mutateRegister(N), F;
      } }, warning: { method(N, F) {
        return D(N && typeof N == "string", "Invalid warning code"), this.$_addRule({ name: "warning", args: { code: N, local: F }, warn: !0 });
      }, validate: (N, F, { code: ae, local: he }) => F.error(ae, he), args: ["code", "local"], multi: !0 } }, modifiers: { keep(N, F = !0) {
        N.keep = F;
      }, message(N, F) {
        N.message = q.compile(F);
      }, warn(N, F = !0) {
        N.warn = F;
      } }, manifest: { build(N, F) {
        for (const ae in F) {
          const he = F[ae];
          if (["examples", "externals", "metas", "notes", "tags"].includes(ae)) for (const tt of he) N = N[ae.slice(0, -1)](tt);
          else if (ae !== "alterations") if (ae !== "whens") {
            if (ae === "shared") for (const tt of he) N = N.shared(tt);
          } else for (const tt of he) {
            const { ref: br, is: rt, not: dr, then: _r, otherwise: Bi, concat: qi } = tt;
            N = qi ? N.concat(qi) : br ? N.when(br, { is: rt, not: dr, then: _r, otherwise: Bi, switch: tt.switch, break: tt.break }) : N.when(rt, { then: _r, otherwise: Bi, break: tt.break });
          }
          else {
            const tt = {};
            for (const { target: br, adjuster: rt } of he) tt[br] = rt;
            N = N.alter(tt);
          }
        }
        return N;
      } }, messages: { "any.custom": "{{#label}} failed custom validation because {{#error.message}}", "any.default": "{{#label}} threw an error when running default method", "any.failover": "{{#label}} threw an error when running failover method", "any.invalid": "{{#label}} contains an invalid value", "any.only": '{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}', "any.ref": "{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}", "any.required": "{{#label}} is required", "any.unknown": "{{#label}} is not allowed" } });
    }, 546: (T, x, C) => {
      const D = C(375), Y = C(9474), L = C(9621), q = C(8068), N = C(8160), F = C(3292), ae = {};
      T.exports = q.extend({ type: "array", flags: { single: { default: !1 }, sparse: { default: !1 } }, terms: { items: { init: [], manifest: "schema" }, ordered: { init: [], manifest: "schema" }, _exclusions: { init: [] }, _inclusions: { init: [] }, _requireds: { init: [] } }, coerce: { from: "object", method(he, { schema: tt, state: br, prefs: rt }) {
        if (!Array.isArray(he)) return;
        const dr = tt.$_getRule("sort");
        return dr ? ae.sort(tt, he, dr.args.options, br, rt) : void 0;
      } }, validate(he, { schema: tt, error: br }) {
        if (!Array.isArray(he)) {
          if (tt._flags.single) {
            const rt = [he];
            return rt[N.symbols.arraySingle] = !0, { value: rt };
          }
          return { errors: br("array.base") };
        }
        if (tt.$_getRule("items") || tt.$_terms.externals) return { value: he.slice() };
      }, rules: { has: { method(he) {
        he = this.$_compile(he, { appendPath: !0 });
        const tt = this.$_addRule({ name: "has", args: { schema: he } });
        return tt.$_mutateRegister(he), tt;
      }, validate(he, { state: tt, prefs: br, error: rt }, { schema: dr }) {
        const _r = [he, ...tt.ancestors];
        for (let qi = 0; qi < he.length; ++qi) {
          const Wi = tt.localize([...tt.path, qi], _r, dr);
          if (dr.$_match(he[qi], Wi, br)) return he;
        }
        const Bi = dr._flags.label;
        return Bi ? rt("array.hasKnown", { patternLabel: Bi }) : rt("array.hasUnknown", null);
      }, multi: !0 }, items: { method(...he) {
        N.verifyFlat(he, "items");
        const tt = this.$_addRule("items");
        for (let br = 0; br < he.length; ++br) {
          const rt = N.tryWithPath(() => this.$_compile(he[br]), br, { append: !0 });
          tt.$_terms.items.push(rt);
        }
        return tt.$_mutateRebuild();
      }, validate(he, { schema: tt, error: br, state: rt, prefs: dr, errorsArray: _r }) {
        const Bi = tt.$_terms._requireds.slice(), qi = tt.$_terms.ordered.slice(), Wi = [...tt.$_terms._inclusions, ...Bi], Vi = !he[N.symbols.arraySingle];
        delete he[N.symbols.arraySingle];
        const Ti = _r();
        let Li = he.length;
        for (let Hi = 0; Hi < Li; ++Hi) {
          const pr = he[Hi];
          let Di = !1, z = !1;
          const gr = Vi ? Hi : new Number(Hi), vr = [...rt.path, gr];
          if (!tt._flags.sparse && pr === void 0) {
            if (Ti.push(br("array.sparse", { key: gr, path: vr, pos: Hi, value: void 0 }, rt.localize(vr))), dr.abortEarly) return Ti;
            qi.shift();
            continue;
          }
          const Oi = [he, ...rt.ancestors];
          for (const xi of tt.$_terms._exclusions) if (xi.$_match(pr, rt.localize(vr, Oi, xi), dr, { presence: "ignore" })) {
            if (Ti.push(br("array.excludes", { pos: Hi, value: pr }, rt.localize(vr))), dr.abortEarly) return Ti;
            Di = !0, qi.shift();
            break;
          }
          if (Di) continue;
          if (tt.$_terms.ordered.length) {
            if (qi.length) {
              const xi = qi.shift(), Si = xi.$_validate(pr, rt.localize(vr, Oi, xi), dr);
              if (Si.errors) {
                if (Ti.push(...Si.errors), dr.abortEarly) return Ti;
              } else if (xi._flags.result === "strip") ae.fastSplice(he, Hi), --Hi, --Li;
              else {
                if (!tt._flags.sparse && Si.value === void 0) {
                  if (Ti.push(br("array.sparse", { key: gr, path: vr, pos: Hi, value: void 0 }, rt.localize(vr))), dr.abortEarly) return Ti;
                  continue;
                }
                he[Hi] = Si.value;
              }
              continue;
            }
            if (!tt.$_terms.items.length) {
              if (Ti.push(br("array.orderedLength", { pos: Hi, limit: tt.$_terms.ordered.length })), dr.abortEarly) return Ti;
              break;
            }
          }
          const Mi = [];
          let ki = Bi.length;
          for (let xi = 0; xi < ki; ++xi) {
            const Si = rt.localize(vr, Oi, Bi[xi]);
            Si.snapshot();
            const Ci = Bi[xi].$_validate(pr, Si, dr);
            if (Mi[xi] = Ci, !Ci.errors) {
              if (Si.commit(), he[Hi] = Ci.value, z = !0, ae.fastSplice(Bi, xi), --xi, --ki, !tt._flags.sparse && Ci.value === void 0 && (Ti.push(br("array.sparse", { key: gr, path: vr, pos: Hi, value: void 0 }, rt.localize(vr))), dr.abortEarly)) return Ti;
              break;
            }
            Si.restore();
          }
          if (z) continue;
          const yr = dr.stripUnknown && !!dr.stripUnknown.arrays || !1;
          ki = Wi.length;
          for (const xi of Wi) {
            let Si;
            const Ci = Bi.indexOf(xi);
            if (Ci !== -1) Si = Mi[Ci];
            else {
              const Ki = rt.localize(vr, Oi, xi);
              if (Ki.snapshot(), Si = xi.$_validate(pr, Ki, dr), !Si.errors) {
                Ki.commit(), xi._flags.result === "strip" ? (ae.fastSplice(he, Hi), --Hi, --Li) : tt._flags.sparse || Si.value !== void 0 ? he[Hi] = Si.value : (Ti.push(br("array.sparse", { key: gr, path: vr, pos: Hi, value: void 0 }, rt.localize(vr))), Di = !0), z = !0;
                break;
              }
              Ki.restore();
            }
            if (ki === 1) {
              if (yr) {
                ae.fastSplice(he, Hi), --Hi, --Li, z = !0;
                break;
              }
              if (Ti.push(...Si.errors), dr.abortEarly) return Ti;
              Di = !0;
              break;
            }
          }
          if (!Di && (tt.$_terms._inclusions.length || tt.$_terms._requireds.length) && !z) {
            if (yr) {
              ae.fastSplice(he, Hi), --Hi, --Li;
              continue;
            }
            if (Ti.push(br("array.includes", { pos: Hi, value: pr }, rt.localize(vr))), dr.abortEarly) return Ti;
          }
        }
        return Bi.length && ae.fillMissedErrors(tt, Ti, Bi, he, rt, dr), qi.length && (ae.fillOrderedErrors(tt, Ti, qi, he, rt, dr), Ti.length || ae.fillDefault(qi, he, rt, dr)), Ti.length ? Ti : he;
      }, priority: !0, manifest: !1 }, length: { method(he) {
        return this.$_addRule({ name: "length", args: { limit: he }, operator: "=" });
      }, validate: (he, tt, { limit: br }, { name: rt, operator: dr, args: _r }) => N.compare(he.length, br, dr) ? he : tt.error("array." + rt, { limit: _r.limit, value: he }), args: [{ name: "limit", ref: !0, assert: N.limit, message: "must be a positive integer" }] }, max: { method(he) {
        return this.$_addRule({ name: "max", method: "length", args: { limit: he }, operator: "<=" });
      } }, min: { method(he) {
        return this.$_addRule({ name: "min", method: "length", args: { limit: he }, operator: ">=" });
      } }, ordered: { method(...he) {
        N.verifyFlat(he, "ordered");
        const tt = this.$_addRule("items");
        for (let br = 0; br < he.length; ++br) {
          const rt = N.tryWithPath(() => this.$_compile(he[br]), br, { append: !0 });
          ae.validateSingle(rt, tt), tt.$_mutateRegister(rt), tt.$_terms.ordered.push(rt);
        }
        return tt.$_mutateRebuild();
      } }, single: { method(he) {
        const tt = he === void 0 || !!he;
        return D(!tt || !this._flags._arrayItems, "Cannot specify single rule when array has array items"), this.$_setFlag("single", tt);
      } }, sort: { method(he = {}) {
        N.assertOptions(he, ["by", "order"]);
        const tt = { order: he.order || "ascending" };
        return he.by && (tt.by = F.ref(he.by, { ancestor: 0 }), D(!tt.by.ancestor, "Cannot sort by ancestor")), this.$_addRule({ name: "sort", args: { options: tt } });
      }, validate(he, { error: tt, state: br, prefs: rt, schema: dr }, { options: _r }) {
        const { value: Bi, errors: qi } = ae.sort(dr, he, _r, br, rt);
        if (qi) return qi;
        for (let Wi = 0; Wi < he.length; ++Wi) if (he[Wi] !== Bi[Wi]) return tt("array.sort", { order: _r.order, by: _r.by ? _r.by.key : "value" });
        return he;
      }, convert: !0 }, sparse: { method(he) {
        const tt = he === void 0 || !!he;
        return this._flags.sparse === tt ? this : (tt ? this.clone() : this.$_addRule("items")).$_setFlag("sparse", tt, { clone: !1 });
      } }, unique: { method(he, tt = {}) {
        D(!he || typeof he == "function" || typeof he == "string", "comparator must be a function or a string"), N.assertOptions(tt, ["ignoreUndefined", "separator"]);
        const br = { name: "unique", args: { options: tt, comparator: he } };
        if (he) if (typeof he == "string") {
          const rt = N.default(tt.separator, ".");
          br.path = rt ? he.split(rt) : [he];
        } else br.comparator = he;
        return this.$_addRule(br);
      }, validate(he, { state: tt, error: br, schema: rt }, { comparator: dr, options: _r }, { comparator: Bi, path: qi }) {
        const Wi = { string: /* @__PURE__ */ Object.create(null), number: /* @__PURE__ */ Object.create(null), undefined: /* @__PURE__ */ Object.create(null), boolean: /* @__PURE__ */ Object.create(null), bigint: /* @__PURE__ */ Object.create(null), object: /* @__PURE__ */ new Map(), function: /* @__PURE__ */ new Map(), custom: /* @__PURE__ */ new Map() }, Vi = Bi || Y, Ti = _r.ignoreUndefined;
        for (let Li = 0; Li < he.length; ++Li) {
          const Hi = qi ? L(he[Li], qi) : he[Li], pr = Bi ? Wi.custom : Wi[typeof Hi];
          if (D(pr, "Failed to find unique map container for type", typeof Hi), pr instanceof Map) {
            const Di = pr.entries();
            let z;
            for (; !(z = Di.next()).done; ) if (Vi(z.value[0], Hi)) {
              const gr = tt.localize([...tt.path, Li], [he, ...tt.ancestors]), vr = { pos: Li, value: he[Li], dupePos: z.value[1], dupeValue: he[z.value[1]] };
              return qi && (vr.path = dr), br("array.unique", vr, gr);
            }
            pr.set(Hi, Li);
          } else {
            if ((!Ti || Hi !== void 0) && pr[Hi] !== void 0) {
              const Di = { pos: Li, value: he[Li], dupePos: pr[Hi], dupeValue: he[pr[Hi]] };
              return qi && (Di.path = dr), br("array.unique", Di, tt.localize([...tt.path, Li], [he, ...tt.ancestors]));
            }
            pr[Hi] = Li;
          }
        }
        return he;
      }, args: ["comparator", "options"], multi: !0 } }, cast: { set: { from: Array.isArray, to: (he, tt) => new Set(he) } }, rebuild(he) {
        he.$_terms._inclusions = [], he.$_terms._exclusions = [], he.$_terms._requireds = [];
        for (const tt of he.$_terms.items) ae.validateSingle(tt, he), tt._flags.presence === "required" ? he.$_terms._requireds.push(tt) : tt._flags.presence === "forbidden" ? he.$_terms._exclusions.push(tt) : he.$_terms._inclusions.push(tt);
        for (const tt of he.$_terms.ordered) ae.validateSingle(tt, he);
      }, manifest: { build: (he, tt) => (tt.items && (he = he.items(...tt.items)), tt.ordered && (he = he.ordered(...tt.ordered)), he) }, messages: { "array.base": "{{#label}} must be an array", "array.excludes": "{{#label}} contains an excluded value", "array.hasKnown": "{{#label}} does not contain at least one required match for type {:#patternLabel}", "array.hasUnknown": "{{#label}} does not contain at least one required match", "array.includes": "{{#label}} does not match any of the allowed types", "array.includesRequiredBoth": "{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)", "array.includesRequiredKnowns": "{{#label}} does not contain {{#knownMisses}}", "array.includesRequiredUnknowns": "{{#label}} does not contain {{#unknownMisses}} required value(s)", "array.length": "{{#label}} must contain {{#limit}} items", "array.max": "{{#label}} must contain less than or equal to {{#limit}} items", "array.min": "{{#label}} must contain at least {{#limit}} items", "array.orderedLength": "{{#label}} must contain at most {{#limit}} items", "array.sort": "{{#label}} must be sorted in {#order} order by {{#by}}", "array.sort.mismatching": "{{#label}} cannot be sorted due to mismatching types", "array.sort.unsupported": "{{#label}} cannot be sorted due to unsupported type {#type}", "array.sparse": "{{#label}} must not be a sparse array item", "array.unique": "{{#label}} contains a duplicate value" } }), ae.fillMissedErrors = function(he, tt, br, rt, dr, _r) {
        const Bi = [];
        let qi = 0;
        for (const Wi of br) {
          const Vi = Wi._flags.label;
          Vi ? Bi.push(Vi) : ++qi;
        }
        Bi.length ? qi ? tt.push(he.$_createError("array.includesRequiredBoth", rt, { knownMisses: Bi, unknownMisses: qi }, dr, _r)) : tt.push(he.$_createError("array.includesRequiredKnowns", rt, { knownMisses: Bi }, dr, _r)) : tt.push(he.$_createError("array.includesRequiredUnknowns", rt, { unknownMisses: qi }, dr, _r));
      }, ae.fillOrderedErrors = function(he, tt, br, rt, dr, _r) {
        const Bi = [];
        for (const qi of br) qi._flags.presence === "required" && Bi.push(qi);
        Bi.length && ae.fillMissedErrors(he, tt, Bi, rt, dr, _r);
      }, ae.fillDefault = function(he, tt, br, rt) {
        const dr = [];
        let _r = !0;
        for (let Bi = he.length - 1; Bi >= 0; --Bi) {
          const qi = he[Bi], Wi = [tt, ...br.ancestors], Vi = qi.$_validate(void 0, br.localize(br.path, Wi, qi), rt).value;
          if (_r) {
            if (Vi === void 0) continue;
            _r = !1;
          }
          dr.unshift(Vi);
        }
        dr.length && tt.push(...dr);
      }, ae.fastSplice = function(he, tt) {
        let br = tt;
        for (; br < he.length; ) he[br++] = he[br];
        --he.length;
      }, ae.validateSingle = function(he, tt) {
        (he.type === "array" || he._flags._arrayItems) && (D(!tt._flags.single, "Cannot specify array item with single rule enabled"), tt.$_setFlag("_arrayItems", !0, { clone: !1 }));
      }, ae.sort = function(he, tt, br, rt, dr) {
        const _r = br.order === "ascending" ? 1 : -1, Bi = -1 * _r, qi = _r, Wi = (Vi, Ti) => {
          let Li = ae.compare(Vi, Ti, Bi, qi);
          if (Li !== null || (br.by && (Vi = br.by.resolve(Vi, rt, dr), Ti = br.by.resolve(Ti, rt, dr)), Li = ae.compare(Vi, Ti, Bi, qi), Li !== null)) return Li;
          const Hi = typeof Vi;
          if (Hi !== typeof Ti) throw he.$_createError("array.sort.mismatching", tt, null, rt, dr);
          if (Hi !== "number" && Hi !== "string") throw he.$_createError("array.sort.unsupported", tt, { type: Hi }, rt, dr);
          return Hi === "number" ? (Vi - Ti) * _r : Vi < Ti ? Bi : qi;
        };
        try {
          return { value: tt.slice().sort(Wi) };
        } catch (Vi) {
          return { errors: Vi };
        }
      }, ae.compare = function(he, tt, br, rt) {
        return he === tt ? 0 : he === void 0 ? 1 : tt === void 0 ? -1 : he === null ? rt : tt === null ? br : null;
      };
    }, 4937: (T, x, C) => {
      const D = C(375), Y = C(8068), L = C(8160), q = C(2036), N = { isBool: function(F) {
        return typeof F == "boolean";
      } };
      T.exports = Y.extend({ type: "boolean", flags: { sensitive: { default: !1 } }, terms: { falsy: { init: null, manifest: "values" }, truthy: { init: null, manifest: "values" } }, coerce(F, { schema: ae }) {
        if (typeof F != "boolean") {
          if (typeof F == "string") {
            const he = ae._flags.sensitive ? F : F.toLowerCase();
            F = he === "true" || he !== "false" && F;
          }
          return typeof F != "boolean" && (F = ae.$_terms.truthy && ae.$_terms.truthy.has(F, null, null, !ae._flags.sensitive) || (!ae.$_terms.falsy || !ae.$_terms.falsy.has(F, null, null, !ae._flags.sensitive)) && F), { value: F };
        }
      }, validate(F, { error: ae }) {
        if (typeof F != "boolean") return { value: F, errors: ae("boolean.base") };
      }, rules: { truthy: { method(...F) {
        L.verifyFlat(F, "truthy");
        const ae = this.clone();
        ae.$_terms.truthy = ae.$_terms.truthy || new q();
        for (let he = 0; he < F.length; ++he) {
          const tt = F[he];
          D(tt !== void 0, "Cannot call truthy with undefined"), ae.$_terms.truthy.add(tt);
        }
        return ae;
      } }, falsy: { method(...F) {
        L.verifyFlat(F, "falsy");
        const ae = this.clone();
        ae.$_terms.falsy = ae.$_terms.falsy || new q();
        for (let he = 0; he < F.length; ++he) {
          const tt = F[he];
          D(tt !== void 0, "Cannot call falsy with undefined"), ae.$_terms.falsy.add(tt);
        }
        return ae;
      } }, sensitive: { method(F = !0) {
        return this.$_setFlag("sensitive", F);
      } } }, cast: { number: { from: N.isBool, to: (F, ae) => F ? 1 : 0 }, string: { from: N.isBool, to: (F, ae) => F ? "true" : "false" } }, manifest: { build: (F, ae) => (ae.truthy && (F = F.truthy(...ae.truthy)), ae.falsy && (F = F.falsy(...ae.falsy)), F) }, messages: { "boolean.base": "{{#label}} must be a boolean" } });
    }, 7500: (T, x, C) => {
      const D = C(375), Y = C(8068), L = C(8160), q = C(3328), N = { isDate: function(F) {
        return F instanceof Date;
      } };
      T.exports = Y.extend({ type: "date", coerce: { from: ["number", "string"], method: (F, { schema: ae }) => ({ value: N.parse(F, ae._flags.format) || F }) }, validate(F, { schema: ae, error: he, prefs: tt }) {
        if (F instanceof Date && !isNaN(F.getTime())) return;
        const br = ae._flags.format;
        return tt.convert && br && typeof F == "string" ? { value: F, errors: he("date.format", { format: br }) } : { value: F, errors: he("date.base") };
      }, rules: { compare: { method: !1, validate(F, ae, { date: he }, { name: tt, operator: br, args: rt }) {
        const dr = he === "now" ? Date.now() : he.getTime();
        return L.compare(F.getTime(), dr, br) ? F : ae.error("date." + tt, { limit: rt.date, value: F });
      }, args: [{ name: "date", ref: !0, normalize: (F) => F === "now" ? F : N.parse(F), assert: (F) => F !== null, message: "must have a valid date format" }] }, format: { method(F) {
        return D(["iso", "javascript", "unix"].includes(F), "Unknown date format", F), this.$_setFlag("format", F);
      } }, greater: { method(F) {
        return this.$_addRule({ name: "greater", method: "compare", args: { date: F }, operator: ">" });
      } }, iso: { method() {
        return this.format("iso");
      } }, less: { method(F) {
        return this.$_addRule({ name: "less", method: "compare", args: { date: F }, operator: "<" });
      } }, max: { method(F) {
        return this.$_addRule({ name: "max", method: "compare", args: { date: F }, operator: "<=" });
      } }, min: { method(F) {
        return this.$_addRule({ name: "min", method: "compare", args: { date: F }, operator: ">=" });
      } }, timestamp: { method(F = "javascript") {
        return D(["javascript", "unix"].includes(F), '"type" must be one of "javascript, unix"'), this.format(F);
      } } }, cast: { number: { from: N.isDate, to: (F, ae) => F.getTime() }, string: { from: N.isDate, to: (F, { prefs: ae }) => q.date(F, ae) } }, messages: { "date.base": "{{#label}} must be a valid date", "date.format": '{{#label}} must be in {msg("date.format." + #format) || #format} format', "date.greater": "{{#label}} must be greater than {{:#limit}}", "date.less": "{{#label}} must be less than {{:#limit}}", "date.max": "{{#label}} must be less than or equal to {{:#limit}}", "date.min": "{{#label}} must be greater than or equal to {{:#limit}}", "date.format.iso": "ISO 8601 date", "date.format.javascript": "timestamp or number of milliseconds", "date.format.unix": "timestamp or number of seconds" } }), N.parse = function(F, ae) {
        if (F instanceof Date) return F;
        if (typeof F != "string" && (isNaN(F) || !isFinite(F)) || /^\s*$/.test(F)) return null;
        if (ae === "iso") return L.isIsoDate(F) ? N.date(F.toString()) : null;
        const he = F;
        if (typeof F == "string" && /^[+-]?\d+(\.\d+)?$/.test(F) && (F = parseFloat(F)), ae) {
          if (ae === "javascript") return N.date(1 * F);
          if (ae === "unix") return N.date(1e3 * F);
          if (typeof he == "string") return null;
        }
        return N.date(F);
      }, N.date = function(F) {
        const ae = new Date(F);
        return isNaN(ae.getTime()) ? null : ae;
      };
    }, 390: (T, x, C) => {
      const D = C(375), Y = C(7824);
      T.exports = Y.extend({ type: "function", properties: { typeof: "function" }, rules: { arity: { method(L) {
        return D(Number.isSafeInteger(L) && L >= 0, "n must be a positive integer"), this.$_addRule({ name: "arity", args: { n: L } });
      }, validate: (L, q, { n: N }) => L.length === N ? L : q.error("function.arity", { n: N }) }, class: { method() {
        return this.$_addRule("class");
      }, validate: (L, q) => /^\s*class\s/.test(L.toString()) ? L : q.error("function.class", { value: L }) }, minArity: { method(L) {
        return D(Number.isSafeInteger(L) && L > 0, "n must be a strict positive integer"), this.$_addRule({ name: "minArity", args: { n: L } });
      }, validate: (L, q, { n: N }) => L.length >= N ? L : q.error("function.minArity", { n: N }) }, maxArity: { method(L) {
        return D(Number.isSafeInteger(L) && L >= 0, "n must be a positive integer"), this.$_addRule({ name: "maxArity", args: { n: L } });
      }, validate: (L, q, { n: N }) => L.length <= N ? L : q.error("function.maxArity", { n: N }) } }, messages: { "function.arity": "{{#label}} must have an arity of {{#n}}", "function.class": "{{#label}} must be a class", "function.maxArity": "{{#label}} must have an arity lesser or equal to {{#n}}", "function.minArity": "{{#label}} must have an arity greater or equal to {{#n}}" } });
    }, 7824: (T, x, C) => {
      const D = C(978), Y = C(375), L = C(8571), q = C(3652), N = C(8068), F = C(8160), ae = C(3292), he = C(6354), tt = C(6133), br = C(3328), rt = { renameDefaults: { alias: !1, multiple: !1, override: !1 } };
      T.exports = N.extend({ type: "_keys", properties: { typeof: "object" }, flags: { unknown: { default: void 0 } }, terms: { dependencies: { init: null }, keys: { init: null, manifest: { mapped: { from: "schema", to: "key" } } }, patterns: { init: null }, renames: { init: null } }, args: (dr, _r) => dr.keys(_r), validate(dr, { schema: _r, error: Bi, state: qi, prefs: Wi }) {
        if (!dr || typeof dr !== _r.$_property("typeof") || Array.isArray(dr)) return { value: dr, errors: Bi("object.base", { type: _r.$_property("typeof") }) };
        if (!(_r.$_terms.renames || _r.$_terms.dependencies || _r.$_terms.keys || _r.$_terms.patterns || _r.$_terms.externals)) return;
        dr = rt.clone(dr, Wi);
        const Vi = [];
        if (_r.$_terms.renames && !rt.rename(_r, dr, qi, Wi, Vi)) return { value: dr, errors: Vi };
        if (!_r.$_terms.keys && !_r.$_terms.patterns && !_r.$_terms.dependencies) return { value: dr, errors: Vi };
        const Ti = new Set(Object.keys(dr));
        if (_r.$_terms.keys) {
          const Li = [dr, ...qi.ancestors];
          for (const Hi of _r.$_terms.keys) {
            const pr = Hi.key, Di = dr[pr];
            Ti.delete(pr);
            const z = qi.localize([...qi.path, pr], Li, Hi), gr = Hi.schema.$_validate(Di, z, Wi);
            if (gr.errors) {
              if (Wi.abortEarly) return { value: dr, errors: gr.errors };
              gr.value !== void 0 && (dr[pr] = gr.value), Vi.push(...gr.errors);
            } else Hi.schema._flags.result === "strip" || gr.value === void 0 && Di !== void 0 ? delete dr[pr] : gr.value !== void 0 && (dr[pr] = gr.value);
          }
        }
        if (Ti.size || _r._flags._hasPatternMatch) {
          const Li = rt.unknown(_r, dr, Ti, Vi, qi, Wi);
          if (Li) return Li;
        }
        if (_r.$_terms.dependencies) for (const Li of _r.$_terms.dependencies) {
          if (Li.key !== null && rt.isPresent(Li.options)(Li.key.resolve(dr, qi, Wi, null, { shadow: !1 })) === !1) continue;
          const Hi = rt.dependencies[Li.rel](_r, Li, dr, qi, Wi);
          if (Hi) {
            const pr = _r.$_createError(Hi.code, dr, Hi.context, qi, Wi);
            if (Wi.abortEarly) return { value: dr, errors: pr };
            Vi.push(pr);
          }
        }
        return { value: dr, errors: Vi };
      }, rules: { and: { method(...dr) {
        return F.verifyFlat(dr, "and"), rt.dependency(this, "and", null, dr);
      } }, append: { method(dr) {
        return dr == null || Object.keys(dr).length === 0 ? this : this.keys(dr);
      } }, assert: { method(dr, _r, Bi) {
        br.isTemplate(dr) || (dr = ae.ref(dr)), Y(Bi === void 0 || typeof Bi == "string", "Message must be a string"), _r = this.$_compile(_r, { appendPath: !0 });
        const qi = this.$_addRule({ name: "assert", args: { subject: dr, schema: _r, message: Bi } });
        return qi.$_mutateRegister(dr), qi.$_mutateRegister(_r), qi;
      }, validate(dr, { error: _r, prefs: Bi, state: qi }, { subject: Wi, schema: Vi, message: Ti }) {
        const Li = Wi.resolve(dr, qi, Bi), Hi = tt.isRef(Wi) ? Wi.absolute(qi) : [];
        return Vi.$_match(Li, qi.localize(Hi, [dr, ...qi.ancestors], Vi), Bi) ? dr : _r("object.assert", { subject: Wi, message: Ti });
      }, args: ["subject", "schema", "message"], multi: !0 }, instance: { method(dr, _r) {
        return Y(typeof dr == "function", "constructor must be a function"), _r = _r || dr.name, this.$_addRule({ name: "instance", args: { constructor: dr, name: _r } });
      }, validate: (dr, _r, { constructor: Bi, name: qi }) => dr instanceof Bi ? dr : _r.error("object.instance", { type: qi, value: dr }), args: ["constructor", "name"] }, keys: { method(dr) {
        Y(dr === void 0 || typeof dr == "object", "Object schema must be a valid object"), Y(!F.isSchema(dr), "Object schema cannot be a joi schema");
        const _r = this.clone();
        if (dr) if (Object.keys(dr).length) {
          _r.$_terms.keys = _r.$_terms.keys ? _r.$_terms.keys.filter((Bi) => !dr.hasOwnProperty(Bi.key)) : new rt.Keys();
          for (const Bi in dr) F.tryWithPath(() => _r.$_terms.keys.push({ key: Bi, schema: this.$_compile(dr[Bi]) }), Bi);
        } else _r.$_terms.keys = new rt.Keys();
        else _r.$_terms.keys = null;
        return _r.$_mutateRebuild();
      } }, length: { method(dr) {
        return this.$_addRule({ name: "length", args: { limit: dr }, operator: "=" });
      }, validate: (dr, _r, { limit: Bi }, { name: qi, operator: Wi, args: Vi }) => F.compare(Object.keys(dr).length, Bi, Wi) ? dr : _r.error("object." + qi, { limit: Vi.limit, value: dr }), args: [{ name: "limit", ref: !0, assert: F.limit, message: "must be a positive integer" }] }, max: { method(dr) {
        return this.$_addRule({ name: "max", method: "length", args: { limit: dr }, operator: "<=" });
      } }, min: { method(dr) {
        return this.$_addRule({ name: "min", method: "length", args: { limit: dr }, operator: ">=" });
      } }, nand: { method(...dr) {
        return F.verifyFlat(dr, "nand"), rt.dependency(this, "nand", null, dr);
      } }, or: { method(...dr) {
        return F.verifyFlat(dr, "or"), rt.dependency(this, "or", null, dr);
      } }, oxor: { method(...dr) {
        return rt.dependency(this, "oxor", null, dr);
      } }, pattern: { method(dr, _r, Bi = {}) {
        const qi = dr instanceof RegExp;
        qi || (dr = this.$_compile(dr, { appendPath: !0 })), Y(_r !== void 0, "Invalid rule"), F.assertOptions(Bi, ["fallthrough", "matches"]), qi && Y(!dr.flags.includes("g") && !dr.flags.includes("y"), "pattern should not use global or sticky mode"), _r = this.$_compile(_r, { appendPath: !0 });
        const Wi = this.clone();
        Wi.$_terms.patterns = Wi.$_terms.patterns || [];
        const Vi = { [qi ? "regex" : "schema"]: dr, rule: _r };
        return Bi.matches && (Vi.matches = this.$_compile(Bi.matches), Vi.matches.type !== "array" && (Vi.matches = Vi.matches.$_root.array().items(Vi.matches)), Wi.$_mutateRegister(Vi.matches), Wi.$_setFlag("_hasPatternMatch", !0, { clone: !1 })), Bi.fallthrough && (Vi.fallthrough = !0), Wi.$_terms.patterns.push(Vi), Wi.$_mutateRegister(_r), Wi;
      } }, ref: { method() {
        return this.$_addRule("ref");
      }, validate: (dr, _r) => tt.isRef(dr) ? dr : _r.error("object.refType", { value: dr }) }, regex: { method() {
        return this.$_addRule("regex");
      }, validate: (dr, _r) => dr instanceof RegExp ? dr : _r.error("object.regex", { value: dr }) }, rename: { method(dr, _r, Bi = {}) {
        Y(typeof dr == "string" || dr instanceof RegExp, "Rename missing the from argument"), Y(typeof _r == "string" || _r instanceof br, "Invalid rename to argument"), Y(_r !== dr, "Cannot rename key to same name:", dr), F.assertOptions(Bi, ["alias", "ignoreUndefined", "override", "multiple"]);
        const qi = this.clone();
        qi.$_terms.renames = qi.$_terms.renames || [];
        for (const Wi of qi.$_terms.renames) Y(Wi.from !== dr, "Cannot rename the same key multiple times");
        return _r instanceof br && qi.$_mutateRegister(_r), qi.$_terms.renames.push({ from: dr, to: _r, options: D(rt.renameDefaults, Bi) }), qi;
      } }, schema: { method(dr = "any") {
        return this.$_addRule({ name: "schema", args: { type: dr } });
      }, validate: (dr, _r, { type: Bi }) => !F.isSchema(dr) || Bi !== "any" && dr.type !== Bi ? _r.error("object.schema", { type: Bi }) : dr }, unknown: { method(dr) {
        return this.$_setFlag("unknown", dr !== !1);
      } }, with: { method(dr, _r, Bi = {}) {
        return rt.dependency(this, "with", dr, _r, Bi);
      } }, without: { method(dr, _r, Bi = {}) {
        return rt.dependency(this, "without", dr, _r, Bi);
      } }, xor: { method(...dr) {
        return F.verifyFlat(dr, "xor"), rt.dependency(this, "xor", null, dr);
      } } }, overrides: { default(dr, _r) {
        return dr === void 0 && (dr = F.symbols.deepDefault), this.$_parent("default", dr, _r);
      } }, rebuild(dr) {
        if (dr.$_terms.keys) {
          const _r = new q.Sorter();
          for (const Bi of dr.$_terms.keys) F.tryWithPath(() => _r.add(Bi, { after: Bi.schema.$_rootReferences(), group: Bi.key }), Bi.key);
          dr.$_terms.keys = new rt.Keys(..._r.nodes);
        }
      }, manifest: { build(dr, _r) {
        if (_r.keys && (dr = dr.keys(_r.keys)), _r.dependencies) for (const { rel: Bi, key: qi = null, peers: Wi, options: Vi } of _r.dependencies) dr = rt.dependency(dr, Bi, qi, Wi, Vi);
        if (_r.patterns) for (const { regex: Bi, schema: qi, rule: Wi, fallthrough: Vi, matches: Ti } of _r.patterns) dr = dr.pattern(Bi || qi, Wi, { fallthrough: Vi, matches: Ti });
        if (_r.renames) for (const { from: Bi, to: qi, options: Wi } of _r.renames) dr = dr.rename(Bi, qi, Wi);
        return dr;
      } }, messages: { "object.and": "{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}", "object.assert": '{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}', "object.base": "{{#label}} must be of type {{#type}}", "object.instance": "{{#label}} must be an instance of {{:#type}}", "object.length": '{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}', "object.max": '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}', "object.min": '{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}', "object.missing": "{{#label}} must contain at least one of {{#peersWithLabels}}", "object.nand": "{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}", "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}", "object.pattern.match": "{{#label}} keys failed to match pattern requirements", "object.refType": "{{#label}} must be a Joi reference", "object.regex": "{{#label}} must be a RegExp object", "object.rename.multiple": "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}", "object.rename.override": "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists", "object.schema": "{{#label}} must be a Joi schema of {{#type}} type", "object.unknown": "{{#label}} is not allowed", "object.with": "{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}", "object.without": "{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}", "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}" } }), rt.clone = function(dr, _r) {
        if (typeof dr == "object") {
          if (_r.nonEnumerables) return L(dr, { shallow: !0 });
          const qi = Object.create(Object.getPrototypeOf(dr));
          return Object.assign(qi, dr), qi;
        }
        const Bi = function(...qi) {
          return dr.apply(this, qi);
        };
        return Bi.prototype = L(dr.prototype), Object.defineProperty(Bi, "name", { value: dr.name, writable: !1 }), Object.defineProperty(Bi, "length", { value: dr.length, writable: !1 }), Object.assign(Bi, dr), Bi;
      }, rt.dependency = function(dr, _r, Bi, qi, Wi) {
        Y(Bi === null || typeof Bi == "string", _r, "key must be a strings"), Wi || (Wi = qi.length > 1 && typeof qi[qi.length - 1] == "object" ? qi.pop() : {}), F.assertOptions(Wi, ["separator", "isPresent"]), qi = [].concat(qi);
        const Vi = F.default(Wi.separator, "."), Ti = [];
        for (const Hi of qi) Y(typeof Hi == "string", _r, "peers must be strings"), Ti.push(ae.ref(Hi, { separator: Vi, ancestor: 0, prefix: !1 }));
        Bi !== null && (Bi = ae.ref(Bi, { separator: Vi, ancestor: 0, prefix: !1 }));
        const Li = dr.clone();
        return Li.$_terms.dependencies = Li.$_terms.dependencies || [], Li.$_terms.dependencies.push(new rt.Dependency(_r, Bi, Ti, qi, Wi)), Li;
      }, rt.dependencies = { and(dr, _r, Bi, qi, Wi) {
        const Vi = [], Ti = [], Li = _r.peers.length, Hi = rt.isPresent(_r.options);
        for (const pr of _r.peers) Hi(pr.resolve(Bi, qi, Wi, null, { shadow: !1 })) === !1 ? Vi.push(pr.key) : Ti.push(pr.key);
        if (Vi.length !== Li && Ti.length !== Li) return { code: "object.and", context: { present: Ti, presentWithLabels: rt.keysToLabels(dr, Ti), missing: Vi, missingWithLabels: rt.keysToLabels(dr, Vi) } };
      }, nand(dr, _r, Bi, qi, Wi) {
        const Vi = [], Ti = rt.isPresent(_r.options);
        for (const pr of _r.peers) Ti(pr.resolve(Bi, qi, Wi, null, { shadow: !1 })) && Vi.push(pr.key);
        if (Vi.length !== _r.peers.length) return;
        const Li = _r.paths[0], Hi = _r.paths.slice(1);
        return { code: "object.nand", context: { main: Li, mainWithLabel: rt.keysToLabels(dr, Li), peers: Hi, peersWithLabels: rt.keysToLabels(dr, Hi) } };
      }, or(dr, _r, Bi, qi, Wi) {
        const Vi = rt.isPresent(_r.options);
        for (const Ti of _r.peers) if (Vi(Ti.resolve(Bi, qi, Wi, null, { shadow: !1 }))) return;
        return { code: "object.missing", context: { peers: _r.paths, peersWithLabels: rt.keysToLabels(dr, _r.paths) } };
      }, oxor(dr, _r, Bi, qi, Wi) {
        const Vi = [], Ti = rt.isPresent(_r.options);
        for (const Hi of _r.peers) Ti(Hi.resolve(Bi, qi, Wi, null, { shadow: !1 })) && Vi.push(Hi.key);
        if (!Vi.length || Vi.length === 1) return;
        const Li = { peers: _r.paths, peersWithLabels: rt.keysToLabels(dr, _r.paths) };
        return Li.present = Vi, Li.presentWithLabels = rt.keysToLabels(dr, Vi), { code: "object.oxor", context: Li };
      }, with(dr, _r, Bi, qi, Wi) {
        const Vi = rt.isPresent(_r.options);
        for (const Ti of _r.peers) if (Vi(Ti.resolve(Bi, qi, Wi, null, { shadow: !1 })) === !1) return { code: "object.with", context: { main: _r.key.key, mainWithLabel: rt.keysToLabels(dr, _r.key.key), peer: Ti.key, peerWithLabel: rt.keysToLabels(dr, Ti.key) } };
      }, without(dr, _r, Bi, qi, Wi) {
        const Vi = rt.isPresent(_r.options);
        for (const Ti of _r.peers) if (Vi(Ti.resolve(Bi, qi, Wi, null, { shadow: !1 }))) return { code: "object.without", context: { main: _r.key.key, mainWithLabel: rt.keysToLabels(dr, _r.key.key), peer: Ti.key, peerWithLabel: rt.keysToLabels(dr, Ti.key) } };
      }, xor(dr, _r, Bi, qi, Wi) {
        const Vi = [], Ti = rt.isPresent(_r.options);
        for (const Hi of _r.peers) Ti(Hi.resolve(Bi, qi, Wi, null, { shadow: !1 })) && Vi.push(Hi.key);
        if (Vi.length === 1) return;
        const Li = { peers: _r.paths, peersWithLabels: rt.keysToLabels(dr, _r.paths) };
        return Vi.length === 0 ? { code: "object.missing", context: Li } : (Li.present = Vi, Li.presentWithLabels = rt.keysToLabels(dr, Vi), { code: "object.xor", context: Li });
      } }, rt.keysToLabels = function(dr, _r) {
        return Array.isArray(_r) ? _r.map((Bi) => dr.$_mapLabels(Bi)) : dr.$_mapLabels(_r);
      }, rt.isPresent = function(dr) {
        return typeof dr.isPresent == "function" ? dr.isPresent : (_r) => _r !== void 0;
      }, rt.rename = function(dr, _r, Bi, qi, Wi) {
        const Vi = {};
        for (const Ti of dr.$_terms.renames) {
          const Li = [], Hi = typeof Ti.from != "string";
          if (Hi) for (const pr in _r) {
            if (_r[pr] === void 0 && Ti.options.ignoreUndefined || pr === Ti.to) continue;
            const Di = Ti.from.exec(pr);
            Di && Li.push({ from: pr, to: Ti.to, match: Di });
          }
          else !Object.prototype.hasOwnProperty.call(_r, Ti.from) || _r[Ti.from] === void 0 && Ti.options.ignoreUndefined || Li.push(Ti);
          for (const pr of Li) {
            const Di = pr.from;
            let z = pr.to;
            if (z instanceof br && (z = z.render(_r, Bi, qi, pr.match)), Di !== z) {
              if (!Ti.options.multiple && Vi[z] && (Wi.push(dr.$_createError("object.rename.multiple", _r, { from: Di, to: z, pattern: Hi }, Bi, qi)), qi.abortEarly) || Object.prototype.hasOwnProperty.call(_r, z) && !Ti.options.override && !Vi[z] && (Wi.push(dr.$_createError("object.rename.override", _r, { from: Di, to: z, pattern: Hi }, Bi, qi)), qi.abortEarly)) return !1;
              _r[Di] === void 0 ? delete _r[z] : _r[z] = _r[Di], Vi[z] = !0, Ti.options.alias || delete _r[Di];
            }
          }
        }
        return !0;
      }, rt.unknown = function(dr, _r, Bi, qi, Wi, Vi) {
        if (dr.$_terms.patterns) {
          let Ti = !1;
          const Li = dr.$_terms.patterns.map((pr) => {
            if (pr.matches) return Ti = !0, [];
          }), Hi = [_r, ...Wi.ancestors];
          for (const pr of Bi) {
            const Di = _r[pr], z = [...Wi.path, pr];
            for (let gr = 0; gr < dr.$_terms.patterns.length; ++gr) {
              const vr = dr.$_terms.patterns[gr];
              if (vr.regex) {
                const ki = vr.regex.test(pr);
                if (Wi.mainstay.tracer.debug(Wi, "rule", `pattern.${gr}`, ki ? "pass" : "error"), !ki) continue;
              } else if (!vr.schema.$_match(pr, Wi.nest(vr.schema, `pattern.${gr}`), Vi)) continue;
              Bi.delete(pr);
              const Oi = Wi.localize(z, Hi, { schema: vr.rule, key: pr }), Mi = vr.rule.$_validate(Di, Oi, Vi);
              if (Mi.errors) {
                if (Vi.abortEarly) return { value: _r, errors: Mi.errors };
                qi.push(...Mi.errors);
              }
              if (vr.matches && Li[gr].push(pr), _r[pr] = Mi.value, !vr.fallthrough) break;
            }
          }
          if (Ti) for (let pr = 0; pr < Li.length; ++pr) {
            const Di = Li[pr];
            if (!Di) continue;
            const z = dr.$_terms.patterns[pr].matches, gr = Wi.localize(Wi.path, Hi, z), vr = z.$_validate(Di, gr, Vi);
            if (vr.errors) {
              const Oi = he.details(vr.errors, { override: !1 });
              Oi.matches = Di;
              const Mi = dr.$_createError("object.pattern.match", _r, Oi, Wi, Vi);
              if (Vi.abortEarly) return { value: _r, errors: Mi };
              qi.push(Mi);
            }
          }
        }
        if (Bi.size && (dr.$_terms.keys || dr.$_terms.patterns)) {
          if (Vi.stripUnknown && dr._flags.unknown === void 0 || Vi.skipFunctions) {
            const Ti = !(!Vi.stripUnknown || Vi.stripUnknown !== !0 && !Vi.stripUnknown.objects);
            for (const Li of Bi) Ti ? (delete _r[Li], Bi.delete(Li)) : typeof _r[Li] == "function" && Bi.delete(Li);
          }
          if (!F.default(dr._flags.unknown, Vi.allowUnknown)) for (const Ti of Bi) {
            const Li = Wi.localize([...Wi.path, Ti], []), Hi = dr.$_createError("object.unknown", _r[Ti], { child: Ti }, Li, Vi, { flags: !1 });
            if (Vi.abortEarly) return { value: _r, errors: Hi };
            qi.push(Hi);
          }
        }
      }, rt.Dependency = class {
        constructor(dr, _r, Bi, qi, Wi) {
          this.rel = dr, this.key = _r, this.peers = Bi, this.paths = qi, this.options = Wi;
        }
        describe() {
          const dr = { rel: this.rel, peers: this.paths };
          return this.key !== null && (dr.key = this.key.key), this.peers[0].separator !== "." && (dr.options = { ...dr.options, separator: this.peers[0].separator }), this.options.isPresent && (dr.options = { ...dr.options, isPresent: this.options.isPresent }), dr;
        }
      }, rt.Keys = class extends Array {
        concat(dr) {
          const _r = this.slice(), Bi = /* @__PURE__ */ new Map();
          for (let qi = 0; qi < _r.length; ++qi) Bi.set(_r[qi].key, qi);
          for (const qi of dr) {
            const Wi = qi.key, Vi = Bi.get(Wi);
            Vi !== void 0 ? _r[Vi] = { key: Wi, schema: _r[Vi].schema.concat(qi.schema) } : _r.push(qi);
          }
          return _r;
        }
      };
    }, 8785: (T, x, C) => {
      const D = C(375), Y = C(8068), L = C(8160), q = C(3292), N = C(6354), F = {};
      T.exports = Y.extend({ type: "link", properties: { schemaChain: !0 }, terms: { link: { init: null, manifest: "single", register: !1 } }, args: (ae, he) => ae.ref(he), validate(ae, { schema: he, state: tt, prefs: br }) {
        D(he.$_terms.link, "Uninitialized link schema");
        const rt = F.generate(he, ae, tt, br), dr = he.$_terms.link[0].ref;
        return rt.$_validate(ae, tt.nest(rt, `link:${dr.display}:${rt.type}`), br);
      }, generate: (ae, he, tt, br) => F.generate(ae, he, tt, br), rules: { ref: { method(ae) {
        D(!this.$_terms.link, "Cannot reinitialize schema"), ae = q.ref(ae), D(ae.type === "value" || ae.type === "local", "Invalid reference type:", ae.type), D(ae.type === "local" || ae.ancestor === "root" || ae.ancestor > 0, "Link cannot reference itself");
        const he = this.clone();
        return he.$_terms.link = [{ ref: ae }], he;
      } }, relative: { method(ae = !0) {
        return this.$_setFlag("relative", ae);
      } } }, overrides: { concat(ae) {
        D(this.$_terms.link, "Uninitialized link schema"), D(L.isSchema(ae), "Invalid schema object"), D(ae.type !== "link", "Cannot merge type link with another link");
        const he = this.clone();
        return he.$_terms.whens || (he.$_terms.whens = []), he.$_terms.whens.push({ concat: ae }), he.$_mutateRebuild();
      } }, manifest: { build: (ae, he) => (D(he.link, "Invalid link description missing link"), ae.ref(he.link)) } }), F.generate = function(ae, he, tt, br) {
        let rt = tt.mainstay.links.get(ae);
        if (rt) return rt._generate(he, tt, br).schema;
        const dr = ae.$_terms.link[0].ref, { perspective: _r, path: Bi } = F.perspective(dr, tt);
        F.assert(_r, "which is outside of schema boundaries", dr, ae, tt, br);
        try {
          rt = Bi.length ? _r.$_reach(Bi) : _r;
        } catch {
          F.assert(!1, "to non-existing schema", dr, ae, tt, br);
        }
        return F.assert(rt.type !== "link", "which is another link", dr, ae, tt, br), ae._flags.relative || tt.mainstay.links.set(ae, rt), rt._generate(he, tt, br).schema;
      }, F.perspective = function(ae, he) {
        if (ae.type === "local") {
          for (const { schema: tt, key: br } of he.schemas) {
            if ((tt._flags.id || br) === ae.path[0]) return { perspective: tt, path: ae.path.slice(1) };
            if (tt.$_terms.shared) {
              for (const rt of tt.$_terms.shared) if (rt._flags.id === ae.path[0]) return { perspective: rt, path: ae.path.slice(1) };
            }
          }
          return { perspective: null, path: null };
        }
        return ae.ancestor === "root" ? { perspective: he.schemas[he.schemas.length - 1].schema, path: ae.path } : { perspective: he.schemas[ae.ancestor] && he.schemas[ae.ancestor].schema, path: ae.path };
      }, F.assert = function(ae, he, tt, br, rt, dr) {
        ae || D(!1, `"${N.label(br._flags, rt, dr)}" contains link reference "${tt.display}" ${he}`);
      };
    }, 3832: (T, x, C) => {
      const D = C(375), Y = C(8068), L = C(8160), q = { numberRx: /^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i, precisionRx: /(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/, exponentialPartRegex: /[eE][+-]?\d+$/, leadingSignAndZerosRegex: /^[+-]?(0*)?/, dotRegex: /\./, trailingZerosRegex: /0+$/, decimalPlaces(N) {
        const F = N.toString(), ae = F.indexOf("."), he = F.indexOf("e");
        return (ae < 0 ? 0 : (he < 0 ? F.length : he) - ae - 1) + (he < 0 ? 0 : Math.max(0, -parseInt(F.slice(he + 1))));
      } };
      T.exports = Y.extend({ type: "number", flags: { unsafe: { default: !1 } }, coerce: { from: "string", method(N, { schema: F, error: ae }) {
        if (!N.match(q.numberRx)) return;
        N = N.trim();
        const he = { value: parseFloat(N) };
        if (he.value === 0 && (he.value = 0), !F._flags.unsafe) if (N.match(/e/i)) {
          if (q.extractSignificantDigits(N) !== q.extractSignificantDigits(String(he.value))) return he.errors = ae("number.unsafe"), he;
        } else {
          const tt = he.value.toString();
          if (tt.match(/e/i)) return he;
          if (tt !== q.normalizeDecimal(N)) return he.errors = ae("number.unsafe"), he;
        }
        return he;
      } }, validate(N, { schema: F, error: ae, prefs: he }) {
        if (N === 1 / 0 || N === -1 / 0) return { value: N, errors: ae("number.infinity") };
        if (!L.isNumber(N)) return { value: N, errors: ae("number.base") };
        const tt = { value: N };
        if (he.convert) {
          const br = F.$_getRule("precision");
          if (br) {
            const rt = Math.pow(10, br.args.limit);
            tt.value = Math.round(tt.value * rt) / rt;
          }
        }
        return tt.value === 0 && (tt.value = 0), !F._flags.unsafe && (N > Number.MAX_SAFE_INTEGER || N < Number.MIN_SAFE_INTEGER) && (tt.errors = ae("number.unsafe")), tt;
      }, rules: { compare: { method: !1, validate: (N, F, { limit: ae }, { name: he, operator: tt, args: br }) => L.compare(N, ae, tt) ? N : F.error("number." + he, { limit: br.limit, value: N }), args: [{ name: "limit", ref: !0, assert: L.isNumber, message: "must be a number" }] }, greater: { method(N) {
        return this.$_addRule({ name: "greater", method: "compare", args: { limit: N }, operator: ">" });
      } }, integer: { method() {
        return this.$_addRule("integer");
      }, validate: (N, F) => Math.trunc(N) - N == 0 ? N : F.error("number.integer") }, less: { method(N) {
        return this.$_addRule({ name: "less", method: "compare", args: { limit: N }, operator: "<" });
      } }, max: { method(N) {
        return this.$_addRule({ name: "max", method: "compare", args: { limit: N }, operator: "<=" });
      } }, min: { method(N) {
        return this.$_addRule({ name: "min", method: "compare", args: { limit: N }, operator: ">=" });
      } }, multiple: { method(N) {
        const F = typeof N == "number" ? q.decimalPlaces(N) : null, ae = Math.pow(10, F);
        return this.$_addRule({ name: "multiple", args: { base: N, baseDecimalPlace: F, pfactor: ae } });
      }, validate: (N, F, { base: ae, baseDecimalPlace: he, pfactor: tt }, br) => q.decimalPlaces(N) > he ? F.error("number.multiple", { multiple: br.args.base, value: N }) : Math.round(tt * N) % Math.round(tt * ae) == 0 ? N : F.error("number.multiple", { multiple: br.args.base, value: N }), args: [{ name: "base", ref: !0, assert: (N) => typeof N == "number" && isFinite(N) && N > 0, message: "must be a positive number" }, "baseDecimalPlace", "pfactor"], multi: !0 }, negative: { method() {
        return this.sign("negative");
      } }, port: { method() {
        return this.$_addRule("port");
      }, validate: (N, F) => Number.isSafeInteger(N) && N >= 0 && N <= 65535 ? N : F.error("number.port") }, positive: { method() {
        return this.sign("positive");
      } }, precision: { method(N) {
        return D(Number.isSafeInteger(N), "limit must be an integer"), this.$_addRule({ name: "precision", args: { limit: N } });
      }, validate(N, F, { limit: ae }) {
        const he = N.toString().match(q.precisionRx);
        return Math.max((he[1] ? he[1].length : 0) - (he[2] ? parseInt(he[2], 10) : 0), 0) <= ae ? N : F.error("number.precision", { limit: ae, value: N });
      }, convert: !0 }, sign: { method(N) {
        return D(["negative", "positive"].includes(N), "Invalid sign", N), this.$_addRule({ name: "sign", args: { sign: N } });
      }, validate: (N, F, { sign: ae }) => ae === "negative" && N < 0 || ae === "positive" && N > 0 ? N : F.error(`number.${ae}`) }, unsafe: { method(N = !0) {
        return D(typeof N == "boolean", "enabled must be a boolean"), this.$_setFlag("unsafe", N);
      } } }, cast: { string: { from: (N) => typeof N == "number", to: (N, F) => N.toString() } }, messages: { "number.base": "{{#label}} must be a number", "number.greater": "{{#label}} must be greater than {{#limit}}", "number.infinity": "{{#label}} cannot be infinity", "number.integer": "{{#label}} must be an integer", "number.less": "{{#label}} must be less than {{#limit}}", "number.max": "{{#label}} must be less than or equal to {{#limit}}", "number.min": "{{#label}} must be greater than or equal to {{#limit}}", "number.multiple": "{{#label}} must be a multiple of {{#multiple}}", "number.negative": "{{#label}} must be a negative number", "number.port": "{{#label}} must be a valid port", "number.positive": "{{#label}} must be a positive number", "number.precision": "{{#label}} must have no more than {{#limit}} decimal places", "number.unsafe": "{{#label}} must be a safe number" } }), q.extractSignificantDigits = function(N) {
        return N.replace(q.exponentialPartRegex, "").replace(q.dotRegex, "").replace(q.trailingZerosRegex, "").replace(q.leadingSignAndZerosRegex, "");
      }, q.normalizeDecimal = function(N) {
        return (N = N.replace(/^\+/, "").replace(/\.0*$/, "").replace(/^(-?)\.([^\.]*)$/, "$10.$2").replace(/^(-?)0+([0-9])/, "$1$2")).includes(".") && N.endsWith("0") && (N = N.replace(/0+$/, "")), N === "-0" ? "0" : N;
      };
    }, 8966: (T, x, C) => {
      const D = C(7824);
      T.exports = D.extend({ type: "object", cast: { map: { from: (Y) => Y && typeof Y == "object", to: (Y, L) => new Map(Object.entries(Y)) } } });
    }, 7417: (T, x, C) => {
      const D = C(375), Y = C(5380), L = C(1745), q = C(9959), N = C(6064), F = C(9926), ae = C(5752), he = C(8068), tt = C(8160), br = { tlds: F instanceof Set && { tlds: { allow: F, deny: null } }, base64Regex: { true: { true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/, false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/ }, false: { true: /^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/, false: /^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/ } }, dataUriRegex: /^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/, hexRegex: { withPrefix: /^0x[0-9a-f]+$/i, withOptionalPrefix: /^(?:0x)?[0-9a-f]+$/i, withoutPrefix: /^[0-9a-f]+$/i }, ipRegex: q.regex({ cidr: "forbidden" }).regex, isoDurationRegex: /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/, guidBrackets: { "{": "}", "[": "]", "(": ")", "": "" }, guidVersions: { uuidv1: "1", uuidv2: "2", uuidv3: "3", uuidv4: "4", uuidv5: "5", uuidv6: "6", uuidv7: "7", uuidv8: "8" }, guidSeparators: /* @__PURE__ */ new Set([void 0, !0, !1, "-", ":"]), normalizationForms: ["NFC", "NFD", "NFKC", "NFKD"] };
      T.exports = he.extend({ type: "string", flags: { insensitive: { default: !1 }, truncate: { default: !1 } }, terms: { replacements: { init: null } }, coerce: { from: "string", method(rt, { schema: dr, state: _r, prefs: Bi }) {
        const qi = dr.$_getRule("normalize");
        qi && (rt = rt.normalize(qi.args.form));
        const Wi = dr.$_getRule("case");
        Wi && (rt = Wi.args.direction === "upper" ? rt.toLocaleUpperCase() : rt.toLocaleLowerCase());
        const Vi = dr.$_getRule("trim");
        if (Vi && Vi.args.enabled && (rt = rt.trim()), dr.$_terms.replacements) for (const Li of dr.$_terms.replacements) rt = rt.replace(Li.pattern, Li.replacement);
        const Ti = dr.$_getRule("hex");
        if (Ti && Ti.args.options.byteAligned && rt.length % 2 != 0 && (rt = `0${rt}`), dr.$_getRule("isoDate")) {
          const Li = br.isoDate(rt);
          Li && (rt = Li);
        }
        if (dr._flags.truncate) {
          const Li = dr.$_getRule("max");
          if (Li) {
            let Hi = Li.args.limit;
            if (tt.isResolvable(Hi) && (Hi = Hi.resolve(rt, _r, Bi), !tt.limit(Hi))) return { value: rt, errors: dr.$_createError("any.ref", Hi, { ref: Li.args.limit, arg: "limit", reason: "must be a positive integer" }, _r, Bi) };
            rt = rt.slice(0, Hi);
          }
        }
        return { value: rt };
      } }, validate(rt, { schema: dr, error: _r }) {
        if (typeof rt != "string") return { value: rt, errors: _r("string.base") };
        if (rt === "") {
          const Bi = dr.$_getRule("min");
          return Bi && Bi.args.limit === 0 ? void 0 : { value: rt, errors: _r("string.empty") };
        }
      }, rules: { alphanum: { method() {
        return this.$_addRule("alphanum");
      }, validate: (rt, dr) => /^[a-zA-Z0-9]+$/.test(rt) ? rt : dr.error("string.alphanum") }, base64: { method(rt = {}) {
        return tt.assertOptions(rt, ["paddingRequired", "urlSafe"]), rt = { urlSafe: !1, paddingRequired: !0, ...rt }, D(typeof rt.paddingRequired == "boolean", "paddingRequired must be boolean"), D(typeof rt.urlSafe == "boolean", "urlSafe must be boolean"), this.$_addRule({ name: "base64", args: { options: rt } });
      }, validate: (rt, dr, { options: _r }) => br.base64Regex[_r.paddingRequired][_r.urlSafe].test(rt) ? rt : dr.error("string.base64") }, case: { method(rt) {
        return D(["lower", "upper"].includes(rt), "Invalid case:", rt), this.$_addRule({ name: "case", args: { direction: rt } });
      }, validate: (rt, dr, { direction: _r }) => _r === "lower" && rt === rt.toLocaleLowerCase() || _r === "upper" && rt === rt.toLocaleUpperCase() ? rt : dr.error(`string.${_r}case`), convert: !0 }, creditCard: { method() {
        return this.$_addRule("creditCard");
      }, validate(rt, dr) {
        let _r = rt.length, Bi = 0, qi = 1;
        for (; _r--; ) {
          const Wi = rt.charAt(_r) * qi;
          Bi += Wi - 9 * (Wi > 9), qi ^= 3;
        }
        return Bi > 0 && Bi % 10 == 0 ? rt : dr.error("string.creditCard");
      } }, dataUri: { method(rt = {}) {
        return tt.assertOptions(rt, ["paddingRequired"]), rt = { paddingRequired: !0, ...rt }, D(typeof rt.paddingRequired == "boolean", "paddingRequired must be boolean"), this.$_addRule({ name: "dataUri", args: { options: rt } });
      }, validate(rt, dr, { options: _r }) {
        const Bi = rt.match(br.dataUriRegex);
        return Bi && (!Bi[2] || Bi[2] !== "base64" || br.base64Regex[_r.paddingRequired].false.test(Bi[3])) ? rt : dr.error("string.dataUri");
      } }, domain: { method(rt) {
        rt && tt.assertOptions(rt, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
        const dr = br.addressOptions(rt);
        return this.$_addRule({ name: "domain", args: { options: rt }, address: dr });
      }, validate: (rt, dr, _r, { address: Bi }) => Y.isValid(rt, Bi) ? rt : dr.error("string.domain") }, email: { method(rt = {}) {
        tt.assertOptions(rt, ["allowFullyQualified", "allowUnicode", "ignoreLength", "maxDomainSegments", "minDomainSegments", "multiple", "separator", "tlds"]), D(rt.multiple === void 0 || typeof rt.multiple == "boolean", "multiple option must be an boolean");
        const dr = br.addressOptions(rt), _r = new RegExp(`\\s*[${rt.separator ? N(rt.separator) : ","}]\\s*`);
        return this.$_addRule({ name: "email", args: { options: rt }, regex: _r, address: dr });
      }, validate(rt, dr, { options: _r }, { regex: Bi, address: qi }) {
        const Wi = _r.multiple ? rt.split(Bi) : [rt], Vi = [];
        for (const Ti of Wi) L.isValid(Ti, qi) || Vi.push(Ti);
        return Vi.length ? dr.error("string.email", { value: rt, invalids: Vi }) : rt;
      } }, guid: { alias: "uuid", method(rt = {}) {
        tt.assertOptions(rt, ["version", "separator"]);
        let dr = "";
        if (rt.version) {
          const qi = [].concat(rt.version);
          D(qi.length >= 1, "version must have at least 1 valid version specified");
          const Wi = /* @__PURE__ */ new Set();
          for (let Vi = 0; Vi < qi.length; ++Vi) {
            const Ti = qi[Vi];
            D(typeof Ti == "string", "version at position " + Vi + " must be a string");
            const Li = br.guidVersions[Ti.toLowerCase()];
            D(Li, "version at position " + Vi + " must be one of " + Object.keys(br.guidVersions).join(", ")), D(!Wi.has(Li), "version at position " + Vi + " must not be a duplicate"), dr += Li, Wi.add(Li);
          }
        }
        D(br.guidSeparators.has(rt.separator), 'separator must be one of true, false, "-", or ":"');
        const _r = rt.separator === void 0 ? "[:-]?" : rt.separator === !0 ? "[:-]" : rt.separator === !1 ? "[]?" : `\\${rt.separator}`, Bi = new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}(${_r})[0-9A-F]{4}\\2?[${dr || "0-9A-F"}][0-9A-F]{3}\\2?[${dr ? "89AB" : "0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`, "i");
        return this.$_addRule({ name: "guid", args: { options: rt }, regex: Bi });
      }, validate(rt, dr, _r, { regex: Bi }) {
        const qi = Bi.exec(rt);
        return qi ? br.guidBrackets[qi[1]] !== qi[qi.length - 1] ? dr.error("string.guid") : rt : dr.error("string.guid");
      } }, hex: { method(rt = {}) {
        return tt.assertOptions(rt, ["byteAligned", "prefix"]), rt = { byteAligned: !1, prefix: !1, ...rt }, D(typeof rt.byteAligned == "boolean", "byteAligned must be boolean"), D(typeof rt.prefix == "boolean" || rt.prefix === "optional", 'prefix must be boolean or "optional"'), this.$_addRule({ name: "hex", args: { options: rt } });
      }, validate: (rt, dr, { options: _r }) => (_r.prefix === "optional" ? br.hexRegex.withOptionalPrefix : _r.prefix === !0 ? br.hexRegex.withPrefix : br.hexRegex.withoutPrefix).test(rt) ? _r.byteAligned && rt.length % 2 != 0 ? dr.error("string.hexAlign") : rt : dr.error("string.hex") }, hostname: { method() {
        return this.$_addRule("hostname");
      }, validate: (rt, dr) => Y.isValid(rt, { minDomainSegments: 1 }) || br.ipRegex.test(rt) ? rt : dr.error("string.hostname") }, insensitive: { method() {
        return this.$_setFlag("insensitive", !0);
      } }, ip: { method(rt = {}) {
        tt.assertOptions(rt, ["cidr", "version"]);
        const { cidr: dr, versions: _r, regex: Bi } = q.regex(rt), qi = rt.version ? _r : void 0;
        return this.$_addRule({ name: "ip", args: { options: { cidr: dr, version: qi } }, regex: Bi });
      }, validate: (rt, dr, { options: _r }, { regex: Bi }) => Bi.test(rt) ? rt : _r.version ? dr.error("string.ipVersion", { value: rt, cidr: _r.cidr, version: _r.version }) : dr.error("string.ip", { value: rt, cidr: _r.cidr }) }, isoDate: { method() {
        return this.$_addRule("isoDate");
      }, validate: (rt, { error: dr }) => br.isoDate(rt) ? rt : dr("string.isoDate") }, isoDuration: { method() {
        return this.$_addRule("isoDuration");
      }, validate: (rt, dr) => br.isoDurationRegex.test(rt) ? rt : dr.error("string.isoDuration") }, length: { method(rt, dr) {
        return br.length(this, "length", rt, "=", dr);
      }, validate(rt, dr, { limit: _r, encoding: Bi }, { name: qi, operator: Wi, args: Vi }) {
        const Ti = !Bi && rt.length;
        return tt.compare(Ti, _r, Wi) ? rt : dr.error("string." + qi, { limit: Vi.limit, value: rt, encoding: Bi });
      }, args: [{ name: "limit", ref: !0, assert: tt.limit, message: "must be a positive integer" }, "encoding"] }, lowercase: { method() {
        return this.case("lower");
      } }, max: { method(rt, dr) {
        return br.length(this, "max", rt, "<=", dr);
      }, args: ["limit", "encoding"] }, min: { method(rt, dr) {
        return br.length(this, "min", rt, ">=", dr);
      }, args: ["limit", "encoding"] }, normalize: { method(rt = "NFC") {
        return D(br.normalizationForms.includes(rt), "normalization form must be one of " + br.normalizationForms.join(", ")), this.$_addRule({ name: "normalize", args: { form: rt } });
      }, validate: (rt, { error: dr }, { form: _r }) => rt === rt.normalize(_r) ? rt : dr("string.normalize", { value: rt, form: _r }), convert: !0 }, pattern: { alias: "regex", method(rt, dr = {}) {
        D(rt instanceof RegExp, "regex must be a RegExp"), D(!rt.flags.includes("g") && !rt.flags.includes("y"), "regex should not use global or sticky mode"), typeof dr == "string" && (dr = { name: dr }), tt.assertOptions(dr, ["invert", "name"]);
        const _r = ["string.pattern", dr.invert ? ".invert" : "", dr.name ? ".name" : ".base"].join("");
        return this.$_addRule({ name: "pattern", args: { regex: rt, options: dr }, errorCode: _r });
      }, validate: (rt, dr, { regex: _r, options: Bi }, { errorCode: qi }) => _r.test(rt) ^ Bi.invert ? rt : dr.error(qi, { name: Bi.name, regex: _r, value: rt }), args: ["regex", "options"], multi: !0 }, replace: { method(rt, dr) {
        typeof rt == "string" && (rt = new RegExp(N(rt), "g")), D(rt instanceof RegExp, "pattern must be a RegExp"), D(typeof dr == "string", "replacement must be a String");
        const _r = this.clone();
        return _r.$_terms.replacements || (_r.$_terms.replacements = []), _r.$_terms.replacements.push({ pattern: rt, replacement: dr }), _r;
      } }, token: { method() {
        return this.$_addRule("token");
      }, validate: (rt, dr) => /^\w+$/.test(rt) ? rt : dr.error("string.token") }, trim: { method(rt = !0) {
        return D(typeof rt == "boolean", "enabled must be a boolean"), this.$_addRule({ name: "trim", args: { enabled: rt } });
      }, validate: (rt, dr, { enabled: _r }) => _r && rt !== rt.trim() ? dr.error("string.trim") : rt, convert: !0 }, truncate: { method(rt = !0) {
        return D(typeof rt == "boolean", "enabled must be a boolean"), this.$_setFlag("truncate", rt);
      } }, uppercase: { method() {
        return this.case("upper");
      } }, uri: { method(rt = {}) {
        tt.assertOptions(rt, ["allowRelative", "allowQuerySquareBrackets", "domain", "relativeOnly", "scheme", "encodeUri"]), rt.domain && tt.assertOptions(rt.domain, ["allowFullyQualified", "allowUnicode", "maxDomainSegments", "minDomainSegments", "tlds"]);
        const { regex: dr, scheme: _r } = ae.regex(rt), Bi = rt.domain ? br.addressOptions(rt.domain) : null;
        return this.$_addRule({ name: "uri", args: { options: rt }, regex: dr, domain: Bi, scheme: _r });
      }, validate(rt, dr, { options: _r }, { regex: Bi, domain: qi, scheme: Wi }) {
        if (["http:/", "https:/"].includes(rt)) return dr.error("string.uri");
        let Vi = Bi.exec(rt);
        if (!Vi && dr.prefs.convert && _r.encodeUri) {
          const Ti = encodeURI(rt);
          Vi = Bi.exec(Ti), Vi && (rt = Ti);
        }
        if (Vi) {
          const Ti = Vi[1] || Vi[2];
          return !qi || _r.allowRelative && !Ti || Y.isValid(Ti, qi) ? rt : dr.error("string.domain", { value: Ti });
        }
        return _r.relativeOnly ? dr.error("string.uriRelativeOnly") : _r.scheme ? dr.error("string.uriCustomScheme", { scheme: Wi, value: rt }) : dr.error("string.uri");
      } } }, manifest: { build(rt, dr) {
        if (dr.replacements) for (const { pattern: _r, replacement: Bi } of dr.replacements) rt = rt.replace(_r, Bi);
        return rt;
      } }, messages: { "string.alphanum": "{{#label}} must only contain alpha-numeric characters", "string.base": "{{#label}} must be a string", "string.base64": "{{#label}} must be a valid base64 string", "string.creditCard": "{{#label}} must be a credit card", "string.dataUri": "{{#label}} must be a valid dataUri string", "string.domain": "{{#label}} must contain a valid domain name", "string.email": "{{#label}} must be a valid email", "string.empty": "{{#label}} is not allowed to be empty", "string.guid": "{{#label}} must be a valid GUID", "string.hex": "{{#label}} must only contain hexadecimal characters", "string.hexAlign": "{{#label}} hex decoded representation must be byte aligned", "string.hostname": "{{#label}} must be a valid hostname", "string.ip": "{{#label}} must be a valid ip address with a {{#cidr}} CIDR", "string.ipVersion": "{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR", "string.isoDate": "{{#label}} must be in iso format", "string.isoDuration": "{{#label}} must be a valid ISO 8601 duration", "string.length": "{{#label}} length must be {{#limit}} characters long", "string.lowercase": "{{#label}} must only contain lowercase characters", "string.max": "{{#label}} length must be less than or equal to {{#limit}} characters long", "string.min": "{{#label}} length must be at least {{#limit}} characters long", "string.normalize": "{{#label}} must be unicode normalized in the {{#form}} form", "string.token": "{{#label}} must only contain alpha-numeric and underscore characters", "string.pattern.base": "{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}", "string.pattern.name": "{{#label}} with value {:[.]} fails to match the {{#name}} pattern", "string.pattern.invert.base": "{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}", "string.pattern.invert.name": "{{#label}} with value {:[.]} matches the inverted {{#name}} pattern", "string.trim": "{{#label}} must not have leading or trailing whitespace", "string.uri": "{{#label}} must be a valid uri", "string.uriCustomScheme": "{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern", "string.uriRelativeOnly": "{{#label}} must be a valid relative uri", "string.uppercase": "{{#label}} must only contain uppercase characters" } }), br.addressOptions = function(rt) {
        if (!rt) return br.tlds || rt;
        if (D(rt.minDomainSegments === void 0 || Number.isSafeInteger(rt.minDomainSegments) && rt.minDomainSegments > 0, "minDomainSegments must be a positive integer"), D(rt.maxDomainSegments === void 0 || Number.isSafeInteger(rt.maxDomainSegments) && rt.maxDomainSegments > 0, "maxDomainSegments must be a positive integer"), rt.tlds === !1) return rt;
        if (rt.tlds === !0 || rt.tlds === void 0) return D(br.tlds, "Built-in TLD list disabled"), Object.assign({}, rt, br.tlds);
        D(typeof rt.tlds == "object", "tlds must be true, false, or an object");
        const dr = rt.tlds.deny;
        if (dr) return Array.isArray(dr) && (rt = Object.assign({}, rt, { tlds: { deny: new Set(dr) } })), D(rt.tlds.deny instanceof Set, "tlds.deny must be an array, Set, or boolean"), D(!rt.tlds.allow, "Cannot specify both tlds.allow and tlds.deny lists"), br.validateTlds(rt.tlds.deny, "tlds.deny"), rt;
        const _r = rt.tlds.allow;
        return _r ? _r === !0 ? (D(br.tlds, "Built-in TLD list disabled"), Object.assign({}, rt, br.tlds)) : (Array.isArray(_r) && (rt = Object.assign({}, rt, { tlds: { allow: new Set(_r) } })), D(rt.tlds.allow instanceof Set, "tlds.allow must be an array, Set, or boolean"), br.validateTlds(rt.tlds.allow, "tlds.allow"), rt) : rt;
      }, br.validateTlds = function(rt, dr) {
        for (const _r of rt) D(Y.isValid(_r, { minDomainSegments: 1, maxDomainSegments: 1 }), `${dr} must contain valid top level domain names`);
      }, br.isoDate = function(rt) {
        if (!tt.isIsoDate(rt)) return null;
        /.*T.*[+-]\d\d$/.test(rt) && (rt += "00");
        const dr = new Date(rt);
        return isNaN(dr.getTime()) ? null : dr.toISOString();
      }, br.length = function(rt, dr, _r, Bi, qi) {
        return D(!qi || !1, "Invalid encoding:", qi), rt.$_addRule({ name: dr, method: "length", args: { limit: _r, encoding: qi }, operator: Bi });
      };
    }, 8826: (T, x, C) => {
      const D = C(375), Y = C(8068), L = {};
      L.Map = class extends Map {
        slice() {
          return new L.Map(this);
        }
      }, T.exports = Y.extend({ type: "symbol", terms: { map: { init: new L.Map() } }, coerce: { method(q, { schema: N, error: F }) {
        const ae = N.$_terms.map.get(q);
        return ae && (q = ae), N._flags.only && typeof q != "symbol" ? { value: q, errors: F("symbol.map", { map: N.$_terms.map }) } : { value: q };
      } }, validate(q, { error: N }) {
        if (typeof q != "symbol") return { value: q, errors: N("symbol.base") };
      }, rules: { map: { method(q) {
        q && !q[Symbol.iterator] && typeof q == "object" && (q = Object.entries(q)), D(q && q[Symbol.iterator], "Iterable must be an iterable or object");
        const N = this.clone(), F = [];
        for (const ae of q) {
          D(ae && ae[Symbol.iterator], "Entry must be an iterable");
          const [he, tt] = ae;
          D(typeof he != "object" && typeof he != "function" && typeof he != "symbol", "Key must not be of type object, function, or Symbol"), D(typeof tt == "symbol", "Value must be a Symbol"), N.$_terms.map.set(he, tt), F.push(tt);
        }
        return N.valid(...F);
      } } }, manifest: { build: (q, N) => (N.map && (q = q.map(N.map)), q) }, messages: { "symbol.base": "{{#label}} must be a symbol", "symbol.map": "{{#label}} must be one of {{#map}}" } });
    }, 8863: (T, x, C) => {
      const D = C(375), Y = C(8571), L = C(738), q = C(9621), N = C(8160), F = C(6354), ae = C(493), he = { result: Symbol("result") };
      x.entry = function(tt, br, rt) {
        let dr = N.defaults;
        rt && (D(rt.warnings === void 0, "Cannot override warnings preference in synchronous validation"), D(rt.artifacts === void 0, "Cannot override artifacts preference in synchronous validation"), dr = N.preferences(N.defaults, rt));
        const _r = he.entry(tt, br, dr);
        D(!_r.mainstay.externals.length, "Schema with external rules must use validateAsync()");
        const Bi = { value: _r.value };
        return _r.error && (Bi.error = _r.error), _r.mainstay.warnings.length && (Bi.warning = F.details(_r.mainstay.warnings)), _r.mainstay.debug && (Bi.debug = _r.mainstay.debug), _r.mainstay.artifacts && (Bi.artifacts = _r.mainstay.artifacts), Bi;
      }, x.entryAsync = async function(tt, br, rt) {
        let dr = N.defaults;
        rt && (dr = N.preferences(N.defaults, rt));
        const _r = he.entry(tt, br, dr), Bi = _r.mainstay;
        if (_r.error) throw Bi.debug && (_r.error.debug = Bi.debug), _r.error;
        if (Bi.externals.length) {
          let Wi = _r.value;
          const Vi = [];
          for (const Ti of Bi.externals) {
            const Li = Ti.state.path, Hi = Ti.schema.type === "link" ? Bi.links.get(Ti.schema) : null;
            let pr, Di, z = Wi;
            const gr = Li.length ? [Wi] : [], vr = Li.length ? q(tt, Li) : tt;
            if (Li.length) {
              pr = Li[Li.length - 1];
              let Oi = Wi;
              for (const Mi of Li.slice(0, -1)) Oi = Oi[Mi], gr.unshift(Oi);
              Di = gr[0], z = Di[pr];
            }
            try {
              const Oi = (ki, yr) => (Hi || Ti.schema).$_createError(ki, z, yr, Ti.state, dr), Mi = await Ti.method(z, { schema: Ti.schema, linked: Hi, state: Ti.state, prefs: rt, original: vr, error: Oi, errorsArray: he.errorsArray, warn: (ki, yr) => Bi.warnings.push((Hi || Ti.schema).$_createError(ki, z, yr, Ti.state, dr)), message: (ki, yr) => (Hi || Ti.schema).$_createError("external", z, yr, Ti.state, dr, { messages: ki }) });
              if (Mi === void 0 || Mi === z) continue;
              if (Mi instanceof F.Report) {
                if (Bi.tracer.log(Ti.schema, Ti.state, "rule", "external", "error"), Vi.push(Mi), dr.abortEarly) break;
                continue;
              }
              if (Array.isArray(Mi) && Mi[N.symbols.errors]) {
                if (Bi.tracer.log(Ti.schema, Ti.state, "rule", "external", "error"), Vi.push(...Mi), dr.abortEarly) break;
                continue;
              }
              Di ? (Bi.tracer.value(Ti.state, "rule", z, Mi, "external"), Di[pr] = Mi) : (Bi.tracer.value(Ti.state, "rule", Wi, Mi, "external"), Wi = Mi);
            } catch (Oi) {
              throw dr.errors.label && (Oi.message += ` (${Ti.label})`), Oi;
            }
          }
          if (_r.value = Wi, Vi.length) throw _r.error = F.process(Vi, tt, dr), Bi.debug && (_r.error.debug = Bi.debug), _r.error;
        }
        if (!dr.warnings && !dr.debug && !dr.artifacts) return _r.value;
        const qi = { value: _r.value };
        return Bi.warnings.length && (qi.warning = F.details(Bi.warnings)), Bi.debug && (qi.debug = Bi.debug), Bi.artifacts && (qi.artifacts = Bi.artifacts), qi;
      }, he.Mainstay = class {
        constructor(tt, br, rt) {
          this.externals = [], this.warnings = [], this.tracer = tt, this.debug = br, this.links = rt, this.shadow = null, this.artifacts = null, this._snapshots = [];
        }
        snapshot() {
          this._snapshots.push({ externals: this.externals.slice(), warnings: this.warnings.slice() });
        }
        restore() {
          const tt = this._snapshots.pop();
          this.externals = tt.externals, this.warnings = tt.warnings;
        }
        commit() {
          this._snapshots.pop();
        }
      }, he.entry = function(tt, br, rt) {
        const { tracer: dr, cleanup: _r } = he.tracer(br, rt), Bi = rt.debug ? [] : null, qi = br._ids._schemaChain ? /* @__PURE__ */ new Map() : null, Wi = new he.Mainstay(dr, Bi, qi), Vi = br._ids._schemaChain ? [{ schema: br }] : null, Ti = new ae([], [], { mainstay: Wi, schemas: Vi }), Li = x.validate(tt, br, Ti, rt);
        _r && br.$_root.untrace();
        const Hi = F.process(Li.errors, tt, rt);
        return { value: Li.value, error: Hi, mainstay: Wi };
      }, he.tracer = function(tt, br) {
        return tt.$_root._tracer ? { tracer: tt.$_root._tracer._register(tt) } : br.debug ? (D(tt.$_root.trace, "Debug mode not supported"), { tracer: tt.$_root.trace()._register(tt), cleanup: !0 }) : { tracer: he.ignore };
      }, x.validate = function(tt, br, rt, dr, _r = {}) {
        if (br.$_terms.whens && (br = br._generate(tt, rt, dr).schema), br._preferences && (dr = he.prefs(br, dr)), br._cache && dr.cache) {
          const Hi = br._cache.get(tt);
          if (rt.mainstay.tracer.debug(rt, "validate", "cached", !!Hi), Hi) return Hi;
        }
        const Bi = (Hi, pr, Di) => br.$_createError(Hi, tt, pr, Di || rt, dr), qi = { original: tt, prefs: dr, schema: br, state: rt, error: Bi, errorsArray: he.errorsArray, warn: (Hi, pr, Di) => rt.mainstay.warnings.push(Bi(Hi, pr, Di)), message: (Hi, pr) => br.$_createError("custom", tt, pr, rt, dr, { messages: Hi }) };
        rt.mainstay.tracer.entry(br, rt);
        const Wi = br._definition;
        if (Wi.prepare && tt !== void 0 && dr.convert) {
          const Hi = Wi.prepare(tt, qi);
          if (Hi) {
            if (rt.mainstay.tracer.value(rt, "prepare", tt, Hi.value), Hi.errors) return he.finalize(Hi.value, [].concat(Hi.errors), qi);
            tt = Hi.value;
          }
        }
        if (Wi.coerce && tt !== void 0 && dr.convert && (!Wi.coerce.from || Wi.coerce.from.includes(typeof tt))) {
          const Hi = Wi.coerce.method(tt, qi);
          if (Hi) {
            if (rt.mainstay.tracer.value(rt, "coerced", tt, Hi.value), Hi.errors) return he.finalize(Hi.value, [].concat(Hi.errors), qi);
            tt = Hi.value;
          }
        }
        const Vi = br._flags.empty;
        Vi && Vi.$_match(he.trim(tt, br), rt.nest(Vi), N.defaults) && (rt.mainstay.tracer.value(rt, "empty", tt, void 0), tt = void 0);
        const Ti = _r.presence || br._flags.presence || (br._flags._endedSwitch ? null : dr.presence);
        if (tt === void 0) {
          if (Ti === "forbidden") return he.finalize(tt, null, qi);
          if (Ti === "required") return he.finalize(tt, [br.$_createError("any.required", tt, null, rt, dr)], qi);
          if (Ti === "optional") {
            if (br._flags.default !== N.symbols.deepDefault) return he.finalize(tt, null, qi);
            rt.mainstay.tracer.value(rt, "default", tt, {}), tt = {};
          }
        } else if (Ti === "forbidden") return he.finalize(tt, [br.$_createError("any.unknown", tt, null, rt, dr)], qi);
        const Li = [];
        if (br._valids) {
          const Hi = br._valids.get(tt, rt, dr, br._flags.insensitive);
          if (Hi) return dr.convert && (rt.mainstay.tracer.value(rt, "valids", tt, Hi.value), tt = Hi.value), rt.mainstay.tracer.filter(br, rt, "valid", Hi), he.finalize(tt, null, qi);
          if (br._flags.only) {
            const pr = br.$_createError("any.only", tt, { valids: br._valids.values({ display: !0 }) }, rt, dr);
            if (dr.abortEarly) return he.finalize(tt, [pr], qi);
            Li.push(pr);
          }
        }
        if (br._invalids) {
          const Hi = br._invalids.get(tt, rt, dr, br._flags.insensitive);
          if (Hi) {
            rt.mainstay.tracer.filter(br, rt, "invalid", Hi);
            const pr = br.$_createError("any.invalid", tt, { invalids: br._invalids.values({ display: !0 }) }, rt, dr);
            if (dr.abortEarly) return he.finalize(tt, [pr], qi);
            Li.push(pr);
          }
        }
        if (Wi.validate) {
          const Hi = Wi.validate(tt, qi);
          if (Hi && (rt.mainstay.tracer.value(rt, "base", tt, Hi.value), tt = Hi.value, Hi.errors)) {
            if (!Array.isArray(Hi.errors)) return Li.push(Hi.errors), he.finalize(tt, Li, qi);
            if (Hi.errors.length) return Li.push(...Hi.errors), he.finalize(tt, Li, qi);
          }
        }
        return br._rules.length ? he.rules(tt, Li, qi) : he.finalize(tt, Li, qi);
      }, he.rules = function(tt, br, rt) {
        const { schema: dr, state: _r, prefs: Bi } = rt;
        for (const qi of dr._rules) {
          const Wi = dr._definition.rules[qi.method];
          if (Wi.convert && Bi.convert) {
            _r.mainstay.tracer.log(dr, _r, "rule", qi.name, "full");
            continue;
          }
          let Vi, Ti = qi.args;
          if (qi._resolve.length) {
            Ti = Object.assign({}, Ti);
            for (const Hi of qi._resolve) {
              const pr = Wi.argsByName.get(Hi), Di = Ti[Hi].resolve(tt, _r, Bi), z = pr.normalize ? pr.normalize(Di) : Di, gr = N.validateArg(z, null, pr);
              if (gr) {
                Vi = dr.$_createError("any.ref", Di, { arg: Hi, ref: Ti[Hi], reason: gr }, _r, Bi);
                break;
              }
              Ti[Hi] = z;
            }
          }
          Vi = Vi || Wi.validate(tt, rt, Ti, qi);
          const Li = he.rule(Vi, qi);
          if (Li.errors) {
            if (_r.mainstay.tracer.log(dr, _r, "rule", qi.name, "error"), qi.warn) {
              _r.mainstay.warnings.push(...Li.errors);
              continue;
            }
            if (Bi.abortEarly) return he.finalize(tt, Li.errors, rt);
            br.push(...Li.errors);
          } else _r.mainstay.tracer.log(dr, _r, "rule", qi.name, "pass"), _r.mainstay.tracer.value(_r, "rule", tt, Li.value, qi.name), tt = Li.value;
        }
        return he.finalize(tt, br, rt);
      }, he.rule = function(tt, br) {
        return tt instanceof F.Report ? (he.error(tt, br), { errors: [tt], value: null }) : Array.isArray(tt) && tt[N.symbols.errors] ? (tt.forEach((rt) => he.error(rt, br)), { errors: tt, value: null }) : { errors: null, value: tt };
      }, he.error = function(tt, br) {
        return br.message && tt._setTemplate(br.message), tt;
      }, he.finalize = function(tt, br, rt) {
        br = br || [];
        const { schema: dr, state: _r, prefs: Bi } = rt;
        if (br.length) {
          const Wi = he.default("failover", void 0, br, rt);
          Wi !== void 0 && (_r.mainstay.tracer.value(_r, "failover", tt, Wi), tt = Wi, br = []);
        }
        if (br.length && dr._flags.error) if (typeof dr._flags.error == "function") {
          br = dr._flags.error(br), Array.isArray(br) || (br = [br]);
          for (const Wi of br) D(Wi instanceof Error || Wi instanceof F.Report, "error() must return an Error object");
        } else br = [dr._flags.error];
        if (tt === void 0) {
          const Wi = he.default("default", tt, br, rt);
          _r.mainstay.tracer.value(_r, "default", tt, Wi), tt = Wi;
        }
        if (dr._flags.cast && tt !== void 0) {
          const Wi = dr._definition.cast[dr._flags.cast];
          if (Wi.from(tt)) {
            const Vi = Wi.to(tt, rt);
            _r.mainstay.tracer.value(_r, "cast", tt, Vi, dr._flags.cast), tt = Vi;
          }
        }
        if (dr.$_terms.externals && Bi.externals && Bi._externals !== !1) for (const { method: Wi } of dr.$_terms.externals) _r.mainstay.externals.push({ method: Wi, schema: dr, state: _r, label: F.label(dr._flags, _r, Bi) });
        const qi = { value: tt, errors: br.length ? br : null };
        return dr._flags.result && (qi.value = dr._flags.result === "strip" ? void 0 : rt.original, _r.mainstay.tracer.value(_r, dr._flags.result, tt, qi.value), _r.shadow(tt, dr._flags.result)), dr._cache && Bi.cache !== !1 && !dr._refs.length && dr._cache.set(rt.original, qi), tt === void 0 || qi.errors || dr._flags.artifact === void 0 || (_r.mainstay.artifacts = _r.mainstay.artifacts || /* @__PURE__ */ new Map(), _r.mainstay.artifacts.has(dr._flags.artifact) || _r.mainstay.artifacts.set(dr._flags.artifact, []), _r.mainstay.artifacts.get(dr._flags.artifact).push(_r.path)), qi;
      }, he.prefs = function(tt, br) {
        const rt = br === N.defaults;
        return rt && tt._preferences[N.symbols.prefs] ? tt._preferences[N.symbols.prefs] : (br = N.preferences(br, tt._preferences), rt && (tt._preferences[N.symbols.prefs] = br), br);
      }, he.default = function(tt, br, rt, dr) {
        const { schema: _r, state: Bi, prefs: qi } = dr, Wi = _r._flags[tt];
        if (qi.noDefaults || Wi === void 0) return br;
        if (Bi.mainstay.tracer.log(_r, Bi, "rule", tt, "full"), !Wi) return Wi;
        if (typeof Wi == "function") {
          const Vi = Wi.length ? [Y(Bi.ancestors[0]), dr] : [];
          try {
            return Wi(...Vi);
          } catch (Ti) {
            return void rt.push(_r.$_createError(`any.${tt}`, null, { error: Ti }, Bi, qi));
          }
        }
        return typeof Wi != "object" ? Wi : Wi[N.symbols.literal] ? Wi.literal : N.isResolvable(Wi) ? Wi.resolve(br, Bi, qi) : Y(Wi);
      }, he.trim = function(tt, br) {
        if (typeof tt != "string") return tt;
        const rt = br.$_getRule("trim");
        return rt && rt.args.enabled ? tt.trim() : tt;
      }, he.ignore = { active: !1, debug: L, entry: L, filter: L, log: L, resolve: L, value: L }, he.errorsArray = function() {
        const tt = [];
        return tt[N.symbols.errors] = !0, tt;
      };
    }, 2036: (T, x, C) => {
      const D = C(375), Y = C(9474), L = C(8160), q = {};
      T.exports = q.Values = class {
        constructor(N, F) {
          this._values = new Set(N), this._refs = new Set(F), this._lowercase = q.lowercases(N), this._override = !1;
        }
        get length() {
          return this._values.size + this._refs.size;
        }
        add(N, F) {
          L.isResolvable(N) ? this._refs.has(N) || (this._refs.add(N), F && F.register(N)) : this.has(N, null, null, !1) || (this._values.add(N), typeof N == "string" && this._lowercase.set(N.toLowerCase(), N));
        }
        static merge(N, F, ae) {
          if (N = N || new q.Values(), F) {
            if (F._override) return F.clone();
            for (const he of [...F._values, ...F._refs]) N.add(he);
          }
          if (ae) for (const he of [...ae._values, ...ae._refs]) N.remove(he);
          return N.length ? N : null;
        }
        remove(N) {
          L.isResolvable(N) ? this._refs.delete(N) : (this._values.delete(N), typeof N == "string" && this._lowercase.delete(N.toLowerCase()));
        }
        has(N, F, ae, he) {
          return !!this.get(N, F, ae, he);
        }
        get(N, F, ae, he) {
          if (!this.length) return !1;
          if (this._values.has(N)) return { value: N };
          if (typeof N == "string" && N && he) {
            const tt = this._lowercase.get(N.toLowerCase());
            if (tt) return { value: tt };
          }
          if (!this._refs.size && typeof N != "object") return !1;
          if (typeof N == "object") {
            for (const tt of this._values) if (Y(tt, N)) return { value: tt };
          }
          if (F) for (const tt of this._refs) {
            const br = tt.resolve(N, F, ae, null, { in: !0 });
            if (br === void 0) continue;
            const rt = tt.in && typeof br == "object" ? Array.isArray(br) ? br : Object.keys(br) : [br];
            for (const dr of rt) if (typeof dr == typeof N) {
              if (he && N && typeof N == "string") {
                if (dr.toLowerCase() === N.toLowerCase()) return { value: dr, ref: tt };
              } else if (Y(dr, N)) return { value: dr, ref: tt };
            }
          }
          return !1;
        }
        override() {
          this._override = !0;
        }
        values(N) {
          if (N && N.display) {
            const F = [];
            for (const ae of [...this._values, ...this._refs]) ae !== void 0 && F.push(ae);
            return F;
          }
          return Array.from([...this._values, ...this._refs]);
        }
        clone() {
          const N = new q.Values(this._values, this._refs);
          return N._override = this._override, N;
        }
        concat(N) {
          D(!N._override, "Cannot concat override set of values");
          const F = new q.Values([...this._values, ...N._values], [...this._refs, ...N._refs]);
          return F._override = this._override, F;
        }
        describe() {
          const N = [];
          this._override && N.push({ override: !0 });
          for (const F of this._values.values()) N.push(F && typeof F == "object" ? { value: F } : F);
          for (const F of this._refs.values()) N.push(F.describe());
          return N;
        }
      }, q.Values.prototype[L.symbols.values] = !0, q.Values.prototype.slice = q.Values.prototype.clone, q.lowercases = function(N) {
        const F = /* @__PURE__ */ new Map();
        if (N) for (const ae of N) typeof ae == "string" && F.set(ae.toLowerCase(), ae);
        return F;
      };
    }, 978: (T, x, C) => {
      const D = C(375), Y = C(8571), L = C(1687), q = C(9621), N = {};
      T.exports = function(F, ae, he = {}) {
        if (D(F && typeof F == "object", "Invalid defaults value: must be an object"), D(!ae || ae === !0 || typeof ae == "object", "Invalid source value: must be true, falsy or an object"), D(typeof he == "object", "Invalid options: must be an object"), !ae) return null;
        if (he.shallow) return N.applyToDefaultsWithShallow(F, ae, he);
        const tt = Y(F);
        if (ae === !0) return tt;
        const br = he.nullOverride !== void 0 && he.nullOverride;
        return L(tt, ae, { nullOverride: br, mergeArrays: !1 });
      }, N.applyToDefaultsWithShallow = function(F, ae, he) {
        const tt = he.shallow;
        D(Array.isArray(tt), "Invalid keys");
        const br = /* @__PURE__ */ new Map(), rt = ae === !0 ? null : /* @__PURE__ */ new Set();
        for (let Bi of tt) {
          Bi = Array.isArray(Bi) ? Bi : Bi.split(".");
          const qi = q(F, Bi);
          qi && typeof qi == "object" ? br.set(qi, rt && q(ae, Bi) || qi) : rt && rt.add(Bi);
        }
        const dr = Y(F, {}, br);
        if (!rt) return dr;
        for (const Bi of rt) N.reachCopy(dr, ae, Bi);
        const _r = he.nullOverride !== void 0 && he.nullOverride;
        return L(dr, ae, { nullOverride: _r, mergeArrays: !1 });
      }, N.reachCopy = function(F, ae, he) {
        for (const rt of he) {
          if (!(rt in ae)) return;
          const dr = ae[rt];
          if (typeof dr != "object" || dr === null) return;
          ae = dr;
        }
        const tt = ae;
        let br = F;
        for (let rt = 0; rt < he.length - 1; ++rt) {
          const dr = he[rt];
          typeof br[dr] != "object" && (br[dr] = {}), br = br[dr];
        }
        br[he[he.length - 1]] = tt;
      };
    }, 375: (T, x, C) => {
      const D = C(7916);
      T.exports = function(Y, ...L) {
        if (!Y)
          throw L.length === 1 && L[0] instanceof Error ? L[0] : new D(L);
      };
    }, 8571: (T, x, C) => {
      const D = C(9621), Y = C(4277), L = C(7043), q = { needsProtoHack: /* @__PURE__ */ new Set([Y.set, Y.map, Y.weakSet, Y.weakMap]) };
      T.exports = q.clone = function(N, F = {}, ae = null) {
        if (typeof N != "object" || N === null) return N;
        let he = q.clone, tt = ae;
        if (F.shallow) {
          if (F.shallow !== !0) return q.cloneWithShallow(N, F);
          he = (_r) => _r;
        } else if (tt) {
          const _r = tt.get(N);
          if (_r) return _r;
        } else tt = /* @__PURE__ */ new Map();
        const br = Y.getInternalProto(N);
        if (br === Y.buffer) return !1;
        if (br === Y.date) return new Date(N.getTime());
        if (br === Y.regex) return new RegExp(N);
        const rt = q.base(N, br, F);
        if (rt === N) return N;
        if (tt && tt.set(N, rt), br === Y.set) for (const _r of N) rt.add(he(_r, F, tt));
        else if (br === Y.map) for (const [_r, Bi] of N) rt.set(_r, he(Bi, F, tt));
        const dr = L.keys(N, F);
        for (const _r of dr) {
          if (_r === "__proto__") continue;
          if (br === Y.array && _r === "length") {
            rt.length = N.length;
            continue;
          }
          const Bi = Object.getOwnPropertyDescriptor(N, _r);
          Bi ? Bi.get || Bi.set ? Object.defineProperty(rt, _r, Bi) : Bi.enumerable ? rt[_r] = he(N[_r], F, tt) : Object.defineProperty(rt, _r, { enumerable: !1, writable: !0, configurable: !0, value: he(N[_r], F, tt) }) : Object.defineProperty(rt, _r, { enumerable: !0, writable: !0, configurable: !0, value: he(N[_r], F, tt) });
        }
        return rt;
      }, q.cloneWithShallow = function(N, F) {
        const ae = F.shallow;
        (F = Object.assign({}, F)).shallow = !1;
        const he = /* @__PURE__ */ new Map();
        for (const tt of ae) {
          const br = D(N, tt);
          typeof br != "object" && typeof br != "function" || he.set(br, br);
        }
        return q.clone(N, F, he);
      }, q.base = function(N, F, ae) {
        if (ae.prototype === !1) return q.needsProtoHack.has(F) ? new F.constructor() : F === Y.array ? [] : {};
        const he = Object.getPrototypeOf(N);
        if (he && he.isImmutable) return N;
        if (F === Y.array) {
          const tt = [];
          return he !== F && Object.setPrototypeOf(tt, he), tt;
        }
        if (q.needsProtoHack.has(F)) {
          const tt = new he.constructor();
          return he !== F && Object.setPrototypeOf(tt, he), tt;
        }
        return Object.create(he);
      };
    }, 9474: (T, x, C) => {
      const D = C(4277), Y = { mismatched: null };
      T.exports = function(L, q, N) {
        return N = Object.assign({ prototype: !0 }, N), !!Y.isDeepEqual(L, q, N, []);
      }, Y.isDeepEqual = function(L, q, N, F) {
        if (L === q) return L !== 0 || 1 / L == 1 / q;
        const ae = typeof L;
        if (ae !== typeof q || L === null || q === null) return !1;
        if (ae === "function") {
          if (!N.deepFunction || L.toString() !== q.toString()) return !1;
        } else if (ae !== "object") return L != L && q != q;
        const he = Y.getSharedType(L, q, !!N.prototype);
        switch (he) {
          case D.buffer:
            return !1;
          case D.promise:
            return L === q;
          case D.regex:
            return L.toString() === q.toString();
          case Y.mismatched:
            return !1;
        }
        for (let tt = F.length - 1; tt >= 0; --tt) if (F[tt].isSame(L, q)) return !0;
        F.push(new Y.SeenEntry(L, q));
        try {
          return !!Y.isDeepEqualObj(he, L, q, N, F);
        } finally {
          F.pop();
        }
      }, Y.getSharedType = function(L, q, N) {
        if (N) return Object.getPrototypeOf(L) !== Object.getPrototypeOf(q) ? Y.mismatched : D.getInternalProto(L);
        const F = D.getInternalProto(L);
        return F !== D.getInternalProto(q) ? Y.mismatched : F;
      }, Y.valueOf = function(L) {
        const q = L.valueOf;
        if (q === void 0) return L;
        try {
          return q.call(L);
        } catch (N) {
          return N;
        }
      }, Y.hasOwnEnumerableProperty = function(L, q) {
        return Object.prototype.propertyIsEnumerable.call(L, q);
      }, Y.isSetSimpleEqual = function(L, q) {
        for (const N of Set.prototype.values.call(L)) if (!Set.prototype.has.call(q, N)) return !1;
        return !0;
      }, Y.isDeepEqualObj = function(L, q, N, F, ae) {
        const { isDeepEqual: he, valueOf: tt, hasOwnEnumerableProperty: br } = Y, { keys: rt, getOwnPropertySymbols: dr } = Object;
        if (L === D.array) {
          if (!F.part) {
            if (q.length !== N.length) return !1;
            for (let Vi = 0; Vi < q.length; ++Vi) if (!he(q[Vi], N[Vi], F, ae)) return !1;
            return !0;
          }
          for (const Vi of q) for (const Ti of N) if (he(Vi, Ti, F, ae)) return !0;
        } else if (L === D.set) {
          if (q.size !== N.size) return !1;
          if (!Y.isSetSimpleEqual(q, N)) {
            const Vi = new Set(Set.prototype.values.call(N));
            for (const Ti of Set.prototype.values.call(q)) {
              if (Vi.delete(Ti)) continue;
              let Li = !1;
              for (const Hi of Vi) if (he(Ti, Hi, F, ae)) {
                Vi.delete(Hi), Li = !0;
                break;
              }
              if (!Li) return !1;
            }
          }
        } else if (L === D.map) {
          if (q.size !== N.size) return !1;
          for (const [Vi, Ti] of Map.prototype.entries.call(q))
            if (Ti === void 0 && !Map.prototype.has.call(N, Vi) || !he(Ti, Map.prototype.get.call(N, Vi), F, ae)) return !1;
        } else if (L === D.error && (q.name !== N.name || q.message !== N.message)) return !1;
        const _r = tt(q), Bi = tt(N);
        if ((q !== _r || N !== Bi) && !he(_r, Bi, F, ae)) return !1;
        const qi = rt(q);
        if (!F.part && qi.length !== rt(N).length && !F.skip) return !1;
        let Wi = 0;
        for (const Vi of qi) if (F.skip && F.skip.includes(Vi)) N[Vi] === void 0 && ++Wi;
        else if (!br(N, Vi) || !he(q[Vi], N[Vi], F, ae)) return !1;
        if (!F.part && qi.length - Wi !== rt(N).length) return !1;
        if (F.symbols !== !1) {
          const Vi = dr(q), Ti = new Set(dr(N));
          for (const Li of Vi) {
            if (!F.skip || !F.skip.includes(Li)) {
              if (br(q, Li)) {
                if (!br(N, Li) || !he(q[Li], N[Li], F, ae)) return !1;
              } else if (br(N, Li)) return !1;
            }
            Ti.delete(Li);
          }
          for (const Li of Ti) if (br(N, Li)) return !1;
        }
        return !0;
      }, Y.SeenEntry = class {
        constructor(L, q) {
          this.obj = L, this.ref = q;
        }
        isSame(L, q) {
          return this.obj === L && this.ref === q;
        }
      };
    }, 7916: (T, x, C) => {
      const D = C(8761);
      T.exports = class extends Error {
        constructor(Y) {
          super(Y.filter((L) => L !== "").map((L) => typeof L == "string" ? L : L instanceof Error ? L.message : D(L)).join(" ") || "Unknown error"), typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, x.assert);
        }
      };
    }, 5277: (T) => {
      const x = {};
      T.exports = function(C) {
        if (!C) return "";
        let D = "";
        for (let Y = 0; Y < C.length; ++Y) {
          const L = C.charCodeAt(Y);
          x.isSafe(L) ? D += C[Y] : D += x.escapeHtmlChar(L);
        }
        return D;
      }, x.escapeHtmlChar = function(C) {
        return x.namedHtml.get(C) || (C >= 256 ? "&#" + C + ";" : `&#x${C.toString(16).padStart(2, "0")};`);
      }, x.isSafe = function(C) {
        return x.safeCharCodes.has(C);
      }, x.namedHtml = /* @__PURE__ */ new Map([[38, "&amp;"], [60, "&lt;"], [62, "&gt;"], [34, "&quot;"], [160, "&nbsp;"], [162, "&cent;"], [163, "&pound;"], [164, "&curren;"], [169, "&copy;"], [174, "&reg;"]]), x.safeCharCodes = function() {
        const C = /* @__PURE__ */ new Set();
        for (let D = 32; D < 123; ++D) (D >= 97 || D >= 65 && D <= 90 || D >= 48 && D <= 57 || D === 32 || D === 46 || D === 44 || D === 45 || D === 58 || D === 95) && C.add(D);
        return C;
      }();
    }, 6064: (T) => {
      T.exports = function(x) {
        return x.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
      };
    }, 738: (T) => {
      T.exports = function() {
      };
    }, 1687: (T, x, C) => {
      const D = C(375), Y = C(8571), L = C(7043), q = {};
      T.exports = q.merge = function(N, F, ae) {
        if (D(N && typeof N == "object", "Invalid target value: must be an object"), D(F == null || typeof F == "object", "Invalid source value: must be null, undefined, or an object"), !F) return N;
        if (ae = Object.assign({ nullOverride: !0, mergeArrays: !0 }, ae), Array.isArray(F)) {
          D(Array.isArray(N), "Cannot merge array onto an object"), ae.mergeArrays || (N.length = 0);
          for (let tt = 0; tt < F.length; ++tt) N.push(Y(F[tt], { symbols: ae.symbols }));
          return N;
        }
        const he = L.keys(F, ae);
        for (let tt = 0; tt < he.length; ++tt) {
          const br = he[tt];
          if (br === "__proto__" || !Object.prototype.propertyIsEnumerable.call(F, br)) continue;
          const rt = F[br];
          if (rt && typeof rt == "object") {
            if (N[br] === rt) continue;
            !N[br] || typeof N[br] != "object" || Array.isArray(N[br]) !== Array.isArray(rt) || rt instanceof Date || rt instanceof RegExp ? N[br] = Y(rt, { symbols: ae.symbols }) : q.merge(N[br], rt, ae);
          } else (rt != null || ae.nullOverride) && (N[br] = rt);
        }
        return N;
      };
    }, 9621: (T, x, C) => {
      const D = C(375), Y = {};
      T.exports = function(L, q, N) {
        if (q === !1 || q == null) return L;
        typeof (N = N || {}) == "string" && (N = { separator: N });
        const F = Array.isArray(q);
        D(!F || !N.separator, "Separator option is not valid for array-based chain");
        const ae = F ? q : q.split(N.separator || ".");
        let he = L;
        for (let tt = 0; tt < ae.length; ++tt) {
          let br = ae[tt];
          const rt = N.iterables && Y.iterables(he);
          if (Array.isArray(he) || rt === "set") {
            const dr = Number(br);
            Number.isInteger(dr) && (br = dr < 0 ? he.length + dr : dr);
          }
          if (!he || typeof he == "function" && N.functions === !1 || !rt && he[br] === void 0) {
            D(!N.strict || tt + 1 === ae.length, "Missing segment", br, "in reach path ", q), D(typeof he == "object" || N.functions === !0 || typeof he != "function", "Invalid segment", br, "in reach path ", q), he = N.default;
            break;
          }
          he = rt ? rt === "set" ? [...he][br] : he.get(br) : he[br];
        }
        return he;
      }, Y.iterables = function(L) {
        return L instanceof Set ? "set" : L instanceof Map ? "map" : void 0;
      };
    }, 8761: (T) => {
      T.exports = function(...x) {
        try {
          return JSON.stringify(...x);
        } catch (C) {
          return "[Cannot display object: " + C.message + "]";
        }
      };
    }, 4277: (T, x) => {
      const C = {};
      x = T.exports = { array: Array.prototype, buffer: !1, date: Date.prototype, error: Error.prototype, generic: Object.prototype, map: Map.prototype, promise: Promise.prototype, regex: RegExp.prototype, set: Set.prototype, weakMap: WeakMap.prototype, weakSet: WeakSet.prototype }, C.typeMap = /* @__PURE__ */ new Map([["[object Error]", x.error], ["[object Map]", x.map], ["[object Promise]", x.promise], ["[object Set]", x.set], ["[object WeakMap]", x.weakMap], ["[object WeakSet]", x.weakSet]]), x.getInternalProto = function(D) {
        if (Array.isArray(D)) return x.array;
        if (D instanceof Date) return x.date;
        if (D instanceof RegExp) return x.regex;
        if (D instanceof Error) return x.error;
        const Y = Object.prototype.toString.call(D);
        return C.typeMap.get(Y) || x.generic;
      };
    }, 7043: (T, x) => {
      x.keys = function(C, D = {}) {
        return D.symbols !== !1 ? Reflect.ownKeys(C) : Object.getOwnPropertyNames(C);
      };
    }, 3652: (T, x, C) => {
      const D = C(375), Y = {};
      x.Sorter = class {
        constructor() {
          this._items = [], this.nodes = [];
        }
        add(L, q) {
          const N = [].concat((q = q || {}).before || []), F = [].concat(q.after || []), ae = q.group || "?", he = q.sort || 0;
          D(!N.includes(ae), `Item cannot come before itself: ${ae}`), D(!N.includes("?"), "Item cannot come before unassociated items"), D(!F.includes(ae), `Item cannot come after itself: ${ae}`), D(!F.includes("?"), "Item cannot come after unassociated items"), Array.isArray(L) || (L = [L]);
          for (const tt of L) {
            const br = { seq: this._items.length, sort: he, before: N, after: F, group: ae, node: tt };
            this._items.push(br);
          }
          if (!q.manual) {
            const tt = this._sort();
            D(tt, "item", ae !== "?" ? `added into group ${ae}` : "", "created a dependencies error");
          }
          return this.nodes;
        }
        merge(L) {
          Array.isArray(L) || (L = [L]);
          for (const N of L) if (N) for (const F of N._items) this._items.push(Object.assign({}, F));
          this._items.sort(Y.mergeSort);
          for (let N = 0; N < this._items.length; ++N) this._items[N].seq = N;
          const q = this._sort();
          return D(q, "merge created a dependencies error"), this.nodes;
        }
        sort() {
          const L = this._sort();
          return D(L, "sort created a dependencies error"), this.nodes;
        }
        _sort() {
          const L = {}, q = /* @__PURE__ */ Object.create(null), N = /* @__PURE__ */ Object.create(null);
          for (const br of this._items) {
            const rt = br.seq, dr = br.group;
            N[dr] = N[dr] || [], N[dr].push(rt), L[rt] = br.before;
            for (const _r of br.after) q[_r] = q[_r] || [], q[_r].push(rt);
          }
          for (const br in L) {
            const rt = [];
            for (const dr in L[br]) {
              const _r = L[br][dr];
              N[_r] = N[_r] || [], rt.push(...N[_r]);
            }
            L[br] = rt;
          }
          for (const br in q) if (N[br]) for (const rt of N[br]) L[rt].push(...q[br]);
          const F = {};
          for (const br in L) {
            const rt = L[br];
            for (const dr of rt) F[dr] = F[dr] || [], F[dr].push(br);
          }
          const ae = {}, he = [];
          for (let br = 0; br < this._items.length; ++br) {
            let rt = br;
            if (F[br]) {
              rt = null;
              for (let dr = 0; dr < this._items.length; ++dr) {
                if (ae[dr] === !0) continue;
                F[dr] || (F[dr] = []);
                const _r = F[dr].length;
                let Bi = 0;
                for (let qi = 0; qi < _r; ++qi) ae[F[dr][qi]] && ++Bi;
                if (Bi === _r) {
                  rt = dr;
                  break;
                }
              }
            }
            rt !== null && (ae[rt] = !0, he.push(rt));
          }
          if (he.length !== this._items.length) return !1;
          const tt = {};
          for (const br of this._items) tt[br.seq] = br;
          this._items = [], this.nodes = [];
          for (const br of he) {
            const rt = tt[br];
            this.nodes.push(rt.node), this._items.push(rt);
          }
          return !0;
        }
      }, Y.mergeSort = (L, q) => L.sort === q.sort ? 0 : L.sort < q.sort ? -1 : 1;
    }, 5380: (T, x, C) => {
      const D = C(443), Y = C(2178), L = { minDomainSegments: 2, nonAsciiRx: /[^\x00-\x7f]/, domainControlRx: /[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/, tldSegmentRx: /^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/, domainSegmentRx: /^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/, URL: D.URL || URL };
      x.analyze = function(q, N = {}) {
        if (!q) return Y.code("DOMAIN_NON_EMPTY_STRING");
        if (typeof q != "string") throw new Error("Invalid input: domain must be a string");
        if (q.length > 256) return Y.code("DOMAIN_TOO_LONG");
        if (L.nonAsciiRx.test(q)) {
          if (N.allowUnicode === !1) return Y.code("DOMAIN_INVALID_UNICODE_CHARS");
          q = q.normalize("NFC");
        }
        if (L.domainControlRx.test(q)) return Y.code("DOMAIN_INVALID_CHARS");
        q = L.punycode(q), N.allowFullyQualified && q[q.length - 1] === "." && (q = q.slice(0, -1));
        const F = N.minDomainSegments || L.minDomainSegments, ae = q.split(".");
        if (ae.length < F) return Y.code("DOMAIN_SEGMENTS_COUNT");
        if (N.maxDomainSegments && ae.length > N.maxDomainSegments) return Y.code("DOMAIN_SEGMENTS_COUNT_MAX");
        const he = N.tlds;
        if (he) {
          const tt = ae[ae.length - 1].toLowerCase();
          if (he.deny && he.deny.has(tt) || he.allow && !he.allow.has(tt)) return Y.code("DOMAIN_FORBIDDEN_TLDS");
        }
        for (let tt = 0; tt < ae.length; ++tt) {
          const br = ae[tt];
          if (!br.length) return Y.code("DOMAIN_EMPTY_SEGMENT");
          if (br.length > 63) return Y.code("DOMAIN_LONG_SEGMENT");
          if (tt < ae.length - 1) {
            if (!L.domainSegmentRx.test(br)) return Y.code("DOMAIN_INVALID_CHARS");
          } else if (!L.tldSegmentRx.test(br)) return Y.code("DOMAIN_INVALID_TLDS_CHARS");
        }
        return null;
      }, x.isValid = function(q, N) {
        return !x.analyze(q, N);
      }, L.punycode = function(q) {
        q.includes("%") && (q = q.replace(/%/g, "%25"));
        try {
          return new L.URL(`http://${q}`).host;
        } catch {
          return q;
        }
      };
    }, 1745: (T, x, C) => {
      const D = C(9848), Y = C(5380), L = C(2178), q = { nonAsciiRx: /[^\x00-\x7f]/, encoder: new (D.TextEncoder || TextEncoder)() };
      x.analyze = function(N, F) {
        return q.email(N, F);
      }, x.isValid = function(N, F) {
        return !q.email(N, F);
      }, q.email = function(N, F = {}) {
        if (typeof N != "string") throw new Error("Invalid input: email must be a string");
        if (!N) return L.code("EMPTY_STRING");
        const ae = !q.nonAsciiRx.test(N);
        if (!ae) {
          if (F.allowUnicode === !1) return L.code("FORBIDDEN_UNICODE");
          N = N.normalize("NFC");
        }
        const he = N.split("@");
        if (he.length !== 2) return he.length > 2 ? L.code("MULTIPLE_AT_CHAR") : L.code("MISSING_AT_CHAR");
        const [tt, br] = he;
        if (!tt) return L.code("EMPTY_LOCAL");
        if (!F.ignoreLength) {
          if (N.length > 254) return L.code("ADDRESS_TOO_LONG");
          if (q.encoder.encode(tt).length > 64) return L.code("LOCAL_TOO_LONG");
        }
        return q.local(tt, ae) || Y.analyze(br, F);
      }, q.local = function(N, F) {
        const ae = N.split(".");
        for (const he of ae) {
          if (!he.length) return L.code("EMPTY_LOCAL_SEGMENT");
          if (F) {
            if (!q.atextRx.test(he)) return L.code("INVALID_LOCAL_CHARS");
          } else for (const tt of he) {
            if (q.atextRx.test(tt)) continue;
            const br = q.binary(tt);
            if (!q.atomRx.test(br)) return L.code("INVALID_LOCAL_CHARS");
          }
        }
      }, q.binary = function(N) {
        return Array.from(q.encoder.encode(N)).map((F) => String.fromCharCode(F)).join("");
      }, q.atextRx = /^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/, q.atomRx = new RegExp(["(?:[\\xc2-\\xdf][\\x80-\\xbf])", "(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})", "(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"].join("|"));
    }, 2178: (T, x) => {
      x.codes = { EMPTY_STRING: "Address must be a non-empty string", FORBIDDEN_UNICODE: "Address contains forbidden Unicode characters", MULTIPLE_AT_CHAR: "Address cannot contain more than one @ character", MISSING_AT_CHAR: "Address must contain one @ character", EMPTY_LOCAL: "Address local part cannot be empty", ADDRESS_TOO_LONG: "Address too long", LOCAL_TOO_LONG: "Address local part too long", EMPTY_LOCAL_SEGMENT: "Address local part contains empty dot-separated segment", INVALID_LOCAL_CHARS: "Address local part contains invalid character", DOMAIN_NON_EMPTY_STRING: "Domain must be a non-empty string", DOMAIN_TOO_LONG: "Domain too long", DOMAIN_INVALID_UNICODE_CHARS: "Domain contains forbidden Unicode characters", DOMAIN_INVALID_CHARS: "Domain contains invalid character", DOMAIN_INVALID_TLDS_CHARS: "Domain contains invalid tld character", DOMAIN_SEGMENTS_COUNT: "Domain lacks the minimum required number of segments", DOMAIN_SEGMENTS_COUNT_MAX: "Domain contains too many segments", DOMAIN_FORBIDDEN_TLDS: "Domain uses forbidden TLD", DOMAIN_EMPTY_SEGMENT: "Domain contains empty dot-separated segment", DOMAIN_LONG_SEGMENT: "Domain contains dot-separated segment that is too long" }, x.code = function(C) {
        return { code: C, error: x.codes[C] };
      };
    }, 9959: (T, x, C) => {
      const D = C(375), Y = C(5752);
      x.regex = function(L = {}) {
        D(L.cidr === void 0 || typeof L.cidr == "string", "options.cidr must be a string");
        const q = L.cidr ? L.cidr.toLowerCase() : "optional";
        D(["required", "optional", "forbidden"].includes(q), "options.cidr must be one of required, optional, forbidden"), D(L.version === void 0 || typeof L.version == "string" || Array.isArray(L.version), "options.version must be a string or an array of string");
        let N = L.version || ["ipv4", "ipv6", "ipvfuture"];
        Array.isArray(N) || (N = [N]), D(N.length >= 1, "options.version must have at least 1 version specified");
        for (let he = 0; he < N.length; ++he) D(typeof N[he] == "string", "options.version must only contain strings"), N[he] = N[he].toLowerCase(), D(["ipv4", "ipv6", "ipvfuture"].includes(N[he]), "options.version contains unknown version " + N[he] + " - must be one of ipv4, ipv6, ipvfuture");
        N = Array.from(new Set(N));
        const F = `(?:${N.map((he) => {
          if (q === "forbidden") return Y.ip[he];
          const tt = `\\/${he === "ipv4" ? Y.ip.v4Cidr : Y.ip.v6Cidr}`;
          return q === "required" ? `${Y.ip[he]}${tt}` : `${Y.ip[he]}(?:${tt})?`;
        }).join("|")})`, ae = new RegExp(`^${F}$`);
        return { cidr: q, versions: N, regex: ae, raw: F };
      };
    }, 5752: (T, x, C) => {
      const D = C(375), Y = C(6064), L = { generate: function() {
        const q = {}, N = "\\dA-Fa-f", F = "[" + N + "]", ae = "\\w-\\.~", he = "!\\$&'\\(\\)\\*\\+,;=", tt = "%" + N, br = ae + tt + he + ":@", rt = "[" + br + "]", dr = "(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
        q.ipv4address = "(?:" + dr + "\\.){3}" + dr;
        const _r = F + "{1,4}", Bi = "(?:" + _r + ":" + _r + "|" + q.ipv4address + ")", qi = "(?:" + _r + ":){6}" + Bi, Wi = "::(?:" + _r + ":){5}" + Bi, Vi = "(?:" + _r + ")?::(?:" + _r + ":){4}" + Bi, Ti = "(?:(?:" + _r + ":){0,1}" + _r + ")?::(?:" + _r + ":){3}" + Bi, Li = "(?:(?:" + _r + ":){0,2}" + _r + ")?::(?:" + _r + ":){2}" + Bi, Hi = "(?:(?:" + _r + ":){0,3}" + _r + ")?::" + _r + ":" + Bi, pr = "(?:(?:" + _r + ":){0,4}" + _r + ")?::" + Bi, Di = "(?:(?:" + _r + ":){0,5}" + _r + ")?::" + _r, z = "(?:(?:" + _r + ":){0,6}" + _r + ")?::";
        q.ipv4Cidr = "(?:\\d|[1-2]\\d|3[0-2])", q.ipv6Cidr = "(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])", q.ipv6address = "(?:" + qi + "|" + Wi + "|" + Vi + "|" + Ti + "|" + Li + "|" + Hi + "|" + pr + "|" + Di + "|" + z + ")", q.ipvFuture = "v" + F + "+\\.[" + ae + he + ":]+", q.scheme = "[a-zA-Z][a-zA-Z\\d+-\\.]*", q.schemeRegex = new RegExp(q.scheme);
        const gr = "[" + ae + tt + he + ":]*", vr = "[" + ae + tt + he + "]{1,255}", Oi = "(?:\\[(?:" + q.ipv6address + "|" + q.ipvFuture + ")\\]|" + q.ipv4address + "|" + vr + ")", Mi = "(?:" + gr + "@)?" + Oi + "(?::\\d*)?", ki = "(?:" + gr + "@)?(" + Oi + ")(?::\\d*)?", yr = rt + "*", xi = rt + "+", Si = "(?:\\/" + yr + ")*", Ci = "\\/(?:" + xi + Si + ")?", Ki = xi + Si, Yi = "[" + ae + tt + he + "@]+" + Si, Qi = "(?:\\/\\/\\/" + yr + Si + ")";
        return q.hierPart = "(?:(?:\\/\\/" + Mi + Si + ")|" + Ci + "|" + Ki + "|" + Qi + ")", q.hierPartCapture = "(?:(?:\\/\\/" + ki + Si + ")|" + Ci + "|" + Ki + ")", q.relativeRef = "(?:(?:\\/\\/" + Mi + Si + ")|" + Ci + "|" + Yi + "|)", q.relativeRefCapture = "(?:(?:\\/\\/" + ki + Si + ")|" + Ci + "|" + Yi + "|)", q.query = "[" + br + "\\/\\?]*(?=#|$)", q.queryWithSquareBrackets = "[" + br + "\\[\\]\\/\\?]*(?=#|$)", q.fragment = "[" + br + "\\/\\?]*", q;
      } };
      L.rfc3986 = L.generate(), x.ip = { v4Cidr: L.rfc3986.ipv4Cidr, v6Cidr: L.rfc3986.ipv6Cidr, ipv4: L.rfc3986.ipv4address, ipv6: L.rfc3986.ipv6address, ipvfuture: L.rfc3986.ipvFuture }, L.createRegex = function(q) {
        const N = L.rfc3986, F = "(?:\\?" + (q.allowQuerySquareBrackets ? N.queryWithSquareBrackets : N.query) + ")?(?:#" + N.fragment + ")?", ae = q.domain ? N.relativeRefCapture : N.relativeRef;
        if (q.relativeOnly) return L.wrap(ae + F);
        let he = "";
        if (q.scheme) {
          D(q.scheme instanceof RegExp || typeof q.scheme == "string" || Array.isArray(q.scheme), "scheme must be a RegExp, String, or Array");
          const rt = [].concat(q.scheme);
          D(rt.length >= 1, "scheme must have at least 1 scheme specified");
          const dr = [];
          for (let _r = 0; _r < rt.length; ++_r) {
            const Bi = rt[_r];
            D(Bi instanceof RegExp || typeof Bi == "string", "scheme at position " + _r + " must be a RegExp or String"), Bi instanceof RegExp ? dr.push(Bi.source.toString()) : (D(N.schemeRegex.test(Bi), "scheme at position " + _r + " must be a valid scheme"), dr.push(Y(Bi)));
          }
          he = dr.join("|");
        }
        const tt = "(?:" + (he ? "(?:" + he + ")" : N.scheme) + ":" + (q.domain ? N.hierPartCapture : N.hierPart) + ")", br = q.allowRelative ? "(?:" + tt + "|" + ae + ")" : tt;
        return L.wrap(br + F, he);
      }, L.wrap = function(q, N) {
        return { raw: q = `(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${q}`, regex: new RegExp(`^${q}$`), scheme: N };
      }, L.uriRegex = L.createRegex({}), x.regex = function(q = {}) {
        return q.scheme || q.allowRelative || q.relativeOnly || q.allowQuerySquareBrackets || q.domain ? L.createRegex(q) : L.uriRegex;
      };
    }, 1447: (T, x) => {
      const C = { operators: ["!", "^", "*", "/", "%", "+", "-", "<", "<=", ">", ">=", "==", "!=", "&&", "||", "??"], operatorCharacters: ["!", "^", "*", "/", "%", "+", "-", "<", "=", ">", "&", "|", "?"], operatorsOrder: [["^"], ["*", "/", "%"], ["+", "-"], ["<", "<=", ">", ">="], ["==", "!="], ["&&"], ["||", "??"]], operatorsPrefix: ["!", "n"], literals: { '"': '"', "`": "`", "'": "'", "[": "]" }, numberRx: /^(?:[0-9]*(\.[0-9]*)?){1}$/, tokenRx: /^[\w\$\#\.\@\:\{\}]+$/, symbol: Symbol("formula"), settings: Symbol("settings") };
      x.Parser = class {
        constructor(D, Y = {}) {
          if (!Y[C.settings] && Y.constants) for (const L in Y.constants) {
            const q = Y.constants[L];
            if (q !== null && !["boolean", "number", "string"].includes(typeof q)) throw new Error(`Formula constant ${L} contains invalid ${typeof q} value type`);
          }
          this.settings = Y[C.settings] ? Y : Object.assign({ [C.settings]: !0, constants: {}, functions: {} }, Y), this.single = null, this._parts = null, this._parse(D);
        }
        _parse(D) {
          let Y = [], L = "", q = 0, N = !1;
          const F = (he) => {
            if (q) throw new Error("Formula missing closing parenthesis");
            const tt = Y.length ? Y[Y.length - 1] : null;
            if (N || L || he) {
              if (tt && tt.type === "reference" && he === ")") return tt.type = "function", tt.value = this._subFormula(L, tt.value), void (L = "");
              if (he === ")") {
                const br = new x.Parser(L, this.settings);
                Y.push({ type: "segment", value: br });
              } else if (N) {
                if (N === "]") return Y.push({ type: "reference", value: L }), void (L = "");
                Y.push({ type: "literal", value: L });
              } else if (C.operatorCharacters.includes(L)) tt && tt.type === "operator" && C.operators.includes(tt.value + L) ? tt.value += L : Y.push({ type: "operator", value: L });
              else if (L.match(C.numberRx)) Y.push({ type: "constant", value: parseFloat(L) });
              else if (this.settings.constants[L] !== void 0) Y.push({ type: "constant", value: this.settings.constants[L] });
              else {
                if (!L.match(C.tokenRx)) throw new Error(`Formula contains invalid token: ${L}`);
                Y.push({ type: "reference", value: L });
              }
              L = "";
            }
          };
          for (const he of D) N ? he === N ? (F(), N = !1) : L += he : q ? he === "(" ? (L += he, ++q) : he === ")" ? (--q, q ? L += he : F(he)) : L += he : he in C.literals ? N = C.literals[he] : he === "(" ? (F(), ++q) : C.operatorCharacters.includes(he) ? (F(), L = he, F()) : he !== " " ? L += he : F();
          F(), Y = Y.map((he, tt) => he.type !== "operator" || he.value !== "-" || tt && Y[tt - 1].type !== "operator" ? he : { type: "operator", value: "n" });
          let ae = !1;
          for (const he of Y) {
            if (he.type === "operator") {
              if (C.operatorsPrefix.includes(he.value)) continue;
              if (!ae) throw new Error("Formula contains an operator in invalid position");
              if (!C.operators.includes(he.value)) throw new Error(`Formula contains an unknown operator ${he.value}`);
            } else if (ae) throw new Error("Formula missing expected operator");
            ae = !ae;
          }
          if (!ae) throw new Error("Formula contains invalid trailing operator");
          Y.length === 1 && ["reference", "literal", "constant"].includes(Y[0].type) && (this.single = { type: Y[0].type === "reference" ? "reference" : "value", value: Y[0].value }), this._parts = Y.map((he) => {
            if (he.type === "operator") return C.operatorsPrefix.includes(he.value) ? he : he.value;
            if (he.type !== "reference") return he.value;
            if (this.settings.tokenRx && !this.settings.tokenRx.test(he.value)) throw new Error(`Formula contains invalid reference ${he.value}`);
            return this.settings.reference ? this.settings.reference(he.value) : C.reference(he.value);
          });
        }
        _subFormula(D, Y) {
          const L = this.settings.functions[Y];
          if (typeof L != "function") throw new Error(`Formula contains unknown function ${Y}`);
          let q = [];
          if (D) {
            let N = "", F = 0, ae = !1;
            const he = () => {
              if (!N) throw new Error(`Formula contains function ${Y} with invalid arguments ${D}`);
              q.push(N), N = "";
            };
            for (let tt = 0; tt < D.length; ++tt) {
              const br = D[tt];
              ae ? (N += br, br === ae && (ae = !1)) : br in C.literals && !F ? (N += br, ae = C.literals[br]) : br !== "," || F ? (N += br, br === "(" ? ++F : br === ")" && --F) : he();
            }
            he();
          }
          return q = q.map((N) => new x.Parser(N, this.settings)), function(N) {
            const F = [];
            for (const ae of q) F.push(ae.evaluate(N));
            return L.call(N, ...F);
          };
        }
        evaluate(D) {
          const Y = this._parts.slice();
          for (let L = Y.length - 2; L >= 0; --L) {
            const q = Y[L];
            if (q && q.type === "operator") {
              const N = Y[L + 1];
              Y.splice(L + 1, 1);
              const F = C.evaluate(N, D);
              Y[L] = C.single(q.value, F);
            }
          }
          return C.operatorsOrder.forEach((L) => {
            for (let q = 1; q < Y.length - 1; ) if (L.includes(Y[q])) {
              const N = Y[q], F = C.evaluate(Y[q - 1], D), ae = C.evaluate(Y[q + 1], D);
              Y.splice(q, 2);
              const he = C.calculate(N, F, ae);
              Y[q - 1] = he === 0 ? 0 : he;
            } else q += 2;
          }), C.evaluate(Y[0], D);
        }
      }, x.Parser.prototype[C.symbol] = !0, C.reference = function(D) {
        return function(Y) {
          return Y && Y[D] !== void 0 ? Y[D] : null;
        };
      }, C.evaluate = function(D, Y) {
        return D === null ? null : typeof D == "function" ? D(Y) : D[C.symbol] ? D.evaluate(Y) : D;
      }, C.single = function(D, Y) {
        if (D === "!") return !Y;
        const L = -Y;
        return L === 0 ? 0 : L;
      }, C.calculate = function(D, Y, L) {
        if (D === "??") return C.exists(Y) ? Y : L;
        if (typeof Y == "string" || typeof L == "string") {
          if (D === "+") return (Y = C.exists(Y) ? Y : "") + (C.exists(L) ? L : "");
        } else switch (D) {
          case "^":
            return Math.pow(Y, L);
          case "*":
            return Y * L;
          case "/":
            return Y / L;
          case "%":
            return Y % L;
          case "+":
            return Y + L;
          case "-":
            return Y - L;
        }
        switch (D) {
          case "<":
            return Y < L;
          case "<=":
            return Y <= L;
          case ">":
            return Y > L;
          case ">=":
            return Y >= L;
          case "==":
            return Y === L;
          case "!=":
            return Y !== L;
          case "&&":
            return Y && L;
          case "||":
            return Y || L;
        }
        return null;
      }, C.exists = function(D) {
        return D != null;
      };
    }, 9926: () => {
    }, 5688: () => {
    }, 9708: () => {
    }, 1152: () => {
    }, 443: () => {
    }, 9848: () => {
    }, 5934: (T) => {
      T.exports = JSON.parse('{"version":"17.13.3"}');
    } }, w = {}, function T(x) {
      var C = w[x];
      if (C !== void 0) return C.exports;
      var D = w[x] = { exports: {} };
      return v[x](D, D.exports, T), D.exports;
    }(5107);
    var v, w;
  });
})(_e, _e.exports);
var kt = _e.exports;
const M = /* @__PURE__ */ Ar$1(kt), ze = (e) => typeof e != "object" || e === null || !("isLuxonDateTime" in e) ? !1 : e.isLuxonDateTime === !0, Ve = (e) => typeof e != "object" || e === null || !("isLuxonDuration" in e) ? !1 : e.isLuxonDuration === !0, Ge = (e) => typeof e != "object" || e === null || !("isLuxonInterval" in e) ? !1 : e.isLuxonInterval === !0, Or = (e) => (
  // @ts-expect-error
  !!e && e.constructor === Object
), jr$1 = (e) => typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "bigint" || typeof e > "u", Ir$1 = [
  "Error"
  // 'EvalError',
  // 'RangeError',
  // 'ReferenceError',
  // 'SyntaxError',
  // 'TypeError',
  // 'URIError',
], Lt = M.string().allow("").required(), Nt = M.number().required(), Tt = M.boolean().required(), Dt = M.any().custom((e, t) => typeof e == "bigint" ? e : t.error("any.invalid")).required(), Ct = M.any().valid(null).required(), Pt = M.any().custom((e, t) => typeof e > "u" ? e : t.error("any.invalid")), Ft = M.alternatives().try(Lt, Nt, Tt, Dt, Ct, Pt), Mt = M.any().custom((e, t) => e instanceof Int8Array ? e : t.error("any.invalid")), Ut = M.any().custom((e, t) => e instanceof Uint8Array ? e : t.error("any.invalid")), qt = M.any().custom((e, t) => e instanceof Uint8ClampedArray ? e : t.error("any.invalid")), zt = M.any().custom((e, t) => e instanceof Int16Array ? e : t.error("any.invalid")), Vt = M.any().custom((e, t) => e instanceof Uint16Array ? e : t.error("any.invalid")), Gt = M.any().custom((e, t) => e instanceof Int32Array ? e : t.error("any.invalid")), Bt = M.any().custom((e, t) => e instanceof Uint32Array ? e : t.error("any.invalid")), Wt = M.any().custom((e, t) => e instanceof Float32Array ? e : t.error("any.invalid")), Ht = M.any().custom((e, t) => e instanceof Float64Array ? e : t.error("any.invalid")), Xt = M.any().custom((e, t) => e instanceof BigInt64Array ? e : t.error("any.invalid")), Zt = M.any().custom((e, t) => e instanceof BigUint64Array ? e : t.error("any.invalid")), Yt = M.alternatives().try(
  Mt,
  Ut,
  qt,
  zt,
  Vt,
  Gt,
  Bt,
  Wt,
  Ht,
  Xt,
  Zt
), Kt = M.any().custom((e, t) => e instanceof Date ? e : t.error("any.invalid")), Jt = M.any().custom((e, t) => e instanceof RegExp ? e : t.error("any.invalid")), Qt = M.any().custom((e, t) => e instanceof ArrayBuffer ? e : t.error("any.invalid")), er = M.any().custom((e, t) => e instanceof DataView ? e : t.error("any.invalid")), tr$1 = M.any().custom((e, t) => {
  if (e instanceof Error) {
    const v = e.constructor.name;
    if (Ir$1.includes(v))
      return e;
  }
  return t.error("any.invalid");
}), rr = M.alternatives().try(Kt, Jt, Qt, er, tr$1), sr$1 = M.any().custom((e, t) => ze(e) ? e : t.error("any.invalid")), nr$1 = M.any().custom((e, t) => Ve(e) ? e : t.error("any.invalid")), ir$1 = M.any().custom((e, t) => Ge(e) ? e : t.error("any.invalid")), ar$1 = M.alternatives().try(sr$1, nr$1, ir$1), ee = M.alternatives().try(
  Ft,
  Yt,
  rr,
  ar$1,
  M.array().items(M.link("#serializable")),
  M.any().custom((e, t) => {
    if (e instanceof Map) {
      for (const [v, w] of e.entries())
        if (ee.validate(v).error || ee.validate(w).error)
          return t.error("any.invalid");
      return e;
    }
    return t.error("any.invalid");
  }),
  M.any().custom((e, t) => {
    if (e instanceof Set) {
      for (const v of e.values())
        if (ee.validate(v).error)
          return t.error("any.invalid");
      return e;
    }
    return t.error("any.invalid");
  }),
  M.any().custom((e, t) => {
    if (Object.getPrototypeOf(e) !== Object.prototype)
      return t.error("any.invalid");
    const v = Object.getOwnPropertyDescriptors(e);
    for (const w in v) {
      const T = v[w];
      if (T.get || T.set || T.enumerable === !1 || ee.validate(w).error || ee.validate(T.value).error)
        return t.error("any.invalid");
    }
    return e;
  })
).id("serializable"), kr$1 = (e) => {
  const { error: t } = ee.validate(e);
  return !t;
}, Pe = (e) => {
  const { error: t } = ee.validate(e, { abortEarly: !1 });
  if (t)
    throw new y$1(t);
  return e;
}, nt = [
  {
    key: "polyfill:Error",
    test: (e) => e instanceof Error,
    encode: (e) => Uint8Array.from(W$6(e)),
    decode: (e) => {
      const t = H(e);
      return typeof t.stack != "string" && (Object.defineProperty(t, "stack", {
        value: "",
        writable: !0,
        enumerable: !1,
        configurable: !0
      }), t.stack = ""), t;
    }
  },
  {
    key: "luxon:DateTime",
    test: (e) => ze(e),
    encode: (e) => {
      const t = e.toISO({ extendedZone: !0 });
      return Uint8Array.from(W$6(t));
    },
    decode: (e) => {
      const t = H(e);
      return t ? DateTime.fromISO(t, { setZone: !0 }) : DateTime.invalid("Previously serialized value is not valid");
    }
  },
  {
    key: "luxon:Duration",
    test: (e) => Ve(e),
    encode: (e) => {
      const t = e.toISO();
      return Uint8Array.from(W$6(t));
    },
    decode: (e) => {
      const t = H(e);
      return t ? Duration.fromISO(t) : Duration.invalid("Previously serialized value is not valid");
    }
  },
  {
    key: "luxon:Interval",
    test: (e) => Ge(e),
    encode: (e) => {
      const t = e.start ? e.start.toISO({ extendedZone: !0 }) : null, v = e.end ? e.end.toISO({ extendedZone: !0 }) : null;
      return Uint8Array.from(W$6([t, v]));
    },
    decode: (e) => {
      const [t, v] = H(e);
      return !t || !v ? Interval.invalid("Previously serialized value is not valid") : Interval.fromDateTimes(
        DateTime.fromISO(t, { setZone: !0 }),
        DateTime.fromISO(v, { setZone: !0 })
      );
    }
  }
], it = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  BigInt64Array,
  BigUint64Array
], at = [
  Date,
  RegExp,
  ArrayBuffer,
  DataView,
  Error,
  EvalError,
  RangeError,
  ReferenceError,
  SyntaxError,
  TypeError,
  URIError
];
var $e = { exports: {} };
const Lr$1 = "2.0.0", or = 256, Nr = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, Tr$1 = 16, Dr$1 = or - 6, Cr$1 = [
  "major",
  "premajor",
  "minor",
  "preminor",
  "patch",
  "prepatch",
  "prerelease"
];
var xe = {
  MAX_LENGTH: or,
  MAX_SAFE_COMPONENT_LENGTH: Tr$1,
  MAX_SAFE_BUILD_LENGTH: Dr$1,
  MAX_SAFE_INTEGER: Nr,
  RELEASE_TYPES: Cr$1,
  SEMVER_SPEC_VERSION: Lr$1,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const Pr$1 = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
};
var Se = Pr$1;
$e.exports;
(function(e, t) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: v,
    MAX_SAFE_BUILD_LENGTH: w,
    MAX_LENGTH: T
  } = xe, x = Se;
  t = e.exports = {};
  const C = t.re = [], D = t.safeRe = [], Y = t.src = [], L = t.safeSrc = [], q = t.t = {};
  let N = 0;
  const F = "[a-zA-Z0-9-]", ae = [
    ["\\s", 1],
    ["\\d", T],
    [F, w]
  ], he = (br) => {
    for (const [rt, dr] of ae)
      br = br.split(`${rt}*`).join(`${rt}{0,${dr}}`).split(`${rt}+`).join(`${rt}{1,${dr}}`);
    return br;
  }, tt = (br, rt, dr) => {
    const _r = he(rt), Bi = N++;
    x(br, Bi, rt), q[br] = Bi, Y[Bi] = rt, L[Bi] = _r, C[Bi] = new RegExp(rt, dr ? "g" : void 0), D[Bi] = new RegExp(_r, dr ? "g" : void 0);
  };
  tt("NUMERICIDENTIFIER", "0|[1-9]\\d*"), tt("NUMERICIDENTIFIERLOOSE", "\\d+"), tt("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${F}*`), tt("MAINVERSION", `(${Y[q.NUMERICIDENTIFIER]})\\.(${Y[q.NUMERICIDENTIFIER]})\\.(${Y[q.NUMERICIDENTIFIER]})`), tt("MAINVERSIONLOOSE", `(${Y[q.NUMERICIDENTIFIERLOOSE]})\\.(${Y[q.NUMERICIDENTIFIERLOOSE]})\\.(${Y[q.NUMERICIDENTIFIERLOOSE]})`), tt("PRERELEASEIDENTIFIER", `(?:${Y[q.NUMERICIDENTIFIER]}|${Y[q.NONNUMERICIDENTIFIER]})`), tt("PRERELEASEIDENTIFIERLOOSE", `(?:${Y[q.NUMERICIDENTIFIERLOOSE]}|${Y[q.NONNUMERICIDENTIFIER]})`), tt("PRERELEASE", `(?:-(${Y[q.PRERELEASEIDENTIFIER]}(?:\\.${Y[q.PRERELEASEIDENTIFIER]})*))`), tt("PRERELEASELOOSE", `(?:-?(${Y[q.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${Y[q.PRERELEASEIDENTIFIERLOOSE]})*))`), tt("BUILDIDENTIFIER", `${F}+`), tt("BUILD", `(?:\\+(${Y[q.BUILDIDENTIFIER]}(?:\\.${Y[q.BUILDIDENTIFIER]})*))`), tt("FULLPLAIN", `v?${Y[q.MAINVERSION]}${Y[q.PRERELEASE]}?${Y[q.BUILD]}?`), tt("FULL", `^${Y[q.FULLPLAIN]}$`), tt("LOOSEPLAIN", `[v=\\s]*${Y[q.MAINVERSIONLOOSE]}${Y[q.PRERELEASELOOSE]}?${Y[q.BUILD]}?`), tt("LOOSE", `^${Y[q.LOOSEPLAIN]}$`), tt("GTLT", "((?:<|>)?=?)"), tt("XRANGEIDENTIFIERLOOSE", `${Y[q.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), tt("XRANGEIDENTIFIER", `${Y[q.NUMERICIDENTIFIER]}|x|X|\\*`), tt("XRANGEPLAIN", `[v=\\s]*(${Y[q.XRANGEIDENTIFIER]})(?:\\.(${Y[q.XRANGEIDENTIFIER]})(?:\\.(${Y[q.XRANGEIDENTIFIER]})(?:${Y[q.PRERELEASE]})?${Y[q.BUILD]}?)?)?`), tt("XRANGEPLAINLOOSE", `[v=\\s]*(${Y[q.XRANGEIDENTIFIERLOOSE]})(?:\\.(${Y[q.XRANGEIDENTIFIERLOOSE]})(?:\\.(${Y[q.XRANGEIDENTIFIERLOOSE]})(?:${Y[q.PRERELEASELOOSE]})?${Y[q.BUILD]}?)?)?`), tt("XRANGE", `^${Y[q.GTLT]}\\s*${Y[q.XRANGEPLAIN]}$`), tt("XRANGELOOSE", `^${Y[q.GTLT]}\\s*${Y[q.XRANGEPLAINLOOSE]}$`), tt("COERCEPLAIN", `(^|[^\\d])(\\d{1,${v}})(?:\\.(\\d{1,${v}}))?(?:\\.(\\d{1,${v}}))?`), tt("COERCE", `${Y[q.COERCEPLAIN]}(?:$|[^\\d])`), tt("COERCEFULL", Y[q.COERCEPLAIN] + `(?:${Y[q.PRERELEASE]})?(?:${Y[q.BUILD]})?(?:$|[^\\d])`), tt("COERCERTL", Y[q.COERCE], !0), tt("COERCERTLFULL", Y[q.COERCEFULL], !0), tt("LONETILDE", "(?:~>?)"), tt("TILDETRIM", `(\\s*)${Y[q.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", tt("TILDE", `^${Y[q.LONETILDE]}${Y[q.XRANGEPLAIN]}$`), tt("TILDELOOSE", `^${Y[q.LONETILDE]}${Y[q.XRANGEPLAINLOOSE]}$`), tt("LONECARET", "(?:\\^)"), tt("CARETTRIM", `(\\s*)${Y[q.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", tt("CARET", `^${Y[q.LONECARET]}${Y[q.XRANGEPLAIN]}$`), tt("CARETLOOSE", `^${Y[q.LONECARET]}${Y[q.XRANGEPLAINLOOSE]}$`), tt("COMPARATORLOOSE", `^${Y[q.GTLT]}\\s*(${Y[q.LOOSEPLAIN]})$|^$`), tt("COMPARATOR", `^${Y[q.GTLT]}\\s*(${Y[q.FULLPLAIN]})$|^$`), tt("COMPARATORTRIM", `(\\s*)${Y[q.GTLT]}\\s*(${Y[q.LOOSEPLAIN]}|${Y[q.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", tt("HYPHENRANGE", `^\\s*(${Y[q.XRANGEPLAIN]})\\s+-\\s+(${Y[q.XRANGEPLAIN]})\\s*$`), tt("HYPHENRANGELOOSE", `^\\s*(${Y[q.XRANGEPLAINLOOSE]})\\s+-\\s+(${Y[q.XRANGEPLAINLOOSE]})\\s*$`), tt("STAR", "(<|>)?=?\\s*\\*"), tt("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), tt("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})($e, $e.exports);
var ue = $e.exports;
const Fr$1 = Object.freeze({ loose: !0 }), Mr$1 = Object.freeze({}), Ur$1 = (e) => e ? typeof e != "object" ? Fr$1 : e : Mr$1;
var Be = Ur$1;
const ot = /^[0-9]+$/, lr = (e, t) => {
  const v = ot.test(e), w = ot.test(t);
  return v && w && (e = +e, t = +t), e === t ? 0 : v && !w ? -1 : w && !v ? 1 : e < t ? -1 : 1;
}, qr$1 = (e, t) => lr(t, e);
var cr = {
  compareIdentifiers: lr,
  rcompareIdentifiers: qr$1
};
const pe = Se, { MAX_LENGTH: lt, MAX_SAFE_INTEGER: de } = xe, { safeRe: ct, safeSrc: ut, t: ge } = ue, zr$1 = Be, { compareIdentifiers: se } = cr;
let Vr$1 = class sa {
  constructor(t, v) {
    if (v = zr$1(v), t instanceof sa) {
      if (t.loose === !!v.loose && t.includePrerelease === !!v.includePrerelease)
        return t;
      t = t.version;
    } else if (typeof t != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof t}".`);
    if (t.length > lt)
      throw new TypeError(
        `version is longer than ${lt} characters`
      );
    pe("SemVer", t, v), this.options = v, this.loose = !!v.loose, this.includePrerelease = !!v.includePrerelease;
    const w = t.trim().match(v.loose ? ct[ge.LOOSE] : ct[ge.FULL]);
    if (!w)
      throw new TypeError(`Invalid Version: ${t}`);
    if (this.raw = t, this.major = +w[1], this.minor = +w[2], this.patch = +w[3], this.major > de || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > de || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > de || this.patch < 0)
      throw new TypeError("Invalid patch version");
    w[4] ? this.prerelease = w[4].split(".").map((T) => {
      if (/^[0-9]+$/.test(T)) {
        const x = +T;
        if (x >= 0 && x < de)
          return x;
      }
      return T;
    }) : this.prerelease = [], this.build = w[5] ? w[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(t) {
    if (pe("SemVer.compare", this.version, this.options, t), !(t instanceof sa)) {
      if (typeof t == "string" && t === this.version)
        return 0;
      t = new sa(t, this.options);
    }
    return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
    return t instanceof sa || (t = new sa(t, this.options)), se(this.major, t.major) || se(this.minor, t.minor) || se(this.patch, t.patch);
  }
  comparePre(t) {
    if (t instanceof sa || (t = new sa(t, this.options)), this.prerelease.length && !t.prerelease.length)
      return -1;
    if (!this.prerelease.length && t.prerelease.length)
      return 1;
    if (!this.prerelease.length && !t.prerelease.length)
      return 0;
    let v = 0;
    do {
      const w = this.prerelease[v], T = t.prerelease[v];
      if (pe("prerelease compare", v, w, T), w === void 0 && T === void 0)
        return 0;
      if (T === void 0)
        return 1;
      if (w === void 0)
        return -1;
      if (w !== T)
        return se(w, T);
    } while (++v);
  }
  compareBuild(t) {
    t instanceof sa || (t = new sa(t, this.options));
    let v = 0;
    do {
      const w = this.build[v], T = t.build[v];
      if (pe("build compare", v, w, T), w === void 0 && T === void 0)
        return 0;
      if (T === void 0)
        return 1;
      if (w === void 0)
        return -1;
      if (w !== T)
        return se(w, T);
    } while (++v);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(t, v, w) {
    if (t.startsWith("pre")) {
      if (!v && w === !1)
        throw new Error("invalid increment argument: identifier is empty");
      if (v) {
        const T = new RegExp(`^${this.options.loose ? ut[ge.PRERELEASELOOSE] : ut[ge.PRERELEASE]}$`), x = `-${v}`.match(T);
        if (!x || x[1] !== v)
          throw new Error(`invalid identifier: ${v}`);
      }
    }
    switch (t) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", v, w);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", v, w);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", v, w), this.inc("pre", v, w);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", v, w), this.inc("pre", v, w);
        break;
      case "release":
        if (this.prerelease.length === 0)
          throw new Error(`version ${this.raw} is not a prerelease`);
        this.prerelease.length = 0;
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
        const T = Number(w) ? 1 : 0;
        if (this.prerelease.length === 0)
          this.prerelease = [T];
        else {
          let x = this.prerelease.length;
          for (; --x >= 0; )
            typeof this.prerelease[x] == "number" && (this.prerelease[x]++, x = -2);
          if (x === -1) {
            if (v === this.prerelease.join(".") && w === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(T);
          }
        }
        if (v) {
          let x = [v, T];
          w === !1 && (x = [v]), se(this.prerelease[0], v) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = x) : this.prerelease = x;
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${t}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
var B = Vr$1;
const ft$2 = B, Gr$1 = (e, t, v = !1) => {
  if (e instanceof ft$2)
    return e;
  try {
    return new ft$2(e, t);
  } catch (w) {
    if (!v)
      return null;
    throw w;
  }
};
var ie = Gr$1;
const Br$1 = ie, Wr$1 = (e, t) => {
  const v = Br$1(e, t);
  return v ? v.version : null;
};
var Hr$1 = Wr$1;
const Xr = ie, Zr = (e, t) => {
  const v = Xr(e.trim().replace(/^[=v]+/, ""), t);
  return v ? v.version : null;
};
var Yr = Zr;
const ht = B, Kr$1 = (e, t, v, w, T) => {
  typeof v == "string" && (T = w, w = v, v = void 0);
  try {
    return new ht(
      e instanceof ht ? e.version : e,
      v
    ).inc(t, w, T).version;
  } catch {
    return null;
  }
};
var Jr = Kr$1;
const mt = ie, Qr = (e, t) => {
  const v = mt(e, null, !0), w = mt(t, null, !0), T = v.compare(w);
  if (T === 0)
    return null;
  const x = T > 0, C = x ? v : w, D = x ? w : v, Y = !!C.prerelease.length;
  if (D.prerelease.length && !Y) {
    if (!D.patch && !D.minor)
      return "major";
    if (D.compareMain(C) === 0)
      return D.minor && !D.patch ? "minor" : "patch";
  }
  const L = Y ? "pre" : "";
  return v.major !== w.major ? L + "major" : v.minor !== w.minor ? L + "minor" : v.patch !== w.patch ? L + "patch" : "prerelease";
};
var es = Qr;
const ts = B, rs = (e, t) => new ts(e, t).major;
var ss = rs;
const ns = B, is = (e, t) => new ns(e, t).minor;
var as = is;
const os = B, ls = (e, t) => new os(e, t).patch;
var cs = ls;
const us = ie, fs = (e, t) => {
  const v = us(e, t);
  return v && v.prerelease.length ? v.prerelease : null;
};
var hs = fs;
const pt = B, ms = (e, t, v) => new pt(e, v).compare(new pt(t, v));
var X = ms;
const ps = X, ds = (e, t, v) => ps(t, e, v);
var gs = ds;
const ys = X, bs = (e, t) => ys(e, t, !0);
var vs = bs;
const dt = B, _s = (e, t, v) => {
  const w = new dt(e, v), T = new dt(t, v);
  return w.compare(T) || w.compareBuild(T);
};
var We = _s;
const $s = We, ws = (e, t) => e.sort((v, w) => $s(v, w, t));
var Es = ws;
const Rs = We, xs = (e, t) => e.sort((v, w) => Rs(w, v, t));
var Ss = xs;
const As = X, Os = (e, t, v) => As(e, t, v) > 0;
var Ae = Os;
const js = X, Is = (e, t, v) => js(e, t, v) < 0;
var He = Is;
const ks = X, Ls = (e, t, v) => ks(e, t, v) === 0;
var ur = Ls;
const Ns = X, Ts = (e, t, v) => Ns(e, t, v) !== 0;
var fr = Ts;
const Ds = X, Cs = (e, t, v) => Ds(e, t, v) >= 0;
var Xe = Cs;
const Ps = X, Fs = (e, t, v) => Ps(e, t, v) <= 0;
var Ze = Fs;
const Ms = ur, Us = fr, qs = Ae, zs = Xe, Vs = He, Gs = Ze, Bs = (e, t, v, w) => {
  switch (t) {
    case "===":
      return typeof e == "object" && (e = e.version), typeof v == "object" && (v = v.version), e === v;
    case "!==":
      return typeof e == "object" && (e = e.version), typeof v == "object" && (v = v.version), e !== v;
    case "":
    case "=":
    case "==":
      return Ms(e, v, w);
    case "!=":
      return Us(e, v, w);
    case ">":
      return qs(e, v, w);
    case ">=":
      return zs(e, v, w);
    case "<":
      return Vs(e, v, w);
    case "<=":
      return Gs(e, v, w);
    default:
      throw new TypeError(`Invalid operator: ${t}`);
  }
};
var hr$1 = Bs;
const Ws = B, Hs = ie, { safeRe: ye, t: be } = ue, Xs = (e, t) => {
  if (e instanceof Ws)
    return e;
  if (typeof e == "number" && (e = String(e)), typeof e != "string")
    return null;
  t = t || {};
  let v = null;
  if (!t.rtl)
    v = e.match(t.includePrerelease ? ye[be.COERCEFULL] : ye[be.COERCE]);
  else {
    const Y = t.includePrerelease ? ye[be.COERCERTLFULL] : ye[be.COERCERTL];
    let L;
    for (; (L = Y.exec(e)) && (!v || v.index + v[0].length !== e.length); )
      (!v || L.index + L[0].length !== v.index + v[0].length) && (v = L), Y.lastIndex = L.index + L[1].length + L[2].length;
    Y.lastIndex = -1;
  }
  if (v === null)
    return null;
  const w = v[2], T = v[3] || "0", x = v[4] || "0", C = t.includePrerelease && v[5] ? `-${v[5]}` : "", D = t.includePrerelease && v[6] ? `+${v[6]}` : "";
  return Hs(`${w}.${T}.${x}${C}${D}`, t);
};
var Zs = Xs;
class Ys {
  constructor() {
    this.max = 1e3, this.map = /* @__PURE__ */ new Map();
  }
  get(t) {
    const v = this.map.get(t);
    if (v !== void 0)
      return this.map.delete(t), this.map.set(t, v), v;
  }
  delete(t) {
    return this.map.delete(t);
  }
  set(t, v) {
    if (!this.delete(t) && v !== void 0) {
      if (this.map.size >= this.max) {
        const w = this.map.keys().next().value;
        this.delete(w);
      }
      this.map.set(t, v);
    }
    return this;
  }
}
var Ks = Ys, Le, gt;
function Z() {
  if (gt) return Le;
  gt = 1;
  const e = /\s+/g;
  class t {
    constructor(vr, Oi) {
      if (Oi = T(Oi), vr instanceof t)
        return vr.loose === !!Oi.loose && vr.includePrerelease === !!Oi.includePrerelease ? vr : new t(vr.raw, Oi);
      if (vr instanceof x)
        return this.raw = vr.value, this.set = [[vr]], this.formatted = void 0, this;
      if (this.options = Oi, this.loose = !!Oi.loose, this.includePrerelease = !!Oi.includePrerelease, this.raw = vr.trim().replace(e, " "), this.set = this.raw.split("||").map((Mi) => this.parseRange(Mi.trim())).filter((Mi) => Mi.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const Mi = this.set[0];
        if (this.set = this.set.filter((ki) => !tt(ki[0])), this.set.length === 0)
          this.set = [Mi];
        else if (this.set.length > 1) {
          for (const ki of this.set)
            if (ki.length === 1 && br(ki[0])) {
              this.set = [ki];
              break;
            }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let vr = 0; vr < this.set.length; vr++) {
          vr > 0 && (this.formatted += "||");
          const Oi = this.set[vr];
          for (let Mi = 0; Mi < Oi.length; Mi++)
            Mi > 0 && (this.formatted += " "), this.formatted += Oi[Mi].toString().trim();
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(vr) {
      const Oi = ((this.options.includePrerelease && ae) | (this.options.loose && he)) + ":" + vr, Mi = w.get(Oi);
      if (Mi)
        return Mi;
      const ki = this.options.loose, yr = ki ? Y[L.HYPHENRANGELOOSE] : Y[L.HYPHENRANGE];
      vr = vr.replace(yr, Di(this.options.includePrerelease)), C("hyphen replace", vr), vr = vr.replace(Y[L.COMPARATORTRIM], q), C("comparator trim", vr), vr = vr.replace(Y[L.TILDETRIM], N), C("tilde trim", vr), vr = vr.replace(Y[L.CARETTRIM], F), C("caret trim", vr);
      let xi = vr.split(" ").map((Yi) => dr(Yi, this.options)).join(" ").split(/\s+/).map((Yi) => pr(Yi, this.options));
      ki && (xi = xi.filter((Yi) => (C("loose invalid filter", Yi, this.options), !!Yi.match(Y[L.COMPARATORLOOSE])))), C("range list", xi);
      const Si = /* @__PURE__ */ new Map(), Ci = xi.map((Yi) => new x(Yi, this.options));
      for (const Yi of Ci) {
        if (tt(Yi))
          return [Yi];
        Si.set(Yi.value, Yi);
      }
      Si.size > 1 && Si.has("") && Si.delete("");
      const Ki = [...Si.values()];
      return w.set(Oi, Ki), Ki;
    }
    intersects(vr, Oi) {
      if (!(vr instanceof t))
        throw new TypeError("a Range is required");
      return this.set.some((Mi) => rt(Mi, Oi) && vr.set.some((ki) => rt(ki, Oi) && Mi.every((yr) => ki.every((xi) => yr.intersects(xi, Oi)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(vr) {
      if (!vr)
        return !1;
      if (typeof vr == "string")
        try {
          vr = new D(vr, this.options);
        } catch {
          return !1;
        }
      for (let Oi = 0; Oi < this.set.length; Oi++)
        if (z(this.set[Oi], vr, this.options))
          return !0;
      return !1;
    }
  }
  Le = t;
  const v = Ks, w = new v(), T = Be, x = Oe(), C = Se, D = B, {
    safeRe: Y,
    t: L,
    comparatorTrimReplace: q,
    tildeTrimReplace: N,
    caretTrimReplace: F
  } = ue, { FLAG_INCLUDE_PRERELEASE: ae, FLAG_LOOSE: he } = xe, tt = (gr) => gr.value === "<0.0.0-0", br = (gr) => gr.value === "", rt = (gr, vr) => {
    let Oi = !0;
    const Mi = gr.slice();
    let ki = Mi.pop();
    for (; Oi && Mi.length; )
      Oi = Mi.every((yr) => ki.intersects(yr, vr)), ki = Mi.pop();
    return Oi;
  }, dr = (gr, vr) => (C("comp", gr, vr), gr = Wi(gr, vr), C("caret", gr), gr = Bi(gr, vr), C("tildes", gr), gr = Ti(gr, vr), C("xrange", gr), gr = Hi(gr, vr), C("stars", gr), gr), _r = (gr) => !gr || gr.toLowerCase() === "x" || gr === "*", Bi = (gr, vr) => gr.trim().split(/\s+/).map((Oi) => qi(Oi, vr)).join(" "), qi = (gr, vr) => {
    const Oi = vr.loose ? Y[L.TILDELOOSE] : Y[L.TILDE];
    return gr.replace(Oi, (Mi, ki, yr, xi, Si) => {
      C("tilde", gr, Mi, ki, yr, xi, Si);
      let Ci;
      return _r(ki) ? Ci = "" : _r(yr) ? Ci = `>=${ki}.0.0 <${+ki + 1}.0.0-0` : _r(xi) ? Ci = `>=${ki}.${yr}.0 <${ki}.${+yr + 1}.0-0` : Si ? (C("replaceTilde pr", Si), Ci = `>=${ki}.${yr}.${xi}-${Si} <${ki}.${+yr + 1}.0-0`) : Ci = `>=${ki}.${yr}.${xi} <${ki}.${+yr + 1}.0-0`, C("tilde return", Ci), Ci;
    });
  }, Wi = (gr, vr) => gr.trim().split(/\s+/).map((Oi) => Vi(Oi, vr)).join(" "), Vi = (gr, vr) => {
    C("caret", gr, vr);
    const Oi = vr.loose ? Y[L.CARETLOOSE] : Y[L.CARET], Mi = vr.includePrerelease ? "-0" : "";
    return gr.replace(Oi, (ki, yr, xi, Si, Ci) => {
      C("caret", gr, ki, yr, xi, Si, Ci);
      let Ki;
      return _r(yr) ? Ki = "" : _r(xi) ? Ki = `>=${yr}.0.0${Mi} <${+yr + 1}.0.0-0` : _r(Si) ? yr === "0" ? Ki = `>=${yr}.${xi}.0${Mi} <${yr}.${+xi + 1}.0-0` : Ki = `>=${yr}.${xi}.0${Mi} <${+yr + 1}.0.0-0` : Ci ? (C("replaceCaret pr", Ci), yr === "0" ? xi === "0" ? Ki = `>=${yr}.${xi}.${Si}-${Ci} <${yr}.${xi}.${+Si + 1}-0` : Ki = `>=${yr}.${xi}.${Si}-${Ci} <${yr}.${+xi + 1}.0-0` : Ki = `>=${yr}.${xi}.${Si}-${Ci} <${+yr + 1}.0.0-0`) : (C("no pr"), yr === "0" ? xi === "0" ? Ki = `>=${yr}.${xi}.${Si}${Mi} <${yr}.${xi}.${+Si + 1}-0` : Ki = `>=${yr}.${xi}.${Si}${Mi} <${yr}.${+xi + 1}.0-0` : Ki = `>=${yr}.${xi}.${Si} <${+yr + 1}.0.0-0`), C("caret return", Ki), Ki;
    });
  }, Ti = (gr, vr) => (C("replaceXRanges", gr, vr), gr.split(/\s+/).map((Oi) => Li(Oi, vr)).join(" ")), Li = (gr, vr) => {
    gr = gr.trim();
    const Oi = vr.loose ? Y[L.XRANGELOOSE] : Y[L.XRANGE];
    return gr.replace(Oi, (Mi, ki, yr, xi, Si, Ci) => {
      C("xRange", gr, Mi, ki, yr, xi, Si, Ci);
      const Ki = _r(yr), Yi = Ki || _r(xi), Qi = Yi || _r(Si), Zi = Qi;
      return ki === "=" && Zi && (ki = ""), Ci = vr.includePrerelease ? "-0" : "", Ki ? ki === ">" || ki === "<" ? Mi = "<0.0.0-0" : Mi = "*" : ki && Zi ? (Yi && (xi = 0), Si = 0, ki === ">" ? (ki = ">=", Yi ? (yr = +yr + 1, xi = 0, Si = 0) : (xi = +xi + 1, Si = 0)) : ki === "<=" && (ki = "<", Yi ? yr = +yr + 1 : xi = +xi + 1), ki === "<" && (Ci = "-0"), Mi = `${ki + yr}.${xi}.${Si}${Ci}`) : Yi ? Mi = `>=${yr}.0.0${Ci} <${+yr + 1}.0.0-0` : Qi && (Mi = `>=${yr}.${xi}.0${Ci} <${yr}.${+xi + 1}.0-0`), C("xRange return", Mi), Mi;
    });
  }, Hi = (gr, vr) => (C("replaceStars", gr, vr), gr.trim().replace(Y[L.STAR], "")), pr = (gr, vr) => (C("replaceGTE0", gr, vr), gr.trim().replace(Y[vr.includePrerelease ? L.GTE0PRE : L.GTE0], "")), Di = (gr) => (vr, Oi, Mi, ki, yr, xi, Si, Ci, Ki, Yi, Qi, Zi) => (_r(Mi) ? Oi = "" : _r(ki) ? Oi = `>=${Mi}.0.0${gr ? "-0" : ""}` : _r(yr) ? Oi = `>=${Mi}.${ki}.0${gr ? "-0" : ""}` : xi ? Oi = `>=${Oi}` : Oi = `>=${Oi}${gr ? "-0" : ""}`, _r(Ki) ? Ci = "" : _r(Yi) ? Ci = `<${+Ki + 1}.0.0-0` : _r(Qi) ? Ci = `<${Ki}.${+Yi + 1}.0-0` : Zi ? Ci = `<=${Ki}.${Yi}.${Qi}-${Zi}` : gr ? Ci = `<${Ki}.${Yi}.${+Qi + 1}-0` : Ci = `<=${Ci}`, `${Oi} ${Ci}`.trim()), z = (gr, vr, Oi) => {
    for (let Mi = 0; Mi < gr.length; Mi++)
      if (!gr[Mi].test(vr))
        return !1;
    if (vr.prerelease.length && !Oi.includePrerelease) {
      for (let Mi = 0; Mi < gr.length; Mi++)
        if (C(gr[Mi].semver), gr[Mi].semver !== x.ANY && gr[Mi].semver.prerelease.length > 0) {
          const ki = gr[Mi].semver;
          if (ki.major === vr.major && ki.minor === vr.minor && ki.patch === vr.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return Le;
}
var Ne, yt;
function Oe() {
  if (yt) return Ne;
  yt = 1;
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(q, N) {
      if (N = v(N), q instanceof t) {
        if (q.loose === !!N.loose)
          return q;
        q = q.value;
      }
      q = q.trim().split(/\s+/).join(" "), C("comparator", q, N), this.options = N, this.loose = !!N.loose, this.parse(q), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, C("comp", this);
    }
    parse(q) {
      const N = this.options.loose ? w[T.COMPARATORLOOSE] : w[T.COMPARATOR], F = q.match(N);
      if (!F)
        throw new TypeError(`Invalid comparator: ${q}`);
      this.operator = F[1] !== void 0 ? F[1] : "", this.operator === "=" && (this.operator = ""), F[2] ? this.semver = new D(F[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(q) {
      if (C("Comparator.test", q, this.options.loose), this.semver === e || q === e)
        return !0;
      if (typeof q == "string")
        try {
          q = new D(q, this.options);
        } catch {
          return !1;
        }
      return x(q, this.operator, this.semver, this.options);
    }
    intersects(q, N) {
      if (!(q instanceof t))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new Y(q.value, N).test(this.value) : q.operator === "" ? q.value === "" ? !0 : new Y(this.value, N).test(q.semver) : (N = v(N), N.includePrerelease && (this.value === "<0.0.0-0" || q.value === "<0.0.0-0") || !N.includePrerelease && (this.value.startsWith("<0.0.0") || q.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && q.operator.startsWith(">") || this.operator.startsWith("<") && q.operator.startsWith("<") || this.semver.version === q.semver.version && this.operator.includes("=") && q.operator.includes("=") || x(this.semver, "<", q.semver, N) && this.operator.startsWith(">") && q.operator.startsWith("<") || x(this.semver, ">", q.semver, N) && this.operator.startsWith("<") && q.operator.startsWith(">")));
    }
  }
  Ne = t;
  const v = Be, { safeRe: w, t: T } = ue, x = hr$1, C = Se, D = B, Y = Z();
  return Ne;
}
const Js = Z(), Qs = (e, t, v) => {
  try {
    t = new Js(t, v);
  } catch {
    return !1;
  }
  return t.test(e);
};
var je = Qs;
const en = Z(), tn = (e, t) => new en(e, t).set.map((v) => v.map((w) => w.value).join(" ").trim().split(" "));
var rn = tn;
const sn = B, nn = Z(), an = (e, t, v) => {
  let w = null, T = null, x = null;
  try {
    x = new nn(t, v);
  } catch {
    return null;
  }
  return e.forEach((C) => {
    x.test(C) && (!w || T.compare(C) === -1) && (w = C, T = new sn(w, v));
  }), w;
};
var on = an;
const ln = B, cn = Z(), un = (e, t, v) => {
  let w = null, T = null, x = null;
  try {
    x = new cn(t, v);
  } catch {
    return null;
  }
  return e.forEach((C) => {
    x.test(C) && (!w || T.compare(C) === 1) && (w = C, T = new ln(w, v));
  }), w;
};
var fn$1 = un;
const Te = B, hn = Z(), bt = Ae, mn = (e, t) => {
  e = new hn(e, t);
  let v = new Te("0.0.0");
  if (e.test(v) || (v = new Te("0.0.0-0"), e.test(v)))
    return v;
  v = null;
  for (let w = 0; w < e.set.length; ++w) {
    const T = e.set[w];
    let x = null;
    T.forEach((C) => {
      const D = new Te(C.semver.version);
      switch (C.operator) {
        case ">":
          D.prerelease.length === 0 ? D.patch++ : D.prerelease.push(0), D.raw = D.format();
        case "":
        case ">=":
          (!x || bt(D, x)) && (x = D);
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${C.operator}`);
      }
    }), x && (!v || bt(v, x)) && (v = x);
  }
  return v && e.test(v) ? v : null;
};
var pn = mn;
const dn = Z(), gn = (e, t) => {
  try {
    return new dn(e, t).range || "*";
  } catch {
    return null;
  }
};
var yn = gn;
const bn$2 = B, mr$1 = Oe(), { ANY: vn } = mr$1, _n = Z(), $n = je, vt = Ae, _t = He, wn = Ze, En = Xe, Rn = (e, t, v, w) => {
  e = new bn$2(e, w), t = new _n(t, w);
  let T, x, C, D, Y;
  switch (v) {
    case ">":
      T = vt, x = wn, C = _t, D = ">", Y = ">=";
      break;
    case "<":
      T = _t, x = En, C = vt, D = "<", Y = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if ($n(e, t, w))
    return !1;
  for (let L = 0; L < t.set.length; ++L) {
    const q = t.set[L];
    let N = null, F = null;
    if (q.forEach((ae) => {
      ae.semver === vn && (ae = new mr$1(">=0.0.0")), N = N || ae, F = F || ae, T(ae.semver, N.semver, w) ? N = ae : C(ae.semver, F.semver, w) && (F = ae);
    }), N.operator === D || N.operator === Y || (!F.operator || F.operator === D) && x(e, F.semver) || F.operator === Y && C(e, F.semver))
      return !1;
  }
  return !0;
};
var Ye = Rn;
const xn = Ye, Sn = (e, t, v) => xn(e, t, ">", v);
var An = Sn;
const On = Ye, jn = (e, t, v) => On(e, t, "<", v);
var In = jn;
const $t = Z(), kn = (e, t, v) => (e = new $t(e, v), t = new $t(t, v), e.intersects(t, v));
var Ln = kn;
const Nn = je, Tn = X;
var Dn = (e, t, v) => {
  const w = [];
  let T = null, x = null;
  const C = e.sort((q, N) => Tn(q, N, v));
  for (const q of C)
    Nn(q, t, v) ? (x = q, T || (T = q)) : (x && w.push([T, x]), x = null, T = null);
  T && w.push([T, null]);
  const D = [];
  for (const [q, N] of w)
    q === N ? D.push(q) : !N && q === C[0] ? D.push("*") : N ? q === C[0] ? D.push(`<=${N}`) : D.push(`${q} - ${N}`) : D.push(`>=${q}`);
  const Y = D.join(" || "), L = typeof t.raw == "string" ? t.raw : String(t);
  return Y.length < L.length ? Y : t;
};
const wt = Z(), Ke = Oe(), { ANY: De } = Ke, le = je, Je = X, Cn = (e, t, v = {}) => {
  if (e === t)
    return !0;
  e = new wt(e, v), t = new wt(t, v);
  let w = !1;
  e: for (const T of e.set) {
    for (const x of t.set) {
      const C = Fn(T, x, v);
      if (w = w || C !== null, C)
        continue e;
    }
    if (w)
      return !1;
  }
  return !0;
}, Pn = [new Ke(">=0.0.0-0")], Et = [new Ke(">=0.0.0")], Fn = (e, t, v) => {
  if (e === t)
    return !0;
  if (e.length === 1 && e[0].semver === De) {
    if (t.length === 1 && t[0].semver === De)
      return !0;
    v.includePrerelease ? e = Pn : e = Et;
  }
  if (t.length === 1 && t[0].semver === De) {
    if (v.includePrerelease)
      return !0;
    t = Et;
  }
  const w = /* @__PURE__ */ new Set();
  let T, x;
  for (const ae of e)
    ae.operator === ">" || ae.operator === ">=" ? T = Rt(T, ae, v) : ae.operator === "<" || ae.operator === "<=" ? x = xt(x, ae, v) : w.add(ae.semver);
  if (w.size > 1)
    return null;
  let C;
  if (T && x && (C = Je(T.semver, x.semver, v), C > 0 || C === 0 && (T.operator !== ">=" || x.operator !== "<=")))
    return null;
  for (const ae of w) {
    if (T && !le(ae, String(T), v) || x && !le(ae, String(x), v))
      return null;
    for (const he of t)
      if (!le(ae, String(he), v))
        return !1;
    return !0;
  }
  let D, Y, L, q, N = x && !v.includePrerelease && x.semver.prerelease.length ? x.semver : !1, F = T && !v.includePrerelease && T.semver.prerelease.length ? T.semver : !1;
  N && N.prerelease.length === 1 && x.operator === "<" && N.prerelease[0] === 0 && (N = !1);
  for (const ae of t) {
    if (q = q || ae.operator === ">" || ae.operator === ">=", L = L || ae.operator === "<" || ae.operator === "<=", T) {
      if (F && ae.semver.prerelease && ae.semver.prerelease.length && ae.semver.major === F.major && ae.semver.minor === F.minor && ae.semver.patch === F.patch && (F = !1), ae.operator === ">" || ae.operator === ">=") {
        if (D = Rt(T, ae, v), D === ae && D !== T)
          return !1;
      } else if (T.operator === ">=" && !le(T.semver, String(ae), v))
        return !1;
    }
    if (x) {
      if (N && ae.semver.prerelease && ae.semver.prerelease.length && ae.semver.major === N.major && ae.semver.minor === N.minor && ae.semver.patch === N.patch && (N = !1), ae.operator === "<" || ae.operator === "<=") {
        if (Y = xt(x, ae, v), Y === ae && Y !== x)
          return !1;
      } else if (x.operator === "<=" && !le(x.semver, String(ae), v))
        return !1;
    }
    if (!ae.operator && (x || T) && C !== 0)
      return !1;
  }
  return !(T && L && !x && C !== 0 || x && q && !T && C !== 0 || F || N);
}, Rt = (e, t, v) => {
  if (!e)
    return t;
  const w = Je(e.semver, t.semver, v);
  return w > 0 ? e : w < 0 || t.operator === ">" && e.operator === ">=" ? t : e;
}, xt = (e, t, v) => {
  if (!e)
    return t;
  const w = Je(e.semver, t.semver, v);
  return w < 0 ? e : w > 0 || t.operator === "<" && e.operator === "<=" ? t : e;
};
var Mn = Cn;
const Ce = ue, St = xe, Un = B, At = cr, qn = ie, zn = Hr$1, Vn = Yr, Gn = Jr, Bn = es, Wn = ss, Hn = as, Xn = cs, Zn = hs, Yn = X, Kn = gs, Jn = vs, Qn = We, ei = Es, ti = Ss, ri = Ae, si = He, ni = ur, ii = fr, ai = Xe, oi = Ze, li = hr$1, ci = Zs, ui = Oe(), fi = Z(), hi = je, mi = rn, pi = on, di = fn$1, gi = pn, yi = yn, bi = Ye, vi = An, _i = In, $i = Ln, wi = Dn, Ei = Mn;
var Ri = {
  parse: qn,
  valid: zn,
  clean: Vn,
  inc: Gn,
  diff: Bn,
  major: Wn,
  minor: Hn,
  patch: Xn,
  prerelease: Zn,
  compare: Yn,
  rcompare: Kn,
  compareLoose: Jn,
  compareBuild: Qn,
  sort: ei,
  rsort: ti,
  gt: ri,
  lt: si,
  eq: ni,
  neq: ii,
  gte: ai,
  lte: oi,
  cmp: li,
  coerce: ci,
  Comparator: ui,
  Range: fi,
  satisfies: hi,
  toComparators: mi,
  maxSatisfying: pi,
  minSatisfying: di,
  minVersion: gi,
  validRange: yi,
  outside: bi,
  gtr: vi,
  ltr: _i,
  intersects: $i,
  simplifyRange: wi,
  subset: Ei,
  SemVer: Un,
  re: Ce.re,
  src: Ce.src,
  tokens: Ce.t,
  SEMVER_SPEC_VERSION: St.SEMVER_SPEC_VERSION,
  RELEASE_TYPES: St.RELEASE_TYPES,
  compareIdentifiers: At.compareIdentifiers,
  rcompareIdentifiers: At.rcompareIdentifiers
};
let ne;
var te, V, J, Q;
const Ee = class Ha {
  constructor() {
    ke(this, V), ke(this, te), et(this, te, /* @__PURE__ */ new Map()), nt.forEach((t) => {
      if (t.key && t.key.startsWith("js:"))
        throw new O$1(t.key);
      fe(this, te).set(t.key, t);
    });
  }
  encode(t) {
    t = Pe(t);
    const v = G$1(this, V, J).call(this, t);
    return W$6(v);
  }
  decode(t) {
    const v = H(t), w = G$1(this, V, Q).call(this, v);
    return Pe(w);
  }
  static encode(t) {
    return ne || (ne = new Ha()), ne.encode(t);
  }
  static decode(t) {
    return ne || (ne = new Ha()), ne.decode(t);
  }
};
te = /* @__PURE__ */ new WeakMap(), V = /* @__PURE__ */ new WeakSet(), J = function(e) {
  const t = nt.find((v) => v.test(e));
  if (t)
    return {
      key: t.key,
      value: t.encode(e),
      version: "1.20250425.1"
    };
  if (e instanceof Map) {
    const v = /* @__PURE__ */ new Map();
    return e.forEach((w, T) => {
      const x = G$1(this, V, J).call(this, T), C = G$1(this, V, J).call(this, w);
      v.set(x, C);
    }), {
      key: "js:Map",
      value: Uint8Array.from(W$6(v)),
      version: "1.20250425.1"
    };
  }
  if (e instanceof Set) {
    const v = /* @__PURE__ */ new Set();
    return e.forEach((w) => {
      const T = G$1(this, V, J).call(this, w);
      v.add(T);
    }), {
      key: "js:Set",
      value: Uint8Array.from(W$6(v)),
      version: "1.20250425.1"
    };
  }
  for (const v of it)
    if (e instanceof v) {
      const w = Array.from(e).map((T) => G$1(this, V, J).call(this, T));
      return {
        key: `js:${v.name}`,
        value: Uint8Array.from(W$6(w)),
        version: "1.20250425.1"
      };
    }
  for (const v of at)
    if (e instanceof v)
      return {
        key: `js:${v.name}`,
        value: Uint8Array.from(W$6(e)),
        version: "1.20250425.1"
      };
  if (Array.isArray(e)) {
    const v = e.map((w) => G$1(this, V, J).call(this, w));
    return {
      key: "js:array",
      value: Uint8Array.from(W$6(v)),
      version: "1.20250425.1"
    };
  }
  if (Or(e)) {
    const v = {};
    return Object.entries(e).forEach(([w, T]) => {
      const x = G$1(this, V, J).call(this, T);
      v[w] = x;
    }), {
      key: "js:object",
      value: Uint8Array.from(W$6(v)),
      version: "1.20250425.1"
    };
  }
  if (e === null)
    return {
      key: "js:null",
      value: Uint8Array.from(W$6(e)),
      version: "1.20250425.1"
    };
  if (jr$1(e))
    return {
      key: "js:primitive",
      value: Uint8Array.from(W$6(e)),
      version: "1.20250425.1"
    };
  throw new U(e);
}, Q = function(e) {
  const { key: t, value: v, version: w } = e;
  if (w !== "1.20250425.1") {
    if (Ri.gt(w, "1.20250425.1"))
      throw new R$1(w);
    try {
      process.emitWarning(P$1(w));
    } catch {
    }
  }
  if (t && fe(this, te).has(t)) {
    const T = fe(this, te).get(t);
    if (T)
      return T.decode(v);
  }
  if (t === "js:Map") {
    const T = H(v), x = /* @__PURE__ */ new Map();
    return T.forEach((C, D) => {
      x.set(G$1(this, V, Q).call(this, D), G$1(this, V, Q).call(this, C));
    }), x;
  }
  if (t === "js:Set") {
    const T = H(v), x = /* @__PURE__ */ new Set();
    return T.forEach((C) => {
      x.add(G$1(this, V, Q).call(this, C));
    }), x;
  }
  for (const T of it)
    if (t === `js:${T.name}`) {
      const x = H(v);
      return new T(x.map((C) => G$1(this, V, Q).call(this, C)));
    }
  for (const T of at)
    if (t === `js:${T.name}`)
      return H(v);
  if (t === "js:array")
    return H(v).map((T) => G$1(this, V, Q).call(this, T));
  if (t === "js:object") {
    const T = H(v), x = {};
    return Object.entries(T).forEach(([C, D]) => {
      x[C] = G$1(this, V, Q).call(this, D);
    }), x;
  }
  if (t === "js:null")
    return null;
  if (t === "js:primitive")
    return H(v);
  throw new S$1(e);
};
let we = Ee;
const ji = (e) => we.encode(e), Ii = (e) => we.decode(e);
kt.ValidationError;
var y = Object.defineProperty, _ = (e) => {
  throw TypeError(e);
}, b = (e, t, v) => t in e ? y(e, t, { enumerable: !0, configurable: !0, writable: !0, value: v }) : e[t] = v, o = (e, t, v) => b(e, typeof t != "symbol" ? t + "" : t, v), f$1 = (e, t, v) => t.has(e) || _("Cannot " + v), u = (e, t, v) => (f$1(e, t, "read from private field"), v ? v.call(e) : t.get(e)), m = (e, t, v) => t.has(e) ? _("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, v), g$2 = (e, t, v, w) => (f$1(e, t, "write to private field"), w ? w.call(e, v) : t.set(e, v), v), E = Object.defineProperty, d = (e, t, v) => t in e ? E(e, t, { enumerable: !0, configurable: !0, writable: !0, value: v }) : e[t] = v, p = (e, t, v) => d(e, typeof t != "symbol" ? t + "" : t, v);
const S = class extends TypeError {
  constructor(e, t, v) {
    const w = v ? { cause: v.cause } : {};
    super(t, w), p(this, "$__name"), p(this, "$__message");
    const T = this.constructor;
    if (Object.setPrototypeOf(this, T), this.$__name = e, this.$__message = t, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, T), typeof this.stack != "string" && Object.defineProperty(this, "stack", {
      value: "",
      writable: !0,
      enumerable: !1,
      configurable: !0
    }), this.stack && v && v.trim && v.trim > 0) {
      const x = this.stack.split(`
`);
      x.splice(0, v.trim), this.stack = x.join(`
`);
    }
    Object.defineProperty(this, "name", {
      get: () => this.$__name,
      enumerable: !0,
      configurable: !1
    }), Object.defineProperty(this, "message", {
      get: () => this.$__message,
      enumerable: !0,
      configurable: !1
    });
  }
  /** @private */
  get name() {
    return this.$__name;
  }
  /** @private */
  get message() {
    return this.$__message;
  }
  /** @private */
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  /** @private */
  toString() {
    return `${this.name}: ${this.message}`;
  }
  /** @private */
  [Symbol.toPrimitive](e) {
    switch (e) {
      case "string":
        return this.toString();
      default:
        return !0;
    }
  }
  /** @private */
  static [Symbol.hasInstance](e) {
    if (typeof e == "object" && e !== null || typeof e == "function") {
      const t = Object.getPrototypeOf(e);
      return t.name === this.name || t === this;
    }
    return !1;
  }
}, P = (e, t, v) => e ? [
  v,
  e.details ? e.details.map((w) => w.message).join(" and ") : e.message
].filter((w) => typeof w == "string").join(" ") : t;
class O extends S {
  /** @private */
  constructor(t) {
    const v = P(
      t,
      "Cannot serialize this value",
      "Cannot serialize this value:"
    );
    super("E_PAYLOAD_UNSERIALIZABLE", v);
  }
}
const l = class extends Error {
  constructor(e, t, v) {
    const w = v ? { cause: v.cause } : {};
    super(t, w), o(this, "$__name"), o(this, "$__message");
    const T = this.constructor;
    if (Object.setPrototypeOf(this, T), this.$__name = e, this.$__message = t, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, T), typeof this.stack != "string" && Object.defineProperty(this, "stack", {
      value: "",
      writable: !0,
      enumerable: !1,
      configurable: !0
    }), this.stack && v && v.trim && v.trim > 0) {
      const x = this.stack.split(`
`);
      x.splice(0, v.trim), this.stack = x.join(`
`);
    }
    Object.defineProperty(this, "name", {
      get: () => this.$__name,
      enumerable: !0,
      configurable: !1
    }), Object.defineProperty(this, "message", {
      get: () => this.$__message,
      enumerable: !0,
      configurable: !1
    });
  }
  /** @private */
  get name() {
    return this.$__name;
  }
  /** @private */
  get message() {
    return this.$__message;
  }
  /** @private */
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  /** @private */
  toString() {
    return `${this.name}: ${this.message}`;
  }
  /** @private */
  [Symbol.toPrimitive](e) {
    switch (e) {
      case "string":
        return this.toString();
      default:
        return !0;
    }
  }
  /** @private */
  static [Symbol.hasInstance](e) {
    if (typeof e == "object" && e !== null || typeof e == "function") {
      const t = Object.getPrototypeOf(e);
      return t.name === this.name || t === this;
    }
    return !1;
  }
};
class $ extends l {
  constructor() {
    super("InsecureAppKeyError", "The value of the encryption key should be at least 16 characters long");
  }
  get code() {
    return "E_INSECURE_APP_KEY";
  }
}
class j extends l {
  constructor() {
    super("MissingAppKeyError", "Missing encryption key. The key is required to encrypt values");
  }
  get code() {
    return "E_MISSING_APP_KEY";
  }
}
const k = $, A = j;
var i$1, c;
class I extends l {
  constructor(t, v) {
    super("RuntimeException", t || "Runtime exception", { trim: 1 }), m(this, i$1), m(this, c), g$2(this, i$1, v == null ? void 0 : v.code), g$2(this, c, v == null ? void 0 : v.status);
  }
  get code() {
    return u(this, i$1);
  }
  get status() {
    return u(this, c);
  }
}
i$1 = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap();
var Wr = Object.defineProperty, Ur = (e) => {
  throw TypeError(e);
}, Vr = (e, t, v) => t in e ? Wr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: v }) : e[t] = v, qr = (e, t, v) => Vr(e, typeof t != "symbol" ? t + "" : t, v), jr = (e, t, v) => t.has(e) || Ur("Cannot " + v), tr = (e, t, v) => (jr(e, t, "read from private field"), v ? v.call(e) : t.get(e)), ir = (e, t, v) => t.has(e) ? Ur("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, v), Br = (e, t, v, w) => (jr(e, t, "write to private field"), w ? w.call(e, v) : t.set(e, v), v), Dr = (e, t, v) => (jr(e, t, "access private method"), v), buffer$1 = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i)
  lookup[i] = code[i], revLookup[code.charCodeAt(i)] = i;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var v = e.indexOf("=");
  v === -1 && (v = t);
  var w = v === t ? 0 : 4 - v % 4;
  return [v, w];
}
function byteLength(e) {
  var t = getLens(e), v = t[0], w = t[1];
  return (v + w) * 3 / 4 - w;
}
function _byteLength(e, t, v) {
  return (t + v) * 3 / 4 - v;
}
function toByteArray(e) {
  var t, v = getLens(e), w = v[0], T = v[1], x = new Arr(_byteLength(e, w, T)), C = 0, D = T > 0 ? w - 4 : w, Y;
  for (Y = 0; Y < D; Y += 4)
    t = revLookup[e.charCodeAt(Y)] << 18 | revLookup[e.charCodeAt(Y + 1)] << 12 | revLookup[e.charCodeAt(Y + 2)] << 6 | revLookup[e.charCodeAt(Y + 3)], x[C++] = t >> 16 & 255, x[C++] = t >> 8 & 255, x[C++] = t & 255;
  return T === 2 && (t = revLookup[e.charCodeAt(Y)] << 2 | revLookup[e.charCodeAt(Y + 1)] >> 4, x[C++] = t & 255), T === 1 && (t = revLookup[e.charCodeAt(Y)] << 10 | revLookup[e.charCodeAt(Y + 1)] << 4 | revLookup[e.charCodeAt(Y + 2)] >> 2, x[C++] = t >> 8 & 255, x[C++] = t & 255), x;
}
function tripletToBase64(e) {
  return lookup[e >> 18 & 63] + lookup[e >> 12 & 63] + lookup[e >> 6 & 63] + lookup[e & 63];
}
function encodeChunk(e, t, v) {
  for (var w, T = [], x = t; x < v; x += 3)
    w = (e[x] << 16 & 16711680) + (e[x + 1] << 8 & 65280) + (e[x + 2] & 255), T.push(tripletToBase64(w));
  return T.join("");
}
function fromByteArray(e) {
  for (var t, v = e.length, w = v % 3, T = [], x = 16383, C = 0, D = v - w; C < D; C += x)
    T.push(encodeChunk(e, C, C + x > D ? D : C + x));
  return w === 1 ? (t = e[v - 1], T.push(
    lookup[t >> 2] + lookup[t << 4 & 63] + "=="
  )) : w === 2 && (t = (e[v - 2] << 8) + e[v - 1], T.push(
    lookup[t >> 10] + lookup[t >> 4 & 63] + lookup[t << 2 & 63] + "="
  )), T.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(e, t, v, w, T) {
  var x, C, D = T * 8 - w - 1, Y = (1 << D) - 1, L = Y >> 1, q = -7, N = v ? T - 1 : 0, F = v ? -1 : 1, ae = e[t + N];
  for (N += F, x = ae & (1 << -q) - 1, ae >>= -q, q += D; q > 0; x = x * 256 + e[t + N], N += F, q -= 8)
    ;
  for (C = x & (1 << -q) - 1, x >>= -q, q += w; q > 0; C = C * 256 + e[t + N], N += F, q -= 8)
    ;
  if (x === 0)
    x = 1 - L;
  else {
    if (x === Y)
      return C ? NaN : (ae ? -1 : 1) * (1 / 0);
    C = C + Math.pow(2, w), x = x - L;
  }
  return (ae ? -1 : 1) * C * Math.pow(2, x - w);
};
ieee754.write = function(e, t, v, w, T, x) {
  var C, D, Y, L = x * 8 - T - 1, q = (1 << L) - 1, N = q >> 1, F = T === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ae = w ? 0 : x - 1, he = w ? 1 : -1, tt = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (D = isNaN(t) ? 1 : 0, C = q) : (C = Math.floor(Math.log(t) / Math.LN2), t * (Y = Math.pow(2, -C)) < 1 && (C--, Y *= 2), C + N >= 1 ? t += F / Y : t += F * Math.pow(2, 1 - N), t * Y >= 2 && (C++, Y /= 2), C + N >= q ? (D = 0, C = q) : C + N >= 1 ? (D = (t * Y - 1) * Math.pow(2, T), C = C + N) : (D = t * Math.pow(2, N - 1) * Math.pow(2, T), C = 0)); T >= 8; e[v + ae] = D & 255, ae += he, D /= 256, T -= 8)
    ;
  for (C = C << T | D, L += T; L > 0; e[v + ae] = C & 255, ae += he, C /= 256, L -= 8)
    ;
  e[v + ae - he] |= tt * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  const t = base64Js, v = ieee754, w = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = q, e.SlowBuffer = qi, e.INSPECT_MAX_BYTES = 50;
  const T = 2147483647;
  e.kMaxLength = T;
  const { Uint8Array: x, ArrayBuffer: C, SharedArrayBuffer: D } = globalThis;
  q.TYPED_ARRAY_SUPPORT = Y(), !q.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function Y() {
    try {
      const Ai = new x(1), Pi = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(Pi, x.prototype), Object.setPrototypeOf(Ai, Pi), Ai.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(q.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (q.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(q.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (q.isBuffer(this))
        return this.byteOffset;
    }
  });
  function L(Ai) {
    if (Ai > T)
      throw new RangeError('The value "' + Ai + '" is invalid for option "size"');
    const Pi = new x(Ai);
    return Object.setPrototypeOf(Pi, q.prototype), Pi;
  }
  function q(Ai, Pi, Ui) {
    if (typeof Ai == "number") {
      if (typeof Pi == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return he(Ai);
    }
    return N(Ai, Pi, Ui);
  }
  q.poolSize = 8192;
  function N(Ai, Pi, Ui) {
    if (typeof Ai == "string")
      return tt(Ai, Pi);
    if (C.isView(Ai))
      return rt(Ai);
    if (Ai == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Ai
      );
    if (_o(Ai, C) || Ai && _o(Ai.buffer, C) || typeof D < "u" && (_o(Ai, D) || Ai && _o(Ai.buffer, D)))
      return dr(Ai, Pi, Ui);
    if (typeof Ai == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const Ji = Ai.valueOf && Ai.valueOf();
    if (Ji != null && Ji !== Ai)
      return q.from(Ji, Pi, Ui);
    const eo = _r(Ai);
    if (eo) return eo;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Ai[Symbol.toPrimitive] == "function")
      return q.from(Ai[Symbol.toPrimitive]("string"), Pi, Ui);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Ai
    );
  }
  q.from = function(Ai, Pi, Ui) {
    return N(Ai, Pi, Ui);
  }, Object.setPrototypeOf(q.prototype, x.prototype), Object.setPrototypeOf(q, x);
  function F(Ai) {
    if (typeof Ai != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Ai < 0)
      throw new RangeError('The value "' + Ai + '" is invalid for option "size"');
  }
  function ae(Ai, Pi, Ui) {
    return F(Ai), Ai <= 0 ? L(Ai) : Pi !== void 0 ? typeof Ui == "string" ? L(Ai).fill(Pi, Ui) : L(Ai).fill(Pi) : L(Ai);
  }
  q.alloc = function(Ai, Pi, Ui) {
    return ae(Ai, Pi, Ui);
  };
  function he(Ai) {
    return F(Ai), L(Ai < 0 ? 0 : Bi(Ai) | 0);
  }
  q.allocUnsafe = function(Ai) {
    return he(Ai);
  }, q.allocUnsafeSlow = function(Ai) {
    return he(Ai);
  };
  function tt(Ai, Pi) {
    if ((typeof Pi != "string" || Pi === "") && (Pi = "utf8"), !q.isEncoding(Pi))
      throw new TypeError("Unknown encoding: " + Pi);
    const Ui = Wi(Ai, Pi) | 0;
    let Ji = L(Ui);
    const eo = Ji.write(Ai, Pi);
    return eo !== Ui && (Ji = Ji.slice(0, eo)), Ji;
  }
  function br(Ai) {
    const Pi = Ai.length < 0 ? 0 : Bi(Ai.length) | 0, Ui = L(Pi);
    for (let Ji = 0; Ji < Pi; Ji += 1)
      Ui[Ji] = Ai[Ji] & 255;
    return Ui;
  }
  function rt(Ai) {
    if (_o(Ai, x)) {
      const Pi = new x(Ai);
      return dr(Pi.buffer, Pi.byteOffset, Pi.byteLength);
    }
    return br(Ai);
  }
  function dr(Ai, Pi, Ui) {
    if (Pi < 0 || Ai.byteLength < Pi)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Ai.byteLength < Pi + (Ui || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let Ji;
    return Pi === void 0 && Ui === void 0 ? Ji = new x(Ai) : Ui === void 0 ? Ji = new x(Ai, Pi) : Ji = new x(Ai, Pi, Ui), Object.setPrototypeOf(Ji, q.prototype), Ji;
  }
  function _r(Ai) {
    if (q.isBuffer(Ai)) {
      const Pi = Bi(Ai.length) | 0, Ui = L(Pi);
      return Ui.length === 0 || Ai.copy(Ui, 0, 0, Pi), Ui;
    }
    if (Ai.length !== void 0)
      return typeof Ai.length != "number" || yo(Ai.length) ? L(0) : br(Ai);
    if (Ai.type === "Buffer" && Array.isArray(Ai.data))
      return br(Ai.data);
  }
  function Bi(Ai) {
    if (Ai >= T)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + T.toString(16) + " bytes");
    return Ai | 0;
  }
  function qi(Ai) {
    return +Ai != Ai && (Ai = 0), q.alloc(+Ai);
  }
  q.isBuffer = function(Ai) {
    return Ai != null && Ai._isBuffer === !0 && Ai !== q.prototype;
  }, q.compare = function(Ai, Pi) {
    if (_o(Ai, x) && (Ai = q.from(Ai, Ai.offset, Ai.byteLength)), _o(Pi, x) && (Pi = q.from(Pi, Pi.offset, Pi.byteLength)), !q.isBuffer(Ai) || !q.isBuffer(Pi))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (Ai === Pi) return 0;
    let Ui = Ai.length, Ji = Pi.length;
    for (let eo = 0, ro = Math.min(Ui, Ji); eo < ro; ++eo)
      if (Ai[eo] !== Pi[eo]) {
        Ui = Ai[eo], Ji = Pi[eo];
        break;
      }
    return Ui < Ji ? -1 : Ji < Ui ? 1 : 0;
  }, q.isEncoding = function(Ai) {
    switch (String(Ai).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, q.concat = function(Ai, Pi) {
    if (!Array.isArray(Ai))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (Ai.length === 0)
      return q.alloc(0);
    let Ui;
    if (Pi === void 0)
      for (Pi = 0, Ui = 0; Ui < Ai.length; ++Ui)
        Pi += Ai[Ui].length;
    const Ji = q.allocUnsafe(Pi);
    let eo = 0;
    for (Ui = 0; Ui < Ai.length; ++Ui) {
      let ro = Ai[Ui];
      if (_o(ro, x))
        eo + ro.length > Ji.length ? (q.isBuffer(ro) || (ro = q.from(ro)), ro.copy(Ji, eo)) : x.prototype.set.call(
          Ji,
          ro,
          eo
        );
      else if (q.isBuffer(ro))
        ro.copy(Ji, eo);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      eo += ro.length;
    }
    return Ji;
  };
  function Wi(Ai, Pi) {
    if (q.isBuffer(Ai))
      return Ai.length;
    if (C.isView(Ai) || _o(Ai, C))
      return Ai.byteLength;
    if (typeof Ai != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Ai
      );
    const Ui = Ai.length, Ji = arguments.length > 2 && arguments[2] === !0;
    if (!Ji && Ui === 0) return 0;
    let eo = !1;
    for (; ; )
      switch (Pi) {
        case "ascii":
        case "latin1":
        case "binary":
          return Ui;
        case "utf8":
        case "utf-8":
          return po(Ai).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ui * 2;
        case "hex":
          return Ui >>> 1;
        case "base64":
          return mo(Ai).length;
        default:
          if (eo)
            return Ji ? -1 : po(Ai).length;
          Pi = ("" + Pi).toLowerCase(), eo = !0;
      }
  }
  q.byteLength = Wi;
  function Vi(Ai, Pi, Ui) {
    let Ji = !1;
    if ((Pi === void 0 || Pi < 0) && (Pi = 0), Pi > this.length || ((Ui === void 0 || Ui > this.length) && (Ui = this.length), Ui <= 0) || (Ui >>>= 0, Pi >>>= 0, Ui <= Pi))
      return "";
    for (Ai || (Ai = "utf8"); ; )
      switch (Ai) {
        case "hex":
          return Ci(this, Pi, Ui);
        case "utf8":
        case "utf-8":
          return Mi(this, Pi, Ui);
        case "ascii":
          return xi(this, Pi, Ui);
        case "latin1":
        case "binary":
          return Si(this, Pi, Ui);
        case "base64":
          return Oi(this, Pi, Ui);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ki(this, Pi, Ui);
        default:
          if (Ji) throw new TypeError("Unknown encoding: " + Ai);
          Ai = (Ai + "").toLowerCase(), Ji = !0;
      }
  }
  q.prototype._isBuffer = !0;
  function Ti(Ai, Pi, Ui) {
    const Ji = Ai[Pi];
    Ai[Pi] = Ai[Ui], Ai[Ui] = Ji;
  }
  q.prototype.swap16 = function() {
    const Ai = this.length;
    if (Ai % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let Pi = 0; Pi < Ai; Pi += 2)
      Ti(this, Pi, Pi + 1);
    return this;
  }, q.prototype.swap32 = function() {
    const Ai = this.length;
    if (Ai % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let Pi = 0; Pi < Ai; Pi += 4)
      Ti(this, Pi, Pi + 3), Ti(this, Pi + 1, Pi + 2);
    return this;
  }, q.prototype.swap64 = function() {
    const Ai = this.length;
    if (Ai % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let Pi = 0; Pi < Ai; Pi += 8)
      Ti(this, Pi, Pi + 7), Ti(this, Pi + 1, Pi + 6), Ti(this, Pi + 2, Pi + 5), Ti(this, Pi + 3, Pi + 4);
    return this;
  }, q.prototype.toString = function() {
    const Ai = this.length;
    return Ai === 0 ? "" : arguments.length === 0 ? Mi(this, 0, Ai) : Vi.apply(this, arguments);
  }, q.prototype.toLocaleString = q.prototype.toString, q.prototype.equals = function(Ai) {
    if (!q.isBuffer(Ai)) throw new TypeError("Argument must be a Buffer");
    return this === Ai ? !0 : q.compare(this, Ai) === 0;
  }, q.prototype.inspect = function() {
    let Ai = "";
    const Pi = e.INSPECT_MAX_BYTES;
    return Ai = this.toString("hex", 0, Pi).replace(/(.{2})/g, "$1 ").trim(), this.length > Pi && (Ai += " ... "), "<Buffer " + Ai + ">";
  }, w && (q.prototype[w] = q.prototype.inspect), q.prototype.compare = function(Ai, Pi, Ui, Ji, eo) {
    if (_o(Ai, x) && (Ai = q.from(Ai, Ai.offset, Ai.byteLength)), !q.isBuffer(Ai))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Ai
      );
    if (Pi === void 0 && (Pi = 0), Ui === void 0 && (Ui = Ai ? Ai.length : 0), Ji === void 0 && (Ji = 0), eo === void 0 && (eo = this.length), Pi < 0 || Ui > Ai.length || Ji < 0 || eo > this.length)
      throw new RangeError("out of range index");
    if (Ji >= eo && Pi >= Ui)
      return 0;
    if (Ji >= eo)
      return -1;
    if (Pi >= Ui)
      return 1;
    if (Pi >>>= 0, Ui >>>= 0, Ji >>>= 0, eo >>>= 0, this === Ai) return 0;
    let ro = eo - Ji, oo = Ui - Pi;
    const bo = Math.min(ro, oo), lo = this.slice(Ji, eo), vo = Ai.slice(Pi, Ui);
    for (let go = 0; go < bo; ++go)
      if (lo[go] !== vo[go]) {
        ro = lo[go], oo = vo[go];
        break;
      }
    return ro < oo ? -1 : oo < ro ? 1 : 0;
  };
  function Li(Ai, Pi, Ui, Ji, eo) {
    if (Ai.length === 0) return -1;
    if (typeof Ui == "string" ? (Ji = Ui, Ui = 0) : Ui > 2147483647 ? Ui = 2147483647 : Ui < -2147483648 && (Ui = -2147483648), Ui = +Ui, yo(Ui) && (Ui = eo ? 0 : Ai.length - 1), Ui < 0 && (Ui = Ai.length + Ui), Ui >= Ai.length) {
      if (eo) return -1;
      Ui = Ai.length - 1;
    } else if (Ui < 0)
      if (eo) Ui = 0;
      else return -1;
    if (typeof Pi == "string" && (Pi = q.from(Pi, Ji)), q.isBuffer(Pi))
      return Pi.length === 0 ? -1 : Hi(Ai, Pi, Ui, Ji, eo);
    if (typeof Pi == "number")
      return Pi = Pi & 255, typeof x.prototype.indexOf == "function" ? eo ? x.prototype.indexOf.call(Ai, Pi, Ui) : x.prototype.lastIndexOf.call(Ai, Pi, Ui) : Hi(Ai, [Pi], Ui, Ji, eo);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Hi(Ai, Pi, Ui, Ji, eo) {
    let ro = 1, oo = Ai.length, bo = Pi.length;
    if (Ji !== void 0 && (Ji = String(Ji).toLowerCase(), Ji === "ucs2" || Ji === "ucs-2" || Ji === "utf16le" || Ji === "utf-16le")) {
      if (Ai.length < 2 || Pi.length < 2)
        return -1;
      ro = 2, oo /= 2, bo /= 2, Ui /= 2;
    }
    function lo(go, co) {
      return ro === 1 ? go[co] : go.readUInt16BE(co * ro);
    }
    let vo;
    if (eo) {
      let go = -1;
      for (vo = Ui; vo < oo; vo++)
        if (lo(Ai, vo) === lo(Pi, go === -1 ? 0 : vo - go)) {
          if (go === -1 && (go = vo), vo - go + 1 === bo) return go * ro;
        } else
          go !== -1 && (vo -= vo - go), go = -1;
    } else
      for (Ui + bo > oo && (Ui = oo - bo), vo = Ui; vo >= 0; vo--) {
        let go = !0;
        for (let co = 0; co < bo; co++)
          if (lo(Ai, vo + co) !== lo(Pi, co)) {
            go = !1;
            break;
          }
        if (go) return vo;
      }
    return -1;
  }
  q.prototype.includes = function(Ai, Pi, Ui) {
    return this.indexOf(Ai, Pi, Ui) !== -1;
  }, q.prototype.indexOf = function(Ai, Pi, Ui) {
    return Li(this, Ai, Pi, Ui, !0);
  }, q.prototype.lastIndexOf = function(Ai, Pi, Ui) {
    return Li(this, Ai, Pi, Ui, !1);
  };
  function pr(Ai, Pi, Ui, Ji) {
    Ui = Number(Ui) || 0;
    const eo = Ai.length - Ui;
    Ji ? (Ji = Number(Ji), Ji > eo && (Ji = eo)) : Ji = eo;
    const ro = Pi.length;
    Ji > ro / 2 && (Ji = ro / 2);
    let oo;
    for (oo = 0; oo < Ji; ++oo) {
      const bo = parseInt(Pi.substr(oo * 2, 2), 16);
      if (yo(bo)) return oo;
      Ai[Ui + oo] = bo;
    }
    return oo;
  }
  function Di(Ai, Pi, Ui, Ji) {
    return Ro(po(Pi, Ai.length - Ui), Ai, Ui, Ji);
  }
  function z(Ai, Pi, Ui, Ji) {
    return Ro(Do(Pi), Ai, Ui, Ji);
  }
  function gr(Ai, Pi, Ui, Ji) {
    return Ro(mo(Pi), Ai, Ui, Ji);
  }
  function vr(Ai, Pi, Ui, Ji) {
    return Ro(Io(Pi, Ai.length - Ui), Ai, Ui, Ji);
  }
  q.prototype.write = function(Ai, Pi, Ui, Ji) {
    if (Pi === void 0)
      Ji = "utf8", Ui = this.length, Pi = 0;
    else if (Ui === void 0 && typeof Pi == "string")
      Ji = Pi, Ui = this.length, Pi = 0;
    else if (isFinite(Pi))
      Pi = Pi >>> 0, isFinite(Ui) ? (Ui = Ui >>> 0, Ji === void 0 && (Ji = "utf8")) : (Ji = Ui, Ui = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const eo = this.length - Pi;
    if ((Ui === void 0 || Ui > eo) && (Ui = eo), Ai.length > 0 && (Ui < 0 || Pi < 0) || Pi > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Ji || (Ji = "utf8");
    let ro = !1;
    for (; ; )
      switch (Ji) {
        case "hex":
          return pr(this, Ai, Pi, Ui);
        case "utf8":
        case "utf-8":
          return Di(this, Ai, Pi, Ui);
        case "ascii":
        case "latin1":
        case "binary":
          return z(this, Ai, Pi, Ui);
        case "base64":
          return gr(this, Ai, Pi, Ui);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return vr(this, Ai, Pi, Ui);
        default:
          if (ro) throw new TypeError("Unknown encoding: " + Ji);
          Ji = ("" + Ji).toLowerCase(), ro = !0;
      }
  }, q.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function Oi(Ai, Pi, Ui) {
    return Pi === 0 && Ui === Ai.length ? t.fromByteArray(Ai) : t.fromByteArray(Ai.slice(Pi, Ui));
  }
  function Mi(Ai, Pi, Ui) {
    Ui = Math.min(Ai.length, Ui);
    const Ji = [];
    let eo = Pi;
    for (; eo < Ui; ) {
      const ro = Ai[eo];
      let oo = null, bo = ro > 239 ? 4 : ro > 223 ? 3 : ro > 191 ? 2 : 1;
      if (eo + bo <= Ui) {
        let lo, vo, go, co;
        switch (bo) {
          case 1:
            ro < 128 && (oo = ro);
            break;
          case 2:
            lo = Ai[eo + 1], (lo & 192) === 128 && (co = (ro & 31) << 6 | lo & 63, co > 127 && (oo = co));
            break;
          case 3:
            lo = Ai[eo + 1], vo = Ai[eo + 2], (lo & 192) === 128 && (vo & 192) === 128 && (co = (ro & 15) << 12 | (lo & 63) << 6 | vo & 63, co > 2047 && (co < 55296 || co > 57343) && (oo = co));
            break;
          case 4:
            lo = Ai[eo + 1], vo = Ai[eo + 2], go = Ai[eo + 3], (lo & 192) === 128 && (vo & 192) === 128 && (go & 192) === 128 && (co = (ro & 15) << 18 | (lo & 63) << 12 | (vo & 63) << 6 | go & 63, co > 65535 && co < 1114112 && (oo = co));
        }
      }
      oo === null ? (oo = 65533, bo = 1) : oo > 65535 && (oo -= 65536, Ji.push(oo >>> 10 & 1023 | 55296), oo = 56320 | oo & 1023), Ji.push(oo), eo += bo;
    }
    return yr(Ji);
  }
  const ki = 4096;
  function yr(Ai) {
    const Pi = Ai.length;
    if (Pi <= ki)
      return String.fromCharCode.apply(String, Ai);
    let Ui = "", Ji = 0;
    for (; Ji < Pi; )
      Ui += String.fromCharCode.apply(
        String,
        Ai.slice(Ji, Ji += ki)
      );
    return Ui;
  }
  function xi(Ai, Pi, Ui) {
    let Ji = "";
    Ui = Math.min(Ai.length, Ui);
    for (let eo = Pi; eo < Ui; ++eo)
      Ji += String.fromCharCode(Ai[eo] & 127);
    return Ji;
  }
  function Si(Ai, Pi, Ui) {
    let Ji = "";
    Ui = Math.min(Ai.length, Ui);
    for (let eo = Pi; eo < Ui; ++eo)
      Ji += String.fromCharCode(Ai[eo]);
    return Ji;
  }
  function Ci(Ai, Pi, Ui) {
    const Ji = Ai.length;
    (!Pi || Pi < 0) && (Pi = 0), (!Ui || Ui < 0 || Ui > Ji) && (Ui = Ji);
    let eo = "";
    for (let ro = Pi; ro < Ui; ++ro)
      eo += To[Ai[ro]];
    return eo;
  }
  function Ki(Ai, Pi, Ui) {
    const Ji = Ai.slice(Pi, Ui);
    let eo = "";
    for (let ro = 0; ro < Ji.length - 1; ro += 2)
      eo += String.fromCharCode(Ji[ro] + Ji[ro + 1] * 256);
    return eo;
  }
  q.prototype.slice = function(Ai, Pi) {
    const Ui = this.length;
    Ai = ~~Ai, Pi = Pi === void 0 ? Ui : ~~Pi, Ai < 0 ? (Ai += Ui, Ai < 0 && (Ai = 0)) : Ai > Ui && (Ai = Ui), Pi < 0 ? (Pi += Ui, Pi < 0 && (Pi = 0)) : Pi > Ui && (Pi = Ui), Pi < Ai && (Pi = Ai);
    const Ji = this.subarray(Ai, Pi);
    return Object.setPrototypeOf(Ji, q.prototype), Ji;
  };
  function Yi(Ai, Pi, Ui) {
    if (Ai % 1 !== 0 || Ai < 0) throw new RangeError("offset is not uint");
    if (Ai + Pi > Ui) throw new RangeError("Trying to access beyond buffer length");
  }
  q.prototype.readUintLE = q.prototype.readUIntLE = function(Ai, Pi, Ui) {
    Ai = Ai >>> 0, Pi = Pi >>> 0, Ui || Yi(Ai, Pi, this.length);
    let Ji = this[Ai], eo = 1, ro = 0;
    for (; ++ro < Pi && (eo *= 256); )
      Ji += this[Ai + ro] * eo;
    return Ji;
  }, q.prototype.readUintBE = q.prototype.readUIntBE = function(Ai, Pi, Ui) {
    Ai = Ai >>> 0, Pi = Pi >>> 0, Ui || Yi(Ai, Pi, this.length);
    let Ji = this[Ai + --Pi], eo = 1;
    for (; Pi > 0 && (eo *= 256); )
      Ji += this[Ai + --Pi] * eo;
    return Ji;
  }, q.prototype.readUint8 = q.prototype.readUInt8 = function(Ai, Pi) {
    return Ai = Ai >>> 0, Pi || Yi(Ai, 1, this.length), this[Ai];
  }, q.prototype.readUint16LE = q.prototype.readUInt16LE = function(Ai, Pi) {
    return Ai = Ai >>> 0, Pi || Yi(Ai, 2, this.length), this[Ai] | this[Ai + 1] << 8;
  }, q.prototype.readUint16BE = q.prototype.readUInt16BE = function(Ai, Pi) {
    return Ai = Ai >>> 0, Pi || Yi(Ai, 2, this.length), this[Ai] << 8 | this[Ai + 1];
  }, q.prototype.readUint32LE = q.prototype.readUInt32LE = function(Ai, Pi) {
    return Ai = Ai >>> 0, Pi || Yi(Ai, 4, this.length), (this[Ai] | this[Ai + 1] << 8 | this[Ai + 2] << 16) + this[Ai + 3] * 16777216;
  }, q.prototype.readUint32BE = q.prototype.readUInt32BE = function(Ai, Pi) {
    return Ai = Ai >>> 0, Pi || Yi(Ai, 4, this.length), this[Ai] * 16777216 + (this[Ai + 1] << 16 | this[Ai + 2] << 8 | this[Ai + 3]);
  }, q.prototype.readBigUInt64LE = xo(function(Ai) {
    Ai = Ai >>> 0, uo(Ai, "offset");
    const Pi = this[Ai], Ui = this[Ai + 7];
    (Pi === void 0 || Ui === void 0) && ao(Ai, this.length - 8);
    const Ji = Pi + this[++Ai] * 2 ** 8 + this[++Ai] * 2 ** 16 + this[++Ai] * 2 ** 24, eo = this[++Ai] + this[++Ai] * 2 ** 8 + this[++Ai] * 2 ** 16 + Ui * 2 ** 24;
    return BigInt(Ji) + (BigInt(eo) << BigInt(32));
  }), q.prototype.readBigUInt64BE = xo(function(Ai) {
    Ai = Ai >>> 0, uo(Ai, "offset");
    const Pi = this[Ai], Ui = this[Ai + 7];
    (Pi === void 0 || Ui === void 0) && ao(Ai, this.length - 8);
    const Ji = Pi * 2 ** 24 + this[++Ai] * 2 ** 16 + this[++Ai] * 2 ** 8 + this[++Ai], eo = this[++Ai] * 2 ** 24 + this[++Ai] * 2 ** 16 + this[++Ai] * 2 ** 8 + Ui;
    return (BigInt(Ji) << BigInt(32)) + BigInt(eo);
  }), q.prototype.readIntLE = function(Ai, Pi, Ui) {
    Ai = Ai >>> 0, Pi = Pi >>> 0, Ui || Yi(Ai, Pi, this.length);
    let Ji = this[Ai], eo = 1, ro = 0;
    for (; ++ro < Pi && (eo *= 256); )
      Ji += this[Ai + ro] * eo;
    return eo *= 128, Ji >= eo && (Ji -= Math.pow(2, 8 * Pi)), Ji;
  }, q.prototype.readIntBE = function(Ai, Pi, Ui) {
    Ai = Ai >>> 0, Pi = Pi >>> 0, Ui || Yi(Ai, Pi, this.length);
    let Ji = Pi, eo = 1, ro = this[Ai + --Ji];
    for (; Ji > 0 && (eo *= 256); )
      ro += this[Ai + --Ji] * eo;
    return eo *= 128, ro >= eo && (ro -= Math.pow(2, 8 * Pi)), ro;
  }, q.prototype.readInt8 = function(Ai, Pi) {
    return Ai = Ai >>> 0, Pi || Yi(Ai, 1, this.length), this[Ai] & 128 ? (255 - this[Ai] + 1) * -1 : this[Ai];
  }, q.prototype.readInt16LE = function(Ai, Pi) {
    Ai = Ai >>> 0, Pi || Yi(Ai, 2, this.length);
    const Ui = this[Ai] | this[Ai + 1] << 8;
    return Ui & 32768 ? Ui | 4294901760 : Ui;
  }, q.prototype.readInt16BE = function(Ai, Pi) {
    Ai = Ai >>> 0, Pi || Yi(Ai, 2, this.length);
    const Ui = this[Ai + 1] | this[Ai] << 8;
    return Ui & 32768 ? Ui | 4294901760 : Ui;
  }, q.prototype.readInt32LE = function(Ai, Pi) {
    return Ai = Ai >>> 0, Pi || Yi(Ai, 4, this.length), this[Ai] | this[Ai + 1] << 8 | this[Ai + 2] << 16 | this[Ai + 3] << 24;
  }, q.prototype.readInt32BE = function(Ai, Pi) {
    return Ai = Ai >>> 0, Pi || Yi(Ai, 4, this.length), this[Ai] << 24 | this[Ai + 1] << 16 | this[Ai + 2] << 8 | this[Ai + 3];
  }, q.prototype.readBigInt64LE = xo(function(Ai) {
    Ai = Ai >>> 0, uo(Ai, "offset");
    const Pi = this[Ai], Ui = this[Ai + 7];
    (Pi === void 0 || Ui === void 0) && ao(Ai, this.length - 8);
    const Ji = this[Ai + 4] + this[Ai + 5] * 2 ** 8 + this[Ai + 6] * 2 ** 16 + (Ui << 24);
    return (BigInt(Ji) << BigInt(32)) + BigInt(Pi + this[++Ai] * 2 ** 8 + this[++Ai] * 2 ** 16 + this[++Ai] * 2 ** 24);
  }), q.prototype.readBigInt64BE = xo(function(Ai) {
    Ai = Ai >>> 0, uo(Ai, "offset");
    const Pi = this[Ai], Ui = this[Ai + 7];
    (Pi === void 0 || Ui === void 0) && ao(Ai, this.length - 8);
    const Ji = (Pi << 24) + // Overflow
    this[++Ai] * 2 ** 16 + this[++Ai] * 2 ** 8 + this[++Ai];
    return (BigInt(Ji) << BigInt(32)) + BigInt(this[++Ai] * 2 ** 24 + this[++Ai] * 2 ** 16 + this[++Ai] * 2 ** 8 + Ui);
  }), q.prototype.readFloatLE = function(Ai, Pi) {
    return Ai = Ai >>> 0, Pi || Yi(Ai, 4, this.length), v.read(this, Ai, !0, 23, 4);
  }, q.prototype.readFloatBE = function(Ai, Pi) {
    return Ai = Ai >>> 0, Pi || Yi(Ai, 4, this.length), v.read(this, Ai, !1, 23, 4);
  }, q.prototype.readDoubleLE = function(Ai, Pi) {
    return Ai = Ai >>> 0, Pi || Yi(Ai, 8, this.length), v.read(this, Ai, !0, 52, 8);
  }, q.prototype.readDoubleBE = function(Ai, Pi) {
    return Ai = Ai >>> 0, Pi || Yi(Ai, 8, this.length), v.read(this, Ai, !1, 52, 8);
  };
  function Qi(Ai, Pi, Ui, Ji, eo, ro) {
    if (!q.isBuffer(Ai)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (Pi > eo || Pi < ro) throw new RangeError('"value" argument is out of bounds');
    if (Ui + Ji > Ai.length) throw new RangeError("Index out of range");
  }
  q.prototype.writeUintLE = q.prototype.writeUIntLE = function(Ai, Pi, Ui, Ji) {
    if (Ai = +Ai, Pi = Pi >>> 0, Ui = Ui >>> 0, !Ji) {
      const oo = Math.pow(2, 8 * Ui) - 1;
      Qi(this, Ai, Pi, Ui, oo, 0);
    }
    let eo = 1, ro = 0;
    for (this[Pi] = Ai & 255; ++ro < Ui && (eo *= 256); )
      this[Pi + ro] = Ai / eo & 255;
    return Pi + Ui;
  }, q.prototype.writeUintBE = q.prototype.writeUIntBE = function(Ai, Pi, Ui, Ji) {
    if (Ai = +Ai, Pi = Pi >>> 0, Ui = Ui >>> 0, !Ji) {
      const oo = Math.pow(2, 8 * Ui) - 1;
      Qi(this, Ai, Pi, Ui, oo, 0);
    }
    let eo = Ui - 1, ro = 1;
    for (this[Pi + eo] = Ai & 255; --eo >= 0 && (ro *= 256); )
      this[Pi + eo] = Ai / ro & 255;
    return Pi + Ui;
  }, q.prototype.writeUint8 = q.prototype.writeUInt8 = function(Ai, Pi, Ui) {
    return Ai = +Ai, Pi = Pi >>> 0, Ui || Qi(this, Ai, Pi, 1, 255, 0), this[Pi] = Ai & 255, Pi + 1;
  }, q.prototype.writeUint16LE = q.prototype.writeUInt16LE = function(Ai, Pi, Ui) {
    return Ai = +Ai, Pi = Pi >>> 0, Ui || Qi(this, Ai, Pi, 2, 65535, 0), this[Pi] = Ai & 255, this[Pi + 1] = Ai >>> 8, Pi + 2;
  }, q.prototype.writeUint16BE = q.prototype.writeUInt16BE = function(Ai, Pi, Ui) {
    return Ai = +Ai, Pi = Pi >>> 0, Ui || Qi(this, Ai, Pi, 2, 65535, 0), this[Pi] = Ai >>> 8, this[Pi + 1] = Ai & 255, Pi + 2;
  }, q.prototype.writeUint32LE = q.prototype.writeUInt32LE = function(Ai, Pi, Ui) {
    return Ai = +Ai, Pi = Pi >>> 0, Ui || Qi(this, Ai, Pi, 4, 4294967295, 0), this[Pi + 3] = Ai >>> 24, this[Pi + 2] = Ai >>> 16, this[Pi + 1] = Ai >>> 8, this[Pi] = Ai & 255, Pi + 4;
  }, q.prototype.writeUint32BE = q.prototype.writeUInt32BE = function(Ai, Pi, Ui) {
    return Ai = +Ai, Pi = Pi >>> 0, Ui || Qi(this, Ai, Pi, 4, 4294967295, 0), this[Pi] = Ai >>> 24, this[Pi + 1] = Ai >>> 16, this[Pi + 2] = Ai >>> 8, this[Pi + 3] = Ai & 255, Pi + 4;
  };
  function Zi(Ai, Pi, Ui, Ji, eo) {
    ho(Pi, Ji, eo, Ai, Ui, 7);
    let ro = Number(Pi & BigInt(4294967295));
    Ai[Ui++] = ro, ro = ro >> 8, Ai[Ui++] = ro, ro = ro >> 8, Ai[Ui++] = ro, ro = ro >> 8, Ai[Ui++] = ro;
    let oo = Number(Pi >> BigInt(32) & BigInt(4294967295));
    return Ai[Ui++] = oo, oo = oo >> 8, Ai[Ui++] = oo, oo = oo >> 8, Ai[Ui++] = oo, oo = oo >> 8, Ai[Ui++] = oo, Ui;
  }
  function Ni(Ai, Pi, Ui, Ji, eo) {
    ho(Pi, Ji, eo, Ai, Ui, 7);
    let ro = Number(Pi & BigInt(4294967295));
    Ai[Ui + 7] = ro, ro = ro >> 8, Ai[Ui + 6] = ro, ro = ro >> 8, Ai[Ui + 5] = ro, ro = ro >> 8, Ai[Ui + 4] = ro;
    let oo = Number(Pi >> BigInt(32) & BigInt(4294967295));
    return Ai[Ui + 3] = oo, oo = oo >> 8, Ai[Ui + 2] = oo, oo = oo >> 8, Ai[Ui + 1] = oo, oo = oo >> 8, Ai[Ui] = oo, Ui + 8;
  }
  q.prototype.writeBigUInt64LE = xo(function(Ai, Pi = 0) {
    return Zi(this, Ai, Pi, BigInt(0), BigInt("0xffffffffffffffff"));
  }), q.prototype.writeBigUInt64BE = xo(function(Ai, Pi = 0) {
    return Ni(this, Ai, Pi, BigInt(0), BigInt("0xffffffffffffffff"));
  }), q.prototype.writeIntLE = function(Ai, Pi, Ui, Ji) {
    if (Ai = +Ai, Pi = Pi >>> 0, !Ji) {
      const bo = Math.pow(2, 8 * Ui - 1);
      Qi(this, Ai, Pi, Ui, bo - 1, -bo);
    }
    let eo = 0, ro = 1, oo = 0;
    for (this[Pi] = Ai & 255; ++eo < Ui && (ro *= 256); )
      Ai < 0 && oo === 0 && this[Pi + eo - 1] !== 0 && (oo = 1), this[Pi + eo] = (Ai / ro >> 0) - oo & 255;
    return Pi + Ui;
  }, q.prototype.writeIntBE = function(Ai, Pi, Ui, Ji) {
    if (Ai = +Ai, Pi = Pi >>> 0, !Ji) {
      const bo = Math.pow(2, 8 * Ui - 1);
      Qi(this, Ai, Pi, Ui, bo - 1, -bo);
    }
    let eo = Ui - 1, ro = 1, oo = 0;
    for (this[Pi + eo] = Ai & 255; --eo >= 0 && (ro *= 256); )
      Ai < 0 && oo === 0 && this[Pi + eo + 1] !== 0 && (oo = 1), this[Pi + eo] = (Ai / ro >> 0) - oo & 255;
    return Pi + Ui;
  }, q.prototype.writeInt8 = function(Ai, Pi, Ui) {
    return Ai = +Ai, Pi = Pi >>> 0, Ui || Qi(this, Ai, Pi, 1, 127, -128), Ai < 0 && (Ai = 255 + Ai + 1), this[Pi] = Ai & 255, Pi + 1;
  }, q.prototype.writeInt16LE = function(Ai, Pi, Ui) {
    return Ai = +Ai, Pi = Pi >>> 0, Ui || Qi(this, Ai, Pi, 2, 32767, -32768), this[Pi] = Ai & 255, this[Pi + 1] = Ai >>> 8, Pi + 2;
  }, q.prototype.writeInt16BE = function(Ai, Pi, Ui) {
    return Ai = +Ai, Pi = Pi >>> 0, Ui || Qi(this, Ai, Pi, 2, 32767, -32768), this[Pi] = Ai >>> 8, this[Pi + 1] = Ai & 255, Pi + 2;
  }, q.prototype.writeInt32LE = function(Ai, Pi, Ui) {
    return Ai = +Ai, Pi = Pi >>> 0, Ui || Qi(this, Ai, Pi, 4, 2147483647, -2147483648), this[Pi] = Ai & 255, this[Pi + 1] = Ai >>> 8, this[Pi + 2] = Ai >>> 16, this[Pi + 3] = Ai >>> 24, Pi + 4;
  }, q.prototype.writeInt32BE = function(Ai, Pi, Ui) {
    return Ai = +Ai, Pi = Pi >>> 0, Ui || Qi(this, Ai, Pi, 4, 2147483647, -2147483648), Ai < 0 && (Ai = 4294967295 + Ai + 1), this[Pi] = Ai >>> 24, this[Pi + 1] = Ai >>> 16, this[Pi + 2] = Ai >>> 8, this[Pi + 3] = Ai & 255, Pi + 4;
  }, q.prototype.writeBigInt64LE = xo(function(Ai, Pi = 0) {
    return Zi(this, Ai, Pi, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), q.prototype.writeBigInt64BE = xo(function(Ai, Pi = 0) {
    return Ni(this, Ai, Pi, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Fi(Ai, Pi, Ui, Ji, eo, ro) {
    if (Ui + Ji > Ai.length) throw new RangeError("Index out of range");
    if (Ui < 0) throw new RangeError("Index out of range");
  }
  function Xi(Ai, Pi, Ui, Ji, eo) {
    return Pi = +Pi, Ui = Ui >>> 0, eo || Fi(Ai, Pi, Ui, 4), v.write(Ai, Pi, Ui, Ji, 23, 4), Ui + 4;
  }
  q.prototype.writeFloatLE = function(Ai, Pi, Ui) {
    return Xi(this, Ai, Pi, !0, Ui);
  }, q.prototype.writeFloatBE = function(Ai, Pi, Ui) {
    return Xi(this, Ai, Pi, !1, Ui);
  };
  function to(Ai, Pi, Ui, Ji, eo) {
    return Pi = +Pi, Ui = Ui >>> 0, eo || Fi(Ai, Pi, Ui, 8), v.write(Ai, Pi, Ui, Ji, 52, 8), Ui + 8;
  }
  q.prototype.writeDoubleLE = function(Ai, Pi, Ui) {
    return to(this, Ai, Pi, !0, Ui);
  }, q.prototype.writeDoubleBE = function(Ai, Pi, Ui) {
    return to(this, Ai, Pi, !1, Ui);
  }, q.prototype.copy = function(Ai, Pi, Ui, Ji) {
    if (!q.isBuffer(Ai)) throw new TypeError("argument should be a Buffer");
    if (Ui || (Ui = 0), !Ji && Ji !== 0 && (Ji = this.length), Pi >= Ai.length && (Pi = Ai.length), Pi || (Pi = 0), Ji > 0 && Ji < Ui && (Ji = Ui), Ji === Ui || Ai.length === 0 || this.length === 0) return 0;
    if (Pi < 0)
      throw new RangeError("targetStart out of bounds");
    if (Ui < 0 || Ui >= this.length) throw new RangeError("Index out of range");
    if (Ji < 0) throw new RangeError("sourceEnd out of bounds");
    Ji > this.length && (Ji = this.length), Ai.length - Pi < Ji - Ui && (Ji = Ai.length - Pi + Ui);
    const eo = Ji - Ui;
    return this === Ai && typeof x.prototype.copyWithin == "function" ? this.copyWithin(Pi, Ui, Ji) : x.prototype.set.call(
      Ai,
      this.subarray(Ui, Ji),
      Pi
    ), eo;
  }, q.prototype.fill = function(Ai, Pi, Ui, Ji) {
    if (typeof Ai == "string") {
      if (typeof Pi == "string" ? (Ji = Pi, Pi = 0, Ui = this.length) : typeof Ui == "string" && (Ji = Ui, Ui = this.length), Ji !== void 0 && typeof Ji != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Ji == "string" && !q.isEncoding(Ji))
        throw new TypeError("Unknown encoding: " + Ji);
      if (Ai.length === 1) {
        const ro = Ai.charCodeAt(0);
        (Ji === "utf8" && ro < 128 || Ji === "latin1") && (Ai = ro);
      }
    } else typeof Ai == "number" ? Ai = Ai & 255 : typeof Ai == "boolean" && (Ai = Number(Ai));
    if (Pi < 0 || this.length < Pi || this.length < Ui)
      throw new RangeError("Out of range index");
    if (Ui <= Pi)
      return this;
    Pi = Pi >>> 0, Ui = Ui === void 0 ? this.length : Ui >>> 0, Ai || (Ai = 0);
    let eo;
    if (typeof Ai == "number")
      for (eo = Pi; eo < Ui; ++eo)
        this[eo] = Ai;
    else {
      const ro = q.isBuffer(Ai) ? Ai : q.from(Ai, Ji), oo = ro.length;
      if (oo === 0)
        throw new TypeError('The value "' + Ai + '" is invalid for argument "value"');
      for (eo = 0; eo < Ui - Pi; ++eo)
        this[eo + Pi] = ro[eo % oo];
    }
    return this;
  };
  const zi = {};
  function Gi(Ai, Pi, Ui) {
    zi[Ai] = class extends Ui {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: Pi.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${Ai}]`, this.stack, delete this.name;
      }
      get code() {
        return Ai;
      }
      set code(Ji) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Ji,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${Ai}]: ${this.message}`;
      }
    };
  }
  Gi(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(Ai) {
      return Ai ? `${Ai} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Gi(
    "ERR_INVALID_ARG_TYPE",
    function(Ai, Pi) {
      return `The "${Ai}" argument must be of type number. Received type ${typeof Pi}`;
    },
    TypeError
  ), Gi(
    "ERR_OUT_OF_RANGE",
    function(Ai, Pi, Ui) {
      let Ji = `The value of "${Ai}" is out of range.`, eo = Ui;
      return Number.isInteger(Ui) && Math.abs(Ui) > 2 ** 32 ? eo = no(String(Ui)) : typeof Ui == "bigint" && (eo = String(Ui), (Ui > BigInt(2) ** BigInt(32) || Ui < -(BigInt(2) ** BigInt(32))) && (eo = no(eo)), eo += "n"), Ji += ` It must be ${Pi}. Received ${eo}`, Ji;
    },
    RangeError
  );
  function no(Ai) {
    let Pi = "", Ui = Ai.length;
    const Ji = Ai[0] === "-" ? 1 : 0;
    for (; Ui >= Ji + 4; Ui -= 3)
      Pi = `_${Ai.slice(Ui - 3, Ui)}${Pi}`;
    return `${Ai.slice(0, Ui)}${Pi}`;
  }
  function so(Ai, Pi, Ui) {
    uo(Pi, "offset"), (Ai[Pi] === void 0 || Ai[Pi + Ui] === void 0) && ao(Pi, Ai.length - (Ui + 1));
  }
  function ho(Ai, Pi, Ui, Ji, eo, ro) {
    if (Ai > Ui || Ai < Pi) {
      const oo = typeof Pi == "bigint" ? "n" : "";
      let bo;
      throw Pi === 0 || Pi === BigInt(0) ? bo = `>= 0${oo} and < 2${oo} ** ${(ro + 1) * 8}${oo}` : bo = `>= -(2${oo} ** ${(ro + 1) * 8 - 1}${oo}) and < 2 ** ${(ro + 1) * 8 - 1}${oo}`, new zi.ERR_OUT_OF_RANGE("value", bo, Ai);
    }
    so(Ji, eo, ro);
  }
  function uo(Ai, Pi) {
    if (typeof Ai != "number")
      throw new zi.ERR_INVALID_ARG_TYPE(Pi, "number", Ai);
  }
  function ao(Ai, Pi, Ui) {
    throw Math.floor(Ai) !== Ai ? (uo(Ai, Ui), new zi.ERR_OUT_OF_RANGE("offset", "an integer", Ai)) : Pi < 0 ? new zi.ERR_BUFFER_OUT_OF_BOUNDS() : new zi.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${Pi}`,
      Ai
    );
  }
  const Bo = /[^+/0-9A-Za-z-_]/g;
  function io(Ai) {
    if (Ai = Ai.split("=")[0], Ai = Ai.trim().replace(Bo, ""), Ai.length < 2) return "";
    for (; Ai.length % 4 !== 0; )
      Ai = Ai + "=";
    return Ai;
  }
  function po(Ai, Pi) {
    Pi = Pi || 1 / 0;
    let Ui;
    const Ji = Ai.length;
    let eo = null;
    const ro = [];
    for (let oo = 0; oo < Ji; ++oo) {
      if (Ui = Ai.charCodeAt(oo), Ui > 55295 && Ui < 57344) {
        if (!eo) {
          if (Ui > 56319) {
            (Pi -= 3) > -1 && ro.push(239, 191, 189);
            continue;
          } else if (oo + 1 === Ji) {
            (Pi -= 3) > -1 && ro.push(239, 191, 189);
            continue;
          }
          eo = Ui;
          continue;
        }
        if (Ui < 56320) {
          (Pi -= 3) > -1 && ro.push(239, 191, 189), eo = Ui;
          continue;
        }
        Ui = (eo - 55296 << 10 | Ui - 56320) + 65536;
      } else eo && (Pi -= 3) > -1 && ro.push(239, 191, 189);
      if (eo = null, Ui < 128) {
        if ((Pi -= 1) < 0) break;
        ro.push(Ui);
      } else if (Ui < 2048) {
        if ((Pi -= 2) < 0) break;
        ro.push(
          Ui >> 6 | 192,
          Ui & 63 | 128
        );
      } else if (Ui < 65536) {
        if ((Pi -= 3) < 0) break;
        ro.push(
          Ui >> 12 | 224,
          Ui >> 6 & 63 | 128,
          Ui & 63 | 128
        );
      } else if (Ui < 1114112) {
        if ((Pi -= 4) < 0) break;
        ro.push(
          Ui >> 18 | 240,
          Ui >> 12 & 63 | 128,
          Ui >> 6 & 63 | 128,
          Ui & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return ro;
  }
  function Do(Ai) {
    const Pi = [];
    for (let Ui = 0; Ui < Ai.length; ++Ui)
      Pi.push(Ai.charCodeAt(Ui) & 255);
    return Pi;
  }
  function Io(Ai, Pi) {
    let Ui, Ji, eo;
    const ro = [];
    for (let oo = 0; oo < Ai.length && !((Pi -= 2) < 0); ++oo)
      Ui = Ai.charCodeAt(oo), Ji = Ui >> 8, eo = Ui % 256, ro.push(eo), ro.push(Ji);
    return ro;
  }
  function mo(Ai) {
    return t.toByteArray(io(Ai));
  }
  function Ro(Ai, Pi, Ui, Ji) {
    let eo;
    for (eo = 0; eo < Ji && !(eo + Ui >= Pi.length || eo >= Ai.length); ++eo)
      Pi[eo + Ui] = Ai[eo];
    return eo;
  }
  function _o(Ai, Pi) {
    return Ai instanceof Pi || Ai != null && Ai.constructor != null && Ai.constructor.name != null && Ai.constructor.name === Pi.name;
  }
  function yo(Ai) {
    return Ai !== Ai;
  }
  const To = function() {
    const Ai = "0123456789abcdef", Pi = new Array(256);
    for (let Ui = 0; Ui < 16; ++Ui) {
      const Ji = Ui * 16;
      for (let eo = 0; eo < 16; ++eo)
        Pi[Ji + eo] = Ai[Ui] + Ai[eo];
    }
    return Pi;
  }();
  function xo(Ai) {
    return typeof BigInt > "u" ? wo : Ai;
  }
  function wo() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer$C = buffer$1.Buffer, Blob = buffer$1.Blob, BlobOptions = buffer$1.BlobOptions, Buffer$1$1 = buffer$1.Buffer, File = buffer$1.File, FileOptions = buffer$1.FileOptions, INSPECT_MAX_BYTES = buffer$1.INSPECT_MAX_BYTES, SlowBuffer = buffer$1.SlowBuffer, TranscodeEncoding = buffer$1.TranscodeEncoding, atob = buffer$1.atob, btoa = buffer$1.btoa, constants$1 = buffer$1.constants, isAscii = buffer$1.isAscii, isUtf8 = buffer$1.isUtf8, kMaxLength = buffer$1.kMaxLength, kStringMaxLength = buffer$1.kStringMaxLength, resolveObjectURL = buffer$1.resolveObjectURL, transcode = buffer$1.transcode, dist = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob,
  BlobOptions,
  Buffer: Buffer$1$1,
  File,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  TranscodeEncoding,
  atob,
  btoa,
  constants: constants$1,
  default: Buffer$C,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs$1(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function getAugmentedNamespace(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var v = function w() {
      return this instanceof w ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    v.prototype = t.prototype;
  } else v = {};
  return Object.defineProperty(v, "__esModule", { value: !0 }), Object.keys(e).forEach(function(w) {
    var T = Object.getOwnPropertyDescriptor(e, w);
    Object.defineProperty(v, w, T.get ? T : {
      enumerable: !0,
      get: function() {
        return e[w];
      }
    });
  }), v;
}
var cryptoBrowserify = {};
function getDefaultExportFromCjs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var browser$c = { exports: {} }, process$1 = browser$c.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(e) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(e, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(e, 0);
  try {
    return cachedSetTimeout(e, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, e, 0);
    } catch {
      return cachedSetTimeout.call(this, e, 0);
    }
  }
}
function runClearTimeout(e) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(e);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(e);
  try {
    return cachedClearTimeout(e);
  } catch {
    try {
      return cachedClearTimeout.call(null, e);
    } catch {
      return cachedClearTimeout.call(this, e);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var e = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var t = queue.length; t; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < t; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, t = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(e);
  }
}
process$1.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var v = 1; v < arguments.length; v++)
      t[v - 1] = arguments[v];
  queue.push(new Item(e, t)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(e, t) {
  this.fun = e, this.array = t;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process$1.title = "browser";
process$1.browser = !0;
process$1.env = {};
process$1.argv = [];
process$1.version = "";
process$1.versions = {};
function noop() {
}
process$1.on = noop;
process$1.addListener = noop;
process$1.once = noop;
process$1.off = noop;
process$1.removeListener = noop;
process$1.removeAllListeners = noop;
process$1.emit = noop;
process$1.prependListener = noop;
process$1.prependOnceListener = noop;
process$1.listeners = function(e) {
  return [];
};
process$1.binding = function(e) {
  throw new Error("process.binding is not supported");
};
process$1.cwd = function() {
  return "/";
};
process$1.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
process$1.umask = function() {
  return 0;
};
var browserExports$1 = browser$c.exports;
const process$1$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports$1);
var browser$b = { exports: {} }, safeBuffer$2 = { exports: {} };
const require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(dist);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
safeBuffer$2.exports;
(function(e, t) {
  var v = require$$1$2, w = v.Buffer;
  function T(C, D) {
    for (var Y in C)
      D[Y] = C[Y];
  }
  w.from && w.alloc && w.allocUnsafe && w.allocUnsafeSlow ? e.exports = v : (T(v, t), t.Buffer = x);
  function x(C, D, Y) {
    return w(C, D, Y);
  }
  x.prototype = Object.create(w.prototype), T(w, x), x.from = function(C, D, Y) {
    if (typeof C == "number")
      throw new TypeError("Argument must not be a number");
    return w(C, D, Y);
  }, x.alloc = function(C, D, Y) {
    if (typeof C != "number")
      throw new TypeError("Argument must be a number");
    var L = w(C);
    return D !== void 0 ? typeof Y == "string" ? L.fill(D, Y) : L.fill(D) : L.fill(0), L;
  }, x.allocUnsafe = function(C) {
    if (typeof C != "number")
      throw new TypeError("Argument must be a number");
    return w(C);
  }, x.allocUnsafeSlow = function(C) {
    if (typeof C != "number")
      throw new TypeError("Argument must be a number");
    return v.SlowBuffer(C);
  };
})(safeBuffer$2, safeBuffer$2.exports);
var safeBufferExports$1 = safeBuffer$2.exports;
browser$b.exports;
var MAX_BYTES = 65536, MAX_UINT32 = 4294967295;
function oldBrowser$1() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var Buffer$B = safeBufferExports$1.Buffer, crypto$1 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
crypto$1 && crypto$1.getRandomValues ? browser$b.exports = randomBytes$2 : browser$b.exports = oldBrowser$1;
function randomBytes$2(e, t) {
  if (e > MAX_UINT32) throw new RangeError("requested too many random bytes");
  var v = Buffer$B.allocUnsafe(e);
  if (e > 0)
    if (e > MAX_BYTES)
      for (var w = 0; w < e; w += MAX_BYTES)
        crypto$1.getRandomValues(v.slice(w, w + MAX_BYTES));
    else
      crypto$1.getRandomValues(v);
  return typeof t == "function" ? process$1$1.nextTick(function() {
    t(null, v);
  }) : v;
}
var browserExports = browser$b.exports, inherits_browser = { exports: {} };
inherits_browser.exports;
typeof Object.create == "function" ? inherits_browser.exports = function(e, t) {
  t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser.exports = function(e, t) {
  if (t) {
    e.super_ = t;
    var v = function() {
    };
    v.prototype = t.prototype, e.prototype = new v(), e.prototype.constructor = e;
  }
};
var inherits_browserExports = inherits_browser.exports, events = { exports: {} };
events.exports;
var R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function(e, t, v) {
  return Function.prototype.apply.call(e, t, v);
}, ReflectOwnKeys;
R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : ReflectOwnKeys = function(e) {
  return Object.getOwnPropertyNames(e);
};
function ProcessEmitWarning(e) {
  console && console.warn && console.warn(e);
}
var NumberIsNaN = Number.isNaN || function(e) {
  return e !== e;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || NumberIsNaN(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    defaultMaxListeners = e;
  }
});
EventEmitter.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || NumberIsNaN(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function _getMaxListeners(e) {
  return e._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : e._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function(e) {
  for (var t = [], v = 1; v < arguments.length; v++) t.push(arguments[v]);
  var w = e === "error", T = this._events;
  if (T !== void 0)
    w = w && T.error === void 0;
  else if (!w)
    return !1;
  if (w) {
    var x;
    if (t.length > 0 && (x = t[0]), x instanceof Error)
      throw x;
    var C = new Error("Unhandled error." + (x ? " (" + x.message + ")" : ""));
    throw C.context = x, C;
  }
  var D = T[e];
  if (D === void 0)
    return !1;
  if (typeof D == "function")
    ReflectApply(D, this, t);
  else
    for (var Y = D.length, L = arrayClone(D, Y), v = 0; v < Y; ++v)
      ReflectApply(L[v], this, t);
  return !0;
};
function _addListener(e, t, v, w) {
  var T, x, C;
  if (checkListener(v), x = e._events, x === void 0 ? (x = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (x.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    v.listener ? v.listener : v
  ), x = e._events), C = x[t]), C === void 0)
    C = x[t] = v, ++e._eventsCount;
  else if (typeof C == "function" ? C = x[t] = w ? [v, C] : [C, v] : w ? C.unshift(v) : C.push(v), T = _getMaxListeners(e), T > 0 && C.length > T && !C.warned) {
    C.warned = !0;
    var D = new Error("Possible EventEmitter memory leak detected. " + C.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    D.name = "MaxListenersExceededWarning", D.emitter = e, D.type = t, D.count = C.length, ProcessEmitWarning(D);
  }
  return e;
}
EventEmitter.prototype.addListener = function(e, t) {
  return _addListener(this, e, t, !1);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function(e, t) {
  return _addListener(this, e, t, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(e, t, v) {
  var w = { fired: !1, wrapFn: void 0, target: e, type: t, listener: v }, T = onceWrapper.bind(w);
  return T.listener = v, w.wrapFn = T, T;
}
EventEmitter.prototype.once = function(e, t) {
  return checkListener(t), this.on(e, _onceWrap(this, e, t)), this;
};
EventEmitter.prototype.prependOnceListener = function(e, t) {
  return checkListener(t), this.prependListener(e, _onceWrap(this, e, t)), this;
};
EventEmitter.prototype.removeListener = function(e, t) {
  var v, w, T, x, C;
  if (checkListener(t), w = this._events, w === void 0)
    return this;
  if (v = w[e], v === void 0)
    return this;
  if (v === t || v.listener === t)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete w[e], w.removeListener && this.emit("removeListener", e, v.listener || t));
  else if (typeof v != "function") {
    for (T = -1, x = v.length - 1; x >= 0; x--)
      if (v[x] === t || v[x].listener === t) {
        C = v[x].listener, T = x;
        break;
      }
    if (T < 0)
      return this;
    T === 0 ? v.shift() : spliceOne(v, T), v.length === 1 && (w[e] = v[0]), w.removeListener !== void 0 && this.emit("removeListener", e, C || t);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function(e) {
  var t, v, w;
  if (v = this._events, v === void 0)
    return this;
  if (v.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : v[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete v[e]), this;
  if (arguments.length === 0) {
    var T = Object.keys(v), x;
    for (w = 0; w < T.length; ++w)
      x = T[w], x !== "removeListener" && this.removeAllListeners(x);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (t = v[e], typeof t == "function")
    this.removeListener(e, t);
  else if (t !== void 0)
    for (w = t.length - 1; w >= 0; w--)
      this.removeListener(e, t[w]);
  return this;
};
function _listeners(e, t, v) {
  var w = e._events;
  if (w === void 0)
    return [];
  var T = w[t];
  return T === void 0 ? [] : typeof T == "function" ? v ? [T.listener || T] : [T] : v ? unwrapListeners(T) : arrayClone(T, T.length);
}
EventEmitter.prototype.listeners = function(e) {
  return _listeners(this, e, !0);
};
EventEmitter.prototype.rawListeners = function(e) {
  return _listeners(this, e, !1);
};
EventEmitter.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : listenerCount.call(e, t);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(e) {
  var t = this._events;
  if (t !== void 0) {
    var v = t[e];
    if (typeof v == "function")
      return 1;
    if (v !== void 0)
      return v.length;
  }
  return 0;
}
EventEmitter.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(e, t) {
  for (var v = new Array(t), w = 0; w < t; ++w)
    v[w] = e[w];
  return v;
}
function spliceOne(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function unwrapListeners(e) {
  for (var t = new Array(e.length), v = 0; v < t.length; ++v)
    t[v] = e[v].listener || e[v];
  return t;
}
function once(e, t) {
  return new Promise(function(v, w) {
    function T(C) {
      e.removeListener(t, x), w(C);
    }
    function x() {
      typeof e.removeListener == "function" && e.removeListener("error", T), v([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(e, t, x, { once: !0 }), t !== "error" && addErrorHandlerIfEventEmitter(e, T, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(e, t, v) {
  typeof e.on == "function" && eventTargetAgnosticAddListener(e, "error", t, v);
}
function eventTargetAgnosticAddListener(e, t, v, w) {
  if (typeof e.on == "function")
    w.once ? e.once(t, v) : e.on(t, v);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function T(x) {
      w.once && e.removeEventListener(t, T), v(x);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var eventsExports = events.exports, streamBrowser$1, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser$1 = eventsExports.EventEmitter), streamBrowser$1;
}
var util$3 = {}, types = {}, shams$1 = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var e = {}, t = Symbol("test"), v = Object(t);
  if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(v) !== "[object Symbol]")
    return !1;
  var w = 42;
  e[t] = w;
  for (var T in e)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
    return !1;
  var x = Object.getOwnPropertySymbols(e);
  if (x.length !== 1 || x[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var C = (
      /** @type {PropertyDescriptor} */
      Object.getOwnPropertyDescriptor(e, t)
    );
    if (C.value !== w || C.enumerable !== !0)
      return !1;
  }
  return !0;
}, hasSymbols$2 = shams$1, shams = function() {
  return hasSymbols$2() && !!Symbol.toStringTag;
}, esObjectAtoms = Object, esErrors = Error, _eval = EvalError, range = RangeError, ref = ReferenceError, syntax = SyntaxError, type = TypeError, uri = URIError, abs$1 = Math.abs, floor$1 = Math.floor, max$2 = Math.max, min$1 = Math.min, pow$1 = Math.pow, round$1 = Math.round, _isNaN = Number.isNaN || function(e) {
  return e !== e;
}, $isNaN = _isNaN, sign$2 = function(e) {
  return $isNaN(e) || e === 0 ? e : e < 0 ? -1 : 1;
}, gOPD$4 = Object.getOwnPropertyDescriptor, $gOPD$1 = gOPD$4;
if ($gOPD$1)
  try {
    $gOPD$1([], "length");
  } catch {
    $gOPD$1 = null;
  }
var gopd$1 = $gOPD$1, $defineProperty$3 = Object.defineProperty || !1;
if ($defineProperty$3)
  try {
    $defineProperty$3({}, "a", { value: 1 });
  } catch {
    $defineProperty$3 = !1;
  }
var esDefineProperty = $defineProperty$3, hasSymbols$1, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols$1;
  hasRequiredHasSymbols = 1;
  var e = typeof Symbol < "u" && Symbol, t = shams$1;
  return hasSymbols$1 = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, hasSymbols$1;
}
var Reflect_getPrototypeOf = typeof Reflect < "u" && Reflect.getPrototypeOf || null, $Object$2 = esObjectAtoms, Object_getPrototypeOf = $Object$2.getPrototypeOf || null, ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$3 = Object.prototype.toString, max$1 = Math.max, funcType = "[object Function]", concatty = function(e, t) {
  for (var v = [], w = 0; w < e.length; w += 1)
    v[w] = e[w];
  for (var T = 0; T < t.length; T += 1)
    v[T + e.length] = t[T];
  return v;
}, slicy = function(e, t) {
  for (var v = [], w = t || 0, T = 0; w < e.length; w += 1, T += 1)
    v[T] = e[w];
  return v;
}, joiny = function(e, t) {
  for (var v = "", w = 0; w < e.length; w += 1)
    v += e[w], w + 1 < e.length && (v += t);
  return v;
}, implementation$1 = function(e) {
  var t = this;
  if (typeof t != "function" || toStr$3.apply(t) !== funcType)
    throw new TypeError(ERROR_MESSAGE + t);
  for (var v = slicy(arguments, 1), w, T = function() {
    if (this instanceof w) {
      var L = t.apply(
        this,
        concatty(v, arguments)
      );
      return Object(L) === L ? L : this;
    }
    return t.apply(
      e,
      concatty(v, arguments)
    );
  }, x = max$1(0, t.length - v.length), C = [], D = 0; D < x; D++)
    C[D] = "$" + D;
  if (w = Function("binder", "return function (" + joiny(C, ",") + "){ return binder.apply(this,arguments); }")(T), t.prototype) {
    var Y = function() {
    };
    Y.prototype = t.prototype, w.prototype = new Y(), Y.prototype = null;
  }
  return w;
}, implementation = implementation$1, functionBind = Function.prototype.bind || implementation, functionCall = Function.prototype.call, functionApply = Function.prototype.apply, reflectApply$1 = typeof Reflect < "u" && Reflect && Reflect.apply, bind$4 = functionBind, $apply$2 = functionApply, $call$2 = functionCall, $reflectApply = reflectApply$1, actualApply$1 = $reflectApply || bind$4.call($call$2, $apply$2), bind$3 = functionBind, $TypeError$4 = type, $call$1 = functionCall, $actualApply = actualApply$1, callBindApplyHelpers = function(e) {
  if (e.length < 1 || typeof e[0] != "function")
    throw new $TypeError$4("a function is required");
  return $actualApply(bind$3, $call$1, e);
}, callBind$2 = callBindApplyHelpers, gOPD$3 = gopd$1, hasProtoAccessor;
try {
  hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
  [].__proto__ === Array.prototype;
} catch (e) {
  if (!e || typeof e != "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS")
    throw e;
}
var desc = !!hasProtoAccessor && gOPD$3 && gOPD$3(
  Object.prototype,
  /** @type {keyof typeof Object.prototype} */
  "__proto__"
), $Object$1 = Object, $getPrototypeOf = $Object$1.getPrototypeOf, get = desc && typeof desc.get == "function" ? callBind$2([desc.get]) : typeof $getPrototypeOf == "function" ? (
  /** @type {import('./get')} */
  function(e) {
    return $getPrototypeOf(e == null ? e : $Object$1(e));
  }
) : !1, reflectGetProto = Reflect_getPrototypeOf, originalGetProto = Object_getPrototypeOf, getDunderProto = get, getProto$3 = reflectGetProto ? function(e) {
  return reflectGetProto(e);
} : originalGetProto ? function(e) {
  if (!e || typeof e != "object" && typeof e != "function")
    throw new TypeError("getProto: not an object");
  return originalGetProto(e);
} : getDunderProto ? function(e) {
  return getDunderProto(e);
} : null, call = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind$2 = functionBind, hasown = bind$2.call(call, $hasOwn), undefined$1, $Object = esObjectAtoms, $Error = esErrors, $EvalError = _eval, $RangeError = range, $ReferenceError = ref, $SyntaxError$1 = syntax, $TypeError$3 = type, $URIError = uri, abs = abs$1, floor = floor$1, max = max$2, min = min$1, pow = pow$1, round = round$1, sign$1 = sign$2, $Function = Function, getEvalledConstructor = function(e) {
  try {
    return $Function('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, $gOPD = gopd$1, $defineProperty$2 = esDefineProperty, throwTypeError = function() {
  throw new $TypeError$3();
}, ThrowTypeError = $gOPD ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols = requireHasSymbols()(), getProto$2 = getProto$3, $ObjectGPO = Object_getPrototypeOf, $ReflectGPO = Reflect_getPrototypeOf, $apply$1 = functionApply, $call = functionCall, needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto$2 ? undefined$1 : getProto$2(Uint8Array), INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto$2 ? getProto$2([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float16Array%": typeof Float16Array > "u" ? undefined$1 : Float16Array,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto$2 ? getProto$2(getProto$2([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto$2 ? undefined$1 : getProto$2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": $Object,
  "%Object.getOwnPropertyDescriptor%": $gOPD,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto$2 ? undefined$1 : getProto$2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto$2 ? getProto$2(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$3,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet,
  "%Function.prototype.call%": $call,
  "%Function.prototype.apply%": $apply$1,
  "%Object.defineProperty%": $defineProperty$2,
  "%Object.getPrototypeOf%": $ObjectGPO,
  "%Math.abs%": abs,
  "%Math.floor%": floor,
  "%Math.max%": max,
  "%Math.min%": min,
  "%Math.pow%": pow,
  "%Math.round%": round,
  "%Math.sign%": sign$1,
  "%Reflect.getPrototypeOf%": $ReflectGPO
};
if (getProto$2)
  try {
    null.error;
  } catch (e) {
    var errorProto = getProto$2(getProto$2(e));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function e(t) {
  var v;
  if (t === "%AsyncFunction%")
    v = getEvalledConstructor("async function () {}");
  else if (t === "%GeneratorFunction%")
    v = getEvalledConstructor("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    v = getEvalledConstructor("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var w = e("%AsyncGeneratorFunction%");
    w && (v = w.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var T = e("%AsyncGenerator%");
    T && getProto$2 && (v = getProto$2(T.prototype));
  }
  return INTRINSICS[t] = v, v;
}, LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind$1 = functionBind, hasOwn$1 = hasown, $concat = bind$1.call($call, Array.prototype.concat), $spliceApply = bind$1.call($apply$1, Array.prototype.splice), $replace = bind$1.call($call, String.prototype.replace), $strSlice = bind$1.call($call, String.prototype.slice), $exec$2 = bind$1.call($call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function(e) {
  var t = $strSlice(e, 0, 1), v = $strSlice(e, -1);
  if (t === "%" && v !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if (v === "%" && t !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var w = [];
  return $replace(e, rePropName, function(T, x, C, D) {
    w[w.length] = C ? $replace(D, reEscapeChar, "$1") : x || T;
  }), w;
}, getBaseIntrinsic = function(e, t) {
  var v = e, w;
  if (hasOwn$1(LEGACY_ALIASES, v) && (w = LEGACY_ALIASES[v], v = "%" + w[0] + "%"), hasOwn$1(INTRINSICS, v)) {
    var T = INTRINSICS[v];
    if (T === needsEval && (T = doEval(v)), typeof T > "u" && !t)
      throw new $TypeError$3("intrinsic " + e + " exists, but is not available. Please file an issue!");
    return {
      alias: w,
      name: v,
      value: T
    };
  }
  throw new $SyntaxError$1("intrinsic " + e + " does not exist!");
}, getIntrinsic = function(e, t) {
  if (typeof e != "string" || e.length === 0)
    throw new $TypeError$3("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof t != "boolean")
    throw new $TypeError$3('"allowMissing" argument must be a boolean');
  if ($exec$2(/^%?[^%]*%?$/, e) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var v = stringToPath(e), w = v.length > 0 ? v[0] : "", T = getBaseIntrinsic("%" + w + "%", t), x = T.name, C = T.value, D = !1, Y = T.alias;
  Y && (w = Y[0], $spliceApply(v, $concat([0, 1], Y)));
  for (var L = 1, q = !0; L < v.length; L += 1) {
    var N = v[L], F = $strSlice(N, 0, 1), ae = $strSlice(N, -1);
    if ((F === '"' || F === "'" || F === "`" || ae === '"' || ae === "'" || ae === "`") && F !== ae)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((N === "constructor" || !q) && (D = !0), w += "." + N, x = "%" + w + "%", hasOwn$1(INTRINSICS, x))
      C = INTRINSICS[x];
    else if (C != null) {
      if (!(N in C)) {
        if (!t)
          throw new $TypeError$3("base intrinsic for " + e + " exists, but the property is not available.");
        return;
      }
      if ($gOPD && L + 1 >= v.length) {
        var he = $gOPD(C, N);
        q = !!he, q && "get" in he && !("originalValue" in he.get) ? C = he.get : C = C[N];
      } else
        q = hasOwn$1(C, N), C = C[N];
      q && !D && (INTRINSICS[x] = C);
    }
  }
  return C;
}, GetIntrinsic$1 = getIntrinsic, callBindBasic = callBindApplyHelpers, $indexOf$1 = callBindBasic([GetIntrinsic$1("%String.prototype.indexOf%")]), callBound$5 = function(e, t) {
  var v = (
    /** @type {(this: unknown, ...args: unknown[]) => unknown} */
    GetIntrinsic$1(e, !!t)
  );
  return typeof v == "function" && $indexOf$1(e, ".prototype.") > -1 ? callBindBasic(
    /** @type {const} */
    [v]
  ) : v;
}, hasToStringTag$4 = shams(), callBound$4 = callBound$5, $toString$2 = callBound$4("Object.prototype.toString"), isStandardArguments = function(e) {
  return hasToStringTag$4 && e && typeof e == "object" && Symbol.toStringTag in e ? !1 : $toString$2(e) === "[object Arguments]";
}, isLegacyArguments = function(e) {
  return isStandardArguments(e) ? !0 : e !== null && typeof e == "object" && "length" in e && typeof e.length == "number" && e.length >= 0 && $toString$2(e) !== "[object Array]" && "callee" in e && $toString$2(e.callee) === "[object Function]";
}, supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments, callBound$3 = callBound$5, hasToStringTag$3 = shams(), hasOwn = hasown, gOPD$2 = gopd$1, fn;
if (hasToStringTag$3) {
  var $exec$1 = callBound$3("RegExp.prototype.exec"), isRegexMarker = {}, throwRegexMarker = function() {
    throw isRegexMarker;
  }, badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };
  typeof Symbol.toPrimitive == "symbol" && (badStringifier[Symbol.toPrimitive] = throwRegexMarker), fn = function(e) {
    if (!e || typeof e != "object")
      return !1;
    var t = (
      /** @type {NonNullable<typeof gOPD>} */
      gOPD$2(
        /** @type {{ lastIndex?: unknown }} */
        e,
        "lastIndex"
      )
    ), v = t && hasOwn(t, "value");
    if (!v)
      return !1;
    try {
      $exec$1(
        e,
        /** @type {string} */
        /** @type {unknown} */
        badStringifier
      );
    } catch (w) {
      return w === isRegexMarker;
    }
  };
} else {
  var $toString$1 = callBound$3("Object.prototype.toString"), regexClass = "[object RegExp]";
  fn = function(e) {
    return !e || typeof e != "object" && typeof e != "function" ? !1 : $toString$1(e) === regexClass;
  };
}
var isRegex$1 = fn, callBound$2 = callBound$5, isRegex = isRegex$1, $exec = callBound$2("RegExp.prototype.exec"), $TypeError$2 = type, safeRegexTest$1 = function(e) {
  if (!isRegex(e))
    throw new $TypeError$2("`regex` must be a RegExp");
  return function(t) {
    return $exec(e, t) !== null;
  };
}, callBound$1 = callBound$5, safeRegexTest = safeRegexTest$1, isFnRegex = safeRegexTest(/^\s*(?:function)?\*/), hasToStringTag$2 = shams(), getProto$1 = getProto$3, toStr$2 = callBound$1("Object.prototype.toString"), fnToStr$1 = callBound$1("Function.prototype.toString"), getGeneratorFunc = function() {
  if (!hasToStringTag$2)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, GeneratorFunction, isGeneratorFunction = function(e) {
  if (typeof e != "function")
    return !1;
  if (isFnRegex(fnToStr$1(e)))
    return !0;
  if (!hasToStringTag$2) {
    var t = toStr$2(e);
    return t === "[object GeneratorFunction]";
  }
  if (!getProto$1)
    return !1;
  if (typeof GeneratorFunction > "u") {
    var v = getGeneratorFunc();
    GeneratorFunction = v ? (
      /** @type {GeneratorFunctionConstructor} */
      getProto$1(v)
    ) : !1;
  }
  return getProto$1(e) === GeneratorFunction;
}, fnToStr = Function.prototype.toString, reflectApply = typeof Reflect == "object" && Reflect !== null && Reflect.apply, badArrayLike, isCallableMarker;
if (typeof reflectApply == "function" && typeof Object.defineProperty == "function")
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    }), isCallableMarker = {}, reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (e) {
    e !== isCallableMarker && (reflectApply = null);
  }
else
  reflectApply = null;
var constructorRegex = /^\s*class\b/, isES6ClassFn = function(e) {
  try {
    var t = fnToStr.call(e);
    return constructorRegex.test(t);
  } catch {
    return !1;
  }
}, tryFunctionObject = function(e) {
  try {
    return isES6ClassFn(e) ? !1 : (fnToStr.call(e), !0);
  } catch {
    return !1;
  }
}, toStr$1 = Object.prototype.toString, objectClass = "[object Object]", fnClass = "[object Function]", genClass = "[object GeneratorFunction]", ddaClass = "[object HTMLAllCollection]", ddaClass2 = "[object HTML document.all class]", ddaClass3 = "[object HTMLCollection]", hasToStringTag$1 = typeof Symbol == "function" && !!Symbol.toStringTag, isIE68 = !(0 in [,]), isDDA = function() {
  return !1;
};
if (typeof document == "object") {
  var all = document.all;
  toStr$1.call(all) === toStr$1.call(document.all) && (isDDA = function(e) {
    if ((isIE68 || !e) && (typeof e > "u" || typeof e == "object"))
      try {
        var t = toStr$1.call(e);
        return (t === ddaClass || t === ddaClass2 || t === ddaClass3 || t === objectClass) && e("") == null;
      } catch {
      }
    return !1;
  });
}
var isCallable$1 = reflectApply ? function(e) {
  if (isDDA(e))
    return !0;
  if (!e || typeof e != "function" && typeof e != "object")
    return !1;
  try {
    reflectApply(e, null, badArrayLike);
  } catch (t) {
    if (t !== isCallableMarker)
      return !1;
  }
  return !isES6ClassFn(e) && tryFunctionObject(e);
} : function(e) {
  if (isDDA(e))
    return !0;
  if (!e || typeof e != "function" && typeof e != "object")
    return !1;
  if (hasToStringTag$1)
    return tryFunctionObject(e);
  if (isES6ClassFn(e))
    return !1;
  var t = toStr$1.call(e);
  return t !== fnClass && t !== genClass && !/^\[object HTML/.test(t) ? !1 : tryFunctionObject(e);
}, isCallable = isCallable$1, toStr = Object.prototype.toString, hasOwnProperty = Object.prototype.hasOwnProperty, forEachArray = function(e, t, v) {
  for (var w = 0, T = e.length; w < T; w++)
    hasOwnProperty.call(e, w) && (v == null ? t(e[w], w, e) : t.call(v, e[w], w, e));
}, forEachString = function(e, t, v) {
  for (var w = 0, T = e.length; w < T; w++)
    v == null ? t(e.charAt(w), w, e) : t.call(v, e.charAt(w), w, e);
}, forEachObject = function(e, t, v) {
  for (var w in e)
    hasOwnProperty.call(e, w) && (v == null ? t(e[w], w, e) : t.call(v, e[w], w, e));
};
function isArray$1(e) {
  return toStr.call(e) === "[object Array]";
}
var forEach$1 = function(e, t, v) {
  if (!isCallable(t))
    throw new TypeError("iterator must be a function");
  var w;
  arguments.length >= 3 && (w = v), isArray$1(e) ? forEachArray(e, t, w) : typeof e == "string" ? forEachString(e, t, w) : forEachObject(e, t, w);
}, possibleTypedArrayNames = [
  "Float16Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
], possibleNames = possibleTypedArrayNames, g$1 = typeof globalThis > "u" ? commonjsGlobal : globalThis, availableTypedArrays$1 = function() {
  for (var e = [], t = 0; t < possibleNames.length; t++)
    typeof g$1[possibleNames[t]] == "function" && (e[e.length] = possibleNames[t]);
  return e;
}, callBind$1 = { exports: {} }, $defineProperty$1 = esDefineProperty, $SyntaxError = syntax, $TypeError$1 = type, gopd = gopd$1, defineDataProperty = function(e, t, v) {
  if (!e || typeof e != "object" && typeof e != "function")
    throw new $TypeError$1("`obj` must be an object or a function`");
  if (typeof t != "string" && typeof t != "symbol")
    throw new $TypeError$1("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$1("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$1("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$1("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$1("`loose`, if provided, must be a boolean");
  var w = arguments.length > 3 ? arguments[3] : null, T = arguments.length > 4 ? arguments[4] : null, x = arguments.length > 5 ? arguments[5] : null, C = arguments.length > 6 ? arguments[6] : !1, D = !!gopd && gopd(e, t);
  if ($defineProperty$1)
    $defineProperty$1(e, t, {
      configurable: x === null && D ? D.configurable : !x,
      enumerable: w === null && D ? D.enumerable : !w,
      value: v,
      writable: T === null && D ? D.writable : !T
    });
  else if (C || !w && !T && !x)
    e[t] = v;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, $defineProperty = esDefineProperty, hasPropertyDescriptors = function() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function() {
  if (!$defineProperty)
    return null;
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors, GetIntrinsic = getIntrinsic, define = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD$1 = gopd$1, $TypeError = type, $floor = GetIntrinsic("%Math.floor%"), setFunctionLength = function(e, t) {
  if (typeof e != "function")
    throw new $TypeError("`fn` is not a function");
  if (typeof t != "number" || t < 0 || t > 4294967295 || $floor(t) !== t)
    throw new $TypeError("`length` must be a positive 32-bit integer");
  var v = arguments.length > 2 && !!arguments[2], w = !0, T = !0;
  if ("length" in e && gOPD$1) {
    var x = gOPD$1(e, "length");
    x && !x.configurable && (w = !1), x && !x.writable && (T = !1);
  }
  return (w || T || !v) && (hasDescriptors ? define(
    /** @type {Parameters<define>[0]} */
    e,
    "length",
    t,
    !0,
    !0
  ) : define(
    /** @type {Parameters<define>[0]} */
    e,
    "length",
    t
  )), e;
}, bind = functionBind, $apply = functionApply, actualApply = actualApply$1, applyBind = function() {
  return actualApply(bind, $apply, arguments);
};
callBind$1.exports;
(function(e) {
  var t = setFunctionLength, v = esDefineProperty, w = callBindApplyHelpers, T = applyBind;
  e.exports = function(x) {
    var C = w(arguments), D = x.length - (arguments.length - 1);
    return t(
      C,
      1 + (D > 0 ? D : 0),
      !0
    );
  }, v ? v(e.exports, "apply", { value: T }) : e.exports.apply = T;
})(callBind$1);
var callBindExports = callBind$1.exports, forEach = forEach$1, availableTypedArrays = availableTypedArrays$1, callBind = callBindExports, callBound = callBound$5, gOPD = gopd$1, getProto = getProto$3, $toString = callBound("Object.prototype.toString"), hasToStringTag = shams(), g = typeof globalThis > "u" ? commonjsGlobal : globalThis, typedArrays = availableTypedArrays(), $slice = callBound("String.prototype.slice"), $indexOf = callBound("Array.prototype.indexOf", !0) || function(e, t) {
  for (var v = 0; v < e.length; v += 1)
    if (e[v] === t)
      return v;
  return -1;
}, cache = { __proto__: null };
hasToStringTag && gOPD && getProto ? forEach(typedArrays, function(e) {
  var t = new g[e]();
  if (Symbol.toStringTag in t && getProto) {
    var v = getProto(t), w = gOPD(v, Symbol.toStringTag);
    if (!w && v) {
      var T = getProto(v);
      w = gOPD(T, Symbol.toStringTag);
    }
    cache["$" + e] = callBind(w.get);
  }
}) : forEach(typedArrays, function(e) {
  var t = new g[e](), v = t.slice || t.set;
  v && (cache[
    /** @type {`$${import('.').TypedArrayName}`} */
    "$" + e
  ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
  // @ts-expect-error TODO FIXME
  callBind(v));
});
var tryTypedArrays = function(e) {
  var t = !1;
  return forEach(
    /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
    cache,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(v, w) {
      if (!t)
        try {
          "$" + v(e) === w && (t = /** @type {import('.').TypedArrayName} */
          $slice(w, 1));
        } catch {
        }
    }
  ), t;
}, trySlices = function(e) {
  var t = !1;
  return forEach(
    /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
    cache,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(v, w) {
      if (!t)
        try {
          v(e), t = /** @type {import('.').TypedArrayName} */
          $slice(w, 1);
        } catch {
        }
    }
  ), t;
}, whichTypedArray$1 = function(e) {
  if (!e || typeof e != "object")
    return !1;
  if (!hasToStringTag) {
    var t = $slice($toString(e), 8, -1);
    return $indexOf(typedArrays, t) > -1 ? t : t !== "Object" ? !1 : trySlices(e);
  }
  return gOPD ? tryTypedArrays(e) : null;
}, whichTypedArray = whichTypedArray$1, isTypedArray = function(e) {
  return !!whichTypedArray(e);
};
(function(e) {
  var t = isArguments, v = isGeneratorFunction, w = whichTypedArray$1, T = isTypedArray;
  function x(io) {
    return io.call.bind(io);
  }
  var C = typeof BigInt < "u", D = typeof Symbol < "u", Y = x(Object.prototype.toString), L = x(Number.prototype.valueOf), q = x(String.prototype.valueOf), N = x(Boolean.prototype.valueOf);
  if (C)
    var F = x(BigInt.prototype.valueOf);
  if (D)
    var ae = x(Symbol.prototype.valueOf);
  function he(io, po) {
    if (typeof io != "object")
      return !1;
    try {
      return po(io), !0;
    } catch {
      return !1;
    }
  }
  e.isArgumentsObject = t, e.isGeneratorFunction = v, e.isTypedArray = T;
  function tt(io) {
    return typeof Promise < "u" && io instanceof Promise || io !== null && typeof io == "object" && typeof io.then == "function" && typeof io.catch == "function";
  }
  e.isPromise = tt;
  function br(io) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(io) : T(io) || Ki(io);
  }
  e.isArrayBufferView = br;
  function rt(io) {
    return w(io) === "Uint8Array";
  }
  e.isUint8Array = rt;
  function dr(io) {
    return w(io) === "Uint8ClampedArray";
  }
  e.isUint8ClampedArray = dr;
  function _r(io) {
    return w(io) === "Uint16Array";
  }
  e.isUint16Array = _r;
  function Bi(io) {
    return w(io) === "Uint32Array";
  }
  e.isUint32Array = Bi;
  function qi(io) {
    return w(io) === "Int8Array";
  }
  e.isInt8Array = qi;
  function Wi(io) {
    return w(io) === "Int16Array";
  }
  e.isInt16Array = Wi;
  function Vi(io) {
    return w(io) === "Int32Array";
  }
  e.isInt32Array = Vi;
  function Ti(io) {
    return w(io) === "Float32Array";
  }
  e.isFloat32Array = Ti;
  function Li(io) {
    return w(io) === "Float64Array";
  }
  e.isFloat64Array = Li;
  function Hi(io) {
    return w(io) === "BigInt64Array";
  }
  e.isBigInt64Array = Hi;
  function pr(io) {
    return w(io) === "BigUint64Array";
  }
  e.isBigUint64Array = pr;
  function Di(io) {
    return Y(io) === "[object Map]";
  }
  Di.working = typeof Map < "u" && Di(/* @__PURE__ */ new Map());
  function z(io) {
    return typeof Map > "u" ? !1 : Di.working ? Di(io) : io instanceof Map;
  }
  e.isMap = z;
  function gr(io) {
    return Y(io) === "[object Set]";
  }
  gr.working = typeof Set < "u" && gr(/* @__PURE__ */ new Set());
  function vr(io) {
    return typeof Set > "u" ? !1 : gr.working ? gr(io) : io instanceof Set;
  }
  e.isSet = vr;
  function Oi(io) {
    return Y(io) === "[object WeakMap]";
  }
  Oi.working = typeof WeakMap < "u" && Oi(/* @__PURE__ */ new WeakMap());
  function Mi(io) {
    return typeof WeakMap > "u" ? !1 : Oi.working ? Oi(io) : io instanceof WeakMap;
  }
  e.isWeakMap = Mi;
  function ki(io) {
    return Y(io) === "[object WeakSet]";
  }
  ki.working = typeof WeakSet < "u" && ki(/* @__PURE__ */ new WeakSet());
  function yr(io) {
    return ki(io);
  }
  e.isWeakSet = yr;
  function xi(io) {
    return Y(io) === "[object ArrayBuffer]";
  }
  xi.working = typeof ArrayBuffer < "u" && xi(new ArrayBuffer());
  function Si(io) {
    return typeof ArrayBuffer > "u" ? !1 : xi.working ? xi(io) : io instanceof ArrayBuffer;
  }
  e.isArrayBuffer = Si;
  function Ci(io) {
    return Y(io) === "[object DataView]";
  }
  Ci.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && Ci(new DataView(new ArrayBuffer(1), 0, 1));
  function Ki(io) {
    return typeof DataView > "u" ? !1 : Ci.working ? Ci(io) : io instanceof DataView;
  }
  e.isDataView = Ki;
  var Yi = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function Qi(io) {
    return Y(io) === "[object SharedArrayBuffer]";
  }
  function Zi(io) {
    return typeof Yi > "u" ? !1 : (typeof Qi.working > "u" && (Qi.working = Qi(new Yi())), Qi.working ? Qi(io) : io instanceof Yi);
  }
  e.isSharedArrayBuffer = Zi;
  function Ni(io) {
    return Y(io) === "[object AsyncFunction]";
  }
  e.isAsyncFunction = Ni;
  function Fi(io) {
    return Y(io) === "[object Map Iterator]";
  }
  e.isMapIterator = Fi;
  function Xi(io) {
    return Y(io) === "[object Set Iterator]";
  }
  e.isSetIterator = Xi;
  function to(io) {
    return Y(io) === "[object Generator]";
  }
  e.isGeneratorObject = to;
  function zi(io) {
    return Y(io) === "[object WebAssembly.Module]";
  }
  e.isWebAssemblyCompiledModule = zi;
  function Gi(io) {
    return he(io, L);
  }
  e.isNumberObject = Gi;
  function no(io) {
    return he(io, q);
  }
  e.isStringObject = no;
  function so(io) {
    return he(io, N);
  }
  e.isBooleanObject = so;
  function ho(io) {
    return C && he(io, F);
  }
  e.isBigIntObject = ho;
  function uo(io) {
    return D && he(io, ae);
  }
  e.isSymbolObject = uo;
  function ao(io) {
    return Gi(io) || no(io) || so(io) || ho(io) || uo(io);
  }
  e.isBoxedPrimitive = ao;
  function Bo(io) {
    return typeof Uint8Array < "u" && (Si(io) || Zi(io));
  }
  e.isAnyArrayBuffer = Bo, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(io) {
    Object.defineProperty(e, io, {
      enumerable: !1,
      value: function() {
        throw new Error(io + " is not supported in userland");
      }
    });
  });
})(types);
var isBufferBrowser = function(e) {
  return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
};
(function(e) {
  var t = Object.getOwnPropertyDescriptors || function(Ci) {
    for (var Ki = Object.keys(Ci), Yi = {}, Qi = 0; Qi < Ki.length; Qi++)
      Yi[Ki[Qi]] = Object.getOwnPropertyDescriptor(Ci, Ki[Qi]);
    return Yi;
  }, v = /%[sdj%]/g;
  e.format = function(Ci) {
    if (!qi(Ci)) {
      for (var Ki = [], Yi = 0; Yi < arguments.length; Yi++)
        Ki.push(C(arguments[Yi]));
      return Ki.join(" ");
    }
    for (var Yi = 1, Qi = arguments, Zi = Qi.length, Ni = String(Ci).replace(v, function(to) {
      if (to === "%%") return "%";
      if (Yi >= Zi) return to;
      switch (to) {
        case "%s":
          return String(Qi[Yi++]);
        case "%d":
          return Number(Qi[Yi++]);
        case "%j":
          try {
            return JSON.stringify(Qi[Yi++]);
          } catch {
            return "[Circular]";
          }
        default:
          return to;
      }
    }), Fi = Qi[Yi]; Yi < Zi; Fi = Qi[++Yi])
      dr(Fi) || !Li(Fi) ? Ni += " " + Fi : Ni += " " + C(Fi);
    return Ni;
  }, e.deprecate = function(Ci, Ki) {
    if (typeof process$1$1 < "u" && process$1$1.noDeprecation === !0)
      return Ci;
    if (typeof process$1$1 > "u")
      return function() {
        return e.deprecate(Ci, Ki).apply(this, arguments);
      };
    var Yi = !1;
    function Qi() {
      if (!Yi) {
        if (process$1$1.throwDeprecation)
          throw new Error(Ki);
        process$1$1.traceDeprecation ? console.trace(Ki) : console.error(Ki), Yi = !0;
      }
      return Ci.apply(this, arguments);
    }
    return Qi;
  };
  var w = {}, T = /^$/;
  if (process$1$1.env.NODE_DEBUG) {
    var x = process$1$1.env.NODE_DEBUG;
    x = x.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), T = new RegExp("^" + x + "$", "i");
  }
  e.debuglog = function(Ci) {
    if (Ci = Ci.toUpperCase(), !w[Ci])
      if (T.test(Ci)) {
        var Ki = process$1$1.pid;
        w[Ci] = function() {
          var Yi = e.format.apply(e, arguments);
          console.error("%s %d: %s", Ci, Ki, Yi);
        };
      } else
        w[Ci] = function() {
        };
    return w[Ci];
  };
  function C(Ci, Ki) {
    var Yi = {
      seen: [],
      stylize: Y
    };
    return arguments.length >= 3 && (Yi.depth = arguments[2]), arguments.length >= 4 && (Yi.colors = arguments[3]), rt(Ki) ? Yi.showHidden = Ki : Ki && e._extend(Yi, Ki), Vi(Yi.showHidden) && (Yi.showHidden = !1), Vi(Yi.depth) && (Yi.depth = 2), Vi(Yi.colors) && (Yi.colors = !1), Vi(Yi.customInspect) && (Yi.customInspect = !0), Yi.colors && (Yi.stylize = D), q(Yi, Ci, Yi.depth);
  }
  e.inspect = C, C.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, C.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function D(Ci, Ki) {
    var Yi = C.styles[Ki];
    return Yi ? "\x1B[" + C.colors[Yi][0] + "m" + Ci + "\x1B[" + C.colors[Yi][1] + "m" : Ci;
  }
  function Y(Ci, Ki) {
    return Ci;
  }
  function L(Ci) {
    var Ki = {};
    return Ci.forEach(function(Yi, Qi) {
      Ki[Yi] = !0;
    }), Ki;
  }
  function q(Ci, Ki, Yi) {
    if (Ci.customInspect && Ki && Di(Ki.inspect) && // Filter out the util module, it's inspect function is special
    Ki.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
    !(Ki.constructor && Ki.constructor.prototype === Ki)) {
      var Qi = Ki.inspect(Yi, Ci);
      return qi(Qi) || (Qi = q(Ci, Qi, Yi)), Qi;
    }
    var Zi = N(Ci, Ki);
    if (Zi)
      return Zi;
    var Ni = Object.keys(Ki), Fi = L(Ni);
    if (Ci.showHidden && (Ni = Object.getOwnPropertyNames(Ki)), pr(Ki) && (Ni.indexOf("message") >= 0 || Ni.indexOf("description") >= 0))
      return F(Ki);
    if (Ni.length === 0) {
      if (Di(Ki)) {
        var Xi = Ki.name ? ": " + Ki.name : "";
        return Ci.stylize("[Function" + Xi + "]", "special");
      }
      if (Ti(Ki))
        return Ci.stylize(RegExp.prototype.toString.call(Ki), "regexp");
      if (Hi(Ki))
        return Ci.stylize(Date.prototype.toString.call(Ki), "date");
      if (pr(Ki))
        return F(Ki);
    }
    var to = "", zi = !1, Gi = ["{", "}"];
    if (br(Ki) && (zi = !0, Gi = ["[", "]"]), Di(Ki)) {
      var no = Ki.name ? ": " + Ki.name : "";
      to = " [Function" + no + "]";
    }
    if (Ti(Ki) && (to = " " + RegExp.prototype.toString.call(Ki)), Hi(Ki) && (to = " " + Date.prototype.toUTCString.call(Ki)), pr(Ki) && (to = " " + F(Ki)), Ni.length === 0 && (!zi || Ki.length == 0))
      return Gi[0] + to + Gi[1];
    if (Yi < 0)
      return Ti(Ki) ? Ci.stylize(RegExp.prototype.toString.call(Ki), "regexp") : Ci.stylize("[Object]", "special");
    Ci.seen.push(Ki);
    var so;
    return zi ? so = ae(Ci, Ki, Yi, Fi, Ni) : so = Ni.map(function(ho) {
      return he(Ci, Ki, Yi, Fi, ho, zi);
    }), Ci.seen.pop(), tt(so, to, Gi);
  }
  function N(Ci, Ki) {
    if (Vi(Ki))
      return Ci.stylize("undefined", "undefined");
    if (qi(Ki)) {
      var Yi = "'" + JSON.stringify(Ki).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return Ci.stylize(Yi, "string");
    }
    if (Bi(Ki))
      return Ci.stylize("" + Ki, "number");
    if (rt(Ki))
      return Ci.stylize("" + Ki, "boolean");
    if (dr(Ki))
      return Ci.stylize("null", "null");
  }
  function F(Ci) {
    return "[" + Error.prototype.toString.call(Ci) + "]";
  }
  function ae(Ci, Ki, Yi, Qi, Zi) {
    for (var Ni = [], Fi = 0, Xi = Ki.length; Fi < Xi; ++Fi)
      ki(Ki, String(Fi)) ? Ni.push(he(
        Ci,
        Ki,
        Yi,
        Qi,
        String(Fi),
        !0
      )) : Ni.push("");
    return Zi.forEach(function(to) {
      to.match(/^\d+$/) || Ni.push(he(
        Ci,
        Ki,
        Yi,
        Qi,
        to,
        !0
      ));
    }), Ni;
  }
  function he(Ci, Ki, Yi, Qi, Zi, Ni) {
    var Fi, Xi, to;
    if (to = Object.getOwnPropertyDescriptor(Ki, Zi) || { value: Ki[Zi] }, to.get ? to.set ? Xi = Ci.stylize("[Getter/Setter]", "special") : Xi = Ci.stylize("[Getter]", "special") : to.set && (Xi = Ci.stylize("[Setter]", "special")), ki(Qi, Zi) || (Fi = "[" + Zi + "]"), Xi || (Ci.seen.indexOf(to.value) < 0 ? (dr(Yi) ? Xi = q(Ci, to.value, null) : Xi = q(Ci, to.value, Yi - 1), Xi.indexOf(`
`) > -1 && (Ni ? Xi = Xi.split(`
`).map(function(zi) {
      return "  " + zi;
    }).join(`
`).slice(2) : Xi = `
` + Xi.split(`
`).map(function(zi) {
      return "   " + zi;
    }).join(`
`))) : Xi = Ci.stylize("[Circular]", "special")), Vi(Fi)) {
      if (Ni && Zi.match(/^\d+$/))
        return Xi;
      Fi = JSON.stringify("" + Zi), Fi.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Fi = Fi.slice(1, -1), Fi = Ci.stylize(Fi, "name")) : (Fi = Fi.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Fi = Ci.stylize(Fi, "string"));
    }
    return Fi + ": " + Xi;
  }
  function tt(Ci, Ki, Yi) {
    var Qi = Ci.reduce(function(Zi, Ni) {
      return Ni.indexOf(`
`) >= 0, Zi + Ni.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return Qi > 60 ? Yi[0] + (Ki === "" ? "" : Ki + `
 `) + " " + Ci.join(`,
  `) + " " + Yi[1] : Yi[0] + Ki + " " + Ci.join(", ") + " " + Yi[1];
  }
  e.types = types;
  function br(Ci) {
    return Array.isArray(Ci);
  }
  e.isArray = br;
  function rt(Ci) {
    return typeof Ci == "boolean";
  }
  e.isBoolean = rt;
  function dr(Ci) {
    return Ci === null;
  }
  e.isNull = dr;
  function _r(Ci) {
    return Ci == null;
  }
  e.isNullOrUndefined = _r;
  function Bi(Ci) {
    return typeof Ci == "number";
  }
  e.isNumber = Bi;
  function qi(Ci) {
    return typeof Ci == "string";
  }
  e.isString = qi;
  function Wi(Ci) {
    return typeof Ci == "symbol";
  }
  e.isSymbol = Wi;
  function Vi(Ci) {
    return Ci === void 0;
  }
  e.isUndefined = Vi;
  function Ti(Ci) {
    return Li(Ci) && gr(Ci) === "[object RegExp]";
  }
  e.isRegExp = Ti, e.types.isRegExp = Ti;
  function Li(Ci) {
    return typeof Ci == "object" && Ci !== null;
  }
  e.isObject = Li;
  function Hi(Ci) {
    return Li(Ci) && gr(Ci) === "[object Date]";
  }
  e.isDate = Hi, e.types.isDate = Hi;
  function pr(Ci) {
    return Li(Ci) && (gr(Ci) === "[object Error]" || Ci instanceof Error);
  }
  e.isError = pr, e.types.isNativeError = pr;
  function Di(Ci) {
    return typeof Ci == "function";
  }
  e.isFunction = Di;
  function z(Ci) {
    return Ci === null || typeof Ci == "boolean" || typeof Ci == "number" || typeof Ci == "string" || typeof Ci == "symbol" || // ES6 symbol
    typeof Ci > "u";
  }
  e.isPrimitive = z, e.isBuffer = isBufferBrowser;
  function gr(Ci) {
    return Object.prototype.toString.call(Ci);
  }
  function vr(Ci) {
    return Ci < 10 ? "0" + Ci.toString(10) : Ci.toString(10);
  }
  var Oi = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function Mi() {
    var Ci = /* @__PURE__ */ new Date(), Ki = [
      vr(Ci.getHours()),
      vr(Ci.getMinutes()),
      vr(Ci.getSeconds())
    ].join(":");
    return [Ci.getDate(), Oi[Ci.getMonth()], Ki].join(" ");
  }
  e.log = function() {
    console.log("%s - %s", Mi(), e.format.apply(e, arguments));
  }, e.inherits = inherits_browserExports, e._extend = function(Ci, Ki) {
    if (!Ki || !Li(Ki)) return Ci;
    for (var Yi = Object.keys(Ki), Qi = Yi.length; Qi--; )
      Ci[Yi[Qi]] = Ki[Yi[Qi]];
    return Ci;
  };
  function ki(Ci, Ki) {
    return Object.prototype.hasOwnProperty.call(Ci, Ki);
  }
  var yr = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  e.promisify = function(Ci) {
    if (typeof Ci != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (yr && Ci[yr]) {
      var Ki = Ci[yr];
      if (typeof Ki != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(Ki, yr, {
        value: Ki,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Ki;
    }
    function Ki() {
      for (var Yi, Qi, Zi = new Promise(function(Xi, to) {
        Yi = Xi, Qi = to;
      }), Ni = [], Fi = 0; Fi < arguments.length; Fi++)
        Ni.push(arguments[Fi]);
      Ni.push(function(Xi, to) {
        Xi ? Qi(Xi) : Yi(to);
      });
      try {
        Ci.apply(this, Ni);
      } catch (Xi) {
        Qi(Xi);
      }
      return Zi;
    }
    return Object.setPrototypeOf(Ki, Object.getPrototypeOf(Ci)), yr && Object.defineProperty(Ki, yr, {
      value: Ki,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      Ki,
      t(Ci)
    );
  }, e.promisify.custom = yr;
  function xi(Ci, Ki) {
    if (!Ci) {
      var Yi = new Error("Promise was rejected with a falsy value");
      Yi.reason = Ci, Ci = Yi;
    }
    return Ki(Ci);
  }
  function Si(Ci) {
    if (typeof Ci != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function Ki() {
      for (var Yi = [], Qi = 0; Qi < arguments.length; Qi++)
        Yi.push(arguments[Qi]);
      var Zi = Yi.pop();
      if (typeof Zi != "function")
        throw new TypeError("The last argument must be of type Function");
      var Ni = this, Fi = function() {
        return Zi.apply(Ni, arguments);
      };
      Ci.apply(this, Yi).then(
        function(Xi) {
          process$1$1.nextTick(Fi.bind(null, null, Xi));
        },
        function(Xi) {
          process$1$1.nextTick(xi.bind(null, Xi, Fi));
        }
      );
    }
    return Object.setPrototypeOf(Ki, Object.getPrototypeOf(Ci)), Object.defineProperties(
      Ki,
      t(Ci)
    ), Ki;
  }
  e.callbackify = Si;
})(util$3);
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function e(he, tt) {
    var br = Object.keys(he);
    if (Object.getOwnPropertySymbols) {
      var rt = Object.getOwnPropertySymbols(he);
      tt && (rt = rt.filter(function(dr) {
        return Object.getOwnPropertyDescriptor(he, dr).enumerable;
      })), br.push.apply(br, rt);
    }
    return br;
  }
  function t(he) {
    for (var tt = 1; tt < arguments.length; tt++) {
      var br = arguments[tt] != null ? arguments[tt] : {};
      tt % 2 ? e(Object(br), !0).forEach(function(rt) {
        v(he, rt, br[rt]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(he, Object.getOwnPropertyDescriptors(br)) : e(Object(br)).forEach(function(rt) {
        Object.defineProperty(he, rt, Object.getOwnPropertyDescriptor(br, rt));
      });
    }
    return he;
  }
  function v(he, tt, br) {
    return tt = C(tt), tt in he ? Object.defineProperty(he, tt, { value: br, enumerable: !0, configurable: !0, writable: !0 }) : he[tt] = br, he;
  }
  function w(he, tt) {
    if (!(he instanceof tt))
      throw new TypeError("Cannot call a class as a function");
  }
  function T(he, tt) {
    for (var br = 0; br < tt.length; br++) {
      var rt = tt[br];
      rt.enumerable = rt.enumerable || !1, rt.configurable = !0, "value" in rt && (rt.writable = !0), Object.defineProperty(he, C(rt.key), rt);
    }
  }
  function x(he, tt, br) {
    return tt && T(he.prototype, tt), Object.defineProperty(he, "prototype", { writable: !1 }), he;
  }
  function C(he) {
    var tt = D(he, "string");
    return typeof tt == "symbol" ? tt : String(tt);
  }
  function D(he, tt) {
    if (typeof he != "object" || he === null) return he;
    var br = he[Symbol.toPrimitive];
    if (br !== void 0) {
      var rt = br.call(he, tt);
      if (typeof rt != "object") return rt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(he);
  }
  var Y = require$$1$2, L = Y.Buffer, q = util$3, N = q.inspect, F = N && N.custom || "inspect";
  function ae(he, tt, br) {
    L.prototype.copy.call(he, tt, br);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function he() {
      w(this, he), this.head = null, this.tail = null, this.length = 0;
    }
    return x(he, [{
      key: "push",
      value: function(tt) {
        var br = {
          data: tt,
          next: null
        };
        this.length > 0 ? this.tail.next = br : this.head = br, this.tail = br, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(tt) {
        var br = {
          data: tt,
          next: this.head
        };
        this.length === 0 && (this.tail = br), this.head = br, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var tt = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, tt;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(tt) {
        if (this.length === 0) return "";
        for (var br = this.head, rt = "" + br.data; br = br.next; ) rt += tt + br.data;
        return rt;
      }
    }, {
      key: "concat",
      value: function(tt) {
        if (this.length === 0) return L.alloc(0);
        for (var br = L.allocUnsafe(tt >>> 0), rt = this.head, dr = 0; rt; )
          ae(rt.data, br, dr), dr += rt.data.length, rt = rt.next;
        return br;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(tt, br) {
        var rt;
        return tt < this.head.data.length ? (rt = this.head.data.slice(0, tt), this.head.data = this.head.data.slice(tt)) : tt === this.head.data.length ? rt = this.shift() : rt = br ? this._getString(tt) : this._getBuffer(tt), rt;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(tt) {
        var br = this.head, rt = 1, dr = br.data;
        for (tt -= dr.length; br = br.next; ) {
          var _r = br.data, Bi = tt > _r.length ? _r.length : tt;
          if (Bi === _r.length ? dr += _r : dr += _r.slice(0, tt), tt -= Bi, tt === 0) {
            Bi === _r.length ? (++rt, br.next ? this.head = br.next : this.head = this.tail = null) : (this.head = br, br.data = _r.slice(Bi));
            break;
          }
          ++rt;
        }
        return this.length -= rt, dr;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(tt) {
        var br = L.allocUnsafe(tt), rt = this.head, dr = 1;
        for (rt.data.copy(br), tt -= rt.data.length; rt = rt.next; ) {
          var _r = rt.data, Bi = tt > _r.length ? _r.length : tt;
          if (_r.copy(br, br.length - tt, 0, Bi), tt -= Bi, tt === 0) {
            Bi === _r.length ? (++dr, rt.next ? this.head = rt.next : this.head = this.tail = null) : (this.head = rt, rt.data = _r.slice(Bi));
            break;
          }
          ++dr;
        }
        return this.length -= dr, br;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: F,
      value: function(tt, br) {
        return N(this, t(t({}, br), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), he;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1$1;
  hasRequiredDestroy = 1;
  function e(C, D) {
    var Y = this, L = this._readableState && this._readableState.destroyed, q = this._writableState && this._writableState.destroyed;
    return L || q ? (D ? D(C) : C && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1$1.nextTick(T, this, C)) : process$1$1.nextTick(T, this, C)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(C || null, function(N) {
      !D && N ? Y._writableState ? Y._writableState.errorEmitted ? process$1$1.nextTick(v, Y) : (Y._writableState.errorEmitted = !0, process$1$1.nextTick(t, Y, N)) : process$1$1.nextTick(t, Y, N) : D ? (process$1$1.nextTick(v, Y), D(N)) : process$1$1.nextTick(v, Y);
    }), this);
  }
  function t(C, D) {
    T(C, D), v(C);
  }
  function v(C) {
    C._writableState && !C._writableState.emitClose || C._readableState && !C._readableState.emitClose || C.emit("close");
  }
  function w() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function T(C, D) {
    C.emit("error", D);
  }
  function x(C, D) {
    var Y = C._readableState, L = C._writableState;
    Y && Y.autoDestroy || L && L.autoDestroy ? C.destroy(D) : C.emit("error", D);
  }
  return destroy_1$1 = {
    destroy: e,
    undestroy: w,
    errorOrDestroy: x
  }, destroy_1$1;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function e(D, Y) {
    D.prototype = Object.create(Y.prototype), D.prototype.constructor = D, D.__proto__ = Y;
  }
  var t = {};
  function v(D, Y, L) {
    L || (L = Error);
    function q(F, ae, he) {
      return typeof Y == "string" ? Y : Y(F, ae, he);
    }
    var N = /* @__PURE__ */ function(F) {
      e(ae, F);
      function ae(he, tt, br) {
        return F.call(this, q(he, tt, br)) || this;
      }
      return ae;
    }(L);
    N.prototype.name = L.name, N.prototype.code = D, t[D] = N;
  }
  function w(D, Y) {
    if (Array.isArray(D)) {
      var L = D.length;
      return D = D.map(function(q) {
        return String(q);
      }), L > 2 ? "one of ".concat(Y, " ").concat(D.slice(0, L - 1).join(", "), ", or ") + D[L - 1] : L === 2 ? "one of ".concat(Y, " ").concat(D[0], " or ").concat(D[1]) : "of ".concat(Y, " ").concat(D[0]);
    } else
      return "of ".concat(Y, " ").concat(String(D));
  }
  function T(D, Y, L) {
    return D.substr(0, Y.length) === Y;
  }
  function x(D, Y, L) {
    return (L === void 0 || L > D.length) && (L = D.length), D.substring(L - Y.length, L) === Y;
  }
  function C(D, Y, L) {
    return typeof L != "number" && (L = 0), L + Y.length > D.length ? !1 : D.indexOf(Y, L) !== -1;
  }
  return v("ERR_INVALID_OPT_VALUE", function(D, Y) {
    return 'The value "' + Y + '" is invalid for option "' + D + '"';
  }, TypeError), v("ERR_INVALID_ARG_TYPE", function(D, Y, L) {
    var q;
    typeof Y == "string" && T(Y, "not ") ? (q = "must not be", Y = Y.replace(/^not /, "")) : q = "must be";
    var N;
    if (x(D, " argument"))
      N = "The ".concat(D, " ").concat(q, " ").concat(w(Y, "type"));
    else {
      var F = C(D, ".") ? "property" : "argument";
      N = 'The "'.concat(D, '" ').concat(F, " ").concat(q, " ").concat(w(Y, "type"));
    }
    return N += ". Received type ".concat(typeof L), N;
  }, TypeError), v("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), v("ERR_METHOD_NOT_IMPLEMENTED", function(D) {
    return "The " + D + " method is not implemented";
  }), v("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), v("ERR_STREAM_DESTROYED", function(D) {
    return "Cannot call " + D + " after a stream was destroyed";
  }), v("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), v("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), v("ERR_STREAM_WRITE_AFTER_END", "write after end"), v("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), v("ERR_UNKNOWN_ENCODING", function(D) {
    return "Unknown encoding: " + D;
  }, TypeError), v("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = t, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var e = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function t(w, T, x) {
    return w.highWaterMark != null ? w.highWaterMark : T ? w[x] : null;
  }
  function v(w, T, x, C) {
    var D = t(T, C, x);
    if (D != null) {
      if (!(isFinite(D) && Math.floor(D) === D) || D < 0) {
        var Y = C ? x : "highWaterMark";
        throw new e(Y, D);
      }
      return Math.floor(D);
    }
    return w.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: v
  }, state;
}
var browser$a = deprecate;
function deprecate(e, t) {
  if (config("noDeprecation"))
    return e;
  var v = !1;
  function w() {
    if (!v) {
      if (config("throwDeprecation"))
        throw new Error(t);
      config("traceDeprecation") ? console.trace(t) : console.warn(t), v = !0;
    }
    return e.apply(this, arguments);
  }
  return w;
}
function config(e) {
  try {
    if (!commonjsGlobal.localStorage) return !1;
  } catch {
    return !1;
  }
  var t = commonjsGlobal.localStorage[e];
  return t == null ? !1 : String(t).toLowerCase() === "true";
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = Ti;
  function e(Zi) {
    var Ni = this;
    this.next = null, this.entry = null, this.finish = function() {
      Qi(Ni, Zi);
    };
  }
  var t;
  Ti.WritableState = Wi;
  var v = {
    deprecate: browser$a
  }, w = requireStreamBrowser(), T = require$$1$2.Buffer, x = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function C(Zi) {
    return T.from(Zi);
  }
  function D(Zi) {
    return T.isBuffer(Zi) || Zi instanceof x;
  }
  var Y = requireDestroy(), L = requireState(), q = L.getHighWaterMark, N = requireErrorsBrowser().codes, F = N.ERR_INVALID_ARG_TYPE, ae = N.ERR_METHOD_NOT_IMPLEMENTED, he = N.ERR_MULTIPLE_CALLBACK, tt = N.ERR_STREAM_CANNOT_PIPE, br = N.ERR_STREAM_DESTROYED, rt = N.ERR_STREAM_NULL_VALUES, dr = N.ERR_STREAM_WRITE_AFTER_END, _r = N.ERR_UNKNOWN_ENCODING, Bi = Y.errorOrDestroy;
  inherits_browserExports(Ti, w);
  function qi() {
  }
  function Wi(Zi, Ni, Fi) {
    t = t || require_stream_duplex$1(), Zi = Zi || {}, typeof Fi != "boolean" && (Fi = Ni instanceof t), this.objectMode = !!Zi.objectMode, Fi && (this.objectMode = this.objectMode || !!Zi.writableObjectMode), this.highWaterMark = q(this, Zi, "writableHighWaterMark", Fi), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Xi = Zi.decodeStrings === !1;
    this.decodeStrings = !Xi, this.defaultEncoding = Zi.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(to) {
      Oi(Ni, to);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Zi.emitClose !== !1, this.autoDestroy = !!Zi.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  Wi.prototype.getBuffer = function() {
    for (var Zi = this.bufferedRequest, Ni = []; Zi; )
      Ni.push(Zi), Zi = Zi.next;
    return Ni;
  }, function() {
    try {
      Object.defineProperty(Wi.prototype, "buffer", {
        get: v.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Vi;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Vi = Function.prototype[Symbol.hasInstance], Object.defineProperty(Ti, Symbol.hasInstance, {
    value: function(Zi) {
      return Vi.call(this, Zi) ? !0 : this !== Ti ? !1 : Zi && Zi._writableState instanceof Wi;
    }
  })) : Vi = function(Zi) {
    return Zi instanceof this;
  };
  function Ti(Zi) {
    t = t || require_stream_duplex$1();
    var Ni = this instanceof t;
    if (!Ni && !Vi.call(Ti, this)) return new Ti(Zi);
    this._writableState = new Wi(Zi, this, Ni), this.writable = !0, Zi && (typeof Zi.write == "function" && (this._write = Zi.write), typeof Zi.writev == "function" && (this._writev = Zi.writev), typeof Zi.destroy == "function" && (this._destroy = Zi.destroy), typeof Zi.final == "function" && (this._final = Zi.final)), w.call(this);
  }
  Ti.prototype.pipe = function() {
    Bi(this, new tt());
  };
  function Li(Zi, Ni) {
    var Fi = new dr();
    Bi(Zi, Fi), process$1$1.nextTick(Ni, Fi);
  }
  function Hi(Zi, Ni, Fi, Xi) {
    var to;
    return Fi === null ? to = new rt() : typeof Fi != "string" && !Ni.objectMode && (to = new F("chunk", ["string", "Buffer"], Fi)), to ? (Bi(Zi, to), process$1$1.nextTick(Xi, to), !1) : !0;
  }
  Ti.prototype.write = function(Zi, Ni, Fi) {
    var Xi = this._writableState, to = !1, zi = !Xi.objectMode && D(Zi);
    return zi && !T.isBuffer(Zi) && (Zi = C(Zi)), typeof Ni == "function" && (Fi = Ni, Ni = null), zi ? Ni = "buffer" : Ni || (Ni = Xi.defaultEncoding), typeof Fi != "function" && (Fi = qi), Xi.ending ? Li(this, Fi) : (zi || Hi(this, Xi, Zi, Fi)) && (Xi.pendingcb++, to = Di(this, Xi, zi, Zi, Ni, Fi)), to;
  }, Ti.prototype.cork = function() {
    this._writableState.corked++;
  }, Ti.prototype.uncork = function() {
    var Zi = this._writableState;
    Zi.corked && (Zi.corked--, !Zi.writing && !Zi.corked && !Zi.bufferProcessing && Zi.bufferedRequest && yr(this, Zi));
  }, Ti.prototype.setDefaultEncoding = function(Zi) {
    if (typeof Zi == "string" && (Zi = Zi.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Zi + "").toLowerCase()) > -1)) throw new _r(Zi);
    return this._writableState.defaultEncoding = Zi, this;
  }, Object.defineProperty(Ti.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function pr(Zi, Ni, Fi) {
    return !Zi.objectMode && Zi.decodeStrings !== !1 && typeof Ni == "string" && (Ni = T.from(Ni, Fi)), Ni;
  }
  Object.defineProperty(Ti.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Di(Zi, Ni, Fi, Xi, to, zi) {
    if (!Fi) {
      var Gi = pr(Ni, Xi, to);
      Xi !== Gi && (Fi = !0, to = "buffer", Xi = Gi);
    }
    var no = Ni.objectMode ? 1 : Xi.length;
    Ni.length += no;
    var so = Ni.length < Ni.highWaterMark;
    if (so || (Ni.needDrain = !0), Ni.writing || Ni.corked) {
      var ho = Ni.lastBufferedRequest;
      Ni.lastBufferedRequest = {
        chunk: Xi,
        encoding: to,
        isBuf: Fi,
        callback: zi,
        next: null
      }, ho ? ho.next = Ni.lastBufferedRequest : Ni.bufferedRequest = Ni.lastBufferedRequest, Ni.bufferedRequestCount += 1;
    } else
      z(Zi, Ni, !1, no, Xi, to, zi);
    return so;
  }
  function z(Zi, Ni, Fi, Xi, to, zi, Gi) {
    Ni.writelen = Xi, Ni.writecb = Gi, Ni.writing = !0, Ni.sync = !0, Ni.destroyed ? Ni.onwrite(new br("write")) : Fi ? Zi._writev(to, Ni.onwrite) : Zi._write(to, zi, Ni.onwrite), Ni.sync = !1;
  }
  function gr(Zi, Ni, Fi, Xi, to) {
    --Ni.pendingcb, Fi ? (process$1$1.nextTick(to, Xi), process$1$1.nextTick(Ki, Zi, Ni), Zi._writableState.errorEmitted = !0, Bi(Zi, Xi)) : (to(Xi), Zi._writableState.errorEmitted = !0, Bi(Zi, Xi), Ki(Zi, Ni));
  }
  function vr(Zi) {
    Zi.writing = !1, Zi.writecb = null, Zi.length -= Zi.writelen, Zi.writelen = 0;
  }
  function Oi(Zi, Ni) {
    var Fi = Zi._writableState, Xi = Fi.sync, to = Fi.writecb;
    if (typeof to != "function") throw new he();
    if (vr(Fi), Ni) gr(Zi, Fi, Xi, Ni, to);
    else {
      var zi = xi(Fi) || Zi.destroyed;
      !zi && !Fi.corked && !Fi.bufferProcessing && Fi.bufferedRequest && yr(Zi, Fi), Xi ? process$1$1.nextTick(Mi, Zi, Fi, zi, to) : Mi(Zi, Fi, zi, to);
    }
  }
  function Mi(Zi, Ni, Fi, Xi) {
    Fi || ki(Zi, Ni), Ni.pendingcb--, Xi(), Ki(Zi, Ni);
  }
  function ki(Zi, Ni) {
    Ni.length === 0 && Ni.needDrain && (Ni.needDrain = !1, Zi.emit("drain"));
  }
  function yr(Zi, Ni) {
    Ni.bufferProcessing = !0;
    var Fi = Ni.bufferedRequest;
    if (Zi._writev && Fi && Fi.next) {
      var Xi = Ni.bufferedRequestCount, to = new Array(Xi), zi = Ni.corkedRequestsFree;
      zi.entry = Fi;
      for (var Gi = 0, no = !0; Fi; )
        to[Gi] = Fi, Fi.isBuf || (no = !1), Fi = Fi.next, Gi += 1;
      to.allBuffers = no, z(Zi, Ni, !0, Ni.length, to, "", zi.finish), Ni.pendingcb++, Ni.lastBufferedRequest = null, zi.next ? (Ni.corkedRequestsFree = zi.next, zi.next = null) : Ni.corkedRequestsFree = new e(Ni), Ni.bufferedRequestCount = 0;
    } else {
      for (; Fi; ) {
        var so = Fi.chunk, ho = Fi.encoding, uo = Fi.callback, ao = Ni.objectMode ? 1 : so.length;
        if (z(Zi, Ni, !1, ao, so, ho, uo), Fi = Fi.next, Ni.bufferedRequestCount--, Ni.writing)
          break;
      }
      Fi === null && (Ni.lastBufferedRequest = null);
    }
    Ni.bufferedRequest = Fi, Ni.bufferProcessing = !1;
  }
  Ti.prototype._write = function(Zi, Ni, Fi) {
    Fi(new ae("_write()"));
  }, Ti.prototype._writev = null, Ti.prototype.end = function(Zi, Ni, Fi) {
    var Xi = this._writableState;
    return typeof Zi == "function" ? (Fi = Zi, Zi = null, Ni = null) : typeof Ni == "function" && (Fi = Ni, Ni = null), Zi != null && this.write(Zi, Ni), Xi.corked && (Xi.corked = 1, this.uncork()), Xi.ending || Yi(this, Xi, Fi), this;
  }, Object.defineProperty(Ti.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function xi(Zi) {
    return Zi.ending && Zi.length === 0 && Zi.bufferedRequest === null && !Zi.finished && !Zi.writing;
  }
  function Si(Zi, Ni) {
    Zi._final(function(Fi) {
      Ni.pendingcb--, Fi && Bi(Zi, Fi), Ni.prefinished = !0, Zi.emit("prefinish"), Ki(Zi, Ni);
    });
  }
  function Ci(Zi, Ni) {
    !Ni.prefinished && !Ni.finalCalled && (typeof Zi._final == "function" && !Ni.destroyed ? (Ni.pendingcb++, Ni.finalCalled = !0, process$1$1.nextTick(Si, Zi, Ni)) : (Ni.prefinished = !0, Zi.emit("prefinish")));
  }
  function Ki(Zi, Ni) {
    var Fi = xi(Ni);
    if (Fi && (Ci(Zi, Ni), Ni.pendingcb === 0 && (Ni.finished = !0, Zi.emit("finish"), Ni.autoDestroy))) {
      var Xi = Zi._readableState;
      (!Xi || Xi.autoDestroy && Xi.endEmitted) && Zi.destroy();
    }
    return Fi;
  }
  function Yi(Zi, Ni, Fi) {
    Ni.ending = !0, Ki(Zi, Ni), Fi && (Ni.finished ? process$1$1.nextTick(Fi) : Zi.once("finish", Fi)), Ni.ended = !0, Zi.writable = !1;
  }
  function Qi(Zi, Ni, Fi) {
    var Xi = Zi.entry;
    for (Zi.entry = null; Xi; ) {
      var to = Xi.callback;
      Ni.pendingcb--, to(Fi), Xi = Xi.next;
    }
    Ni.corkedRequestsFree.next = Zi;
  }
  return Object.defineProperty(Ti.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Zi) {
      this._writableState && (this._writableState.destroyed = Zi);
    }
  }), Ti.prototype.destroy = Y.destroy, Ti.prototype._undestroy = Y.undestroy, Ti.prototype._destroy = function(Zi, Ni) {
    Ni(Zi);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var e = Object.keys || function(L) {
    var q = [];
    for (var N in L) q.push(N);
    return q;
  };
  _stream_duplex$1 = C;
  var t = require_stream_readable$1(), v = require_stream_writable$1();
  inherits_browserExports(C, t);
  for (var w = e(v.prototype), T = 0; T < w.length; T++) {
    var x = w[T];
    C.prototype[x] || (C.prototype[x] = v.prototype[x]);
  }
  function C(L) {
    if (!(this instanceof C)) return new C(L);
    t.call(this, L), v.call(this, L), this.allowHalfOpen = !0, L && (L.readable === !1 && (this.readable = !1), L.writable === !1 && (this.writable = !1), L.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", D)));
  }
  Object.defineProperty(C.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(C.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(C.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function D() {
    this._writableState.ended || process$1$1.nextTick(Y, this);
  }
  function Y(L) {
    L.end();
  }
  return Object.defineProperty(C.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(L) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = L, this._writableState.destroyed = L);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, safeBuffer$1 = { exports: {} };
safeBuffer$1.exports;
(function(e, t) {
  var v = require$$1$2, w = v.Buffer;
  function T(C, D) {
    for (var Y in C)
      D[Y] = C[Y];
  }
  w.from && w.alloc && w.allocUnsafe && w.allocUnsafeSlow ? e.exports = v : (T(v, t), t.Buffer = x);
  function x(C, D, Y) {
    return w(C, D, Y);
  }
  T(w, x), x.from = function(C, D, Y) {
    if (typeof C == "number")
      throw new TypeError("Argument must not be a number");
    return w(C, D, Y);
  }, x.alloc = function(C, D, Y) {
    if (typeof C != "number")
      throw new TypeError("Argument must be a number");
    var L = w(C);
    return D !== void 0 ? typeof Y == "string" ? L.fill(D, Y) : L.fill(D) : L.fill(0), L;
  }, x.allocUnsafe = function(C) {
    if (typeof C != "number")
      throw new TypeError("Argument must be a number");
    return w(C);
  }, x.allocUnsafeSlow = function(C) {
    if (typeof C != "number")
      throw new TypeError("Argument must be a number");
    return v.SlowBuffer(C);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, Buffer$A = safeBufferExports.Buffer, isEncoding = Buffer$A.isEncoding || function(e) {
  switch (e = "" + e, e && e.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function _normalizeEncoding(e) {
  if (!e) return "utf8";
  for (var t; ; )
    switch (e) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return e;
      default:
        if (t) return;
        e = ("" + e).toLowerCase(), t = !0;
    }
}
function normalizeEncoding(e) {
  var t = _normalizeEncoding(e);
  if (typeof t != "string" && (Buffer$A.isEncoding === isEncoding || !isEncoding(e))) throw new Error("Unknown encoding: " + e);
  return t || e;
}
string_decoder.StringDecoder = StringDecoder$1;
function StringDecoder$1(e) {
  this.encoding = normalizeEncoding(e);
  var t;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text, this.end = utf16End, t = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast, t = 4;
      break;
    case "base64":
      this.text = base64Text, this.end = base64End, t = 3;
      break;
    default:
      this.write = simpleWrite, this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer$A.allocUnsafe(t);
}
StringDecoder$1.prototype.write = function(e) {
  if (e.length === 0) return "";
  var t, v;
  if (this.lastNeed) {
    if (t = this.fillLast(e), t === void 0) return "";
    v = this.lastNeed, this.lastNeed = 0;
  } else
    v = 0;
  return v < e.length ? t ? t + this.text(e, v) : this.text(e, v) : t || "";
};
StringDecoder$1.prototype.end = utf8End;
StringDecoder$1.prototype.text = utf8Text;
StringDecoder$1.prototype.fillLast = function(e) {
  if (this.lastNeed <= e.length)
    return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
};
function utf8CheckByte(e) {
  return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(e, t, v) {
  var w = t.length - 1;
  if (w < v) return 0;
  var T = utf8CheckByte(t[w]);
  return T >= 0 ? (T > 0 && (e.lastNeed = T - 1), T) : --w < v || T === -2 ? 0 : (T = utf8CheckByte(t[w]), T >= 0 ? (T > 0 && (e.lastNeed = T - 2), T) : --w < v || T === -2 ? 0 : (T = utf8CheckByte(t[w]), T >= 0 ? (T > 0 && (T === 2 ? T = 0 : e.lastNeed = T - 3), T) : 0));
}
function utf8CheckExtraBytes(e, t, v) {
  if ((t[0] & 192) !== 128)
    return e.lastNeed = 0, "�";
  if (e.lastNeed > 1 && t.length > 1) {
    if ((t[1] & 192) !== 128)
      return e.lastNeed = 1, "�";
    if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
      return e.lastNeed = 2, "�";
  }
}
function utf8FillLast(e) {
  var t = this.lastTotal - this.lastNeed, v = utf8CheckExtraBytes(this, e);
  if (v !== void 0) return v;
  if (this.lastNeed <= e.length)
    return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
}
function utf8Text(e, t) {
  var v = utf8CheckIncomplete(this, e, t);
  if (!this.lastNeed) return e.toString("utf8", t);
  this.lastTotal = v;
  var w = e.length - (v - this.lastNeed);
  return e.copy(this.lastChar, 0, w), e.toString("utf8", t, w);
}
function utf8End(e) {
  var t = e && e.length ? this.write(e) : "";
  return this.lastNeed ? t + "�" : t;
}
function utf16Text(e, t) {
  if ((e.length - t) % 2 === 0) {
    var v = e.toString("utf16le", t);
    if (v) {
      var w = v.charCodeAt(v.length - 1);
      if (w >= 55296 && w <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], v.slice(0, -1);
    }
    return v;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
}
function utf16End(e) {
  var t = e && e.length ? this.write(e) : "";
  if (this.lastNeed) {
    var v = this.lastTotal - this.lastNeed;
    return t + this.lastChar.toString("utf16le", 0, v);
  }
  return t;
}
function base64Text(e, t) {
  var v = (e.length - t) % 3;
  return v === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - v, this.lastTotal = 3, v === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - v));
}
function base64End(e) {
  var t = e && e.length ? this.write(e) : "";
  return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
}
function simpleWrite(e) {
  return e.toString(this.encoding);
}
function simpleEnd(e) {
  return e && e.length ? this.write(e) : "";
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var e = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function t(x) {
    var C = !1;
    return function() {
      if (!C) {
        C = !0;
        for (var D = arguments.length, Y = new Array(D), L = 0; L < D; L++)
          Y[L] = arguments[L];
        x.apply(this, Y);
      }
    };
  }
  function v() {
  }
  function w(x) {
    return x.setHeader && typeof x.abort == "function";
  }
  function T(x, C, D) {
    if (typeof C == "function") return T(x, null, C);
    C || (C = {}), D = t(D || v);
    var Y = C.readable || C.readable !== !1 && x.readable, L = C.writable || C.writable !== !1 && x.writable, q = function() {
      x.writable || F();
    }, N = x._writableState && x._writableState.finished, F = function() {
      L = !1, N = !0, Y || D.call(x);
    }, ae = x._readableState && x._readableState.endEmitted, he = function() {
      Y = !1, ae = !0, L || D.call(x);
    }, tt = function(dr) {
      D.call(x, dr);
    }, br = function() {
      var dr;
      if (Y && !ae)
        return (!x._readableState || !x._readableState.ended) && (dr = new e()), D.call(x, dr);
      if (L && !N)
        return (!x._writableState || !x._writableState.ended) && (dr = new e()), D.call(x, dr);
    }, rt = function() {
      x.req.on("finish", F);
    };
    return w(x) ? (x.on("complete", F), x.on("abort", br), x.req ? rt() : x.on("request", rt)) : L && !x._writableState && (x.on("end", q), x.on("close", q)), x.on("end", he), x.on("finish", F), C.error !== !1 && x.on("error", tt), x.on("close", br), function() {
      x.removeListener("complete", F), x.removeListener("abort", br), x.removeListener("request", rt), x.req && x.req.removeListener("finish", F), x.removeListener("end", q), x.removeListener("close", q), x.removeListener("finish", F), x.removeListener("end", he), x.removeListener("error", tt), x.removeListener("close", br);
    };
  }
  return endOfStream = T, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var e;
  function t(_r, Bi, qi) {
    return Bi = v(Bi), Bi in _r ? Object.defineProperty(_r, Bi, { value: qi, enumerable: !0, configurable: !0, writable: !0 }) : _r[Bi] = qi, _r;
  }
  function v(_r) {
    var Bi = w(_r, "string");
    return typeof Bi == "symbol" ? Bi : String(Bi);
  }
  function w(_r, Bi) {
    if (typeof _r != "object" || _r === null) return _r;
    var qi = _r[Symbol.toPrimitive];
    if (qi !== void 0) {
      var Wi = qi.call(_r, Bi);
      if (typeof Wi != "object") return Wi;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(_r);
  }
  var T = requireEndOfStream(), x = Symbol("lastResolve"), C = Symbol("lastReject"), D = Symbol("error"), Y = Symbol("ended"), L = Symbol("lastPromise"), q = Symbol("handlePromise"), N = Symbol("stream");
  function F(_r, Bi) {
    return {
      value: _r,
      done: Bi
    };
  }
  function ae(_r) {
    var Bi = _r[x];
    if (Bi !== null) {
      var qi = _r[N].read();
      qi !== null && (_r[L] = null, _r[x] = null, _r[C] = null, Bi(F(qi, !1)));
    }
  }
  function he(_r) {
    process$1$1.nextTick(ae, _r);
  }
  function tt(_r, Bi) {
    return function(qi, Wi) {
      _r.then(function() {
        if (Bi[Y]) {
          qi(F(void 0, !0));
          return;
        }
        Bi[q](qi, Wi);
      }, Wi);
    };
  }
  var br = Object.getPrototypeOf(function() {
  }), rt = Object.setPrototypeOf((e = {
    get stream() {
      return this[N];
    },
    next: function() {
      var _r = this, Bi = this[D];
      if (Bi !== null)
        return Promise.reject(Bi);
      if (this[Y])
        return Promise.resolve(F(void 0, !0));
      if (this[N].destroyed)
        return new Promise(function(Ti, Li) {
          process$1$1.nextTick(function() {
            _r[D] ? Li(_r[D]) : Ti(F(void 0, !0));
          });
        });
      var qi = this[L], Wi;
      if (qi)
        Wi = new Promise(tt(qi, this));
      else {
        var Vi = this[N].read();
        if (Vi !== null)
          return Promise.resolve(F(Vi, !1));
        Wi = new Promise(this[q]);
      }
      return this[L] = Wi, Wi;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var _r = this;
    return new Promise(function(Bi, qi) {
      _r[N].destroy(null, function(Wi) {
        if (Wi) {
          qi(Wi);
          return;
        }
        Bi(F(void 0, !0));
      });
    });
  }), e), br), dr = function(_r) {
    var Bi, qi = Object.create(rt, (Bi = {}, t(Bi, N, {
      value: _r,
      writable: !0
    }), t(Bi, x, {
      value: null,
      writable: !0
    }), t(Bi, C, {
      value: null,
      writable: !0
    }), t(Bi, D, {
      value: null,
      writable: !0
    }), t(Bi, Y, {
      value: _r._readableState.endEmitted,
      writable: !0
    }), t(Bi, q, {
      value: function(Wi, Vi) {
        var Ti = qi[N].read();
        Ti ? (qi[L] = null, qi[x] = null, qi[C] = null, Wi(F(Ti, !1))) : (qi[x] = Wi, qi[C] = Vi);
      },
      writable: !0
    }), Bi));
    return qi[L] = null, T(_r, function(Wi) {
      if (Wi && Wi.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Vi = qi[C];
        Vi !== null && (qi[L] = null, qi[x] = null, qi[C] = null, Vi(Wi)), qi[D] = Wi;
        return;
      }
      var Ti = qi[x];
      Ti !== null && (qi[L] = null, qi[x] = null, qi[C] = null, Ti(F(void 0, !0))), qi[Y] = !0;
    }), _r.on("readable", he.bind(null, qi)), qi;
  };
  return async_iterator = dr, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = Li;
  var e;
  Li.ReadableState = Ti, eventsExports.EventEmitter;
  var t = function(zi, Gi) {
    return zi.listeners(Gi).length;
  }, v = requireStreamBrowser(), w = require$$1$2.Buffer, T = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function x(zi) {
    return w.from(zi);
  }
  function C(zi) {
    return w.isBuffer(zi) || zi instanceof T;
  }
  var D = util$3, Y;
  D && D.debuglog ? Y = D.debuglog("stream") : Y = function() {
  };
  var L = requireBuffer_list(), q = requireDestroy(), N = requireState(), F = N.getHighWaterMark, ae = requireErrorsBrowser().codes, he = ae.ERR_INVALID_ARG_TYPE, tt = ae.ERR_STREAM_PUSH_AFTER_EOF, br = ae.ERR_METHOD_NOT_IMPLEMENTED, rt = ae.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, dr, _r, Bi;
  inherits_browserExports(Li, v);
  var qi = q.errorOrDestroy, Wi = ["error", "close", "destroy", "pause", "resume"];
  function Vi(zi, Gi, no) {
    if (typeof zi.prependListener == "function") return zi.prependListener(Gi, no);
    !zi._events || !zi._events[Gi] ? zi.on(Gi, no) : Array.isArray(zi._events[Gi]) ? zi._events[Gi].unshift(no) : zi._events[Gi] = [no, zi._events[Gi]];
  }
  function Ti(zi, Gi, no) {
    e = e || require_stream_duplex$1(), zi = zi || {}, typeof no != "boolean" && (no = Gi instanceof e), this.objectMode = !!zi.objectMode, no && (this.objectMode = this.objectMode || !!zi.readableObjectMode), this.highWaterMark = F(this, zi, "readableHighWaterMark", no), this.buffer = new L(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = zi.emitClose !== !1, this.autoDestroy = !!zi.autoDestroy, this.destroyed = !1, this.defaultEncoding = zi.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, zi.encoding && (dr || (dr = string_decoder.StringDecoder), this.decoder = new dr(zi.encoding), this.encoding = zi.encoding);
  }
  function Li(zi) {
    if (e = e || require_stream_duplex$1(), !(this instanceof Li)) return new Li(zi);
    var Gi = this instanceof e;
    this._readableState = new Ti(zi, this, Gi), this.readable = !0, zi && (typeof zi.read == "function" && (this._read = zi.read), typeof zi.destroy == "function" && (this._destroy = zi.destroy)), v.call(this);
  }
  Object.defineProperty(Li.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(zi) {
      this._readableState && (this._readableState.destroyed = zi);
    }
  }), Li.prototype.destroy = q.destroy, Li.prototype._undestroy = q.undestroy, Li.prototype._destroy = function(zi, Gi) {
    Gi(zi);
  }, Li.prototype.push = function(zi, Gi) {
    var no = this._readableState, so;
    return no.objectMode ? so = !0 : typeof zi == "string" && (Gi = Gi || no.defaultEncoding, Gi !== no.encoding && (zi = w.from(zi, Gi), Gi = ""), so = !0), Hi(this, zi, Gi, !1, so);
  }, Li.prototype.unshift = function(zi) {
    return Hi(this, zi, null, !0, !1);
  };
  function Hi(zi, Gi, no, so, ho) {
    Y("readableAddChunk", Gi);
    var uo = zi._readableState;
    if (Gi === null)
      uo.reading = !1, Oi(zi, uo);
    else {
      var ao;
      if (ho || (ao = Di(uo, Gi)), ao)
        qi(zi, ao);
      else if (uo.objectMode || Gi && Gi.length > 0)
        if (typeof Gi != "string" && !uo.objectMode && Object.getPrototypeOf(Gi) !== w.prototype && (Gi = x(Gi)), so)
          uo.endEmitted ? qi(zi, new rt()) : pr(zi, uo, Gi, !0);
        else if (uo.ended)
          qi(zi, new tt());
        else {
          if (uo.destroyed)
            return !1;
          uo.reading = !1, uo.decoder && !no ? (Gi = uo.decoder.write(Gi), uo.objectMode || Gi.length !== 0 ? pr(zi, uo, Gi, !1) : yr(zi, uo)) : pr(zi, uo, Gi, !1);
        }
      else so || (uo.reading = !1, yr(zi, uo));
    }
    return !uo.ended && (uo.length < uo.highWaterMark || uo.length === 0);
  }
  function pr(zi, Gi, no, so) {
    Gi.flowing && Gi.length === 0 && !Gi.sync ? (Gi.awaitDrain = 0, zi.emit("data", no)) : (Gi.length += Gi.objectMode ? 1 : no.length, so ? Gi.buffer.unshift(no) : Gi.buffer.push(no), Gi.needReadable && Mi(zi)), yr(zi, Gi);
  }
  function Di(zi, Gi) {
    var no;
    return !C(Gi) && typeof Gi != "string" && Gi !== void 0 && !zi.objectMode && (no = new he("chunk", ["string", "Buffer", "Uint8Array"], Gi)), no;
  }
  Li.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Li.prototype.setEncoding = function(zi) {
    dr || (dr = string_decoder.StringDecoder);
    var Gi = new dr(zi);
    this._readableState.decoder = Gi, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var no = this._readableState.buffer.head, so = ""; no !== null; )
      so += Gi.write(no.data), no = no.next;
    return this._readableState.buffer.clear(), so !== "" && this._readableState.buffer.push(so), this._readableState.length = so.length, this;
  };
  var z = 1073741824;
  function gr(zi) {
    return zi >= z ? zi = z : (zi--, zi |= zi >>> 1, zi |= zi >>> 2, zi |= zi >>> 4, zi |= zi >>> 8, zi |= zi >>> 16, zi++), zi;
  }
  function vr(zi, Gi) {
    return zi <= 0 || Gi.length === 0 && Gi.ended ? 0 : Gi.objectMode ? 1 : zi !== zi ? Gi.flowing && Gi.length ? Gi.buffer.head.data.length : Gi.length : (zi > Gi.highWaterMark && (Gi.highWaterMark = gr(zi)), zi <= Gi.length ? zi : Gi.ended ? Gi.length : (Gi.needReadable = !0, 0));
  }
  Li.prototype.read = function(zi) {
    Y("read", zi), zi = parseInt(zi, 10);
    var Gi = this._readableState, no = zi;
    if (zi !== 0 && (Gi.emittedReadable = !1), zi === 0 && Gi.needReadable && ((Gi.highWaterMark !== 0 ? Gi.length >= Gi.highWaterMark : Gi.length > 0) || Gi.ended))
      return Y("read: emitReadable", Gi.length, Gi.ended), Gi.length === 0 && Gi.ended ? Fi(this) : Mi(this), null;
    if (zi = vr(zi, Gi), zi === 0 && Gi.ended)
      return Gi.length === 0 && Fi(this), null;
    var so = Gi.needReadable;
    Y("need readable", so), (Gi.length === 0 || Gi.length - zi < Gi.highWaterMark) && (so = !0, Y("length less than watermark", so)), Gi.ended || Gi.reading ? (so = !1, Y("reading or ended", so)) : so && (Y("do read"), Gi.reading = !0, Gi.sync = !0, Gi.length === 0 && (Gi.needReadable = !0), this._read(Gi.highWaterMark), Gi.sync = !1, Gi.reading || (zi = vr(no, Gi)));
    var ho;
    return zi > 0 ? ho = Ni(zi, Gi) : ho = null, ho === null ? (Gi.needReadable = Gi.length <= Gi.highWaterMark, zi = 0) : (Gi.length -= zi, Gi.awaitDrain = 0), Gi.length === 0 && (Gi.ended || (Gi.needReadable = !0), no !== zi && Gi.ended && Fi(this)), ho !== null && this.emit("data", ho), ho;
  };
  function Oi(zi, Gi) {
    if (Y("onEofChunk"), !Gi.ended) {
      if (Gi.decoder) {
        var no = Gi.decoder.end();
        no && no.length && (Gi.buffer.push(no), Gi.length += Gi.objectMode ? 1 : no.length);
      }
      Gi.ended = !0, Gi.sync ? Mi(zi) : (Gi.needReadable = !1, Gi.emittedReadable || (Gi.emittedReadable = !0, ki(zi)));
    }
  }
  function Mi(zi) {
    var Gi = zi._readableState;
    Y("emitReadable", Gi.needReadable, Gi.emittedReadable), Gi.needReadable = !1, Gi.emittedReadable || (Y("emitReadable", Gi.flowing), Gi.emittedReadable = !0, process$1$1.nextTick(ki, zi));
  }
  function ki(zi) {
    var Gi = zi._readableState;
    Y("emitReadable_", Gi.destroyed, Gi.length, Gi.ended), !Gi.destroyed && (Gi.length || Gi.ended) && (zi.emit("readable"), Gi.emittedReadable = !1), Gi.needReadable = !Gi.flowing && !Gi.ended && Gi.length <= Gi.highWaterMark, Zi(zi);
  }
  function yr(zi, Gi) {
    Gi.readingMore || (Gi.readingMore = !0, process$1$1.nextTick(xi, zi, Gi));
  }
  function xi(zi, Gi) {
    for (; !Gi.reading && !Gi.ended && (Gi.length < Gi.highWaterMark || Gi.flowing && Gi.length === 0); ) {
      var no = Gi.length;
      if (Y("maybeReadMore read 0"), zi.read(0), no === Gi.length)
        break;
    }
    Gi.readingMore = !1;
  }
  Li.prototype._read = function(zi) {
    qi(this, new br("_read()"));
  }, Li.prototype.pipe = function(zi, Gi) {
    var no = this, so = this._readableState;
    switch (so.pipesCount) {
      case 0:
        so.pipes = zi;
        break;
      case 1:
        so.pipes = [so.pipes, zi];
        break;
      default:
        so.pipes.push(zi);
        break;
    }
    so.pipesCount += 1, Y("pipe count=%d opts=%j", so.pipesCount, Gi);
    var ho = (!Gi || Gi.end !== !1) && zi !== process$1$1.stdout && zi !== process$1$1.stderr, uo = ho ? Bo : yo;
    so.endEmitted ? process$1$1.nextTick(uo) : no.once("end", uo), zi.on("unpipe", ao);
    function ao(To, xo) {
      Y("onunpipe"), To === no && xo && xo.hasUnpiped === !1 && (xo.hasUnpiped = !0, Do());
    }
    function Bo() {
      Y("onend"), zi.end();
    }
    var io = Si(no);
    zi.on("drain", io);
    var po = !1;
    function Do() {
      Y("cleanup"), zi.removeListener("close", Ro), zi.removeListener("finish", _o), zi.removeListener("drain", io), zi.removeListener("error", mo), zi.removeListener("unpipe", ao), no.removeListener("end", Bo), no.removeListener("end", yo), no.removeListener("data", Io), po = !0, so.awaitDrain && (!zi._writableState || zi._writableState.needDrain) && io();
    }
    no.on("data", Io);
    function Io(To) {
      Y("ondata");
      var xo = zi.write(To);
      Y("dest.write", xo), xo === !1 && ((so.pipesCount === 1 && so.pipes === zi || so.pipesCount > 1 && to(so.pipes, zi) !== -1) && !po && (Y("false write response, pause", so.awaitDrain), so.awaitDrain++), no.pause());
    }
    function mo(To) {
      Y("onerror", To), yo(), zi.removeListener("error", mo), t(zi, "error") === 0 && qi(zi, To);
    }
    Vi(zi, "error", mo);
    function Ro() {
      zi.removeListener("finish", _o), yo();
    }
    zi.once("close", Ro);
    function _o() {
      Y("onfinish"), zi.removeListener("close", Ro), yo();
    }
    zi.once("finish", _o);
    function yo() {
      Y("unpipe"), no.unpipe(zi);
    }
    return zi.emit("pipe", no), so.flowing || (Y("pipe resume"), no.resume()), zi;
  };
  function Si(zi) {
    return function() {
      var Gi = zi._readableState;
      Y("pipeOnDrain", Gi.awaitDrain), Gi.awaitDrain && Gi.awaitDrain--, Gi.awaitDrain === 0 && t(zi, "data") && (Gi.flowing = !0, Zi(zi));
    };
  }
  Li.prototype.unpipe = function(zi) {
    var Gi = this._readableState, no = {
      hasUnpiped: !1
    };
    if (Gi.pipesCount === 0) return this;
    if (Gi.pipesCount === 1)
      return zi && zi !== Gi.pipes ? this : (zi || (zi = Gi.pipes), Gi.pipes = null, Gi.pipesCount = 0, Gi.flowing = !1, zi && zi.emit("unpipe", this, no), this);
    if (!zi) {
      var so = Gi.pipes, ho = Gi.pipesCount;
      Gi.pipes = null, Gi.pipesCount = 0, Gi.flowing = !1;
      for (var uo = 0; uo < ho; uo++) so[uo].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var ao = to(Gi.pipes, zi);
    return ao === -1 ? this : (Gi.pipes.splice(ao, 1), Gi.pipesCount -= 1, Gi.pipesCount === 1 && (Gi.pipes = Gi.pipes[0]), zi.emit("unpipe", this, no), this);
  }, Li.prototype.on = function(zi, Gi) {
    var no = v.prototype.on.call(this, zi, Gi), so = this._readableState;
    return zi === "data" ? (so.readableListening = this.listenerCount("readable") > 0, so.flowing !== !1 && this.resume()) : zi === "readable" && !so.endEmitted && !so.readableListening && (so.readableListening = so.needReadable = !0, so.flowing = !1, so.emittedReadable = !1, Y("on readable", so.length, so.reading), so.length ? Mi(this) : so.reading || process$1$1.nextTick(Ki, this)), no;
  }, Li.prototype.addListener = Li.prototype.on, Li.prototype.removeListener = function(zi, Gi) {
    var no = v.prototype.removeListener.call(this, zi, Gi);
    return zi === "readable" && process$1$1.nextTick(Ci, this), no;
  }, Li.prototype.removeAllListeners = function(zi) {
    var Gi = v.prototype.removeAllListeners.apply(this, arguments);
    return (zi === "readable" || zi === void 0) && process$1$1.nextTick(Ci, this), Gi;
  };
  function Ci(zi) {
    var Gi = zi._readableState;
    Gi.readableListening = zi.listenerCount("readable") > 0, Gi.resumeScheduled && !Gi.paused ? Gi.flowing = !0 : zi.listenerCount("data") > 0 && zi.resume();
  }
  function Ki(zi) {
    Y("readable nexttick read 0"), zi.read(0);
  }
  Li.prototype.resume = function() {
    var zi = this._readableState;
    return zi.flowing || (Y("resume"), zi.flowing = !zi.readableListening, Yi(this, zi)), zi.paused = !1, this;
  };
  function Yi(zi, Gi) {
    Gi.resumeScheduled || (Gi.resumeScheduled = !0, process$1$1.nextTick(Qi, zi, Gi));
  }
  function Qi(zi, Gi) {
    Y("resume", Gi.reading), Gi.reading || zi.read(0), Gi.resumeScheduled = !1, zi.emit("resume"), Zi(zi), Gi.flowing && !Gi.reading && zi.read(0);
  }
  Li.prototype.pause = function() {
    return Y("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (Y("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function Zi(zi) {
    var Gi = zi._readableState;
    for (Y("flow", Gi.flowing); Gi.flowing && zi.read() !== null; ) ;
  }
  Li.prototype.wrap = function(zi) {
    var Gi = this, no = this._readableState, so = !1;
    zi.on("end", function() {
      if (Y("wrapped end"), no.decoder && !no.ended) {
        var ao = no.decoder.end();
        ao && ao.length && Gi.push(ao);
      }
      Gi.push(null);
    }), zi.on("data", function(ao) {
      if (Y("wrapped data"), no.decoder && (ao = no.decoder.write(ao)), !(no.objectMode && ao == null) && !(!no.objectMode && (!ao || !ao.length))) {
        var Bo = Gi.push(ao);
        Bo || (so = !0, zi.pause());
      }
    });
    for (var ho in zi)
      this[ho] === void 0 && typeof zi[ho] == "function" && (this[ho] = /* @__PURE__ */ function(ao) {
        return function() {
          return zi[ao].apply(zi, arguments);
        };
      }(ho));
    for (var uo = 0; uo < Wi.length; uo++)
      zi.on(Wi[uo], this.emit.bind(this, Wi[uo]));
    return this._read = function(ao) {
      Y("wrapped _read", ao), so && (so = !1, zi.resume());
    }, this;
  }, typeof Symbol == "function" && (Li.prototype[Symbol.asyncIterator] = function() {
    return _r === void 0 && (_r = requireAsync_iterator()), _r(this);
  }), Object.defineProperty(Li.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(Li.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(Li.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(zi) {
      this._readableState && (this._readableState.flowing = zi);
    }
  }), Li._fromList = Ni, Object.defineProperty(Li.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Ni(zi, Gi) {
    if (Gi.length === 0) return null;
    var no;
    return Gi.objectMode ? no = Gi.buffer.shift() : !zi || zi >= Gi.length ? (Gi.decoder ? no = Gi.buffer.join("") : Gi.buffer.length === 1 ? no = Gi.buffer.first() : no = Gi.buffer.concat(Gi.length), Gi.buffer.clear()) : no = Gi.buffer.consume(zi, Gi.decoder), no;
  }
  function Fi(zi) {
    var Gi = zi._readableState;
    Y("endReadable", Gi.endEmitted), Gi.endEmitted || (Gi.ended = !0, process$1$1.nextTick(Xi, Gi, zi));
  }
  function Xi(zi, Gi) {
    if (Y("endReadableNT", zi.endEmitted, zi.length), !zi.endEmitted && zi.length === 0 && (zi.endEmitted = !0, Gi.readable = !1, Gi.emit("end"), zi.autoDestroy)) {
      var no = Gi._writableState;
      (!no || no.autoDestroy && no.finished) && Gi.destroy();
    }
  }
  typeof Symbol == "function" && (Li.from = function(zi, Gi) {
    return Bi === void 0 && (Bi = requireFromBrowser()), Bi(Li, zi, Gi);
  });
  function to(zi, Gi) {
    for (var no = 0, so = zi.length; no < so; no++)
      if (zi[no] === Gi) return no;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform$1;
  hasRequired_stream_transform = 1, _stream_transform$1 = D;
  var e = requireErrorsBrowser().codes, t = e.ERR_METHOD_NOT_IMPLEMENTED, v = e.ERR_MULTIPLE_CALLBACK, w = e.ERR_TRANSFORM_ALREADY_TRANSFORMING, T = e.ERR_TRANSFORM_WITH_LENGTH_0, x = require_stream_duplex$1();
  inherits_browserExports(D, x);
  function C(q, N) {
    var F = this._transformState;
    F.transforming = !1;
    var ae = F.writecb;
    if (ae === null)
      return this.emit("error", new v());
    F.writechunk = null, F.writecb = null, N != null && this.push(N), ae(q);
    var he = this._readableState;
    he.reading = !1, (he.needReadable || he.length < he.highWaterMark) && this._read(he.highWaterMark);
  }
  function D(q) {
    if (!(this instanceof D)) return new D(q);
    x.call(this, q), this._transformState = {
      afterTransform: C.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, q && (typeof q.transform == "function" && (this._transform = q.transform), typeof q.flush == "function" && (this._flush = q.flush)), this.on("prefinish", Y);
  }
  function Y() {
    var q = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(N, F) {
      L(q, N, F);
    }) : L(this, null, null);
  }
  D.prototype.push = function(q, N) {
    return this._transformState.needTransform = !1, x.prototype.push.call(this, q, N);
  }, D.prototype._transform = function(q, N, F) {
    F(new t("_transform()"));
  }, D.prototype._write = function(q, N, F) {
    var ae = this._transformState;
    if (ae.writecb = F, ae.writechunk = q, ae.writeencoding = N, !ae.transforming) {
      var he = this._readableState;
      (ae.needTransform || he.needReadable || he.length < he.highWaterMark) && this._read(he.highWaterMark);
    }
  }, D.prototype._read = function(q) {
    var N = this._transformState;
    N.writechunk !== null && !N.transforming ? (N.transforming = !0, this._transform(N.writechunk, N.writeencoding, N.afterTransform)) : N.needTransform = !0;
  }, D.prototype._destroy = function(q, N) {
    x.prototype._destroy.call(this, q, function(F) {
      N(F);
    });
  };
  function L(q, N, F) {
    if (N) return q.emit("error", N);
    if (F != null && q.push(F), q._writableState.length) throw new T();
    if (q._transformState.transforming) throw new w();
    return q.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough$1;
  hasRequired_stream_passthrough = 1, _stream_passthrough$1 = t;
  var e = require_stream_transform();
  inherits_browserExports(t, e);
  function t(v) {
    if (!(this instanceof t)) return new t(v);
    e.call(this, v);
  }
  return t.prototype._transform = function(v, w, T) {
    T(null, v);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var e;
  function t(F) {
    var ae = !1;
    return function() {
      ae || (ae = !0, F.apply(void 0, arguments));
    };
  }
  var v = requireErrorsBrowser().codes, w = v.ERR_MISSING_ARGS, T = v.ERR_STREAM_DESTROYED;
  function x(F) {
    if (F) throw F;
  }
  function C(F) {
    return F.setHeader && typeof F.abort == "function";
  }
  function D(F, ae, he, tt) {
    tt = t(tt);
    var br = !1;
    F.on("close", function() {
      br = !0;
    }), e === void 0 && (e = requireEndOfStream()), e(F, {
      readable: ae,
      writable: he
    }, function(dr) {
      if (dr) return tt(dr);
      br = !0, tt();
    });
    var rt = !1;
    return function(dr) {
      if (!br && !rt) {
        if (rt = !0, C(F)) return F.abort();
        if (typeof F.destroy == "function") return F.destroy();
        tt(dr || new T("pipe"));
      }
    };
  }
  function Y(F) {
    F();
  }
  function L(F, ae) {
    return F.pipe(ae);
  }
  function q(F) {
    return !F.length || typeof F[F.length - 1] != "function" ? x : F.pop();
  }
  function N() {
    for (var F = arguments.length, ae = new Array(F), he = 0; he < F; he++)
      ae[he] = arguments[he];
    var tt = q(ae);
    if (Array.isArray(ae[0]) && (ae = ae[0]), ae.length < 2)
      throw new w("streams");
    var br, rt = ae.map(function(dr, _r) {
      var Bi = _r < ae.length - 1, qi = _r > 0;
      return D(dr, Bi, qi, function(Wi) {
        br || (br = Wi), Wi && rt.forEach(Y), !Bi && (rt.forEach(Y), tt(br));
      });
    });
    return ae.reduce(L);
  }
  return pipeline_1 = N, pipeline_1;
}
var streamBrowserify = Stream, EE = eventsExports.EventEmitter, inherits$q = inherits_browserExports;
inherits$q(Stream, EE);
Stream.Readable = require_stream_readable$1();
Stream.Writable = require_stream_writable$1();
Stream.Duplex = require_stream_duplex$1();
Stream.Transform = require_stream_transform();
Stream.PassThrough = require_stream_passthrough();
Stream.finished = requireEndOfStream();
Stream.pipeline = requirePipeline();
Stream.Stream = Stream;
function Stream() {
  EE.call(this);
}
Stream.prototype.pipe = function(e, t) {
  var v = this;
  function w(q) {
    e.writable && e.write(q) === !1 && v.pause && v.pause();
  }
  v.on("data", w);
  function T() {
    v.readable && v.resume && v.resume();
  }
  e.on("drain", T), !e._isStdio && (!t || t.end !== !1) && (v.on("end", C), v.on("close", D));
  var x = !1;
  function C() {
    x || (x = !0, e.end());
  }
  function D() {
    x || (x = !0, typeof e.destroy == "function" && e.destroy());
  }
  function Y(q) {
    if (L(), EE.listenerCount(this, "error") === 0)
      throw q;
  }
  v.on("error", Y), e.on("error", Y);
  function L() {
    v.removeListener("data", w), e.removeListener("drain", T), v.removeListener("end", C), v.removeListener("close", D), v.removeListener("error", Y), e.removeListener("error", Y), v.removeListener("end", L), v.removeListener("close", L), e.removeListener("close", L);
  }
  return v.on("end", L), v.on("close", L), e.on("close", L), e.emit("pipe", v), e;
};
var Buffer$z = safeBufferExports$1.Buffer, Transform$7 = streamBrowserify.Transform, inherits$p = inherits_browserExports;
function HashBase$2(e) {
  Transform$7.call(this), this._block = Buffer$z.allocUnsafe(e), this._blockSize = e, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
inherits$p(HashBase$2, Transform$7);
HashBase$2.prototype._transform = function(e, t, v) {
  var w = null;
  try {
    this.update(e, t);
  } catch (T) {
    w = T;
  }
  v(w);
};
HashBase$2.prototype._flush = function(e) {
  var t = null;
  try {
    this.push(this.digest());
  } catch (v) {
    t = v;
  }
  e(t);
};
var useUint8Array$1 = typeof Uint8Array < "u", useArrayBuffer$1 = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (Buffer$z.prototype instanceof Uint8Array || Buffer$z.TYPED_ARRAY_SUPPORT);
function toBuffer$4(e, t) {
  if (e instanceof Buffer$z) return e;
  if (typeof e == "string") return Buffer$z.from(e, t);
  if (useArrayBuffer$1 && ArrayBuffer.isView(e)) {
    if (e.byteLength === 0) return Buffer$z.alloc(0);
    var v = Buffer$z.from(e.buffer, e.byteOffset, e.byteLength);
    if (v.byteLength === e.byteLength) return v;
  }
  if (useUint8Array$1 && e instanceof Uint8Array || Buffer$z.isBuffer(e) && e.constructor && typeof e.constructor.isBuffer == "function" && e.constructor.isBuffer(e))
    return Buffer$z.from(e);
  throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
}
HashBase$2.prototype.update = function(e, t) {
  if (this._finalized) throw new Error("Digest already called");
  e = toBuffer$4(e, t);
  for (var v = this._block, w = 0; this._blockOffset + e.length - w >= this._blockSize; ) {
    for (var T = this._blockOffset; T < this._blockSize; ) v[T++] = e[w++];
    this._update(), this._blockOffset = 0;
  }
  for (; w < e.length; ) v[this._blockOffset++] = e[w++];
  for (var x = 0, C = e.length * 8; C > 0; ++x)
    this._length[x] += C, C = this._length[x] / 4294967296 | 0, C > 0 && (this._length[x] -= 4294967296 * C);
  return this;
};
HashBase$2.prototype._update = function() {
  throw new Error("_update is not implemented");
};
HashBase$2.prototype.digest = function(e) {
  if (this._finalized) throw new Error("Digest already called");
  this._finalized = !0;
  var t = this._digest();
  e !== void 0 && (t = t.toString(e)), this._block.fill(0), this._blockOffset = 0;
  for (var v = 0; v < 4; ++v) this._length[v] = 0;
  return t;
};
HashBase$2.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var hashBase = HashBase$2, inherits$o = inherits_browserExports, HashBase$1 = hashBase, Buffer$y = safeBufferExports$1.Buffer, ARRAY16$1 = new Array(16);
function MD5$3() {
  HashBase$1.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
inherits$o(MD5$3, HashBase$1);
MD5$3.prototype._update = function() {
  for (var e = ARRAY16$1, t = 0; t < 16; ++t) e[t] = this._block.readInt32LE(t * 4);
  var v = this._a, w = this._b, T = this._c, x = this._d;
  v = fnF(v, w, T, x, e[0], 3614090360, 7), x = fnF(x, v, w, T, e[1], 3905402710, 12), T = fnF(T, x, v, w, e[2], 606105819, 17), w = fnF(w, T, x, v, e[3], 3250441966, 22), v = fnF(v, w, T, x, e[4], 4118548399, 7), x = fnF(x, v, w, T, e[5], 1200080426, 12), T = fnF(T, x, v, w, e[6], 2821735955, 17), w = fnF(w, T, x, v, e[7], 4249261313, 22), v = fnF(v, w, T, x, e[8], 1770035416, 7), x = fnF(x, v, w, T, e[9], 2336552879, 12), T = fnF(T, x, v, w, e[10], 4294925233, 17), w = fnF(w, T, x, v, e[11], 2304563134, 22), v = fnF(v, w, T, x, e[12], 1804603682, 7), x = fnF(x, v, w, T, e[13], 4254626195, 12), T = fnF(T, x, v, w, e[14], 2792965006, 17), w = fnF(w, T, x, v, e[15], 1236535329, 22), v = fnG(v, w, T, x, e[1], 4129170786, 5), x = fnG(x, v, w, T, e[6], 3225465664, 9), T = fnG(T, x, v, w, e[11], 643717713, 14), w = fnG(w, T, x, v, e[0], 3921069994, 20), v = fnG(v, w, T, x, e[5], 3593408605, 5), x = fnG(x, v, w, T, e[10], 38016083, 9), T = fnG(T, x, v, w, e[15], 3634488961, 14), w = fnG(w, T, x, v, e[4], 3889429448, 20), v = fnG(v, w, T, x, e[9], 568446438, 5), x = fnG(x, v, w, T, e[14], 3275163606, 9), T = fnG(T, x, v, w, e[3], 4107603335, 14), w = fnG(w, T, x, v, e[8], 1163531501, 20), v = fnG(v, w, T, x, e[13], 2850285829, 5), x = fnG(x, v, w, T, e[2], 4243563512, 9), T = fnG(T, x, v, w, e[7], 1735328473, 14), w = fnG(w, T, x, v, e[12], 2368359562, 20), v = fnH(v, w, T, x, e[5], 4294588738, 4), x = fnH(x, v, w, T, e[8], 2272392833, 11), T = fnH(T, x, v, w, e[11], 1839030562, 16), w = fnH(w, T, x, v, e[14], 4259657740, 23), v = fnH(v, w, T, x, e[1], 2763975236, 4), x = fnH(x, v, w, T, e[4], 1272893353, 11), T = fnH(T, x, v, w, e[7], 4139469664, 16), w = fnH(w, T, x, v, e[10], 3200236656, 23), v = fnH(v, w, T, x, e[13], 681279174, 4), x = fnH(x, v, w, T, e[0], 3936430074, 11), T = fnH(T, x, v, w, e[3], 3572445317, 16), w = fnH(w, T, x, v, e[6], 76029189, 23), v = fnH(v, w, T, x, e[9], 3654602809, 4), x = fnH(x, v, w, T, e[12], 3873151461, 11), T = fnH(T, x, v, w, e[15], 530742520, 16), w = fnH(w, T, x, v, e[2], 3299628645, 23), v = fnI(v, w, T, x, e[0], 4096336452, 6), x = fnI(x, v, w, T, e[7], 1126891415, 10), T = fnI(T, x, v, w, e[14], 2878612391, 15), w = fnI(w, T, x, v, e[5], 4237533241, 21), v = fnI(v, w, T, x, e[12], 1700485571, 6), x = fnI(x, v, w, T, e[3], 2399980690, 10), T = fnI(T, x, v, w, e[10], 4293915773, 15), w = fnI(w, T, x, v, e[1], 2240044497, 21), v = fnI(v, w, T, x, e[8], 1873313359, 6), x = fnI(x, v, w, T, e[15], 4264355552, 10), T = fnI(T, x, v, w, e[6], 2734768916, 15), w = fnI(w, T, x, v, e[13], 1309151649, 21), v = fnI(v, w, T, x, e[4], 4149444226, 6), x = fnI(x, v, w, T, e[11], 3174756917, 10), T = fnI(T, x, v, w, e[2], 718787259, 15), w = fnI(w, T, x, v, e[9], 3951481745, 21), this._a = this._a + v | 0, this._b = this._b + w | 0, this._c = this._c + T | 0, this._d = this._d + x | 0;
};
MD5$3.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var e = Buffer$y.allocUnsafe(16);
  return e.writeInt32LE(this._a, 0), e.writeInt32LE(this._b, 4), e.writeInt32LE(this._c, 8), e.writeInt32LE(this._d, 12), e;
};
function rotl$1(e, t) {
  return e << t | e >>> 32 - t;
}
function fnF(e, t, v, w, T, x, C) {
  return rotl$1(e + (t & v | ~t & w) + T + x | 0, C) + t | 0;
}
function fnG(e, t, v, w, T, x, C) {
  return rotl$1(e + (t & w | v & ~w) + T + x | 0, C) + t | 0;
}
function fnH(e, t, v, w, T, x, C) {
  return rotl$1(e + (t ^ v ^ w) + T + x | 0, C) + t | 0;
}
function fnI(e, t, v, w, T, x, C) {
  return rotl$1(e + (v ^ (t | ~w)) + T + x | 0, C) + t | 0;
}
var md5_js = MD5$3, Buffer$x = require$$1$2.Buffer, inherits$n = inherits_browserExports, HashBase = hashBase, ARRAY16 = new Array(16), zl = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], zr = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], sl = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sr = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], hl = [0, 1518500249, 1859775393, 2400959708, 2840853838], hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function RIPEMD160$4() {
  HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
inherits$n(RIPEMD160$4, HashBase);
RIPEMD160$4.prototype._update = function() {
  for (var e = ARRAY16, t = 0; t < 16; ++t) e[t] = this._block.readInt32LE(t * 4);
  for (var v = this._a | 0, w = this._b | 0, T = this._c | 0, x = this._d | 0, C = this._e | 0, D = this._a | 0, Y = this._b | 0, L = this._c | 0, q = this._d | 0, N = this._e | 0, F = 0; F < 80; F += 1) {
    var ae, he;
    F < 16 ? (ae = fn1(v, w, T, x, C, e[zl[F]], hl[0], sl[F]), he = fn5(D, Y, L, q, N, e[zr[F]], hr[0], sr[F])) : F < 32 ? (ae = fn2(v, w, T, x, C, e[zl[F]], hl[1], sl[F]), he = fn4(D, Y, L, q, N, e[zr[F]], hr[1], sr[F])) : F < 48 ? (ae = fn3(v, w, T, x, C, e[zl[F]], hl[2], sl[F]), he = fn3(D, Y, L, q, N, e[zr[F]], hr[2], sr[F])) : F < 64 ? (ae = fn4(v, w, T, x, C, e[zl[F]], hl[3], sl[F]), he = fn2(D, Y, L, q, N, e[zr[F]], hr[3], sr[F])) : (ae = fn5(v, w, T, x, C, e[zl[F]], hl[4], sl[F]), he = fn1(D, Y, L, q, N, e[zr[F]], hr[4], sr[F])), v = C, C = x, x = rotl(T, 10), T = w, w = ae, D = N, N = q, q = rotl(L, 10), L = Y, Y = he;
  }
  var tt = this._b + T + q | 0;
  this._b = this._c + x + N | 0, this._c = this._d + C + D | 0, this._d = this._e + v + Y | 0, this._e = this._a + w + L | 0, this._a = tt;
};
RIPEMD160$4.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var e = Buffer$x.alloc ? Buffer$x.alloc(20) : new Buffer$x(20);
  return e.writeInt32LE(this._a, 0), e.writeInt32LE(this._b, 4), e.writeInt32LE(this._c, 8), e.writeInt32LE(this._d, 12), e.writeInt32LE(this._e, 16), e;
};
function rotl(e, t) {
  return e << t | e >>> 32 - t;
}
function fn1(e, t, v, w, T, x, C, D) {
  return rotl(e + (t ^ v ^ w) + x + C | 0, D) + T | 0;
}
function fn2(e, t, v, w, T, x, C, D) {
  return rotl(e + (t & v | ~t & w) + x + C | 0, D) + T | 0;
}
function fn3(e, t, v, w, T, x, C, D) {
  return rotl(e + ((t | ~v) ^ w) + x + C | 0, D) + T | 0;
}
function fn4(e, t, v, w, T, x, C, D) {
  return rotl(e + (t & w | v & ~w) + x + C | 0, D) + T | 0;
}
function fn5(e, t, v, w, T, x, C, D) {
  return rotl(e + (t ^ (v | ~w)) + x + C | 0, D) + T | 0;
}
var ripemd160 = RIPEMD160$4, sha_js = { exports: {} }, Buffer$w = safeBufferExports$1.Buffer;
function Hash$7(e, t) {
  this._block = Buffer$w.alloc(e), this._finalSize = t, this._blockSize = e, this._len = 0;
}
Hash$7.prototype.update = function(e, t) {
  typeof e == "string" && (t = t || "utf8", e = Buffer$w.from(e, t));
  for (var v = this._block, w = this._blockSize, T = e.length, x = this._len, C = 0; C < T; ) {
    for (var D = x % w, Y = Math.min(T - C, w - D), L = 0; L < Y; L++)
      v[D + L] = e[C + L];
    x += Y, C += Y, x % w === 0 && this._update(v);
  }
  return this._len += T, this;
};
Hash$7.prototype.digest = function(e) {
  var t = this._len % this._blockSize;
  this._block[t] = 128, this._block.fill(0, t + 1), t >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var v = this._len * 8;
  if (v <= 4294967295)
    this._block.writeUInt32BE(v, this._blockSize - 4);
  else {
    var w = (v & 4294967295) >>> 0, T = (v - w) / 4294967296;
    this._block.writeUInt32BE(T, this._blockSize - 8), this._block.writeUInt32BE(w, this._blockSize - 4);
  }
  this._update(this._block);
  var x = this._hash();
  return e ? x.toString(e) : x;
};
Hash$7.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var hash$3 = Hash$7, inherits$m = inherits_browserExports, Hash$6 = hash$3, Buffer$v = safeBufferExports$1.Buffer, K$4 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$5 = new Array(80);
function Sha() {
  this.init(), this._w = W$5, Hash$6.call(this, 64, 56);
}
inherits$m(Sha, Hash$6);
Sha.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl5$1(e) {
  return e << 5 | e >>> 27;
}
function rotl30$1(e) {
  return e << 30 | e >>> 2;
}
function ft$1(e, t, v, w) {
  return e === 0 ? t & v | ~t & w : e === 2 ? t & v | t & w | v & w : t ^ v ^ w;
}
Sha.prototype._update = function(e) {
  for (var t = this._w, v = this._a | 0, w = this._b | 0, T = this._c | 0, x = this._d | 0, C = this._e | 0, D = 0; D < 16; ++D) t[D] = e.readInt32BE(D * 4);
  for (; D < 80; ++D) t[D] = t[D - 3] ^ t[D - 8] ^ t[D - 14] ^ t[D - 16];
  for (var Y = 0; Y < 80; ++Y) {
    var L = ~~(Y / 20), q = rotl5$1(v) + ft$1(L, w, T, x) + C + t[Y] + K$4[L] | 0;
    C = x, x = T, T = rotl30$1(w), w = v, v = q;
  }
  this._a = v + this._a | 0, this._b = w + this._b | 0, this._c = T + this._c | 0, this._d = x + this._d | 0, this._e = C + this._e | 0;
};
Sha.prototype._hash = function() {
  var e = Buffer$v.allocUnsafe(20);
  return e.writeInt32BE(this._a | 0, 0), e.writeInt32BE(this._b | 0, 4), e.writeInt32BE(this._c | 0, 8), e.writeInt32BE(this._d | 0, 12), e.writeInt32BE(this._e | 0, 16), e;
};
var sha$4 = Sha, inherits$l = inherits_browserExports, Hash$5 = hash$3, Buffer$u = safeBufferExports$1.Buffer, K$3 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$4 = new Array(80);
function Sha1() {
  this.init(), this._w = W$4, Hash$5.call(this, 64, 56);
}
inherits$l(Sha1, Hash$5);
Sha1.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl1(e) {
  return e << 1 | e >>> 31;
}
function rotl5(e) {
  return e << 5 | e >>> 27;
}
function rotl30(e) {
  return e << 30 | e >>> 2;
}
function ft(e, t, v, w) {
  return e === 0 ? t & v | ~t & w : e === 2 ? t & v | t & w | v & w : t ^ v ^ w;
}
Sha1.prototype._update = function(e) {
  for (var t = this._w, v = this._a | 0, w = this._b | 0, T = this._c | 0, x = this._d | 0, C = this._e | 0, D = 0; D < 16; ++D) t[D] = e.readInt32BE(D * 4);
  for (; D < 80; ++D) t[D] = rotl1(t[D - 3] ^ t[D - 8] ^ t[D - 14] ^ t[D - 16]);
  for (var Y = 0; Y < 80; ++Y) {
    var L = ~~(Y / 20), q = rotl5(v) + ft(L, w, T, x) + C + t[Y] + K$3[L] | 0;
    C = x, x = T, T = rotl30(w), w = v, v = q;
  }
  this._a = v + this._a | 0, this._b = w + this._b | 0, this._c = T + this._c | 0, this._d = x + this._d | 0, this._e = C + this._e | 0;
};
Sha1.prototype._hash = function() {
  var e = Buffer$u.allocUnsafe(20);
  return e.writeInt32BE(this._a | 0, 0), e.writeInt32BE(this._b | 0, 4), e.writeInt32BE(this._c | 0, 8), e.writeInt32BE(this._d | 0, 12), e.writeInt32BE(this._e | 0, 16), e;
};
var sha1 = Sha1, inherits$k = inherits_browserExports, Hash$4 = hash$3, Buffer$t = safeBufferExports$1.Buffer, K$2 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], W$3 = new Array(64);
function Sha256$1() {
  this.init(), this._w = W$3, Hash$4.call(this, 64, 56);
}
inherits$k(Sha256$1, Hash$4);
Sha256$1.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function ch(e, t, v) {
  return v ^ e & (t ^ v);
}
function maj$1(e, t, v) {
  return e & t | v & (e | t);
}
function sigma0$1(e) {
  return (e >>> 2 | e << 30) ^ (e >>> 13 | e << 19) ^ (e >>> 22 | e << 10);
}
function sigma1$1(e) {
  return (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
}
function gamma0(e) {
  return (e >>> 7 | e << 25) ^ (e >>> 18 | e << 14) ^ e >>> 3;
}
function gamma1(e) {
  return (e >>> 17 | e << 15) ^ (e >>> 19 | e << 13) ^ e >>> 10;
}
Sha256$1.prototype._update = function(e) {
  for (var t = this._w, v = this._a | 0, w = this._b | 0, T = this._c | 0, x = this._d | 0, C = this._e | 0, D = this._f | 0, Y = this._g | 0, L = this._h | 0, q = 0; q < 16; ++q) t[q] = e.readInt32BE(q * 4);
  for (; q < 64; ++q) t[q] = gamma1(t[q - 2]) + t[q - 7] + gamma0(t[q - 15]) + t[q - 16] | 0;
  for (var N = 0; N < 64; ++N) {
    var F = L + sigma1$1(C) + ch(C, D, Y) + K$2[N] + t[N] | 0, ae = sigma0$1(v) + maj$1(v, w, T) | 0;
    L = Y, Y = D, D = C, C = x + F | 0, x = T, T = w, w = v, v = F + ae | 0;
  }
  this._a = v + this._a | 0, this._b = w + this._b | 0, this._c = T + this._c | 0, this._d = x + this._d | 0, this._e = C + this._e | 0, this._f = D + this._f | 0, this._g = Y + this._g | 0, this._h = L + this._h | 0;
};
Sha256$1.prototype._hash = function() {
  var e = Buffer$t.allocUnsafe(32);
  return e.writeInt32BE(this._a, 0), e.writeInt32BE(this._b, 4), e.writeInt32BE(this._c, 8), e.writeInt32BE(this._d, 12), e.writeInt32BE(this._e, 16), e.writeInt32BE(this._f, 20), e.writeInt32BE(this._g, 24), e.writeInt32BE(this._h, 28), e;
};
var sha256$1 = Sha256$1, inherits$j = inherits_browserExports, Sha256 = sha256$1, Hash$3 = hash$3, Buffer$s = safeBufferExports$1.Buffer, W$2 = new Array(64);
function Sha224() {
  this.init(), this._w = W$2, Hash$3.call(this, 64, 56);
}
inherits$j(Sha224, Sha256);
Sha224.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
Sha224.prototype._hash = function() {
  var e = Buffer$s.allocUnsafe(28);
  return e.writeInt32BE(this._a, 0), e.writeInt32BE(this._b, 4), e.writeInt32BE(this._c, 8), e.writeInt32BE(this._d, 12), e.writeInt32BE(this._e, 16), e.writeInt32BE(this._f, 20), e.writeInt32BE(this._g, 24), e;
};
var sha224$1 = Sha224, inherits$i = inherits_browserExports, Hash$2 = hash$3, Buffer$r = safeBufferExports$1.Buffer, K$1 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], W$1 = new Array(160);
function Sha512() {
  this.init(), this._w = W$1, Hash$2.call(this, 128, 112);
}
inherits$i(Sha512, Hash$2);
Sha512.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function Ch(e, t, v) {
  return v ^ e & (t ^ v);
}
function maj(e, t, v) {
  return e & t | v & (e | t);
}
function sigma0(e, t) {
  return (e >>> 28 | t << 4) ^ (t >>> 2 | e << 30) ^ (t >>> 7 | e << 25);
}
function sigma1(e, t) {
  return (e >>> 14 | t << 18) ^ (e >>> 18 | t << 14) ^ (t >>> 9 | e << 23);
}
function Gamma0(e, t) {
  return (e >>> 1 | t << 31) ^ (e >>> 8 | t << 24) ^ e >>> 7;
}
function Gamma0l(e, t) {
  return (e >>> 1 | t << 31) ^ (e >>> 8 | t << 24) ^ (e >>> 7 | t << 25);
}
function Gamma1(e, t) {
  return (e >>> 19 | t << 13) ^ (t >>> 29 | e << 3) ^ e >>> 6;
}
function Gamma1l(e, t) {
  return (e >>> 19 | t << 13) ^ (t >>> 29 | e << 3) ^ (e >>> 6 | t << 26);
}
function getCarry(e, t) {
  return e >>> 0 < t >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(e) {
  for (var t = this._w, v = this._ah | 0, w = this._bh | 0, T = this._ch | 0, x = this._dh | 0, C = this._eh | 0, D = this._fh | 0, Y = this._gh | 0, L = this._hh | 0, q = this._al | 0, N = this._bl | 0, F = this._cl | 0, ae = this._dl | 0, he = this._el | 0, tt = this._fl | 0, br = this._gl | 0, rt = this._hl | 0, dr = 0; dr < 32; dr += 2)
    t[dr] = e.readInt32BE(dr * 4), t[dr + 1] = e.readInt32BE(dr * 4 + 4);
  for (; dr < 160; dr += 2) {
    var _r = t[dr - 30], Bi = t[dr - 15 * 2 + 1], qi = Gamma0(_r, Bi), Wi = Gamma0l(Bi, _r);
    _r = t[dr - 2 * 2], Bi = t[dr - 2 * 2 + 1];
    var Vi = Gamma1(_r, Bi), Ti = Gamma1l(Bi, _r), Li = t[dr - 7 * 2], Hi = t[dr - 7 * 2 + 1], pr = t[dr - 16 * 2], Di = t[dr - 16 * 2 + 1], z = Wi + Hi | 0, gr = qi + Li + getCarry(z, Wi) | 0;
    z = z + Ti | 0, gr = gr + Vi + getCarry(z, Ti) | 0, z = z + Di | 0, gr = gr + pr + getCarry(z, Di) | 0, t[dr] = gr, t[dr + 1] = z;
  }
  for (var vr = 0; vr < 160; vr += 2) {
    gr = t[vr], z = t[vr + 1];
    var Oi = maj(v, w, T), Mi = maj(q, N, F), ki = sigma0(v, q), yr = sigma0(q, v), xi = sigma1(C, he), Si = sigma1(he, C), Ci = K$1[vr], Ki = K$1[vr + 1], Yi = Ch(C, D, Y), Qi = Ch(he, tt, br), Zi = rt + Si | 0, Ni = L + xi + getCarry(Zi, rt) | 0;
    Zi = Zi + Qi | 0, Ni = Ni + Yi + getCarry(Zi, Qi) | 0, Zi = Zi + Ki | 0, Ni = Ni + Ci + getCarry(Zi, Ki) | 0, Zi = Zi + z | 0, Ni = Ni + gr + getCarry(Zi, z) | 0;
    var Fi = yr + Mi | 0, Xi = ki + Oi + getCarry(Fi, yr) | 0;
    L = Y, rt = br, Y = D, br = tt, D = C, tt = he, he = ae + Zi | 0, C = x + Ni + getCarry(he, ae) | 0, x = T, ae = F, T = w, F = N, w = v, N = q, q = Zi + Fi | 0, v = Ni + Xi + getCarry(q, Zi) | 0;
  }
  this._al = this._al + q | 0, this._bl = this._bl + N | 0, this._cl = this._cl + F | 0, this._dl = this._dl + ae | 0, this._el = this._el + he | 0, this._fl = this._fl + tt | 0, this._gl = this._gl + br | 0, this._hl = this._hl + rt | 0, this._ah = this._ah + v + getCarry(this._al, q) | 0, this._bh = this._bh + w + getCarry(this._bl, N) | 0, this._ch = this._ch + T + getCarry(this._cl, F) | 0, this._dh = this._dh + x + getCarry(this._dl, ae) | 0, this._eh = this._eh + C + getCarry(this._el, he) | 0, this._fh = this._fh + D + getCarry(this._fl, tt) | 0, this._gh = this._gh + Y + getCarry(this._gl, br) | 0, this._hh = this._hh + L + getCarry(this._hl, rt) | 0;
};
Sha512.prototype._hash = function() {
  var e = Buffer$r.allocUnsafe(64);
  function t(v, w, T) {
    e.writeInt32BE(v, T), e.writeInt32BE(w, T + 4);
  }
  return t(this._ah, this._al, 0), t(this._bh, this._bl, 8), t(this._ch, this._cl, 16), t(this._dh, this._dl, 24), t(this._eh, this._el, 32), t(this._fh, this._fl, 40), t(this._gh, this._gl, 48), t(this._hh, this._hl, 56), e;
};
var sha512$1 = Sha512, inherits$h = inherits_browserExports, SHA512$2 = sha512$1, Hash$1 = hash$3, Buffer$q = safeBufferExports$1.Buffer, W = new Array(160);
function Sha384() {
  this.init(), this._w = W, Hash$1.call(this, 128, 112);
}
inherits$h(Sha384, SHA512$2);
Sha384.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
Sha384.prototype._hash = function() {
  var e = Buffer$q.allocUnsafe(48);
  function t(v, w, T) {
    e.writeInt32BE(v, T), e.writeInt32BE(w, T + 4);
  }
  return t(this._ah, this._al, 0), t(this._bh, this._bl, 8), t(this._ch, this._cl, 16), t(this._dh, this._dl, 24), t(this._eh, this._el, 32), t(this._fh, this._fl, 40), e;
};
var sha384$1 = Sha384;
sha_js.exports;
var exports = sha_js.exports = function(e) {
  e = e.toLowerCase();
  var t = exports[e];
  if (!t) throw new Error(e + " is not supported (we accept pull requests)");
  return new t();
};
exports.sha = sha$4;
exports.sha1 = sha1;
exports.sha224 = sha224$1;
exports.sha256 = sha256$1;
exports.sha384 = sha384$1;
exports.sha512 = sha512$1;
var sha_jsExports = sha_js.exports, Buffer$p = safeBufferExports$1.Buffer, Transform$6 = streamBrowserify.Transform, StringDecoder = string_decoder.StringDecoder, inherits$g = inherits_browserExports;
function CipherBase$1(e) {
  Transform$6.call(this), this.hashMode = typeof e == "string", this.hashMode ? this[e] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
inherits$g(CipherBase$1, Transform$6);
var useUint8Array = typeof Uint8Array < "u", useArrayBuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (Buffer$p.prototype instanceof Uint8Array || Buffer$p.TYPED_ARRAY_SUPPORT);
function toBuffer$3(e, t) {
  if (e instanceof Buffer$p)
    return e;
  if (typeof e == "string")
    return Buffer$p.from(e, t);
  if (useArrayBuffer && ArrayBuffer.isView(e)) {
    if (e.byteLength === 0)
      return Buffer$p.alloc(0);
    var v = Buffer$p.from(e.buffer, e.byteOffset, e.byteLength);
    if (v.byteLength === e.byteLength)
      return v;
  }
  if (useUint8Array && e instanceof Uint8Array || Buffer$p.isBuffer(e) && e.constructor && typeof e.constructor.isBuffer == "function" && e.constructor.isBuffer(e))
    return Buffer$p.from(e);
  throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
}
CipherBase$1.prototype.update = function(e, t, v) {
  var w = toBuffer$3(e, t), T = this._update(w);
  return this.hashMode ? this : (v && (T = this._toString(T, v)), T);
};
CipherBase$1.prototype.setAutoPadding = function() {
};
CipherBase$1.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
CipherBase$1.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
CipherBase$1.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
CipherBase$1.prototype._transform = function(e, t, v) {
  var w;
  try {
    this.hashMode ? this._update(e) : this.push(this._update(e));
  } catch (T) {
    w = T;
  } finally {
    v(w);
  }
};
CipherBase$1.prototype._flush = function(e) {
  var t;
  try {
    this.push(this.__final());
  } catch (v) {
    t = v;
  }
  e(t);
};
CipherBase$1.prototype._finalOrDigest = function(e) {
  var t = this.__final() || Buffer$p.alloc(0);
  return e && (t = this._toString(t, e, !0)), t;
};
CipherBase$1.prototype._toString = function(e, t, v) {
  if (this._decoder || (this._decoder = new StringDecoder(t), this._encoding = t), this._encoding !== t)
    throw new Error("can’t switch encodings");
  var w = this._decoder.write(e);
  return v && (w += this._decoder.end()), w;
};
var cipherBase = CipherBase$1, inherits$f = inherits_browserExports, MD5$2 = md5_js, RIPEMD160$3 = ripemd160, sha$3 = sha_jsExports, Base$5 = cipherBase;
function Hash(e) {
  Base$5.call(this, "digest"), this._hash = e;
}
inherits$f(Hash, Base$5);
Hash.prototype._update = function(e) {
  this._hash.update(e);
};
Hash.prototype._final = function() {
  return this._hash.digest();
};
var browser$9 = function(e) {
  return e = e.toLowerCase(), e === "md5" ? new MD5$2() : e === "rmd160" || e === "ripemd160" ? new RIPEMD160$3() : new Hash(sha$3(e));
}, inherits$e = inherits_browserExports, Buffer$o = safeBufferExports$1.Buffer, Base$4 = cipherBase, ZEROS$2 = Buffer$o.alloc(128), blocksize = 64;
function Hmac$4(e, t) {
  Base$4.call(this, "digest"), typeof t == "string" && (t = Buffer$o.from(t)), this._alg = e, this._key = t, t.length > blocksize ? t = e(t) : t.length < blocksize && (t = Buffer$o.concat([t, ZEROS$2], blocksize));
  for (var v = this._ipad = Buffer$o.allocUnsafe(blocksize), w = this._opad = Buffer$o.allocUnsafe(blocksize), T = 0; T < blocksize; T++)
    v[T] = t[T] ^ 54, w[T] = t[T] ^ 92;
  this._hash = [v];
}
inherits$e(Hmac$4, Base$4);
Hmac$4.prototype._update = function(e) {
  this._hash.push(e);
};
Hmac$4.prototype._final = function() {
  var e = this._alg(Buffer$o.concat(this._hash));
  return this._alg(Buffer$o.concat([this._opad, e]));
};
var legacy = Hmac$4, MD5$1 = md5_js, md5$2 = function(e) {
  return new MD5$1().update(e).digest();
}, inherits$d = inherits_browserExports, Legacy = legacy, Base$3 = cipherBase, Buffer$n = safeBufferExports$1.Buffer, md5$1 = md5$2, RIPEMD160$2 = ripemd160, sha$2 = sha_jsExports, ZEROS$1 = Buffer$n.alloc(128);
function Hmac$3(e, t) {
  Base$3.call(this, "digest"), typeof t == "string" && (t = Buffer$n.from(t));
  var v = e === "sha512" || e === "sha384" ? 128 : 64;
  if (this._alg = e, this._key = t, t.length > v) {
    var w = e === "rmd160" ? new RIPEMD160$2() : sha$2(e);
    t = w.update(t).digest();
  } else t.length < v && (t = Buffer$n.concat([t, ZEROS$1], v));
  for (var T = this._ipad = Buffer$n.allocUnsafe(v), x = this._opad = Buffer$n.allocUnsafe(v), C = 0; C < v; C++)
    T[C] = t[C] ^ 54, x[C] = t[C] ^ 92;
  this._hash = e === "rmd160" ? new RIPEMD160$2() : sha$2(e), this._hash.update(T);
}
inherits$d(Hmac$3, Base$3);
Hmac$3.prototype._update = function(e) {
  this._hash.update(e);
};
Hmac$3.prototype._final = function() {
  var e = this._hash.digest(), t = this._alg === "rmd160" ? new RIPEMD160$2() : sha$2(this._alg);
  return t.update(this._opad).update(e).digest();
};
var browser$8 = function(e, t) {
  return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new Hmac$3("rmd160", t) : e === "md5" ? new Legacy(md5$1, t) : new Hmac$3(e, t);
};
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos = require$$6, browser$7 = {}, MAX_ALLOC = Math.pow(2, 30) - 1, precondition = function(e, t) {
  if (typeof e != "number")
    throw new TypeError("Iterations not a number");
  if (e < 0)
    throw new TypeError("Bad iterations");
  if (typeof t != "number")
    throw new TypeError("Key length not a number");
  if (t < 0 || t > MAX_ALLOC || t !== t)
    throw new TypeError("Bad key length");
}, defaultEncoding$2;
if (commonjsGlobal.process && commonjsGlobal.process.browser)
  defaultEncoding$2 = "utf-8";
else if (commonjsGlobal.process && commonjsGlobal.process.version) {
  var pVersionMajor = parseInt(process$1$1.version.split(".")[0].slice(1), 10);
  defaultEncoding$2 = pVersionMajor >= 6 ? "utf-8" : "binary";
} else
  defaultEncoding$2 = "utf-8";
var defaultEncoding_1 = defaultEncoding$2, Buffer$m = safeBufferExports$1.Buffer, toBuffer$2 = function(e, t, v) {
  if (Buffer$m.isBuffer(e))
    return e;
  if (typeof e == "string")
    return Buffer$m.from(e, t);
  if (ArrayBuffer.isView(e))
    return Buffer$m.from(e.buffer);
  throw new TypeError(v + " must be a string, a Buffer, a typed array or a DataView");
}, md5 = md5$2, RIPEMD160$1 = ripemd160, sha$1 = sha_jsExports, Buffer$l = safeBufferExports$1.Buffer, checkParameters$1 = precondition, defaultEncoding$1 = defaultEncoding_1, toBuffer$1 = toBuffer$2, ZEROS = Buffer$l.alloc(128), sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};
function Hmac$2(e, t, v) {
  var w = getDigest(e), T = e === "sha512" || e === "sha384" ? 128 : 64;
  t.length > T ? t = w(t) : t.length < T && (t = Buffer$l.concat([t, ZEROS], T));
  for (var x = Buffer$l.allocUnsafe(T + sizes[e]), C = Buffer$l.allocUnsafe(T + sizes[e]), D = 0; D < T; D++)
    x[D] = t[D] ^ 54, C[D] = t[D] ^ 92;
  var Y = Buffer$l.allocUnsafe(T + v + 4);
  x.copy(Y, 0, 0, T), this.ipad1 = Y, this.ipad2 = x, this.opad = C, this.alg = e, this.blocksize = T, this.hash = w, this.size = sizes[e];
}
Hmac$2.prototype.run = function(e, t) {
  e.copy(t, this.blocksize);
  var v = this.hash(t);
  return v.copy(this.opad, this.blocksize), this.hash(this.opad);
};
function getDigest(e) {
  function t(w) {
    return sha$1(e).update(w).digest();
  }
  function v(w) {
    return new RIPEMD160$1().update(w).digest();
  }
  return e === "rmd160" || e === "ripemd160" ? v : e === "md5" ? md5 : t;
}
function pbkdf2(e, t, v, w, T) {
  checkParameters$1(v, w), e = toBuffer$1(e, defaultEncoding$1, "Password"), t = toBuffer$1(t, defaultEncoding$1, "Salt"), T = T || "sha1";
  var x = new Hmac$2(T, e, t.length), C = Buffer$l.allocUnsafe(w), D = Buffer$l.allocUnsafe(t.length + 4);
  t.copy(D, 0, 0, t.length);
  for (var Y = 0, L = sizes[T], q = Math.ceil(w / L), N = 1; N <= q; N++) {
    D.writeUInt32BE(N, t.length);
    for (var F = x.run(D, x.ipad1), ae = F, he = 1; he < v; he++) {
      ae = x.run(ae, x.ipad2);
      for (var tt = 0; tt < L; tt++) F[tt] ^= ae[tt];
    }
    F.copy(C, Y), Y += L;
  }
  return C;
}
var syncBrowser = pbkdf2, Buffer$k = safeBufferExports$1.Buffer, checkParameters = precondition, defaultEncoding = defaultEncoding_1, sync = syncBrowser, toBuffer = toBuffer$2, ZERO_BUF, subtle = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, toBrowser = {
  sha: "SHA-1",
  "sha-1": "SHA-1",
  sha1: "SHA-1",
  sha256: "SHA-256",
  "sha-256": "SHA-256",
  sha384: "SHA-384",
  "sha-384": "SHA-384",
  "sha-512": "SHA-512",
  sha512: "SHA-512"
}, checks = [];
function checkNative(e) {
  if (commonjsGlobal.process && !commonjsGlobal.process.browser || !subtle || !subtle.importKey || !subtle.deriveBits)
    return Promise.resolve(!1);
  if (checks[e] !== void 0)
    return checks[e];
  ZERO_BUF = ZERO_BUF || Buffer$k.alloc(8);
  var t = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, e).then(function() {
    return !0;
  }).catch(function() {
    return !1;
  });
  return checks[e] = t, t;
}
var nextTick$1;
function getNextTick() {
  return nextTick$1 || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? nextTick$1 = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? nextTick$1 = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? nextTick$1 = commonjsGlobal.setImmediate : nextTick$1 = commonjsGlobal.setTimeout, nextTick$1);
}
function browserPbkdf2(e, t, v, w, T) {
  return subtle.importKey(
    "raw",
    e,
    { name: "PBKDF2" },
    !1,
    ["deriveBits"]
  ).then(function(x) {
    return subtle.deriveBits({
      name: "PBKDF2",
      salt: t,
      iterations: v,
      hash: {
        name: T
      }
    }, x, w << 3);
  }).then(function(x) {
    return Buffer$k.from(x);
  });
}
function resolvePromise(e, t) {
  e.then(function(v) {
    getNextTick()(function() {
      t(null, v);
    });
  }, function(v) {
    getNextTick()(function() {
      t(v);
    });
  });
}
var async = function(e, t, v, w, T, x) {
  typeof T == "function" && (x = T, T = void 0), T = T || "sha1";
  var C = toBrowser[T.toLowerCase()];
  if (!C || typeof commonjsGlobal.Promise != "function") {
    getNextTick()(function() {
      var D;
      try {
        D = sync(e, t, v, w, T);
      } catch (Y) {
        return x(Y);
      }
      x(null, D);
    });
    return;
  }
  if (checkParameters(v, w), e = toBuffer(e, defaultEncoding, "Password"), t = toBuffer(t, defaultEncoding, "Salt"), typeof x != "function") throw new Error("No callback provided to pbkdf2");
  resolvePromise(checkNative(C).then(function(D) {
    return D ? browserPbkdf2(e, t, v, w, C) : sync(e, t, v, w, T);
  }), x);
};
browser$7.pbkdf2 = async;
browser$7.pbkdf2Sync = syncBrowser;
var browser$6 = {}, des$2 = {}, utils$n = {};
utils$n.readUInt32BE = function(e, t) {
  var v = e[0 + t] << 24 | e[1 + t] << 16 | e[2 + t] << 8 | e[3 + t];
  return v >>> 0;
};
utils$n.writeUInt32BE = function(e, t, v) {
  e[0 + v] = t >>> 24, e[1 + v] = t >>> 16 & 255, e[2 + v] = t >>> 8 & 255, e[3 + v] = t & 255;
};
utils$n.ip = function(e, t, v, w) {
  for (var T = 0, x = 0, C = 6; C >= 0; C -= 2) {
    for (var D = 0; D <= 24; D += 8)
      T <<= 1, T |= t >>> D + C & 1;
    for (var D = 0; D <= 24; D += 8)
      T <<= 1, T |= e >>> D + C & 1;
  }
  for (var C = 6; C >= 0; C -= 2) {
    for (var D = 1; D <= 25; D += 8)
      x <<= 1, x |= t >>> D + C & 1;
    for (var D = 1; D <= 25; D += 8)
      x <<= 1, x |= e >>> D + C & 1;
  }
  v[w + 0] = T >>> 0, v[w + 1] = x >>> 0;
};
utils$n.rip = function(e, t, v, w) {
  for (var T = 0, x = 0, C = 0; C < 4; C++)
    for (var D = 24; D >= 0; D -= 8)
      T <<= 1, T |= t >>> D + C & 1, T <<= 1, T |= e >>> D + C & 1;
  for (var C = 4; C < 8; C++)
    for (var D = 24; D >= 0; D -= 8)
      x <<= 1, x |= t >>> D + C & 1, x <<= 1, x |= e >>> D + C & 1;
  v[w + 0] = T >>> 0, v[w + 1] = x >>> 0;
};
utils$n.pc1 = function(e, t, v, w) {
  for (var T = 0, x = 0, C = 7; C >= 5; C--) {
    for (var D = 0; D <= 24; D += 8)
      T <<= 1, T |= t >> D + C & 1;
    for (var D = 0; D <= 24; D += 8)
      T <<= 1, T |= e >> D + C & 1;
  }
  for (var D = 0; D <= 24; D += 8)
    T <<= 1, T |= t >> D + C & 1;
  for (var C = 1; C <= 3; C++) {
    for (var D = 0; D <= 24; D += 8)
      x <<= 1, x |= t >> D + C & 1;
    for (var D = 0; D <= 24; D += 8)
      x <<= 1, x |= e >> D + C & 1;
  }
  for (var D = 0; D <= 24; D += 8)
    x <<= 1, x |= e >> D + C & 1;
  v[w + 0] = T >>> 0, v[w + 1] = x >>> 0;
};
utils$n.r28shl = function(e, t) {
  return e << t & 268435455 | e >>> 28 - t;
};
var pc2table = [
  // inL => outL
  14,
  11,
  17,
  4,
  27,
  23,
  25,
  0,
  13,
  22,
  7,
  18,
  5,
  9,
  16,
  24,
  2,
  20,
  12,
  21,
  1,
  8,
  15,
  26,
  // inR => outR
  15,
  4,
  25,
  19,
  9,
  1,
  26,
  16,
  5,
  11,
  23,
  8,
  12,
  7,
  17,
  0,
  22,
  3,
  10,
  14,
  6,
  20,
  27,
  24
];
utils$n.pc2 = function(e, t, v, w) {
  for (var T = 0, x = 0, C = pc2table.length >>> 1, D = 0; D < C; D++)
    T <<= 1, T |= e >>> pc2table[D] & 1;
  for (var D = C; D < pc2table.length; D++)
    x <<= 1, x |= t >>> pc2table[D] & 1;
  v[w + 0] = T >>> 0, v[w + 1] = x >>> 0;
};
utils$n.expand = function(e, t, v) {
  var w = 0, T = 0;
  w = (e & 1) << 5 | e >>> 27;
  for (var x = 23; x >= 15; x -= 4)
    w <<= 6, w |= e >>> x & 63;
  for (var x = 11; x >= 3; x -= 4)
    T |= e >>> x & 63, T <<= 6;
  T |= (e & 31) << 1 | e >>> 31, t[v + 0] = w >>> 0, t[v + 1] = T >>> 0;
};
var sTable = [
  14,
  0,
  4,
  15,
  13,
  7,
  1,
  4,
  2,
  14,
  15,
  2,
  11,
  13,
  8,
  1,
  3,
  10,
  10,
  6,
  6,
  12,
  12,
  11,
  5,
  9,
  9,
  5,
  0,
  3,
  7,
  8,
  4,
  15,
  1,
  12,
  14,
  8,
  8,
  2,
  13,
  4,
  6,
  9,
  2,
  1,
  11,
  7,
  15,
  5,
  12,
  11,
  9,
  3,
  7,
  14,
  3,
  10,
  10,
  0,
  5,
  6,
  0,
  13,
  15,
  3,
  1,
  13,
  8,
  4,
  14,
  7,
  6,
  15,
  11,
  2,
  3,
  8,
  4,
  14,
  9,
  12,
  7,
  0,
  2,
  1,
  13,
  10,
  12,
  6,
  0,
  9,
  5,
  11,
  10,
  5,
  0,
  13,
  14,
  8,
  7,
  10,
  11,
  1,
  10,
  3,
  4,
  15,
  13,
  4,
  1,
  2,
  5,
  11,
  8,
  6,
  12,
  7,
  6,
  12,
  9,
  0,
  3,
  5,
  2,
  14,
  15,
  9,
  10,
  13,
  0,
  7,
  9,
  0,
  14,
  9,
  6,
  3,
  3,
  4,
  15,
  6,
  5,
  10,
  1,
  2,
  13,
  8,
  12,
  5,
  7,
  14,
  11,
  12,
  4,
  11,
  2,
  15,
  8,
  1,
  13,
  1,
  6,
  10,
  4,
  13,
  9,
  0,
  8,
  6,
  15,
  9,
  3,
  8,
  0,
  7,
  11,
  4,
  1,
  15,
  2,
  14,
  12,
  3,
  5,
  11,
  10,
  5,
  14,
  2,
  7,
  12,
  7,
  13,
  13,
  8,
  14,
  11,
  3,
  5,
  0,
  6,
  6,
  15,
  9,
  0,
  10,
  3,
  1,
  4,
  2,
  7,
  8,
  2,
  5,
  12,
  11,
  1,
  12,
  10,
  4,
  14,
  15,
  9,
  10,
  3,
  6,
  15,
  9,
  0,
  0,
  6,
  12,
  10,
  11,
  1,
  7,
  13,
  13,
  8,
  15,
  9,
  1,
  4,
  3,
  5,
  14,
  11,
  5,
  12,
  2,
  7,
  8,
  2,
  4,
  14,
  2,
  14,
  12,
  11,
  4,
  2,
  1,
  12,
  7,
  4,
  10,
  7,
  11,
  13,
  6,
  1,
  8,
  5,
  5,
  0,
  3,
  15,
  15,
  10,
  13,
  3,
  0,
  9,
  14,
  8,
  9,
  6,
  4,
  11,
  2,
  8,
  1,
  12,
  11,
  7,
  10,
  1,
  13,
  14,
  7,
  2,
  8,
  13,
  15,
  6,
  9,
  15,
  12,
  0,
  5,
  9,
  6,
  10,
  3,
  4,
  0,
  5,
  14,
  3,
  12,
  10,
  1,
  15,
  10,
  4,
  15,
  2,
  9,
  7,
  2,
  12,
  6,
  9,
  8,
  5,
  0,
  6,
  13,
  1,
  3,
  13,
  4,
  14,
  14,
  0,
  7,
  11,
  5,
  3,
  11,
  8,
  9,
  4,
  14,
  3,
  15,
  2,
  5,
  12,
  2,
  9,
  8,
  5,
  12,
  15,
  3,
  10,
  7,
  11,
  0,
  14,
  4,
  1,
  10,
  7,
  1,
  6,
  13,
  0,
  11,
  8,
  6,
  13,
  4,
  13,
  11,
  0,
  2,
  11,
  14,
  7,
  15,
  4,
  0,
  9,
  8,
  1,
  13,
  10,
  3,
  14,
  12,
  3,
  9,
  5,
  7,
  12,
  5,
  2,
  10,
  15,
  6,
  8,
  1,
  6,
  1,
  6,
  4,
  11,
  11,
  13,
  13,
  8,
  12,
  1,
  3,
  4,
  7,
  10,
  14,
  7,
  10,
  9,
  15,
  5,
  6,
  0,
  8,
  15,
  0,
  14,
  5,
  2,
  9,
  3,
  2,
  12,
  13,
  1,
  2,
  15,
  8,
  13,
  4,
  8,
  6,
  10,
  15,
  3,
  11,
  7,
  1,
  4,
  10,
  12,
  9,
  5,
  3,
  6,
  14,
  11,
  5,
  0,
  0,
  14,
  12,
  9,
  7,
  2,
  7,
  2,
  11,
  1,
  4,
  14,
  1,
  7,
  9,
  4,
  12,
  10,
  14,
  8,
  2,
  13,
  0,
  15,
  6,
  12,
  10,
  9,
  13,
  0,
  15,
  3,
  3,
  5,
  5,
  6,
  8,
  11
];
utils$n.substitute = function(e, t) {
  for (var v = 0, w = 0; w < 4; w++) {
    var T = e >>> 18 - w * 6 & 63, x = sTable[w * 64 + T];
    v <<= 4, v |= x;
  }
  for (var w = 0; w < 4; w++) {
    var T = t >>> 18 - w * 6 & 63, x = sTable[4 * 64 + w * 64 + T];
    v <<= 4, v |= x;
  }
  return v >>> 0;
};
var permuteTable = [
  16,
  25,
  12,
  11,
  3,
  20,
  4,
  15,
  31,
  17,
  9,
  6,
  27,
  14,
  1,
  22,
  30,
  24,
  8,
  18,
  0,
  5,
  29,
  23,
  13,
  19,
  2,
  26,
  10,
  21,
  28,
  7
];
utils$n.permute = function(e) {
  for (var t = 0, v = 0; v < permuteTable.length; v++)
    t <<= 1, t |= e >>> permuteTable[v] & 1;
  return t >>> 0;
};
utils$n.padSplit = function(e, t, v) {
  for (var w = e.toString(2); w.length < t; )
    w = "0" + w;
  for (var T = [], x = 0; x < t; x += v)
    T.push(w.slice(x, x + v));
  return T.join(" ");
};
var minimalisticAssert = assert$i;
function assert$i(e, t) {
  if (!e)
    throw new Error(t || "Assertion failed");
}
assert$i.equal = function(e, t, v) {
  if (e != t)
    throw new Error(v || "Assertion failed: " + e + " != " + t);
};
var assert$h = minimalisticAssert;
function Cipher$3(e) {
  this.options = e, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = e.padding !== !1;
}
var cipher = Cipher$3;
Cipher$3.prototype._init = function() {
};
Cipher$3.prototype.update = function(e) {
  return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e);
};
Cipher$3.prototype._buffer = function(e, t) {
  for (var v = Math.min(this.buffer.length - this.bufferOff, e.length - t), w = 0; w < v; w++)
    this.buffer[this.bufferOff + w] = e[t + w];
  return this.bufferOff += v, v;
};
Cipher$3.prototype._flushBuffer = function(e, t) {
  return this._update(this.buffer, 0, e, t), this.bufferOff = 0, this.blockSize;
};
Cipher$3.prototype._updateEncrypt = function(e) {
  var t = 0, v = 0, w = (this.bufferOff + e.length) / this.blockSize | 0, T = new Array(w * this.blockSize);
  this.bufferOff !== 0 && (t += this._buffer(e, t), this.bufferOff === this.buffer.length && (v += this._flushBuffer(T, v)));
  for (var x = e.length - (e.length - t) % this.blockSize; t < x; t += this.blockSize)
    this._update(e, t, T, v), v += this.blockSize;
  for (; t < e.length; t++, this.bufferOff++)
    this.buffer[this.bufferOff] = e[t];
  return T;
};
Cipher$3.prototype._updateDecrypt = function(e) {
  for (var t = 0, v = 0, w = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, T = new Array(w * this.blockSize); w > 0; w--)
    t += this._buffer(e, t), v += this._flushBuffer(T, v);
  return t += this._buffer(e, t), T;
};
Cipher$3.prototype.final = function(e) {
  var t;
  e && (t = this.update(e));
  var v;
  return this.type === "encrypt" ? v = this._finalEncrypt() : v = this._finalDecrypt(), t ? t.concat(v) : v;
};
Cipher$3.prototype._pad = function(e, t) {
  if (t === 0)
    return !1;
  for (; t < e.length; )
    e[t++] = 0;
  return !0;
};
Cipher$3.prototype._finalEncrypt = function() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];
  var e = new Array(this.blockSize);
  return this._update(this.buffer, 0, e, 0), e;
};
Cipher$3.prototype._unpad = function(e) {
  return e;
};
Cipher$3.prototype._finalDecrypt = function() {
  assert$h.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
  var e = new Array(this.blockSize);
  return this._flushBuffer(e, 0), this._unpad(e);
};
var assert$g = minimalisticAssert, inherits$c = inherits_browserExports, utils$m = utils$n, Cipher$2 = cipher;
function DESState() {
  this.tmp = new Array(2), this.keys = null;
}
function DES$3(e) {
  Cipher$2.call(this, e);
  var t = new DESState();
  this._desState = t, this.deriveKeys(t, e.key);
}
inherits$c(DES$3, Cipher$2);
var des$1 = DES$3;
DES$3.create = function(e) {
  return new DES$3(e);
};
var shiftTable = [
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1
];
DES$3.prototype.deriveKeys = function(e, t) {
  e.keys = new Array(16 * 2), assert$g.equal(t.length, this.blockSize, "Invalid key length");
  var v = utils$m.readUInt32BE(t, 0), w = utils$m.readUInt32BE(t, 4);
  utils$m.pc1(v, w, e.tmp, 0), v = e.tmp[0], w = e.tmp[1];
  for (var T = 0; T < e.keys.length; T += 2) {
    var x = shiftTable[T >>> 1];
    v = utils$m.r28shl(v, x), w = utils$m.r28shl(w, x), utils$m.pc2(v, w, e.keys, T);
  }
};
DES$3.prototype._update = function(e, t, v, w) {
  var T = this._desState, x = utils$m.readUInt32BE(e, t), C = utils$m.readUInt32BE(e, t + 4);
  utils$m.ip(x, C, T.tmp, 0), x = T.tmp[0], C = T.tmp[1], this.type === "encrypt" ? this._encrypt(T, x, C, T.tmp, 0) : this._decrypt(T, x, C, T.tmp, 0), x = T.tmp[0], C = T.tmp[1], utils$m.writeUInt32BE(v, x, w), utils$m.writeUInt32BE(v, C, w + 4);
};
DES$3.prototype._pad = function(e, t) {
  if (this.padding === !1)
    return !1;
  for (var v = e.length - t, w = t; w < e.length; w++)
    e[w] = v;
  return !0;
};
DES$3.prototype._unpad = function(e) {
  if (this.padding === !1)
    return e;
  for (var t = e[e.length - 1], v = e.length - t; v < e.length; v++)
    assert$g.equal(e[v], t);
  return e.slice(0, e.length - t);
};
DES$3.prototype._encrypt = function(e, t, v, w, T) {
  for (var x = t, C = v, D = 0; D < e.keys.length; D += 2) {
    var Y = e.keys[D], L = e.keys[D + 1];
    utils$m.expand(C, e.tmp, 0), Y ^= e.tmp[0], L ^= e.tmp[1];
    var q = utils$m.substitute(Y, L), N = utils$m.permute(q), F = C;
    C = (x ^ N) >>> 0, x = F;
  }
  utils$m.rip(C, x, w, T);
};
DES$3.prototype._decrypt = function(e, t, v, w, T) {
  for (var x = v, C = t, D = e.keys.length - 2; D >= 0; D -= 2) {
    var Y = e.keys[D], L = e.keys[D + 1];
    utils$m.expand(x, e.tmp, 0), Y ^= e.tmp[0], L ^= e.tmp[1];
    var q = utils$m.substitute(Y, L), N = utils$m.permute(q), F = x;
    x = (C ^ N) >>> 0, C = F;
  }
  utils$m.rip(x, C, w, T);
};
var cbc$1 = {}, assert$f = minimalisticAssert, inherits$b = inherits_browserExports, proto = {};
function CBCState(e) {
  assert$f.equal(e.length, 8, "Invalid IV length"), this.iv = new Array(8);
  for (var t = 0; t < this.iv.length; t++)
    this.iv[t] = e[t];
}
function instantiate(e) {
  function t(x) {
    e.call(this, x), this._cbcInit();
  }
  inherits$b(t, e);
  for (var v = Object.keys(proto), w = 0; w < v.length; w++) {
    var T = v[w];
    t.prototype[T] = proto[T];
  }
  return t.create = function(x) {
    return new t(x);
  }, t;
}
cbc$1.instantiate = instantiate;
proto._cbcInit = function() {
  var e = new CBCState(this.options.iv);
  this._cbcState = e;
};
proto._update = function(e, t, v, w) {
  var T = this._cbcState, x = this.constructor.super_.prototype, C = T.iv;
  if (this.type === "encrypt") {
    for (var D = 0; D < this.blockSize; D++)
      C[D] ^= e[t + D];
    x._update.call(this, C, 0, v, w);
    for (var D = 0; D < this.blockSize; D++)
      C[D] = v[w + D];
  } else {
    x._update.call(this, e, t, v, w);
    for (var D = 0; D < this.blockSize; D++)
      v[w + D] ^= C[D];
    for (var D = 0; D < this.blockSize; D++)
      C[D] = e[t + D];
  }
};
var assert$e = minimalisticAssert, inherits$a = inherits_browserExports, Cipher$1 = cipher, DES$2 = des$1;
function EDEState(e, t) {
  assert$e.equal(t.length, 24, "Invalid key length");
  var v = t.slice(0, 8), w = t.slice(8, 16), T = t.slice(16, 24);
  e === "encrypt" ? this.ciphers = [
    DES$2.create({ type: "encrypt", key: v }),
    DES$2.create({ type: "decrypt", key: w }),
    DES$2.create({ type: "encrypt", key: T })
  ] : this.ciphers = [
    DES$2.create({ type: "decrypt", key: T }),
    DES$2.create({ type: "encrypt", key: w }),
    DES$2.create({ type: "decrypt", key: v })
  ];
}
function EDE(e) {
  Cipher$1.call(this, e);
  var t = new EDEState(this.type, this.options.key);
  this._edeState = t;
}
inherits$a(EDE, Cipher$1);
var ede = EDE;
EDE.create = function(e) {
  return new EDE(e);
};
EDE.prototype._update = function(e, t, v, w) {
  var T = this._edeState;
  T.ciphers[0]._update(e, t, v, w), T.ciphers[1]._update(v, w, v, w), T.ciphers[2]._update(v, w, v, w);
};
EDE.prototype._pad = DES$2.prototype._pad;
EDE.prototype._unpad = DES$2.prototype._unpad;
des$2.utils = utils$n;
des$2.Cipher = cipher;
des$2.DES = des$1;
des$2.CBC = cbc$1;
des$2.EDE = ede;
var CipherBase = cipherBase, des = des$2, inherits$9 = inherits_browserExports, Buffer$j = safeBufferExports$1.Buffer, modes$3 = {
  "des-ede3-cbc": des.CBC.instantiate(des.EDE),
  "des-ede3": des.EDE,
  "des-ede-cbc": des.CBC.instantiate(des.EDE),
  "des-ede": des.EDE,
  "des-cbc": des.CBC.instantiate(des.DES),
  "des-ecb": des.DES
};
modes$3.des = modes$3["des-cbc"];
modes$3.des3 = modes$3["des-ede3-cbc"];
var browserifyDes = DES$1;
inherits$9(DES$1, CipherBase);
function DES$1(e) {
  CipherBase.call(this);
  var t = e.mode.toLowerCase(), v = modes$3[t], w;
  e.decrypt ? w = "decrypt" : w = "encrypt";
  var T = e.key;
  Buffer$j.isBuffer(T) || (T = Buffer$j.from(T)), (t === "des-ede" || t === "des-ede-cbc") && (T = Buffer$j.concat([T, T.slice(0, 8)]));
  var x = e.iv;
  Buffer$j.isBuffer(x) || (x = Buffer$j.from(x)), this._des = v.create({
    key: T,
    iv: x,
    type: w
  });
}
DES$1.prototype._update = function(e) {
  return Buffer$j.from(this._des.update(e));
};
DES$1.prototype._final = function() {
  return Buffer$j.from(this._des.final());
};
var browser$5 = {}, encrypter = {}, ecb = {};
ecb.encrypt = function(e, t) {
  return e._cipher.encryptBlock(t);
};
ecb.decrypt = function(e, t) {
  return e._cipher.decryptBlock(t);
};
var cbc = {}, bufferXor = function(e, t) {
  for (var v = Math.min(e.length, t.length), w = new Buffer$C(v), T = 0; T < v; ++T)
    w[T] = e[T] ^ t[T];
  return w;
}, xor$7 = bufferXor;
cbc.encrypt = function(e, t) {
  var v = xor$7(t, e._prev);
  return e._prev = e._cipher.encryptBlock(v), e._prev;
};
cbc.decrypt = function(e, t) {
  var v = e._prev;
  e._prev = t;
  var w = e._cipher.decryptBlock(t);
  return xor$7(w, v);
};
var cfb = {}, Buffer$i = safeBufferExports$1.Buffer, xor$6 = bufferXor;
function encryptStart(e, t, v) {
  var w = t.length, T = xor$6(t, e._cache);
  return e._cache = e._cache.slice(w), e._prev = Buffer$i.concat([e._prev, v ? t : T]), T;
}
cfb.encrypt = function(e, t, v) {
  for (var w = Buffer$i.allocUnsafe(0), T; t.length; )
    if (e._cache.length === 0 && (e._cache = e._cipher.encryptBlock(e._prev), e._prev = Buffer$i.allocUnsafe(0)), e._cache.length <= t.length)
      T = e._cache.length, w = Buffer$i.concat([w, encryptStart(e, t.slice(0, T), v)]), t = t.slice(T);
    else {
      w = Buffer$i.concat([w, encryptStart(e, t, v)]);
      break;
    }
  return w;
};
var cfb8 = {}, Buffer$h = safeBufferExports$1.Buffer;
function encryptByte$1(e, t, v) {
  var w = e._cipher.encryptBlock(e._prev), T = w[0] ^ t;
  return e._prev = Buffer$h.concat([
    e._prev.slice(1),
    Buffer$h.from([v ? t : T])
  ]), T;
}
cfb8.encrypt = function(e, t, v) {
  for (var w = t.length, T = Buffer$h.allocUnsafe(w), x = -1; ++x < w; )
    T[x] = encryptByte$1(e, t[x], v);
  return T;
};
var cfb1 = {}, Buffer$g = safeBufferExports$1.Buffer;
function encryptByte(e, t, v) {
  for (var w, T = -1, x = 8, C = 0, D, Y; ++T < x; )
    w = e._cipher.encryptBlock(e._prev), D = t & 1 << 7 - T ? 128 : 0, Y = w[0] ^ D, C += (Y & 128) >> T % 8, e._prev = shiftIn(e._prev, v ? D : Y);
  return C;
}
function shiftIn(e, t) {
  var v = e.length, w = -1, T = Buffer$g.allocUnsafe(e.length);
  for (e = Buffer$g.concat([e, Buffer$g.from([t])]); ++w < v; )
    T[w] = e[w] << 1 | e[w + 1] >> 7;
  return T;
}
cfb1.encrypt = function(e, t, v) {
  for (var w = t.length, T = Buffer$g.allocUnsafe(w), x = -1; ++x < w; )
    T[x] = encryptByte(e, t[x], v);
  return T;
};
var ofb = {}, xor$5 = bufferXor;
function getBlock$1(e) {
  return e._prev = e._cipher.encryptBlock(e._prev), e._prev;
}
ofb.encrypt = function(e, t) {
  for (; e._cache.length < t.length; )
    e._cache = Buffer$C.concat([e._cache, getBlock$1(e)]);
  var v = e._cache.slice(0, t.length);
  return e._cache = e._cache.slice(t.length), xor$5(t, v);
};
var ctr = {};
function incr32$2(e) {
  for (var t = e.length, v; t--; )
    if (v = e.readUInt8(t), v === 255)
      e.writeUInt8(0, t);
    else {
      v++, e.writeUInt8(v, t);
      break;
    }
}
var incr32_1 = incr32$2, xor$4 = bufferXor, Buffer$f = safeBufferExports$1.Buffer, incr32$1 = incr32_1;
function getBlock(e) {
  var t = e._cipher.encryptBlockRaw(e._prev);
  return incr32$1(e._prev), t;
}
var blockSize = 16;
ctr.encrypt = function(e, t) {
  var v = Math.ceil(t.length / blockSize), w = e._cache.length;
  e._cache = Buffer$f.concat([
    e._cache,
    Buffer$f.allocUnsafe(v * blockSize)
  ]);
  for (var T = 0; T < v; T++) {
    var x = getBlock(e), C = w + T * blockSize;
    e._cache.writeUInt32BE(x[0], C + 0), e._cache.writeUInt32BE(x[1], C + 4), e._cache.writeUInt32BE(x[2], C + 8), e._cache.writeUInt32BE(x[3], C + 12);
  }
  var D = e._cache.slice(0, t.length);
  return e._cache = e._cache.slice(t.length), xor$4(t, D);
};
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modeModules = {
  ECB: ecb,
  CBC: cbc,
  CFB: cfb,
  CFB8: cfb8,
  CFB1: cfb1,
  OFB: ofb,
  CTR: ctr,
  GCM: ctr
}, modes$2 = require$$2;
for (var key$2 in modes$2)
  modes$2[key$2].module = modeModules[modes$2[key$2].mode];
var modes_1 = modes$2, aes$5 = {}, Buffer$e = safeBufferExports$1.Buffer;
function asUInt32Array(e) {
  Buffer$e.isBuffer(e) || (e = Buffer$e.from(e));
  for (var t = e.length / 4 | 0, v = new Array(t), w = 0; w < t; w++)
    v[w] = e.readUInt32BE(w * 4);
  return v;
}
function scrubVec(e) {
  for (var t = 0; t < e.length; e++)
    e[t] = 0;
}
function cryptBlock(e, t, v, w, T) {
  for (var x = v[0], C = v[1], D = v[2], Y = v[3], L = e[0] ^ t[0], q = e[1] ^ t[1], N = e[2] ^ t[2], F = e[3] ^ t[3], ae, he, tt, br, rt = 4, dr = 1; dr < T; dr++)
    ae = x[L >>> 24] ^ C[q >>> 16 & 255] ^ D[N >>> 8 & 255] ^ Y[F & 255] ^ t[rt++], he = x[q >>> 24] ^ C[N >>> 16 & 255] ^ D[F >>> 8 & 255] ^ Y[L & 255] ^ t[rt++], tt = x[N >>> 24] ^ C[F >>> 16 & 255] ^ D[L >>> 8 & 255] ^ Y[q & 255] ^ t[rt++], br = x[F >>> 24] ^ C[L >>> 16 & 255] ^ D[q >>> 8 & 255] ^ Y[N & 255] ^ t[rt++], L = ae, q = he, N = tt, F = br;
  return ae = (w[L >>> 24] << 24 | w[q >>> 16 & 255] << 16 | w[N >>> 8 & 255] << 8 | w[F & 255]) ^ t[rt++], he = (w[q >>> 24] << 24 | w[N >>> 16 & 255] << 16 | w[F >>> 8 & 255] << 8 | w[L & 255]) ^ t[rt++], tt = (w[N >>> 24] << 24 | w[F >>> 16 & 255] << 16 | w[L >>> 8 & 255] << 8 | w[q & 255]) ^ t[rt++], br = (w[F >>> 24] << 24 | w[L >>> 16 & 255] << 16 | w[q >>> 8 & 255] << 8 | w[N & 255]) ^ t[rt++], ae = ae >>> 0, he = he >>> 0, tt = tt >>> 0, br = br >>> 0, [ae, he, tt, br];
}
var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], G = function() {
  for (var e = new Array(256), t = 0; t < 256; t++)
    t < 128 ? e[t] = t << 1 : e[t] = t << 1 ^ 283;
  for (var v = [], w = [], T = [[], [], [], []], x = [[], [], [], []], C = 0, D = 0, Y = 0; Y < 256; ++Y) {
    var L = D ^ D << 1 ^ D << 2 ^ D << 3 ^ D << 4;
    L = L >>> 8 ^ L & 255 ^ 99, v[C] = L, w[L] = C;
    var q = e[C], N = e[q], F = e[N], ae = e[L] * 257 ^ L * 16843008;
    T[0][C] = ae << 24 | ae >>> 8, T[1][C] = ae << 16 | ae >>> 16, T[2][C] = ae << 8 | ae >>> 24, T[3][C] = ae, ae = F * 16843009 ^ N * 65537 ^ q * 257 ^ C * 16843008, x[0][L] = ae << 24 | ae >>> 8, x[1][L] = ae << 16 | ae >>> 16, x[2][L] = ae << 8 | ae >>> 24, x[3][L] = ae, C === 0 ? C = D = 1 : (C = q ^ e[e[e[F ^ q]]], D ^= e[e[D]]);
  }
  return {
    SBOX: v,
    INV_SBOX: w,
    SUB_MIX: T,
    INV_SUB_MIX: x
  };
}();
function AES(e) {
  this._key = asUInt32Array(e), this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
  for (var e = this._key, t = e.length, v = t + 6, w = (v + 1) * 4, T = [], x = 0; x < t; x++)
    T[x] = e[x];
  for (x = t; x < w; x++) {
    var C = T[x - 1];
    x % t === 0 ? (C = C << 8 | C >>> 24, C = G.SBOX[C >>> 24] << 24 | G.SBOX[C >>> 16 & 255] << 16 | G.SBOX[C >>> 8 & 255] << 8 | G.SBOX[C & 255], C ^= RCON[x / t | 0] << 24) : t > 6 && x % t === 4 && (C = G.SBOX[C >>> 24] << 24 | G.SBOX[C >>> 16 & 255] << 16 | G.SBOX[C >>> 8 & 255] << 8 | G.SBOX[C & 255]), T[x] = T[x - t] ^ C;
  }
  for (var D = [], Y = 0; Y < w; Y++) {
    var L = w - Y, q = T[L - (Y % 4 ? 0 : 4)];
    Y < 4 || L <= 4 ? D[Y] = q : D[Y] = G.INV_SUB_MIX[0][G.SBOX[q >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[q >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[q >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[q & 255]];
  }
  this._nRounds = v, this._keySchedule = T, this._invKeySchedule = D;
};
AES.prototype.encryptBlockRaw = function(e) {
  return e = asUInt32Array(e), cryptBlock(e, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(e) {
  var t = this.encryptBlockRaw(e), v = Buffer$e.allocUnsafe(16);
  return v.writeUInt32BE(t[0], 0), v.writeUInt32BE(t[1], 4), v.writeUInt32BE(t[2], 8), v.writeUInt32BE(t[3], 12), v;
};
AES.prototype.decryptBlock = function(e) {
  e = asUInt32Array(e);
  var t = e[1];
  e[1] = e[3], e[3] = t;
  var v = cryptBlock(e, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds), w = Buffer$e.allocUnsafe(16);
  return w.writeUInt32BE(v[0], 0), w.writeUInt32BE(v[3], 4), w.writeUInt32BE(v[2], 8), w.writeUInt32BE(v[1], 12), w;
};
AES.prototype.scrub = function() {
  scrubVec(this._keySchedule), scrubVec(this._invKeySchedule), scrubVec(this._key);
};
aes$5.AES = AES;
var Buffer$d = safeBufferExports$1.Buffer, ZEROES = Buffer$d.alloc(16, 0);
function toArray$1(e) {
  return [
    e.readUInt32BE(0),
    e.readUInt32BE(4),
    e.readUInt32BE(8),
    e.readUInt32BE(12)
  ];
}
function fromArray(e) {
  var t = Buffer$d.allocUnsafe(16);
  return t.writeUInt32BE(e[0] >>> 0, 0), t.writeUInt32BE(e[1] >>> 0, 4), t.writeUInt32BE(e[2] >>> 0, 8), t.writeUInt32BE(e[3] >>> 0, 12), t;
}
function GHASH$1(e) {
  this.h = e, this.state = Buffer$d.alloc(16, 0), this.cache = Buffer$d.allocUnsafe(0);
}
GHASH$1.prototype.ghash = function(e) {
  for (var t = -1; ++t < e.length; )
    this.state[t] ^= e[t];
  this._multiply();
};
GHASH$1.prototype._multiply = function() {
  for (var e = toArray$1(this.h), t = [0, 0, 0, 0], v, w, T, x = -1; ++x < 128; ) {
    for (w = (this.state[~~(x / 8)] & 1 << 7 - x % 8) !== 0, w && (t[0] ^= e[0], t[1] ^= e[1], t[2] ^= e[2], t[3] ^= e[3]), T = (e[3] & 1) !== 0, v = 3; v > 0; v--)
      e[v] = e[v] >>> 1 | (e[v - 1] & 1) << 31;
    e[0] = e[0] >>> 1, T && (e[0] = e[0] ^ 225 << 24);
  }
  this.state = fromArray(t);
};
GHASH$1.prototype.update = function(e) {
  this.cache = Buffer$d.concat([this.cache, e]);
  for (var t; this.cache.length >= 16; )
    t = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(t);
};
GHASH$1.prototype.final = function(e, t) {
  return this.cache.length && this.ghash(Buffer$d.concat([this.cache, ZEROES], 16)), this.ghash(fromArray([0, e, 0, t])), this.state;
};
var ghash = GHASH$1, aes$4 = aes$5, Buffer$c = safeBufferExports$1.Buffer, Transform$5 = cipherBase, inherits$8 = inherits_browserExports, GHASH = ghash, xor$3 = bufferXor, incr32 = incr32_1;
function xorTest(e, t) {
  var v = 0;
  e.length !== t.length && v++;
  for (var w = Math.min(e.length, t.length), T = 0; T < w; ++T)
    v += e[T] ^ t[T];
  return v;
}
function calcIv(e, t, v) {
  if (t.length === 12)
    return e._finID = Buffer$c.concat([t, Buffer$c.from([0, 0, 0, 1])]), Buffer$c.concat([t, Buffer$c.from([0, 0, 0, 2])]);
  var w = new GHASH(v), T = t.length, x = T % 16;
  w.update(t), x && (x = 16 - x, w.update(Buffer$c.alloc(x, 0))), w.update(Buffer$c.alloc(8, 0));
  var C = T * 8, D = Buffer$c.alloc(8);
  D.writeUIntBE(C, 0, 8), w.update(D), e._finID = w.state;
  var Y = Buffer$c.from(e._finID);
  return incr32(Y), Y;
}
function StreamCipher$3(e, t, v, w) {
  Transform$5.call(this);
  var T = Buffer$c.alloc(4, 0);
  this._cipher = new aes$4.AES(t);
  var x = this._cipher.encryptBlock(T);
  this._ghash = new GHASH(x), v = calcIv(this, v, x), this._prev = Buffer$c.from(v), this._cache = Buffer$c.allocUnsafe(0), this._secCache = Buffer$c.allocUnsafe(0), this._decrypt = w, this._alen = 0, this._len = 0, this._mode = e, this._authTag = null, this._called = !1;
}
inherits$8(StreamCipher$3, Transform$5);
StreamCipher$3.prototype._update = function(e) {
  if (!this._called && this._alen) {
    var t = 16 - this._alen % 16;
    t < 16 && (t = Buffer$c.alloc(t, 0), this._ghash.update(t));
  }
  this._called = !0;
  var v = this._mode.encrypt(this, e);
  return this._decrypt ? this._ghash.update(e) : this._ghash.update(v), this._len += e.length, v;
};
StreamCipher$3.prototype._final = function() {
  if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
  var e = xor$3(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && xorTest(e, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
  this._authTag = e, this._cipher.scrub();
};
StreamCipher$3.prototype.getAuthTag = function() {
  if (this._decrypt || !Buffer$c.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
  return this._authTag;
};
StreamCipher$3.prototype.setAuthTag = function(e) {
  if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
  this._authTag = e;
};
StreamCipher$3.prototype.setAAD = function(e) {
  if (this._called) throw new Error("Attempting to set AAD in unsupported state");
  this._ghash.update(e), this._alen += e.length;
};
var authCipher = StreamCipher$3, aes$3 = aes$5, Buffer$b = safeBufferExports$1.Buffer, Transform$4 = cipherBase, inherits$7 = inherits_browserExports;
function StreamCipher$2(e, t, v, w) {
  Transform$4.call(this), this._cipher = new aes$3.AES(t), this._prev = Buffer$b.from(v), this._cache = Buffer$b.allocUnsafe(0), this._secCache = Buffer$b.allocUnsafe(0), this._decrypt = w, this._mode = e;
}
inherits$7(StreamCipher$2, Transform$4);
StreamCipher$2.prototype._update = function(e) {
  return this._mode.encrypt(this, e, this._decrypt);
};
StreamCipher$2.prototype._final = function() {
  this._cipher.scrub();
};
var streamCipher = StreamCipher$2, Buffer$a = safeBufferExports$1.Buffer, MD5 = md5_js;
function EVP_BytesToKey(e, t, v, w) {
  if (Buffer$a.isBuffer(e) || (e = Buffer$a.from(e, "binary")), t && (Buffer$a.isBuffer(t) || (t = Buffer$a.from(t, "binary")), t.length !== 8))
    throw new RangeError("salt should be Buffer with 8 byte length");
  for (var T = v / 8, x = Buffer$a.alloc(T), C = Buffer$a.alloc(w || 0), D = Buffer$a.alloc(0); T > 0 || w > 0; ) {
    var Y = new MD5();
    Y.update(D), Y.update(e), t && Y.update(t), D = Y.digest();
    var L = 0;
    if (T > 0) {
      var q = x.length - T;
      L = Math.min(T, D.length), D.copy(x, q, 0, L), T -= L;
    }
    if (L < D.length && w > 0) {
      var N = C.length - w, F = Math.min(w, D.length - L);
      D.copy(C, N, L, L + F), w -= F;
    }
  }
  return D.fill(0), { key: x, iv: C };
}
var evp_bytestokey = EVP_BytesToKey, MODES$1 = modes_1, AuthCipher$1 = authCipher, Buffer$9 = safeBufferExports$1.Buffer, StreamCipher$1 = streamCipher, Transform$3 = cipherBase, aes$2 = aes$5, ebtk$2 = evp_bytestokey, inherits$6 = inherits_browserExports;
function Cipher(e, t, v) {
  Transform$3.call(this), this._cache = new Splitter$1(), this._cipher = new aes$2.AES(t), this._prev = Buffer$9.from(v), this._mode = e, this._autopadding = !0;
}
inherits$6(Cipher, Transform$3);
Cipher.prototype._update = function(e) {
  this._cache.add(e);
  for (var t, v, w = []; t = this._cache.get(); )
    v = this._mode.encrypt(this, t), w.push(v);
  return Buffer$9.concat(w);
};
var PADDING = Buffer$9.alloc(16, 16);
Cipher.prototype._final = function() {
  var e = this._cache.flush();
  if (this._autopadding)
    return e = this._mode.encrypt(this, e), this._cipher.scrub(), e;
  if (!e.equals(PADDING))
    throw this._cipher.scrub(), new Error("data not multiple of block length");
};
Cipher.prototype.setAutoPadding = function(e) {
  return this._autopadding = !!e, this;
};
function Splitter$1() {
  this.cache = Buffer$9.allocUnsafe(0);
}
Splitter$1.prototype.add = function(e) {
  this.cache = Buffer$9.concat([this.cache, e]);
};
Splitter$1.prototype.get = function() {
  if (this.cache.length > 15) {
    var e = this.cache.slice(0, 16);
    return this.cache = this.cache.slice(16), e;
  }
  return null;
};
Splitter$1.prototype.flush = function() {
  for (var e = 16 - this.cache.length, t = Buffer$9.allocUnsafe(e), v = -1; ++v < e; )
    t.writeUInt8(e, v);
  return Buffer$9.concat([this.cache, t]);
};
function createCipheriv$1(e, t, v) {
  var w = MODES$1[e.toLowerCase()];
  if (!w) throw new TypeError("invalid suite type");
  if (typeof t == "string" && (t = Buffer$9.from(t)), t.length !== w.key / 8) throw new TypeError("invalid key length " + t.length);
  if (typeof v == "string" && (v = Buffer$9.from(v)), w.mode !== "GCM" && v.length !== w.iv) throw new TypeError("invalid iv length " + v.length);
  return w.type === "stream" ? new StreamCipher$1(w.module, t, v) : w.type === "auth" ? new AuthCipher$1(w.module, t, v) : new Cipher(w.module, t, v);
}
function createCipher$1(e, t) {
  var v = MODES$1[e.toLowerCase()];
  if (!v) throw new TypeError("invalid suite type");
  var w = ebtk$2(t, !1, v.key, v.iv);
  return createCipheriv$1(e, w.key, w.iv);
}
encrypter.createCipheriv = createCipheriv$1;
encrypter.createCipher = createCipher$1;
var decrypter = {}, AuthCipher = authCipher, Buffer$8 = safeBufferExports$1.Buffer, MODES = modes_1, StreamCipher = streamCipher, Transform$2 = cipherBase, aes$1 = aes$5, ebtk$1 = evp_bytestokey, inherits$5 = inherits_browserExports;
function Decipher(e, t, v) {
  Transform$2.call(this), this._cache = new Splitter(), this._last = void 0, this._cipher = new aes$1.AES(t), this._prev = Buffer$8.from(v), this._mode = e, this._autopadding = !0;
}
inherits$5(Decipher, Transform$2);
Decipher.prototype._update = function(e) {
  this._cache.add(e);
  for (var t, v, w = []; t = this._cache.get(this._autopadding); )
    v = this._mode.decrypt(this, t), w.push(v);
  return Buffer$8.concat(w);
};
Decipher.prototype._final = function() {
  var e = this._cache.flush();
  if (this._autopadding)
    return unpad(this._mode.decrypt(this, e));
  if (e)
    throw new Error("data not multiple of block length");
};
Decipher.prototype.setAutoPadding = function(e) {
  return this._autopadding = !!e, this;
};
function Splitter() {
  this.cache = Buffer$8.allocUnsafe(0);
}
Splitter.prototype.add = function(e) {
  this.cache = Buffer$8.concat([this.cache, e]);
};
Splitter.prototype.get = function(e) {
  var t;
  if (e) {
    if (this.cache.length > 16)
      return t = this.cache.slice(0, 16), this.cache = this.cache.slice(16), t;
  } else if (this.cache.length >= 16)
    return t = this.cache.slice(0, 16), this.cache = this.cache.slice(16), t;
  return null;
};
Splitter.prototype.flush = function() {
  if (this.cache.length) return this.cache;
};
function unpad(e) {
  var t = e[15];
  if (t < 1 || t > 16)
    throw new Error("unable to decrypt data");
  for (var v = -1; ++v < t; )
    if (e[v + (16 - t)] !== t)
      throw new Error("unable to decrypt data");
  if (t !== 16)
    return e.slice(0, 16 - t);
}
function createDecipheriv$1(e, t, v) {
  var w = MODES[e.toLowerCase()];
  if (!w) throw new TypeError("invalid suite type");
  if (typeof v == "string" && (v = Buffer$8.from(v)), w.mode !== "GCM" && v.length !== w.iv) throw new TypeError("invalid iv length " + v.length);
  if (typeof t == "string" && (t = Buffer$8.from(t)), t.length !== w.key / 8) throw new TypeError("invalid key length " + t.length);
  return w.type === "stream" ? new StreamCipher(w.module, t, v, !0) : w.type === "auth" ? new AuthCipher(w.module, t, v, !0) : new Decipher(w.module, t, v);
}
function createDecipher$1(e, t) {
  var v = MODES[e.toLowerCase()];
  if (!v) throw new TypeError("invalid suite type");
  var w = ebtk$1(t, !1, v.key, v.iv);
  return createDecipheriv$1(e, w.key, w.iv);
}
decrypter.createDecipher = createDecipher$1;
decrypter.createDecipheriv = createDecipheriv$1;
var ciphers$2 = encrypter, deciphers = decrypter, modes$1 = require$$2;
function getCiphers$1() {
  return Object.keys(modes$1);
}
browser$5.createCipher = browser$5.Cipher = ciphers$2.createCipher;
browser$5.createCipheriv = browser$5.Cipheriv = ciphers$2.createCipheriv;
browser$5.createDecipher = browser$5.Decipher = deciphers.createDecipher;
browser$5.createDecipheriv = browser$5.Decipheriv = deciphers.createDecipheriv;
browser$5.listCiphers = browser$5.getCiphers = getCiphers$1;
var modes = {};
(function(e) {
  e["des-ecb"] = {
    key: 8,
    iv: 0
  }, e["des-cbc"] = e.des = {
    key: 8,
    iv: 8
  }, e["des-ede3-cbc"] = e.des3 = {
    key: 24,
    iv: 8
  }, e["des-ede3"] = {
    key: 24,
    iv: 0
  }, e["des-ede-cbc"] = {
    key: 16,
    iv: 8
  }, e["des-ede"] = {
    key: 16,
    iv: 0
  };
})(modes);
var DES = browserifyDes, aes = browser$5, aesModes = modes_1, desModes = modes, ebtk = evp_bytestokey;
function createCipher(e, t) {
  e = e.toLowerCase();
  var v, w;
  if (aesModes[e])
    v = aesModes[e].key, w = aesModes[e].iv;
  else if (desModes[e])
    v = desModes[e].key * 8, w = desModes[e].iv;
  else
    throw new TypeError("invalid suite type");
  var T = ebtk(t, !1, v, w);
  return createCipheriv(e, T.key, T.iv);
}
function createDecipher(e, t) {
  e = e.toLowerCase();
  var v, w;
  if (aesModes[e])
    v = aesModes[e].key, w = aesModes[e].iv;
  else if (desModes[e])
    v = desModes[e].key * 8, w = desModes[e].iv;
  else
    throw new TypeError("invalid suite type");
  var T = ebtk(t, !1, v, w);
  return createDecipheriv(e, T.key, T.iv);
}
function createCipheriv(e, t, v) {
  if (e = e.toLowerCase(), aesModes[e]) return aes.createCipheriv(e, t, v);
  if (desModes[e]) return new DES({ key: t, iv: v, mode: e });
  throw new TypeError("invalid suite type");
}
function createDecipheriv(e, t, v) {
  if (e = e.toLowerCase(), aesModes[e]) return aes.createDecipheriv(e, t, v);
  if (desModes[e]) return new DES({ key: t, iv: v, mode: e, decrypt: !0 });
  throw new TypeError("invalid suite type");
}
function getCiphers() {
  return Object.keys(desModes).concat(aes.getCiphers());
}
browser$6.createCipher = browser$6.Cipher = createCipher;
browser$6.createCipheriv = browser$6.Cipheriv = createCipheriv;
browser$6.createDecipher = browser$6.Decipher = createDecipher;
browser$6.createDecipheriv = browser$6.Decipheriv = createDecipheriv;
browser$6.listCiphers = browser$6.getCiphers = getCiphers;
var browser$4 = {}, bn$1 = { exports: {} };
bn$1.exports;
(function(e) {
  (function(t, v) {
    function w(pr, Di) {
      if (!pr) throw new Error(Di || "Assertion failed");
    }
    function T(pr, Di) {
      pr.super_ = Di;
      var z = function() {
      };
      z.prototype = Di.prototype, pr.prototype = new z(), pr.prototype.constructor = pr;
    }
    function x(pr, Di, z) {
      if (x.isBN(pr))
        return pr;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, pr !== null && ((Di === "le" || Di === "be") && (z = Di, Di = 10), this._init(pr || 0, Di || 10, z || "be"));
    }
    typeof t == "object" ? t.exports = x : v.BN = x, x.BN = x, x.wordSize = 26;
    var C;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? C = window.Buffer : C = require$$1$2.Buffer;
    } catch {
    }
    x.isBN = function(pr) {
      return pr instanceof x ? !0 : pr !== null && typeof pr == "object" && pr.constructor.wordSize === x.wordSize && Array.isArray(pr.words);
    }, x.max = function(pr, Di) {
      return pr.cmp(Di) > 0 ? pr : Di;
    }, x.min = function(pr, Di) {
      return pr.cmp(Di) < 0 ? pr : Di;
    }, x.prototype._init = function(pr, Di, z) {
      if (typeof pr == "number")
        return this._initNumber(pr, Di, z);
      if (typeof pr == "object")
        return this._initArray(pr, Di, z);
      Di === "hex" && (Di = 16), w(Di === (Di | 0) && Di >= 2 && Di <= 36), pr = pr.toString().replace(/\s+/g, "");
      var gr = 0;
      pr[0] === "-" && (gr++, this.negative = 1), gr < pr.length && (Di === 16 ? this._parseHex(pr, gr, z) : (this._parseBase(pr, Di, gr), z === "le" && this._initArray(this.toArray(), Di, z)));
    }, x.prototype._initNumber = function(pr, Di, z) {
      pr < 0 && (this.negative = 1, pr = -pr), pr < 67108864 ? (this.words = [pr & 67108863], this.length = 1) : pr < 4503599627370496 ? (this.words = [
        pr & 67108863,
        pr / 67108864 & 67108863
      ], this.length = 2) : (w(pr < 9007199254740992), this.words = [
        pr & 67108863,
        pr / 67108864 & 67108863,
        1
      ], this.length = 3), z === "le" && this._initArray(this.toArray(), Di, z);
    }, x.prototype._initArray = function(pr, Di, z) {
      if (w(typeof pr.length == "number"), pr.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(pr.length / 3), this.words = new Array(this.length);
      for (var gr = 0; gr < this.length; gr++)
        this.words[gr] = 0;
      var vr, Oi, Mi = 0;
      if (z === "be")
        for (gr = pr.length - 1, vr = 0; gr >= 0; gr -= 3)
          Oi = pr[gr] | pr[gr - 1] << 8 | pr[gr - 2] << 16, this.words[vr] |= Oi << Mi & 67108863, this.words[vr + 1] = Oi >>> 26 - Mi & 67108863, Mi += 24, Mi >= 26 && (Mi -= 26, vr++);
      else if (z === "le")
        for (gr = 0, vr = 0; gr < pr.length; gr += 3)
          Oi = pr[gr] | pr[gr + 1] << 8 | pr[gr + 2] << 16, this.words[vr] |= Oi << Mi & 67108863, this.words[vr + 1] = Oi >>> 26 - Mi & 67108863, Mi += 24, Mi >= 26 && (Mi -= 26, vr++);
      return this.strip();
    };
    function D(pr, Di) {
      var z = pr.charCodeAt(Di);
      return z >= 65 && z <= 70 ? z - 55 : z >= 97 && z <= 102 ? z - 87 : z - 48 & 15;
    }
    function Y(pr, Di, z) {
      var gr = D(pr, z);
      return z - 1 >= Di && (gr |= D(pr, z - 1) << 4), gr;
    }
    x.prototype._parseHex = function(pr, Di, z) {
      this.length = Math.ceil((pr.length - Di) / 6), this.words = new Array(this.length);
      for (var gr = 0; gr < this.length; gr++)
        this.words[gr] = 0;
      var vr = 0, Oi = 0, Mi;
      if (z === "be")
        for (gr = pr.length - 1; gr >= Di; gr -= 2)
          Mi = Y(pr, Di, gr) << vr, this.words[Oi] |= Mi & 67108863, vr >= 18 ? (vr -= 18, Oi += 1, this.words[Oi] |= Mi >>> 26) : vr += 8;
      else {
        var ki = pr.length - Di;
        for (gr = ki % 2 === 0 ? Di + 1 : Di; gr < pr.length; gr += 2)
          Mi = Y(pr, Di, gr) << vr, this.words[Oi] |= Mi & 67108863, vr >= 18 ? (vr -= 18, Oi += 1, this.words[Oi] |= Mi >>> 26) : vr += 8;
      }
      this.strip();
    };
    function L(pr, Di, z, gr) {
      for (var vr = 0, Oi = Math.min(pr.length, z), Mi = Di; Mi < Oi; Mi++) {
        var ki = pr.charCodeAt(Mi) - 48;
        vr *= gr, ki >= 49 ? vr += ki - 49 + 10 : ki >= 17 ? vr += ki - 17 + 10 : vr += ki;
      }
      return vr;
    }
    x.prototype._parseBase = function(pr, Di, z) {
      this.words = [0], this.length = 1;
      for (var gr = 0, vr = 1; vr <= 67108863; vr *= Di)
        gr++;
      gr--, vr = vr / Di | 0;
      for (var Oi = pr.length - z, Mi = Oi % gr, ki = Math.min(Oi, Oi - Mi) + z, yr = 0, xi = z; xi < ki; xi += gr)
        yr = L(pr, xi, xi + gr, Di), this.imuln(vr), this.words[0] + yr < 67108864 ? this.words[0] += yr : this._iaddn(yr);
      if (Mi !== 0) {
        var Si = 1;
        for (yr = L(pr, xi, pr.length, Di), xi = 0; xi < Mi; xi++)
          Si *= Di;
        this.imuln(Si), this.words[0] + yr < 67108864 ? this.words[0] += yr : this._iaddn(yr);
      }
      this.strip();
    }, x.prototype.copy = function(pr) {
      pr.words = new Array(this.length);
      for (var Di = 0; Di < this.length; Di++)
        pr.words[Di] = this.words[Di];
      pr.length = this.length, pr.negative = this.negative, pr.red = this.red;
    }, x.prototype.clone = function() {
      var pr = new x(null);
      return this.copy(pr), pr;
    }, x.prototype._expand = function(pr) {
      for (; this.length < pr; )
        this.words[this.length++] = 0;
      return this;
    }, x.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, x.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, x.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var q = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], N = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], F = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    x.prototype.toString = function(pr, Di) {
      pr = pr || 10, Di = Di | 0 || 1;
      var z;
      if (pr === 16 || pr === "hex") {
        z = "";
        for (var gr = 0, vr = 0, Oi = 0; Oi < this.length; Oi++) {
          var Mi = this.words[Oi], ki = ((Mi << gr | vr) & 16777215).toString(16);
          vr = Mi >>> 24 - gr & 16777215, gr += 2, gr >= 26 && (gr -= 26, Oi--), vr !== 0 || Oi !== this.length - 1 ? z = q[6 - ki.length] + ki + z : z = ki + z;
        }
        for (vr !== 0 && (z = vr.toString(16) + z); z.length % Di !== 0; )
          z = "0" + z;
        return this.negative !== 0 && (z = "-" + z), z;
      }
      if (pr === (pr | 0) && pr >= 2 && pr <= 36) {
        var yr = N[pr], xi = F[pr];
        z = "";
        var Si = this.clone();
        for (Si.negative = 0; !Si.isZero(); ) {
          var Ci = Si.modn(xi).toString(pr);
          Si = Si.idivn(xi), Si.isZero() ? z = Ci + z : z = q[yr - Ci.length] + Ci + z;
        }
        for (this.isZero() && (z = "0" + z); z.length % Di !== 0; )
          z = "0" + z;
        return this.negative !== 0 && (z = "-" + z), z;
      }
      w(!1, "Base should be between 2 and 36");
    }, x.prototype.toNumber = function() {
      var pr = this.words[0];
      return this.length === 2 ? pr += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? pr += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && w(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -pr : pr;
    }, x.prototype.toJSON = function() {
      return this.toString(16);
    }, x.prototype.toBuffer = function(pr, Di) {
      return w(typeof C < "u"), this.toArrayLike(C, pr, Di);
    }, x.prototype.toArray = function(pr, Di) {
      return this.toArrayLike(Array, pr, Di);
    }, x.prototype.toArrayLike = function(pr, Di, z) {
      var gr = this.byteLength(), vr = z || Math.max(1, gr);
      w(gr <= vr, "byte array longer than desired length"), w(vr > 0, "Requested array length <= 0"), this.strip();
      var Oi = Di === "le", Mi = new pr(vr), ki, yr, xi = this.clone();
      if (Oi) {
        for (yr = 0; !xi.isZero(); yr++)
          ki = xi.andln(255), xi.iushrn(8), Mi[yr] = ki;
        for (; yr < vr; yr++)
          Mi[yr] = 0;
      } else {
        for (yr = 0; yr < vr - gr; yr++)
          Mi[yr] = 0;
        for (yr = 0; !xi.isZero(); yr++)
          ki = xi.andln(255), xi.iushrn(8), Mi[vr - yr - 1] = ki;
      }
      return Mi;
    }, Math.clz32 ? x.prototype._countBits = function(pr) {
      return 32 - Math.clz32(pr);
    } : x.prototype._countBits = function(pr) {
      var Di = pr, z = 0;
      return Di >= 4096 && (z += 13, Di >>>= 13), Di >= 64 && (z += 7, Di >>>= 7), Di >= 8 && (z += 4, Di >>>= 4), Di >= 2 && (z += 2, Di >>>= 2), z + Di;
    }, x.prototype._zeroBits = function(pr) {
      if (pr === 0) return 26;
      var Di = pr, z = 0;
      return Di & 8191 || (z += 13, Di >>>= 13), Di & 127 || (z += 7, Di >>>= 7), Di & 15 || (z += 4, Di >>>= 4), Di & 3 || (z += 2, Di >>>= 2), Di & 1 || z++, z;
    }, x.prototype.bitLength = function() {
      var pr = this.words[this.length - 1], Di = this._countBits(pr);
      return (this.length - 1) * 26 + Di;
    };
    function ae(pr) {
      for (var Di = new Array(pr.bitLength()), z = 0; z < Di.length; z++) {
        var gr = z / 26 | 0, vr = z % 26;
        Di[z] = (pr.words[gr] & 1 << vr) >>> vr;
      }
      return Di;
    }
    x.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var pr = 0, Di = 0; Di < this.length; Di++) {
        var z = this._zeroBits(this.words[Di]);
        if (pr += z, z !== 26) break;
      }
      return pr;
    }, x.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, x.prototype.toTwos = function(pr) {
      return this.negative !== 0 ? this.abs().inotn(pr).iaddn(1) : this.clone();
    }, x.prototype.fromTwos = function(pr) {
      return this.testn(pr - 1) ? this.notn(pr).iaddn(1).ineg() : this.clone();
    }, x.prototype.isNeg = function() {
      return this.negative !== 0;
    }, x.prototype.neg = function() {
      return this.clone().ineg();
    }, x.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, x.prototype.iuor = function(pr) {
      for (; this.length < pr.length; )
        this.words[this.length++] = 0;
      for (var Di = 0; Di < pr.length; Di++)
        this.words[Di] = this.words[Di] | pr.words[Di];
      return this.strip();
    }, x.prototype.ior = function(pr) {
      return w((this.negative | pr.negative) === 0), this.iuor(pr);
    }, x.prototype.or = function(pr) {
      return this.length > pr.length ? this.clone().ior(pr) : pr.clone().ior(this);
    }, x.prototype.uor = function(pr) {
      return this.length > pr.length ? this.clone().iuor(pr) : pr.clone().iuor(this);
    }, x.prototype.iuand = function(pr) {
      var Di;
      this.length > pr.length ? Di = pr : Di = this;
      for (var z = 0; z < Di.length; z++)
        this.words[z] = this.words[z] & pr.words[z];
      return this.length = Di.length, this.strip();
    }, x.prototype.iand = function(pr) {
      return w((this.negative | pr.negative) === 0), this.iuand(pr);
    }, x.prototype.and = function(pr) {
      return this.length > pr.length ? this.clone().iand(pr) : pr.clone().iand(this);
    }, x.prototype.uand = function(pr) {
      return this.length > pr.length ? this.clone().iuand(pr) : pr.clone().iuand(this);
    }, x.prototype.iuxor = function(pr) {
      var Di, z;
      this.length > pr.length ? (Di = this, z = pr) : (Di = pr, z = this);
      for (var gr = 0; gr < z.length; gr++)
        this.words[gr] = Di.words[gr] ^ z.words[gr];
      if (this !== Di)
        for (; gr < Di.length; gr++)
          this.words[gr] = Di.words[gr];
      return this.length = Di.length, this.strip();
    }, x.prototype.ixor = function(pr) {
      return w((this.negative | pr.negative) === 0), this.iuxor(pr);
    }, x.prototype.xor = function(pr) {
      return this.length > pr.length ? this.clone().ixor(pr) : pr.clone().ixor(this);
    }, x.prototype.uxor = function(pr) {
      return this.length > pr.length ? this.clone().iuxor(pr) : pr.clone().iuxor(this);
    }, x.prototype.inotn = function(pr) {
      w(typeof pr == "number" && pr >= 0);
      var Di = Math.ceil(pr / 26) | 0, z = pr % 26;
      this._expand(Di), z > 0 && Di--;
      for (var gr = 0; gr < Di; gr++)
        this.words[gr] = ~this.words[gr] & 67108863;
      return z > 0 && (this.words[gr] = ~this.words[gr] & 67108863 >> 26 - z), this.strip();
    }, x.prototype.notn = function(pr) {
      return this.clone().inotn(pr);
    }, x.prototype.setn = function(pr, Di) {
      w(typeof pr == "number" && pr >= 0);
      var z = pr / 26 | 0, gr = pr % 26;
      return this._expand(z + 1), Di ? this.words[z] = this.words[z] | 1 << gr : this.words[z] = this.words[z] & ~(1 << gr), this.strip();
    }, x.prototype.iadd = function(pr) {
      var Di;
      if (this.negative !== 0 && pr.negative === 0)
        return this.negative = 0, Di = this.isub(pr), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && pr.negative !== 0)
        return pr.negative = 0, Di = this.isub(pr), pr.negative = 1, Di._normSign();
      var z, gr;
      this.length > pr.length ? (z = this, gr = pr) : (z = pr, gr = this);
      for (var vr = 0, Oi = 0; Oi < gr.length; Oi++)
        Di = (z.words[Oi] | 0) + (gr.words[Oi] | 0) + vr, this.words[Oi] = Di & 67108863, vr = Di >>> 26;
      for (; vr !== 0 && Oi < z.length; Oi++)
        Di = (z.words[Oi] | 0) + vr, this.words[Oi] = Di & 67108863, vr = Di >>> 26;
      if (this.length = z.length, vr !== 0)
        this.words[this.length] = vr, this.length++;
      else if (z !== this)
        for (; Oi < z.length; Oi++)
          this.words[Oi] = z.words[Oi];
      return this;
    }, x.prototype.add = function(pr) {
      var Di;
      return pr.negative !== 0 && this.negative === 0 ? (pr.negative = 0, Di = this.sub(pr), pr.negative ^= 1, Di) : pr.negative === 0 && this.negative !== 0 ? (this.negative = 0, Di = pr.sub(this), this.negative = 1, Di) : this.length > pr.length ? this.clone().iadd(pr) : pr.clone().iadd(this);
    }, x.prototype.isub = function(pr) {
      if (pr.negative !== 0) {
        pr.negative = 0;
        var Di = this.iadd(pr);
        return pr.negative = 1, Di._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(pr), this.negative = 1, this._normSign();
      var z = this.cmp(pr);
      if (z === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var gr, vr;
      z > 0 ? (gr = this, vr = pr) : (gr = pr, vr = this);
      for (var Oi = 0, Mi = 0; Mi < vr.length; Mi++)
        Di = (gr.words[Mi] | 0) - (vr.words[Mi] | 0) + Oi, Oi = Di >> 26, this.words[Mi] = Di & 67108863;
      for (; Oi !== 0 && Mi < gr.length; Mi++)
        Di = (gr.words[Mi] | 0) + Oi, Oi = Di >> 26, this.words[Mi] = Di & 67108863;
      if (Oi === 0 && Mi < gr.length && gr !== this)
        for (; Mi < gr.length; Mi++)
          this.words[Mi] = gr.words[Mi];
      return this.length = Math.max(this.length, Mi), gr !== this && (this.negative = 1), this.strip();
    }, x.prototype.sub = function(pr) {
      return this.clone().isub(pr);
    };
    function he(pr, Di, z) {
      z.negative = Di.negative ^ pr.negative;
      var gr = pr.length + Di.length | 0;
      z.length = gr, gr = gr - 1 | 0;
      var vr = pr.words[0] | 0, Oi = Di.words[0] | 0, Mi = vr * Oi, ki = Mi & 67108863, yr = Mi / 67108864 | 0;
      z.words[0] = ki;
      for (var xi = 1; xi < gr; xi++) {
        for (var Si = yr >>> 26, Ci = yr & 67108863, Ki = Math.min(xi, Di.length - 1), Yi = Math.max(0, xi - pr.length + 1); Yi <= Ki; Yi++) {
          var Qi = xi - Yi | 0;
          vr = pr.words[Qi] | 0, Oi = Di.words[Yi] | 0, Mi = vr * Oi + Ci, Si += Mi / 67108864 | 0, Ci = Mi & 67108863;
        }
        z.words[xi] = Ci | 0, yr = Si | 0;
      }
      return yr !== 0 ? z.words[xi] = yr | 0 : z.length--, z.strip();
    }
    var tt = function(pr, Di, z) {
      var gr = pr.words, vr = Di.words, Oi = z.words, Mi = 0, ki, yr, xi, Si = gr[0] | 0, Ci = Si & 8191, Ki = Si >>> 13, Yi = gr[1] | 0, Qi = Yi & 8191, Zi = Yi >>> 13, Ni = gr[2] | 0, Fi = Ni & 8191, Xi = Ni >>> 13, to = gr[3] | 0, zi = to & 8191, Gi = to >>> 13, no = gr[4] | 0, so = no & 8191, ho = no >>> 13, uo = gr[5] | 0, ao = uo & 8191, Bo = uo >>> 13, io = gr[6] | 0, po = io & 8191, Do = io >>> 13, Io = gr[7] | 0, mo = Io & 8191, Ro = Io >>> 13, _o = gr[8] | 0, yo = _o & 8191, To = _o >>> 13, xo = gr[9] | 0, wo = xo & 8191, Ai = xo >>> 13, Pi = vr[0] | 0, Ui = Pi & 8191, Ji = Pi >>> 13, eo = vr[1] | 0, ro = eo & 8191, oo = eo >>> 13, bo = vr[2] | 0, lo = bo & 8191, vo = bo >>> 13, go = vr[3] | 0, co = go & 8191, Lo = go >>> 13, jo = vr[4] | 0, $o = jo & 8191, qo = jo >>> 13, Uo = vr[5] | 0, So = Uo & 8191, Fo = Uo >>> 13, Wo = vr[6] | 0, Eo = Wo & 8191, Ho = Wo >>> 13, zo = vr[7] | 0, Mo = zo & 8191, Go = zo >>> 13, Vo = vr[8] | 0, ko = Vo & 8191, Ko = Vo >>> 13, Zo = vr[9] | 0, Ao = Zo & 8191, Yo = Zo >>> 13;
      z.negative = pr.negative ^ Di.negative, z.length = 19, ki = Math.imul(Ci, Ui), yr = Math.imul(Ci, Ji), yr = yr + Math.imul(Ki, Ui) | 0, xi = Math.imul(Ki, Ji);
      var Po = (Mi + ki | 0) + ((yr & 8191) << 13) | 0;
      Mi = (xi + (yr >>> 13) | 0) + (Po >>> 26) | 0, Po &= 67108863, ki = Math.imul(Qi, Ui), yr = Math.imul(Qi, Ji), yr = yr + Math.imul(Zi, Ui) | 0, xi = Math.imul(Zi, Ji), ki = ki + Math.imul(Ci, ro) | 0, yr = yr + Math.imul(Ci, oo) | 0, yr = yr + Math.imul(Ki, ro) | 0, xi = xi + Math.imul(Ki, oo) | 0;
      var No = (Mi + ki | 0) + ((yr & 8191) << 13) | 0;
      Mi = (xi + (yr >>> 13) | 0) + (No >>> 26) | 0, No &= 67108863, ki = Math.imul(Fi, Ui), yr = Math.imul(Fi, Ji), yr = yr + Math.imul(Xi, Ui) | 0, xi = Math.imul(Xi, Ji), ki = ki + Math.imul(Qi, ro) | 0, yr = yr + Math.imul(Qi, oo) | 0, yr = yr + Math.imul(Zi, ro) | 0, xi = xi + Math.imul(Zi, oo) | 0, ki = ki + Math.imul(Ci, lo) | 0, yr = yr + Math.imul(Ci, vo) | 0, yr = yr + Math.imul(Ki, lo) | 0, xi = xi + Math.imul(Ki, vo) | 0;
      var ha = (Mi + ki | 0) + ((yr & 8191) << 13) | 0;
      Mi = (xi + (yr >>> 13) | 0) + (ha >>> 26) | 0, ha &= 67108863, ki = Math.imul(zi, Ui), yr = Math.imul(zi, Ji), yr = yr + Math.imul(Gi, Ui) | 0, xi = Math.imul(Gi, Ji), ki = ki + Math.imul(Fi, ro) | 0, yr = yr + Math.imul(Fi, oo) | 0, yr = yr + Math.imul(Xi, ro) | 0, xi = xi + Math.imul(Xi, oo) | 0, ki = ki + Math.imul(Qi, lo) | 0, yr = yr + Math.imul(Qi, vo) | 0, yr = yr + Math.imul(Zi, lo) | 0, xi = xi + Math.imul(Zi, vo) | 0, ki = ki + Math.imul(Ci, co) | 0, yr = yr + Math.imul(Ci, Lo) | 0, yr = yr + Math.imul(Ki, co) | 0, xi = xi + Math.imul(Ki, Lo) | 0;
      var da = (Mi + ki | 0) + ((yr & 8191) << 13) | 0;
      Mi = (xi + (yr >>> 13) | 0) + (da >>> 26) | 0, da &= 67108863, ki = Math.imul(so, Ui), yr = Math.imul(so, Ji), yr = yr + Math.imul(ho, Ui) | 0, xi = Math.imul(ho, Ji), ki = ki + Math.imul(zi, ro) | 0, yr = yr + Math.imul(zi, oo) | 0, yr = yr + Math.imul(Gi, ro) | 0, xi = xi + Math.imul(Gi, oo) | 0, ki = ki + Math.imul(Fi, lo) | 0, yr = yr + Math.imul(Fi, vo) | 0, yr = yr + Math.imul(Xi, lo) | 0, xi = xi + Math.imul(Xi, vo) | 0, ki = ki + Math.imul(Qi, co) | 0, yr = yr + Math.imul(Qi, Lo) | 0, yr = yr + Math.imul(Zi, co) | 0, xi = xi + Math.imul(Zi, Lo) | 0, ki = ki + Math.imul(Ci, $o) | 0, yr = yr + Math.imul(Ci, qo) | 0, yr = yr + Math.imul(Ki, $o) | 0, xi = xi + Math.imul(Ki, qo) | 0;
      var pa = (Mi + ki | 0) + ((yr & 8191) << 13) | 0;
      Mi = (xi + (yr >>> 13) | 0) + (pa >>> 26) | 0, pa &= 67108863, ki = Math.imul(ao, Ui), yr = Math.imul(ao, Ji), yr = yr + Math.imul(Bo, Ui) | 0, xi = Math.imul(Bo, Ji), ki = ki + Math.imul(so, ro) | 0, yr = yr + Math.imul(so, oo) | 0, yr = yr + Math.imul(ho, ro) | 0, xi = xi + Math.imul(ho, oo) | 0, ki = ki + Math.imul(zi, lo) | 0, yr = yr + Math.imul(zi, vo) | 0, yr = yr + Math.imul(Gi, lo) | 0, xi = xi + Math.imul(Gi, vo) | 0, ki = ki + Math.imul(Fi, co) | 0, yr = yr + Math.imul(Fi, Lo) | 0, yr = yr + Math.imul(Xi, co) | 0, xi = xi + Math.imul(Xi, Lo) | 0, ki = ki + Math.imul(Qi, $o) | 0, yr = yr + Math.imul(Qi, qo) | 0, yr = yr + Math.imul(Zi, $o) | 0, xi = xi + Math.imul(Zi, qo) | 0, ki = ki + Math.imul(Ci, So) | 0, yr = yr + Math.imul(Ci, Fo) | 0, yr = yr + Math.imul(Ki, So) | 0, xi = xi + Math.imul(Ki, Fo) | 0;
      var ma = (Mi + ki | 0) + ((yr & 8191) << 13) | 0;
      Mi = (xi + (yr >>> 13) | 0) + (ma >>> 26) | 0, ma &= 67108863, ki = Math.imul(po, Ui), yr = Math.imul(po, Ji), yr = yr + Math.imul(Do, Ui) | 0, xi = Math.imul(Do, Ji), ki = ki + Math.imul(ao, ro) | 0, yr = yr + Math.imul(ao, oo) | 0, yr = yr + Math.imul(Bo, ro) | 0, xi = xi + Math.imul(Bo, oo) | 0, ki = ki + Math.imul(so, lo) | 0, yr = yr + Math.imul(so, vo) | 0, yr = yr + Math.imul(ho, lo) | 0, xi = xi + Math.imul(ho, vo) | 0, ki = ki + Math.imul(zi, co) | 0, yr = yr + Math.imul(zi, Lo) | 0, yr = yr + Math.imul(Gi, co) | 0, xi = xi + Math.imul(Gi, Lo) | 0, ki = ki + Math.imul(Fi, $o) | 0, yr = yr + Math.imul(Fi, qo) | 0, yr = yr + Math.imul(Xi, $o) | 0, xi = xi + Math.imul(Xi, qo) | 0, ki = ki + Math.imul(Qi, So) | 0, yr = yr + Math.imul(Qi, Fo) | 0, yr = yr + Math.imul(Zi, So) | 0, xi = xi + Math.imul(Zi, Fo) | 0, ki = ki + Math.imul(Ci, Eo) | 0, yr = yr + Math.imul(Ci, Ho) | 0, yr = yr + Math.imul(Ki, Eo) | 0, xi = xi + Math.imul(Ki, Ho) | 0;
      var ya = (Mi + ki | 0) + ((yr & 8191) << 13) | 0;
      Mi = (xi + (yr >>> 13) | 0) + (ya >>> 26) | 0, ya &= 67108863, ki = Math.imul(mo, Ui), yr = Math.imul(mo, Ji), yr = yr + Math.imul(Ro, Ui) | 0, xi = Math.imul(Ro, Ji), ki = ki + Math.imul(po, ro) | 0, yr = yr + Math.imul(po, oo) | 0, yr = yr + Math.imul(Do, ro) | 0, xi = xi + Math.imul(Do, oo) | 0, ki = ki + Math.imul(ao, lo) | 0, yr = yr + Math.imul(ao, vo) | 0, yr = yr + Math.imul(Bo, lo) | 0, xi = xi + Math.imul(Bo, vo) | 0, ki = ki + Math.imul(so, co) | 0, yr = yr + Math.imul(so, Lo) | 0, yr = yr + Math.imul(ho, co) | 0, xi = xi + Math.imul(ho, Lo) | 0, ki = ki + Math.imul(zi, $o) | 0, yr = yr + Math.imul(zi, qo) | 0, yr = yr + Math.imul(Gi, $o) | 0, xi = xi + Math.imul(Gi, qo) | 0, ki = ki + Math.imul(Fi, So) | 0, yr = yr + Math.imul(Fi, Fo) | 0, yr = yr + Math.imul(Xi, So) | 0, xi = xi + Math.imul(Xi, Fo) | 0, ki = ki + Math.imul(Qi, Eo) | 0, yr = yr + Math.imul(Qi, Ho) | 0, yr = yr + Math.imul(Zi, Eo) | 0, xi = xi + Math.imul(Zi, Ho) | 0, ki = ki + Math.imul(Ci, Mo) | 0, yr = yr + Math.imul(Ci, Go) | 0, yr = yr + Math.imul(Ki, Mo) | 0, xi = xi + Math.imul(Ki, Go) | 0;
      var ga = (Mi + ki | 0) + ((yr & 8191) << 13) | 0;
      Mi = (xi + (yr >>> 13) | 0) + (ga >>> 26) | 0, ga &= 67108863, ki = Math.imul(yo, Ui), yr = Math.imul(yo, Ji), yr = yr + Math.imul(To, Ui) | 0, xi = Math.imul(To, Ji), ki = ki + Math.imul(mo, ro) | 0, yr = yr + Math.imul(mo, oo) | 0, yr = yr + Math.imul(Ro, ro) | 0, xi = xi + Math.imul(Ro, oo) | 0, ki = ki + Math.imul(po, lo) | 0, yr = yr + Math.imul(po, vo) | 0, yr = yr + Math.imul(Do, lo) | 0, xi = xi + Math.imul(Do, vo) | 0, ki = ki + Math.imul(ao, co) | 0, yr = yr + Math.imul(ao, Lo) | 0, yr = yr + Math.imul(Bo, co) | 0, xi = xi + Math.imul(Bo, Lo) | 0, ki = ki + Math.imul(so, $o) | 0, yr = yr + Math.imul(so, qo) | 0, yr = yr + Math.imul(ho, $o) | 0, xi = xi + Math.imul(ho, qo) | 0, ki = ki + Math.imul(zi, So) | 0, yr = yr + Math.imul(zi, Fo) | 0, yr = yr + Math.imul(Gi, So) | 0, xi = xi + Math.imul(Gi, Fo) | 0, ki = ki + Math.imul(Fi, Eo) | 0, yr = yr + Math.imul(Fi, Ho) | 0, yr = yr + Math.imul(Xi, Eo) | 0, xi = xi + Math.imul(Xi, Ho) | 0, ki = ki + Math.imul(Qi, Mo) | 0, yr = yr + Math.imul(Qi, Go) | 0, yr = yr + Math.imul(Zi, Mo) | 0, xi = xi + Math.imul(Zi, Go) | 0, ki = ki + Math.imul(Ci, ko) | 0, yr = yr + Math.imul(Ci, Ko) | 0, yr = yr + Math.imul(Ki, ko) | 0, xi = xi + Math.imul(Ki, Ko) | 0;
      var ba = (Mi + ki | 0) + ((yr & 8191) << 13) | 0;
      Mi = (xi + (yr >>> 13) | 0) + (ba >>> 26) | 0, ba &= 67108863, ki = Math.imul(wo, Ui), yr = Math.imul(wo, Ji), yr = yr + Math.imul(Ai, Ui) | 0, xi = Math.imul(Ai, Ji), ki = ki + Math.imul(yo, ro) | 0, yr = yr + Math.imul(yo, oo) | 0, yr = yr + Math.imul(To, ro) | 0, xi = xi + Math.imul(To, oo) | 0, ki = ki + Math.imul(mo, lo) | 0, yr = yr + Math.imul(mo, vo) | 0, yr = yr + Math.imul(Ro, lo) | 0, xi = xi + Math.imul(Ro, vo) | 0, ki = ki + Math.imul(po, co) | 0, yr = yr + Math.imul(po, Lo) | 0, yr = yr + Math.imul(Do, co) | 0, xi = xi + Math.imul(Do, Lo) | 0, ki = ki + Math.imul(ao, $o) | 0, yr = yr + Math.imul(ao, qo) | 0, yr = yr + Math.imul(Bo, $o) | 0, xi = xi + Math.imul(Bo, qo) | 0, ki = ki + Math.imul(so, So) | 0, yr = yr + Math.imul(so, Fo) | 0, yr = yr + Math.imul(ho, So) | 0, xi = xi + Math.imul(ho, Fo) | 0, ki = ki + Math.imul(zi, Eo) | 0, yr = yr + Math.imul(zi, Ho) | 0, yr = yr + Math.imul(Gi, Eo) | 0, xi = xi + Math.imul(Gi, Ho) | 0, ki = ki + Math.imul(Fi, Mo) | 0, yr = yr + Math.imul(Fi, Go) | 0, yr = yr + Math.imul(Xi, Mo) | 0, xi = xi + Math.imul(Xi, Go) | 0, ki = ki + Math.imul(Qi, ko) | 0, yr = yr + Math.imul(Qi, Ko) | 0, yr = yr + Math.imul(Zi, ko) | 0, xi = xi + Math.imul(Zi, Ko) | 0, ki = ki + Math.imul(Ci, Ao) | 0, yr = yr + Math.imul(Ci, Yo) | 0, yr = yr + Math.imul(Ki, Ao) | 0, xi = xi + Math.imul(Ki, Yo) | 0;
      var va = (Mi + ki | 0) + ((yr & 8191) << 13) | 0;
      Mi = (xi + (yr >>> 13) | 0) + (va >>> 26) | 0, va &= 67108863, ki = Math.imul(wo, ro), yr = Math.imul(wo, oo), yr = yr + Math.imul(Ai, ro) | 0, xi = Math.imul(Ai, oo), ki = ki + Math.imul(yo, lo) | 0, yr = yr + Math.imul(yo, vo) | 0, yr = yr + Math.imul(To, lo) | 0, xi = xi + Math.imul(To, vo) | 0, ki = ki + Math.imul(mo, co) | 0, yr = yr + Math.imul(mo, Lo) | 0, yr = yr + Math.imul(Ro, co) | 0, xi = xi + Math.imul(Ro, Lo) | 0, ki = ki + Math.imul(po, $o) | 0, yr = yr + Math.imul(po, qo) | 0, yr = yr + Math.imul(Do, $o) | 0, xi = xi + Math.imul(Do, qo) | 0, ki = ki + Math.imul(ao, So) | 0, yr = yr + Math.imul(ao, Fo) | 0, yr = yr + Math.imul(Bo, So) | 0, xi = xi + Math.imul(Bo, Fo) | 0, ki = ki + Math.imul(so, Eo) | 0, yr = yr + Math.imul(so, Ho) | 0, yr = yr + Math.imul(ho, Eo) | 0, xi = xi + Math.imul(ho, Ho) | 0, ki = ki + Math.imul(zi, Mo) | 0, yr = yr + Math.imul(zi, Go) | 0, yr = yr + Math.imul(Gi, Mo) | 0, xi = xi + Math.imul(Gi, Go) | 0, ki = ki + Math.imul(Fi, ko) | 0, yr = yr + Math.imul(Fi, Ko) | 0, yr = yr + Math.imul(Xi, ko) | 0, xi = xi + Math.imul(Xi, Ko) | 0, ki = ki + Math.imul(Qi, Ao) | 0, yr = yr + Math.imul(Qi, Yo) | 0, yr = yr + Math.imul(Zi, Ao) | 0, xi = xi + Math.imul(Zi, Yo) | 0;
      var _a = (Mi + ki | 0) + ((yr & 8191) << 13) | 0;
      Mi = (xi + (yr >>> 13) | 0) + (_a >>> 26) | 0, _a &= 67108863, ki = Math.imul(wo, lo), yr = Math.imul(wo, vo), yr = yr + Math.imul(Ai, lo) | 0, xi = Math.imul(Ai, vo), ki = ki + Math.imul(yo, co) | 0, yr = yr + Math.imul(yo, Lo) | 0, yr = yr + Math.imul(To, co) | 0, xi = xi + Math.imul(To, Lo) | 0, ki = ki + Math.imul(mo, $o) | 0, yr = yr + Math.imul(mo, qo) | 0, yr = yr + Math.imul(Ro, $o) | 0, xi = xi + Math.imul(Ro, qo) | 0, ki = ki + Math.imul(po, So) | 0, yr = yr + Math.imul(po, Fo) | 0, yr = yr + Math.imul(Do, So) | 0, xi = xi + Math.imul(Do, Fo) | 0, ki = ki + Math.imul(ao, Eo) | 0, yr = yr + Math.imul(ao, Ho) | 0, yr = yr + Math.imul(Bo, Eo) | 0, xi = xi + Math.imul(Bo, Ho) | 0, ki = ki + Math.imul(so, Mo) | 0, yr = yr + Math.imul(so, Go) | 0, yr = yr + Math.imul(ho, Mo) | 0, xi = xi + Math.imul(ho, Go) | 0, ki = ki + Math.imul(zi, ko) | 0, yr = yr + Math.imul(zi, Ko) | 0, yr = yr + Math.imul(Gi, ko) | 0, xi = xi + Math.imul(Gi, Ko) | 0, ki = ki + Math.imul(Fi, Ao) | 0, yr = yr + Math.imul(Fi, Yo) | 0, yr = yr + Math.imul(Xi, Ao) | 0, xi = xi + Math.imul(Xi, Yo) | 0;
      var wa = (Mi + ki | 0) + ((yr & 8191) << 13) | 0;
      Mi = (xi + (yr >>> 13) | 0) + (wa >>> 26) | 0, wa &= 67108863, ki = Math.imul(wo, co), yr = Math.imul(wo, Lo), yr = yr + Math.imul(Ai, co) | 0, xi = Math.imul(Ai, Lo), ki = ki + Math.imul(yo, $o) | 0, yr = yr + Math.imul(yo, qo) | 0, yr = yr + Math.imul(To, $o) | 0, xi = xi + Math.imul(To, qo) | 0, ki = ki + Math.imul(mo, So) | 0, yr = yr + Math.imul(mo, Fo) | 0, yr = yr + Math.imul(Ro, So) | 0, xi = xi + Math.imul(Ro, Fo) | 0, ki = ki + Math.imul(po, Eo) | 0, yr = yr + Math.imul(po, Ho) | 0, yr = yr + Math.imul(Do, Eo) | 0, xi = xi + Math.imul(Do, Ho) | 0, ki = ki + Math.imul(ao, Mo) | 0, yr = yr + Math.imul(ao, Go) | 0, yr = yr + Math.imul(Bo, Mo) | 0, xi = xi + Math.imul(Bo, Go) | 0, ki = ki + Math.imul(so, ko) | 0, yr = yr + Math.imul(so, Ko) | 0, yr = yr + Math.imul(ho, ko) | 0, xi = xi + Math.imul(ho, Ko) | 0, ki = ki + Math.imul(zi, Ao) | 0, yr = yr + Math.imul(zi, Yo) | 0, yr = yr + Math.imul(Gi, Ao) | 0, xi = xi + Math.imul(Gi, Yo) | 0;
      var $a = (Mi + ki | 0) + ((yr & 8191) << 13) | 0;
      Mi = (xi + (yr >>> 13) | 0) + ($a >>> 26) | 0, $a &= 67108863, ki = Math.imul(wo, $o), yr = Math.imul(wo, qo), yr = yr + Math.imul(Ai, $o) | 0, xi = Math.imul(Ai, qo), ki = ki + Math.imul(yo, So) | 0, yr = yr + Math.imul(yo, Fo) | 0, yr = yr + Math.imul(To, So) | 0, xi = xi + Math.imul(To, Fo) | 0, ki = ki + Math.imul(mo, Eo) | 0, yr = yr + Math.imul(mo, Ho) | 0, yr = yr + Math.imul(Ro, Eo) | 0, xi = xi + Math.imul(Ro, Ho) | 0, ki = ki + Math.imul(po, Mo) | 0, yr = yr + Math.imul(po, Go) | 0, yr = yr + Math.imul(Do, Mo) | 0, xi = xi + Math.imul(Do, Go) | 0, ki = ki + Math.imul(ao, ko) | 0, yr = yr + Math.imul(ao, Ko) | 0, yr = yr + Math.imul(Bo, ko) | 0, xi = xi + Math.imul(Bo, Ko) | 0, ki = ki + Math.imul(so, Ao) | 0, yr = yr + Math.imul(so, Yo) | 0, yr = yr + Math.imul(ho, Ao) | 0, xi = xi + Math.imul(ho, Yo) | 0;
      var Sa = (Mi + ki | 0) + ((yr & 8191) << 13) | 0;
      Mi = (xi + (yr >>> 13) | 0) + (Sa >>> 26) | 0, Sa &= 67108863, ki = Math.imul(wo, So), yr = Math.imul(wo, Fo), yr = yr + Math.imul(Ai, So) | 0, xi = Math.imul(Ai, Fo), ki = ki + Math.imul(yo, Eo) | 0, yr = yr + Math.imul(yo, Ho) | 0, yr = yr + Math.imul(To, Eo) | 0, xi = xi + Math.imul(To, Ho) | 0, ki = ki + Math.imul(mo, Mo) | 0, yr = yr + Math.imul(mo, Go) | 0, yr = yr + Math.imul(Ro, Mo) | 0, xi = xi + Math.imul(Ro, Go) | 0, ki = ki + Math.imul(po, ko) | 0, yr = yr + Math.imul(po, Ko) | 0, yr = yr + Math.imul(Do, ko) | 0, xi = xi + Math.imul(Do, Ko) | 0, ki = ki + Math.imul(ao, Ao) | 0, yr = yr + Math.imul(ao, Yo) | 0, yr = yr + Math.imul(Bo, Ao) | 0, xi = xi + Math.imul(Bo, Yo) | 0;
      var Ea = (Mi + ki | 0) + ((yr & 8191) << 13) | 0;
      Mi = (xi + (yr >>> 13) | 0) + (Ea >>> 26) | 0, Ea &= 67108863, ki = Math.imul(wo, Eo), yr = Math.imul(wo, Ho), yr = yr + Math.imul(Ai, Eo) | 0, xi = Math.imul(Ai, Ho), ki = ki + Math.imul(yo, Mo) | 0, yr = yr + Math.imul(yo, Go) | 0, yr = yr + Math.imul(To, Mo) | 0, xi = xi + Math.imul(To, Go) | 0, ki = ki + Math.imul(mo, ko) | 0, yr = yr + Math.imul(mo, Ko) | 0, yr = yr + Math.imul(Ro, ko) | 0, xi = xi + Math.imul(Ro, Ko) | 0, ki = ki + Math.imul(po, Ao) | 0, yr = yr + Math.imul(po, Yo) | 0, yr = yr + Math.imul(Do, Ao) | 0, xi = xi + Math.imul(Do, Yo) | 0;
      var Ma = (Mi + ki | 0) + ((yr & 8191) << 13) | 0;
      Mi = (xi + (yr >>> 13) | 0) + (Ma >>> 26) | 0, Ma &= 67108863, ki = Math.imul(wo, Mo), yr = Math.imul(wo, Go), yr = yr + Math.imul(Ai, Mo) | 0, xi = Math.imul(Ai, Go), ki = ki + Math.imul(yo, ko) | 0, yr = yr + Math.imul(yo, Ko) | 0, yr = yr + Math.imul(To, ko) | 0, xi = xi + Math.imul(To, Ko) | 0, ki = ki + Math.imul(mo, Ao) | 0, yr = yr + Math.imul(mo, Yo) | 0, yr = yr + Math.imul(Ro, Ao) | 0, xi = xi + Math.imul(Ro, Yo) | 0;
      var ka = (Mi + ki | 0) + ((yr & 8191) << 13) | 0;
      Mi = (xi + (yr >>> 13) | 0) + (ka >>> 26) | 0, ka &= 67108863, ki = Math.imul(wo, ko), yr = Math.imul(wo, Ko), yr = yr + Math.imul(Ai, ko) | 0, xi = Math.imul(Ai, Ko), ki = ki + Math.imul(yo, Ao) | 0, yr = yr + Math.imul(yo, Yo) | 0, yr = yr + Math.imul(To, Ao) | 0, xi = xi + Math.imul(To, Yo) | 0;
      var Aa = (Mi + ki | 0) + ((yr & 8191) << 13) | 0;
      Mi = (xi + (yr >>> 13) | 0) + (Aa >>> 26) | 0, Aa &= 67108863, ki = Math.imul(wo, Ao), yr = Math.imul(wo, Yo), yr = yr + Math.imul(Ai, Ao) | 0, xi = Math.imul(Ai, Yo);
      var Ra = (Mi + ki | 0) + ((yr & 8191) << 13) | 0;
      return Mi = (xi + (yr >>> 13) | 0) + (Ra >>> 26) | 0, Ra &= 67108863, Oi[0] = Po, Oi[1] = No, Oi[2] = ha, Oi[3] = da, Oi[4] = pa, Oi[5] = ma, Oi[6] = ya, Oi[7] = ga, Oi[8] = ba, Oi[9] = va, Oi[10] = _a, Oi[11] = wa, Oi[12] = $a, Oi[13] = Sa, Oi[14] = Ea, Oi[15] = Ma, Oi[16] = ka, Oi[17] = Aa, Oi[18] = Ra, Mi !== 0 && (Oi[19] = Mi, z.length++), z;
    };
    Math.imul || (tt = he);
    function br(pr, Di, z) {
      z.negative = Di.negative ^ pr.negative, z.length = pr.length + Di.length;
      for (var gr = 0, vr = 0, Oi = 0; Oi < z.length - 1; Oi++) {
        var Mi = vr;
        vr = 0;
        for (var ki = gr & 67108863, yr = Math.min(Oi, Di.length - 1), xi = Math.max(0, Oi - pr.length + 1); xi <= yr; xi++) {
          var Si = Oi - xi, Ci = pr.words[Si] | 0, Ki = Di.words[xi] | 0, Yi = Ci * Ki, Qi = Yi & 67108863;
          Mi = Mi + (Yi / 67108864 | 0) | 0, Qi = Qi + ki | 0, ki = Qi & 67108863, Mi = Mi + (Qi >>> 26) | 0, vr += Mi >>> 26, Mi &= 67108863;
        }
        z.words[Oi] = ki, gr = Mi, Mi = vr;
      }
      return gr !== 0 ? z.words[Oi] = gr : z.length--, z.strip();
    }
    function rt(pr, Di, z) {
      var gr = new dr();
      return gr.mulp(pr, Di, z);
    }
    x.prototype.mulTo = function(pr, Di) {
      var z, gr = this.length + pr.length;
      return this.length === 10 && pr.length === 10 ? z = tt(this, pr, Di) : gr < 63 ? z = he(this, pr, Di) : gr < 1024 ? z = br(this, pr, Di) : z = rt(this, pr, Di), z;
    };
    function dr(pr, Di) {
      this.x = pr, this.y = Di;
    }
    dr.prototype.makeRBT = function(pr) {
      for (var Di = new Array(pr), z = x.prototype._countBits(pr) - 1, gr = 0; gr < pr; gr++)
        Di[gr] = this.revBin(gr, z, pr);
      return Di;
    }, dr.prototype.revBin = function(pr, Di, z) {
      if (pr === 0 || pr === z - 1) return pr;
      for (var gr = 0, vr = 0; vr < Di; vr++)
        gr |= (pr & 1) << Di - vr - 1, pr >>= 1;
      return gr;
    }, dr.prototype.permute = function(pr, Di, z, gr, vr, Oi) {
      for (var Mi = 0; Mi < Oi; Mi++)
        gr[Mi] = Di[pr[Mi]], vr[Mi] = z[pr[Mi]];
    }, dr.prototype.transform = function(pr, Di, z, gr, vr, Oi) {
      this.permute(Oi, pr, Di, z, gr, vr);
      for (var Mi = 1; Mi < vr; Mi <<= 1)
        for (var ki = Mi << 1, yr = Math.cos(2 * Math.PI / ki), xi = Math.sin(2 * Math.PI / ki), Si = 0; Si < vr; Si += ki)
          for (var Ci = yr, Ki = xi, Yi = 0; Yi < Mi; Yi++) {
            var Qi = z[Si + Yi], Zi = gr[Si + Yi], Ni = z[Si + Yi + Mi], Fi = gr[Si + Yi + Mi], Xi = Ci * Ni - Ki * Fi;
            Fi = Ci * Fi + Ki * Ni, Ni = Xi, z[Si + Yi] = Qi + Ni, gr[Si + Yi] = Zi + Fi, z[Si + Yi + Mi] = Qi - Ni, gr[Si + Yi + Mi] = Zi - Fi, Yi !== ki && (Xi = yr * Ci - xi * Ki, Ki = yr * Ki + xi * Ci, Ci = Xi);
          }
    }, dr.prototype.guessLen13b = function(pr, Di) {
      var z = Math.max(Di, pr) | 1, gr = z & 1, vr = 0;
      for (z = z / 2 | 0; z; z = z >>> 1)
        vr++;
      return 1 << vr + 1 + gr;
    }, dr.prototype.conjugate = function(pr, Di, z) {
      if (!(z <= 1))
        for (var gr = 0; gr < z / 2; gr++) {
          var vr = pr[gr];
          pr[gr] = pr[z - gr - 1], pr[z - gr - 1] = vr, vr = Di[gr], Di[gr] = -Di[z - gr - 1], Di[z - gr - 1] = -vr;
        }
    }, dr.prototype.normalize13b = function(pr, Di) {
      for (var z = 0, gr = 0; gr < Di / 2; gr++) {
        var vr = Math.round(pr[2 * gr + 1] / Di) * 8192 + Math.round(pr[2 * gr] / Di) + z;
        pr[gr] = vr & 67108863, vr < 67108864 ? z = 0 : z = vr / 67108864 | 0;
      }
      return pr;
    }, dr.prototype.convert13b = function(pr, Di, z, gr) {
      for (var vr = 0, Oi = 0; Oi < Di; Oi++)
        vr = vr + (pr[Oi] | 0), z[2 * Oi] = vr & 8191, vr = vr >>> 13, z[2 * Oi + 1] = vr & 8191, vr = vr >>> 13;
      for (Oi = 2 * Di; Oi < gr; ++Oi)
        z[Oi] = 0;
      w(vr === 0), w((vr & -8192) === 0);
    }, dr.prototype.stub = function(pr) {
      for (var Di = new Array(pr), z = 0; z < pr; z++)
        Di[z] = 0;
      return Di;
    }, dr.prototype.mulp = function(pr, Di, z) {
      var gr = 2 * this.guessLen13b(pr.length, Di.length), vr = this.makeRBT(gr), Oi = this.stub(gr), Mi = new Array(gr), ki = new Array(gr), yr = new Array(gr), xi = new Array(gr), Si = new Array(gr), Ci = new Array(gr), Ki = z.words;
      Ki.length = gr, this.convert13b(pr.words, pr.length, Mi, gr), this.convert13b(Di.words, Di.length, xi, gr), this.transform(Mi, Oi, ki, yr, gr, vr), this.transform(xi, Oi, Si, Ci, gr, vr);
      for (var Yi = 0; Yi < gr; Yi++) {
        var Qi = ki[Yi] * Si[Yi] - yr[Yi] * Ci[Yi];
        yr[Yi] = ki[Yi] * Ci[Yi] + yr[Yi] * Si[Yi], ki[Yi] = Qi;
      }
      return this.conjugate(ki, yr, gr), this.transform(ki, yr, Ki, Oi, gr, vr), this.conjugate(Ki, Oi, gr), this.normalize13b(Ki, gr), z.negative = pr.negative ^ Di.negative, z.length = pr.length + Di.length, z.strip();
    }, x.prototype.mul = function(pr) {
      var Di = new x(null);
      return Di.words = new Array(this.length + pr.length), this.mulTo(pr, Di);
    }, x.prototype.mulf = function(pr) {
      var Di = new x(null);
      return Di.words = new Array(this.length + pr.length), rt(this, pr, Di);
    }, x.prototype.imul = function(pr) {
      return this.clone().mulTo(pr, this);
    }, x.prototype.imuln = function(pr) {
      w(typeof pr == "number"), w(pr < 67108864);
      for (var Di = 0, z = 0; z < this.length; z++) {
        var gr = (this.words[z] | 0) * pr, vr = (gr & 67108863) + (Di & 67108863);
        Di >>= 26, Di += gr / 67108864 | 0, Di += vr >>> 26, this.words[z] = vr & 67108863;
      }
      return Di !== 0 && (this.words[z] = Di, this.length++), this;
    }, x.prototype.muln = function(pr) {
      return this.clone().imuln(pr);
    }, x.prototype.sqr = function() {
      return this.mul(this);
    }, x.prototype.isqr = function() {
      return this.imul(this.clone());
    }, x.prototype.pow = function(pr) {
      var Di = ae(pr);
      if (Di.length === 0) return new x(1);
      for (var z = this, gr = 0; gr < Di.length && Di[gr] === 0; gr++, z = z.sqr())
        ;
      if (++gr < Di.length)
        for (var vr = z.sqr(); gr < Di.length; gr++, vr = vr.sqr())
          Di[gr] !== 0 && (z = z.mul(vr));
      return z;
    }, x.prototype.iushln = function(pr) {
      w(typeof pr == "number" && pr >= 0);
      var Di = pr % 26, z = (pr - Di) / 26, gr = 67108863 >>> 26 - Di << 26 - Di, vr;
      if (Di !== 0) {
        var Oi = 0;
        for (vr = 0; vr < this.length; vr++) {
          var Mi = this.words[vr] & gr, ki = (this.words[vr] | 0) - Mi << Di;
          this.words[vr] = ki | Oi, Oi = Mi >>> 26 - Di;
        }
        Oi && (this.words[vr] = Oi, this.length++);
      }
      if (z !== 0) {
        for (vr = this.length - 1; vr >= 0; vr--)
          this.words[vr + z] = this.words[vr];
        for (vr = 0; vr < z; vr++)
          this.words[vr] = 0;
        this.length += z;
      }
      return this.strip();
    }, x.prototype.ishln = function(pr) {
      return w(this.negative === 0), this.iushln(pr);
    }, x.prototype.iushrn = function(pr, Di, z) {
      w(typeof pr == "number" && pr >= 0);
      var gr;
      Di ? gr = (Di - Di % 26) / 26 : gr = 0;
      var vr = pr % 26, Oi = Math.min((pr - vr) / 26, this.length), Mi = 67108863 ^ 67108863 >>> vr << vr, ki = z;
      if (gr -= Oi, gr = Math.max(0, gr), ki) {
        for (var yr = 0; yr < Oi; yr++)
          ki.words[yr] = this.words[yr];
        ki.length = Oi;
      }
      if (Oi !== 0) if (this.length > Oi)
        for (this.length -= Oi, yr = 0; yr < this.length; yr++)
          this.words[yr] = this.words[yr + Oi];
      else
        this.words[0] = 0, this.length = 1;
      var xi = 0;
      for (yr = this.length - 1; yr >= 0 && (xi !== 0 || yr >= gr); yr--) {
        var Si = this.words[yr] | 0;
        this.words[yr] = xi << 26 - vr | Si >>> vr, xi = Si & Mi;
      }
      return ki && xi !== 0 && (ki.words[ki.length++] = xi), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, x.prototype.ishrn = function(pr, Di, z) {
      return w(this.negative === 0), this.iushrn(pr, Di, z);
    }, x.prototype.shln = function(pr) {
      return this.clone().ishln(pr);
    }, x.prototype.ushln = function(pr) {
      return this.clone().iushln(pr);
    }, x.prototype.shrn = function(pr) {
      return this.clone().ishrn(pr);
    }, x.prototype.ushrn = function(pr) {
      return this.clone().iushrn(pr);
    }, x.prototype.testn = function(pr) {
      w(typeof pr == "number" && pr >= 0);
      var Di = pr % 26, z = (pr - Di) / 26, gr = 1 << Di;
      if (this.length <= z) return !1;
      var vr = this.words[z];
      return !!(vr & gr);
    }, x.prototype.imaskn = function(pr) {
      w(typeof pr == "number" && pr >= 0);
      var Di = pr % 26, z = (pr - Di) / 26;
      if (w(this.negative === 0, "imaskn works only with positive numbers"), this.length <= z)
        return this;
      if (Di !== 0 && z++, this.length = Math.min(z, this.length), Di !== 0) {
        var gr = 67108863 ^ 67108863 >>> Di << Di;
        this.words[this.length - 1] &= gr;
      }
      return this.strip();
    }, x.prototype.maskn = function(pr) {
      return this.clone().imaskn(pr);
    }, x.prototype.iaddn = function(pr) {
      return w(typeof pr == "number"), w(pr < 67108864), pr < 0 ? this.isubn(-pr) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < pr ? (this.words[0] = pr - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(pr), this.negative = 1, this) : this._iaddn(pr);
    }, x.prototype._iaddn = function(pr) {
      this.words[0] += pr;
      for (var Di = 0; Di < this.length && this.words[Di] >= 67108864; Di++)
        this.words[Di] -= 67108864, Di === this.length - 1 ? this.words[Di + 1] = 1 : this.words[Di + 1]++;
      return this.length = Math.max(this.length, Di + 1), this;
    }, x.prototype.isubn = function(pr) {
      if (w(typeof pr == "number"), w(pr < 67108864), pr < 0) return this.iaddn(-pr);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(pr), this.negative = 1, this;
      if (this.words[0] -= pr, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var Di = 0; Di < this.length && this.words[Di] < 0; Di++)
          this.words[Di] += 67108864, this.words[Di + 1] -= 1;
      return this.strip();
    }, x.prototype.addn = function(pr) {
      return this.clone().iaddn(pr);
    }, x.prototype.subn = function(pr) {
      return this.clone().isubn(pr);
    }, x.prototype.iabs = function() {
      return this.negative = 0, this;
    }, x.prototype.abs = function() {
      return this.clone().iabs();
    }, x.prototype._ishlnsubmul = function(pr, Di, z) {
      var gr = pr.length + z, vr;
      this._expand(gr);
      var Oi, Mi = 0;
      for (vr = 0; vr < pr.length; vr++) {
        Oi = (this.words[vr + z] | 0) + Mi;
        var ki = (pr.words[vr] | 0) * Di;
        Oi -= ki & 67108863, Mi = (Oi >> 26) - (ki / 67108864 | 0), this.words[vr + z] = Oi & 67108863;
      }
      for (; vr < this.length - z; vr++)
        Oi = (this.words[vr + z] | 0) + Mi, Mi = Oi >> 26, this.words[vr + z] = Oi & 67108863;
      if (Mi === 0) return this.strip();
      for (w(Mi === -1), Mi = 0, vr = 0; vr < this.length; vr++)
        Oi = -(this.words[vr] | 0) + Mi, Mi = Oi >> 26, this.words[vr] = Oi & 67108863;
      return this.negative = 1, this.strip();
    }, x.prototype._wordDiv = function(pr, Di) {
      var z = this.length - pr.length, gr = this.clone(), vr = pr, Oi = vr.words[vr.length - 1] | 0, Mi = this._countBits(Oi);
      z = 26 - Mi, z !== 0 && (vr = vr.ushln(z), gr.iushln(z), Oi = vr.words[vr.length - 1] | 0);
      var ki = gr.length - vr.length, yr;
      if (Di !== "mod") {
        yr = new x(null), yr.length = ki + 1, yr.words = new Array(yr.length);
        for (var xi = 0; xi < yr.length; xi++)
          yr.words[xi] = 0;
      }
      var Si = gr.clone()._ishlnsubmul(vr, 1, ki);
      Si.negative === 0 && (gr = Si, yr && (yr.words[ki] = 1));
      for (var Ci = ki - 1; Ci >= 0; Ci--) {
        var Ki = (gr.words[vr.length + Ci] | 0) * 67108864 + (gr.words[vr.length + Ci - 1] | 0);
        for (Ki = Math.min(Ki / Oi | 0, 67108863), gr._ishlnsubmul(vr, Ki, Ci); gr.negative !== 0; )
          Ki--, gr.negative = 0, gr._ishlnsubmul(vr, 1, Ci), gr.isZero() || (gr.negative ^= 1);
        yr && (yr.words[Ci] = Ki);
      }
      return yr && yr.strip(), gr.strip(), Di !== "div" && z !== 0 && gr.iushrn(z), {
        div: yr || null,
        mod: gr
      };
    }, x.prototype.divmod = function(pr, Di, z) {
      if (w(!pr.isZero()), this.isZero())
        return {
          div: new x(0),
          mod: new x(0)
        };
      var gr, vr, Oi;
      return this.negative !== 0 && pr.negative === 0 ? (Oi = this.neg().divmod(pr, Di), Di !== "mod" && (gr = Oi.div.neg()), Di !== "div" && (vr = Oi.mod.neg(), z && vr.negative !== 0 && vr.iadd(pr)), {
        div: gr,
        mod: vr
      }) : this.negative === 0 && pr.negative !== 0 ? (Oi = this.divmod(pr.neg(), Di), Di !== "mod" && (gr = Oi.div.neg()), {
        div: gr,
        mod: Oi.mod
      }) : this.negative & pr.negative ? (Oi = this.neg().divmod(pr.neg(), Di), Di !== "div" && (vr = Oi.mod.neg(), z && vr.negative !== 0 && vr.isub(pr)), {
        div: Oi.div,
        mod: vr
      }) : pr.length > this.length || this.cmp(pr) < 0 ? {
        div: new x(0),
        mod: this
      } : pr.length === 1 ? Di === "div" ? {
        div: this.divn(pr.words[0]),
        mod: null
      } : Di === "mod" ? {
        div: null,
        mod: new x(this.modn(pr.words[0]))
      } : {
        div: this.divn(pr.words[0]),
        mod: new x(this.modn(pr.words[0]))
      } : this._wordDiv(pr, Di);
    }, x.prototype.div = function(pr) {
      return this.divmod(pr, "div", !1).div;
    }, x.prototype.mod = function(pr) {
      return this.divmod(pr, "mod", !1).mod;
    }, x.prototype.umod = function(pr) {
      return this.divmod(pr, "mod", !0).mod;
    }, x.prototype.divRound = function(pr) {
      var Di = this.divmod(pr);
      if (Di.mod.isZero()) return Di.div;
      var z = Di.div.negative !== 0 ? Di.mod.isub(pr) : Di.mod, gr = pr.ushrn(1), vr = pr.andln(1), Oi = z.cmp(gr);
      return Oi < 0 || vr === 1 && Oi === 0 ? Di.div : Di.div.negative !== 0 ? Di.div.isubn(1) : Di.div.iaddn(1);
    }, x.prototype.modn = function(pr) {
      w(pr <= 67108863);
      for (var Di = (1 << 26) % pr, z = 0, gr = this.length - 1; gr >= 0; gr--)
        z = (Di * z + (this.words[gr] | 0)) % pr;
      return z;
    }, x.prototype.idivn = function(pr) {
      w(pr <= 67108863);
      for (var Di = 0, z = this.length - 1; z >= 0; z--) {
        var gr = (this.words[z] | 0) + Di * 67108864;
        this.words[z] = gr / pr | 0, Di = gr % pr;
      }
      return this.strip();
    }, x.prototype.divn = function(pr) {
      return this.clone().idivn(pr);
    }, x.prototype.egcd = function(pr) {
      w(pr.negative === 0), w(!pr.isZero());
      var Di = this, z = pr.clone();
      Di.negative !== 0 ? Di = Di.umod(pr) : Di = Di.clone();
      for (var gr = new x(1), vr = new x(0), Oi = new x(0), Mi = new x(1), ki = 0; Di.isEven() && z.isEven(); )
        Di.iushrn(1), z.iushrn(1), ++ki;
      for (var yr = z.clone(), xi = Di.clone(); !Di.isZero(); ) {
        for (var Si = 0, Ci = 1; !(Di.words[0] & Ci) && Si < 26; ++Si, Ci <<= 1) ;
        if (Si > 0)
          for (Di.iushrn(Si); Si-- > 0; )
            (gr.isOdd() || vr.isOdd()) && (gr.iadd(yr), vr.isub(xi)), gr.iushrn(1), vr.iushrn(1);
        for (var Ki = 0, Yi = 1; !(z.words[0] & Yi) && Ki < 26; ++Ki, Yi <<= 1) ;
        if (Ki > 0)
          for (z.iushrn(Ki); Ki-- > 0; )
            (Oi.isOdd() || Mi.isOdd()) && (Oi.iadd(yr), Mi.isub(xi)), Oi.iushrn(1), Mi.iushrn(1);
        Di.cmp(z) >= 0 ? (Di.isub(z), gr.isub(Oi), vr.isub(Mi)) : (z.isub(Di), Oi.isub(gr), Mi.isub(vr));
      }
      return {
        a: Oi,
        b: Mi,
        gcd: z.iushln(ki)
      };
    }, x.prototype._invmp = function(pr) {
      w(pr.negative === 0), w(!pr.isZero());
      var Di = this, z = pr.clone();
      Di.negative !== 0 ? Di = Di.umod(pr) : Di = Di.clone();
      for (var gr = new x(1), vr = new x(0), Oi = z.clone(); Di.cmpn(1) > 0 && z.cmpn(1) > 0; ) {
        for (var Mi = 0, ki = 1; !(Di.words[0] & ki) && Mi < 26; ++Mi, ki <<= 1) ;
        if (Mi > 0)
          for (Di.iushrn(Mi); Mi-- > 0; )
            gr.isOdd() && gr.iadd(Oi), gr.iushrn(1);
        for (var yr = 0, xi = 1; !(z.words[0] & xi) && yr < 26; ++yr, xi <<= 1) ;
        if (yr > 0)
          for (z.iushrn(yr); yr-- > 0; )
            vr.isOdd() && vr.iadd(Oi), vr.iushrn(1);
        Di.cmp(z) >= 0 ? (Di.isub(z), gr.isub(vr)) : (z.isub(Di), vr.isub(gr));
      }
      var Si;
      return Di.cmpn(1) === 0 ? Si = gr : Si = vr, Si.cmpn(0) < 0 && Si.iadd(pr), Si;
    }, x.prototype.gcd = function(pr) {
      if (this.isZero()) return pr.abs();
      if (pr.isZero()) return this.abs();
      var Di = this.clone(), z = pr.clone();
      Di.negative = 0, z.negative = 0;
      for (var gr = 0; Di.isEven() && z.isEven(); gr++)
        Di.iushrn(1), z.iushrn(1);
      do {
        for (; Di.isEven(); )
          Di.iushrn(1);
        for (; z.isEven(); )
          z.iushrn(1);
        var vr = Di.cmp(z);
        if (vr < 0) {
          var Oi = Di;
          Di = z, z = Oi;
        } else if (vr === 0 || z.cmpn(1) === 0)
          break;
        Di.isub(z);
      } while (!0);
      return z.iushln(gr);
    }, x.prototype.invm = function(pr) {
      return this.egcd(pr).a.umod(pr);
    }, x.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, x.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, x.prototype.andln = function(pr) {
      return this.words[0] & pr;
    }, x.prototype.bincn = function(pr) {
      w(typeof pr == "number");
      var Di = pr % 26, z = (pr - Di) / 26, gr = 1 << Di;
      if (this.length <= z)
        return this._expand(z + 1), this.words[z] |= gr, this;
      for (var vr = gr, Oi = z; vr !== 0 && Oi < this.length; Oi++) {
        var Mi = this.words[Oi] | 0;
        Mi += vr, vr = Mi >>> 26, Mi &= 67108863, this.words[Oi] = Mi;
      }
      return vr !== 0 && (this.words[Oi] = vr, this.length++), this;
    }, x.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, x.prototype.cmpn = function(pr) {
      var Di = pr < 0;
      if (this.negative !== 0 && !Di) return -1;
      if (this.negative === 0 && Di) return 1;
      this.strip();
      var z;
      if (this.length > 1)
        z = 1;
      else {
        Di && (pr = -pr), w(pr <= 67108863, "Number is too big");
        var gr = this.words[0] | 0;
        z = gr === pr ? 0 : gr < pr ? -1 : 1;
      }
      return this.negative !== 0 ? -z | 0 : z;
    }, x.prototype.cmp = function(pr) {
      if (this.negative !== 0 && pr.negative === 0) return -1;
      if (this.negative === 0 && pr.negative !== 0) return 1;
      var Di = this.ucmp(pr);
      return this.negative !== 0 ? -Di | 0 : Di;
    }, x.prototype.ucmp = function(pr) {
      if (this.length > pr.length) return 1;
      if (this.length < pr.length) return -1;
      for (var Di = 0, z = this.length - 1; z >= 0; z--) {
        var gr = this.words[z] | 0, vr = pr.words[z] | 0;
        if (gr !== vr) {
          gr < vr ? Di = -1 : gr > vr && (Di = 1);
          break;
        }
      }
      return Di;
    }, x.prototype.gtn = function(pr) {
      return this.cmpn(pr) === 1;
    }, x.prototype.gt = function(pr) {
      return this.cmp(pr) === 1;
    }, x.prototype.gten = function(pr) {
      return this.cmpn(pr) >= 0;
    }, x.prototype.gte = function(pr) {
      return this.cmp(pr) >= 0;
    }, x.prototype.ltn = function(pr) {
      return this.cmpn(pr) === -1;
    }, x.prototype.lt = function(pr) {
      return this.cmp(pr) === -1;
    }, x.prototype.lten = function(pr) {
      return this.cmpn(pr) <= 0;
    }, x.prototype.lte = function(pr) {
      return this.cmp(pr) <= 0;
    }, x.prototype.eqn = function(pr) {
      return this.cmpn(pr) === 0;
    }, x.prototype.eq = function(pr) {
      return this.cmp(pr) === 0;
    }, x.red = function(pr) {
      return new Li(pr);
    }, x.prototype.toRed = function(pr) {
      return w(!this.red, "Already a number in reduction context"), w(this.negative === 0, "red works only with positives"), pr.convertTo(this)._forceRed(pr);
    }, x.prototype.fromRed = function() {
      return w(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, x.prototype._forceRed = function(pr) {
      return this.red = pr, this;
    }, x.prototype.forceRed = function(pr) {
      return w(!this.red, "Already a number in reduction context"), this._forceRed(pr);
    }, x.prototype.redAdd = function(pr) {
      return w(this.red, "redAdd works only with red numbers"), this.red.add(this, pr);
    }, x.prototype.redIAdd = function(pr) {
      return w(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, pr);
    }, x.prototype.redSub = function(pr) {
      return w(this.red, "redSub works only with red numbers"), this.red.sub(this, pr);
    }, x.prototype.redISub = function(pr) {
      return w(this.red, "redISub works only with red numbers"), this.red.isub(this, pr);
    }, x.prototype.redShl = function(pr) {
      return w(this.red, "redShl works only with red numbers"), this.red.shl(this, pr);
    }, x.prototype.redMul = function(pr) {
      return w(this.red, "redMul works only with red numbers"), this.red._verify2(this, pr), this.red.mul(this, pr);
    }, x.prototype.redIMul = function(pr) {
      return w(this.red, "redMul works only with red numbers"), this.red._verify2(this, pr), this.red.imul(this, pr);
    }, x.prototype.redSqr = function() {
      return w(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, x.prototype.redISqr = function() {
      return w(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, x.prototype.redSqrt = function() {
      return w(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, x.prototype.redInvm = function() {
      return w(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, x.prototype.redNeg = function() {
      return w(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, x.prototype.redPow = function(pr) {
      return w(this.red && !pr.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, pr);
    };
    var _r = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Bi(pr, Di) {
      this.name = pr, this.p = new x(Di, 16), this.n = this.p.bitLength(), this.k = new x(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Bi.prototype._tmp = function() {
      var pr = new x(null);
      return pr.words = new Array(Math.ceil(this.n / 13)), pr;
    }, Bi.prototype.ireduce = function(pr) {
      var Di = pr, z;
      do
        this.split(Di, this.tmp), Di = this.imulK(Di), Di = Di.iadd(this.tmp), z = Di.bitLength();
      while (z > this.n);
      var gr = z < this.n ? -1 : Di.ucmp(this.p);
      return gr === 0 ? (Di.words[0] = 0, Di.length = 1) : gr > 0 ? Di.isub(this.p) : Di.strip !== void 0 ? Di.strip() : Di._strip(), Di;
    }, Bi.prototype.split = function(pr, Di) {
      pr.iushrn(this.n, 0, Di);
    }, Bi.prototype.imulK = function(pr) {
      return pr.imul(this.k);
    };
    function qi() {
      Bi.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    T(qi, Bi), qi.prototype.split = function(pr, Di) {
      for (var z = 4194303, gr = Math.min(pr.length, 9), vr = 0; vr < gr; vr++)
        Di.words[vr] = pr.words[vr];
      if (Di.length = gr, pr.length <= 9) {
        pr.words[0] = 0, pr.length = 1;
        return;
      }
      var Oi = pr.words[9];
      for (Di.words[Di.length++] = Oi & z, vr = 10; vr < pr.length; vr++) {
        var Mi = pr.words[vr] | 0;
        pr.words[vr - 10] = (Mi & z) << 4 | Oi >>> 22, Oi = Mi;
      }
      Oi >>>= 22, pr.words[vr - 10] = Oi, Oi === 0 && pr.length > 10 ? pr.length -= 10 : pr.length -= 9;
    }, qi.prototype.imulK = function(pr) {
      pr.words[pr.length] = 0, pr.words[pr.length + 1] = 0, pr.length += 2;
      for (var Di = 0, z = 0; z < pr.length; z++) {
        var gr = pr.words[z] | 0;
        Di += gr * 977, pr.words[z] = Di & 67108863, Di = gr * 64 + (Di / 67108864 | 0);
      }
      return pr.words[pr.length - 1] === 0 && (pr.length--, pr.words[pr.length - 1] === 0 && pr.length--), pr;
    };
    function Wi() {
      Bi.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    T(Wi, Bi);
    function Vi() {
      Bi.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    T(Vi, Bi);
    function Ti() {
      Bi.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    T(Ti, Bi), Ti.prototype.imulK = function(pr) {
      for (var Di = 0, z = 0; z < pr.length; z++) {
        var gr = (pr.words[z] | 0) * 19 + Di, vr = gr & 67108863;
        gr >>>= 26, pr.words[z] = vr, Di = gr;
      }
      return Di !== 0 && (pr.words[pr.length++] = Di), pr;
    }, x._prime = function(pr) {
      if (_r[pr]) return _r[pr];
      var Di;
      if (pr === "k256")
        Di = new qi();
      else if (pr === "p224")
        Di = new Wi();
      else if (pr === "p192")
        Di = new Vi();
      else if (pr === "p25519")
        Di = new Ti();
      else
        throw new Error("Unknown prime " + pr);
      return _r[pr] = Di, Di;
    };
    function Li(pr) {
      if (typeof pr == "string") {
        var Di = x._prime(pr);
        this.m = Di.p, this.prime = Di;
      } else
        w(pr.gtn(1), "modulus must be greater than 1"), this.m = pr, this.prime = null;
    }
    Li.prototype._verify1 = function(pr) {
      w(pr.negative === 0, "red works only with positives"), w(pr.red, "red works only with red numbers");
    }, Li.prototype._verify2 = function(pr, Di) {
      w((pr.negative | Di.negative) === 0, "red works only with positives"), w(
        pr.red && pr.red === Di.red,
        "red works only with red numbers"
      );
    }, Li.prototype.imod = function(pr) {
      return this.prime ? this.prime.ireduce(pr)._forceRed(this) : pr.umod(this.m)._forceRed(this);
    }, Li.prototype.neg = function(pr) {
      return pr.isZero() ? pr.clone() : this.m.sub(pr)._forceRed(this);
    }, Li.prototype.add = function(pr, Di) {
      this._verify2(pr, Di);
      var z = pr.add(Di);
      return z.cmp(this.m) >= 0 && z.isub(this.m), z._forceRed(this);
    }, Li.prototype.iadd = function(pr, Di) {
      this._verify2(pr, Di);
      var z = pr.iadd(Di);
      return z.cmp(this.m) >= 0 && z.isub(this.m), z;
    }, Li.prototype.sub = function(pr, Di) {
      this._verify2(pr, Di);
      var z = pr.sub(Di);
      return z.cmpn(0) < 0 && z.iadd(this.m), z._forceRed(this);
    }, Li.prototype.isub = function(pr, Di) {
      this._verify2(pr, Di);
      var z = pr.isub(Di);
      return z.cmpn(0) < 0 && z.iadd(this.m), z;
    }, Li.prototype.shl = function(pr, Di) {
      return this._verify1(pr), this.imod(pr.ushln(Di));
    }, Li.prototype.imul = function(pr, Di) {
      return this._verify2(pr, Di), this.imod(pr.imul(Di));
    }, Li.prototype.mul = function(pr, Di) {
      return this._verify2(pr, Di), this.imod(pr.mul(Di));
    }, Li.prototype.isqr = function(pr) {
      return this.imul(pr, pr.clone());
    }, Li.prototype.sqr = function(pr) {
      return this.mul(pr, pr);
    }, Li.prototype.sqrt = function(pr) {
      if (pr.isZero()) return pr.clone();
      var Di = this.m.andln(3);
      if (w(Di % 2 === 1), Di === 3) {
        var z = this.m.add(new x(1)).iushrn(2);
        return this.pow(pr, z);
      }
      for (var gr = this.m.subn(1), vr = 0; !gr.isZero() && gr.andln(1) === 0; )
        vr++, gr.iushrn(1);
      w(!gr.isZero());
      var Oi = new x(1).toRed(this), Mi = Oi.redNeg(), ki = this.m.subn(1).iushrn(1), yr = this.m.bitLength();
      for (yr = new x(2 * yr * yr).toRed(this); this.pow(yr, ki).cmp(Mi) !== 0; )
        yr.redIAdd(Mi);
      for (var xi = this.pow(yr, gr), Si = this.pow(pr, gr.addn(1).iushrn(1)), Ci = this.pow(pr, gr), Ki = vr; Ci.cmp(Oi) !== 0; ) {
        for (var Yi = Ci, Qi = 0; Yi.cmp(Oi) !== 0; Qi++)
          Yi = Yi.redSqr();
        w(Qi < Ki);
        var Zi = this.pow(xi, new x(1).iushln(Ki - Qi - 1));
        Si = Si.redMul(Zi), xi = Zi.redSqr(), Ci = Ci.redMul(xi), Ki = Qi;
      }
      return Si;
    }, Li.prototype.invm = function(pr) {
      var Di = pr._invmp(this.m);
      return Di.negative !== 0 ? (Di.negative = 0, this.imod(Di).redNeg()) : this.imod(Di);
    }, Li.prototype.pow = function(pr, Di) {
      if (Di.isZero()) return new x(1).toRed(this);
      if (Di.cmpn(1) === 0) return pr.clone();
      var z = 4, gr = new Array(1 << z);
      gr[0] = new x(1).toRed(this), gr[1] = pr;
      for (var vr = 2; vr < gr.length; vr++)
        gr[vr] = this.mul(gr[vr - 1], pr);
      var Oi = gr[0], Mi = 0, ki = 0, yr = Di.bitLength() % 26;
      for (yr === 0 && (yr = 26), vr = Di.length - 1; vr >= 0; vr--) {
        for (var xi = Di.words[vr], Si = yr - 1; Si >= 0; Si--) {
          var Ci = xi >> Si & 1;
          if (Oi !== gr[0] && (Oi = this.sqr(Oi)), Ci === 0 && Mi === 0) {
            ki = 0;
            continue;
          }
          Mi <<= 1, Mi |= Ci, ki++, !(ki !== z && (vr !== 0 || Si !== 0)) && (Oi = this.mul(Oi, gr[Mi]), ki = 0, Mi = 0);
        }
        yr = 26;
      }
      return Oi;
    }, Li.prototype.convertTo = function(pr) {
      var Di = pr.umod(this.m);
      return Di === pr ? Di.clone() : Di;
    }, Li.prototype.convertFrom = function(pr) {
      var Di = pr.clone();
      return Di.red = null, Di;
    }, x.mont = function(pr) {
      return new Hi(pr);
    };
    function Hi(pr) {
      Li.call(this, pr), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new x(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    T(Hi, Li), Hi.prototype.convertTo = function(pr) {
      return this.imod(pr.ushln(this.shift));
    }, Hi.prototype.convertFrom = function(pr) {
      var Di = this.imod(pr.mul(this.rinv));
      return Di.red = null, Di;
    }, Hi.prototype.imul = function(pr, Di) {
      if (pr.isZero() || Di.isZero())
        return pr.words[0] = 0, pr.length = 1, pr;
      var z = pr.imul(Di), gr = z.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), vr = z.isub(gr).iushrn(this.shift), Oi = vr;
      return vr.cmp(this.m) >= 0 ? Oi = vr.isub(this.m) : vr.cmpn(0) < 0 && (Oi = vr.iadd(this.m)), Oi._forceRed(this);
    }, Hi.prototype.mul = function(pr, Di) {
      if (pr.isZero() || Di.isZero()) return new x(0)._forceRed(this);
      var z = pr.mul(Di), gr = z.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), vr = z.isub(gr).iushrn(this.shift), Oi = vr;
      return vr.cmp(this.m) >= 0 ? Oi = vr.isub(this.m) : vr.cmpn(0) < 0 && (Oi = vr.iadd(this.m)), Oi._forceRed(this);
    }, Hi.prototype.invm = function(pr) {
      var Di = this.imod(pr._invmp(this.m).mul(this.r2));
      return Di._forceRed(this);
    };
  })(e, commonjsGlobal);
})(bn$1);
var bnExports$1 = bn$1.exports, brorand = { exports: {} };
brorand.exports;
var hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var e;
  brorand.exports = function(w) {
    return e || (e = new t(null)), e.generate(w);
  };
  function t(w) {
    this.rand = w;
  }
  if (brorand.exports.Rand = t, t.prototype.generate = function(w) {
    return this._rand(w);
  }, t.prototype._rand = function(w) {
    if (this.rand.getBytes)
      return this.rand.getBytes(w);
    for (var T = new Uint8Array(w), x = 0; x < T.length; x++)
      T[x] = this.rand.getByte();
    return T;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? t.prototype._rand = function(w) {
      var T = new Uint8Array(w);
      return self.crypto.getRandomValues(T), T;
    } : self.msCrypto && self.msCrypto.getRandomValues ? t.prototype._rand = function(w) {
      var T = new Uint8Array(w);
      return self.msCrypto.getRandomValues(T), T;
    } : typeof window == "object" && (t.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var v = requireCryptoBrowserify();
      if (typeof v.randomBytes != "function")
        throw new Error("Not supported");
      t.prototype._rand = function(w) {
        return v.randomBytes(w);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr;
  hasRequiredMr = 1;
  var e = bnExports$1, t = requireBrorand();
  function v(w) {
    this.rand = w || new t.Rand();
  }
  return mr = v, v.create = function(w) {
    return new v(w);
  }, v.prototype._randbelow = function(w) {
    var T = w.bitLength(), x = Math.ceil(T / 8);
    do
      var C = new e(this.rand.generate(x));
    while (C.cmp(w) >= 0);
    return C;
  }, v.prototype._randrange = function(w, T) {
    var x = T.sub(w);
    return w.add(this._randbelow(x));
  }, v.prototype.test = function(w, T, x) {
    var C = w.bitLength(), D = e.mont(w), Y = new e(1).toRed(D);
    T || (T = Math.max(1, C / 48 | 0));
    for (var L = w.subn(1), q = 0; !L.testn(q); q++)
      ;
    for (var N = w.shrn(q), F = L.toRed(D), ae = !0; T > 0; T--) {
      var he = this._randrange(new e(2), L);
      x && x(he);
      var tt = he.toRed(D).redPow(N);
      if (!(tt.cmp(Y) === 0 || tt.cmp(F) === 0)) {
        for (var br = 1; br < q; br++) {
          if (tt = tt.redSqr(), tt.cmp(Y) === 0)
            return !1;
          if (tt.cmp(F) === 0)
            break;
        }
        if (br === q)
          return !1;
      }
    }
    return ae;
  }, v.prototype.getDivisor = function(w, T) {
    var x = w.bitLength(), C = e.mont(w), D = new e(1).toRed(C);
    T || (T = Math.max(1, x / 48 | 0));
    for (var Y = w.subn(1), L = 0; !Y.testn(L); L++)
      ;
    for (var q = w.shrn(L), N = Y.toRed(C); T > 0; T--) {
      var F = this._randrange(new e(2), Y), ae = w.gcd(F);
      if (ae.cmpn(1) !== 0)
        return ae;
      var he = F.toRed(C).redPow(q);
      if (!(he.cmp(D) === 0 || he.cmp(N) === 0)) {
        for (var tt = 1; tt < L; tt++) {
          if (he = he.redSqr(), he.cmp(D) === 0)
            return he.fromRed().subn(1).gcd(w);
          if (he.cmp(N) === 0)
            break;
        }
        if (tt === L)
          return he = he.redSqr(), he.fromRed().subn(1).gcd(w);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var e = browserExports;
  generatePrime = br, br.simpleSieve = he, br.fermatTest = tt;
  var t = bnExports$1, v = new t(24), w = requireMr(), T = new w(), x = new t(1), C = new t(2), D = new t(5);
  new t(16), new t(8);
  var Y = new t(10), L = new t(3);
  new t(7);
  var q = new t(11), N = new t(4);
  new t(12);
  var F = null;
  function ae() {
    if (F !== null)
      return F;
    var rt = 1048576, dr = [];
    dr[0] = 2;
    for (var _r = 1, Bi = 3; Bi < rt; Bi += 2) {
      for (var qi = Math.ceil(Math.sqrt(Bi)), Wi = 0; Wi < _r && dr[Wi] <= qi && Bi % dr[Wi] !== 0; Wi++)
        ;
      _r !== Wi && dr[Wi] <= qi || (dr[_r++] = Bi);
    }
    return F = dr, dr;
  }
  function he(rt) {
    for (var dr = ae(), _r = 0; _r < dr.length; _r++)
      if (rt.modn(dr[_r]) === 0)
        return rt.cmpn(dr[_r]) === 0;
    return !0;
  }
  function tt(rt) {
    var dr = t.mont(rt);
    return C.toRed(dr).redPow(rt.subn(1)).fromRed().cmpn(1) === 0;
  }
  function br(rt, dr) {
    if (rt < 16)
      return dr === 2 || dr === 5 ? new t([140, 123]) : new t([140, 39]);
    dr = new t(dr);
    for (var _r, Bi; ; ) {
      for (_r = new t(e(Math.ceil(rt / 8))); _r.bitLength() > rt; )
        _r.ishrn(1);
      if (_r.isEven() && _r.iadd(x), _r.testn(1) || _r.iadd(C), dr.cmp(C)) {
        if (!dr.cmp(D))
          for (; _r.mod(Y).cmp(L); )
            _r.iadd(N);
      } else for (; _r.mod(v).cmp(q); )
        _r.iadd(N);
      if (Bi = _r.shrn(1), he(Bi) && he(_r) && tt(Bi) && tt(_r) && T.test(Bi) && T.test(_r))
        return _r;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var e = bnExports$1, t = requireMr(), v = new t(), w = new e(24), T = new e(11), x = new e(10), C = new e(3), D = new e(7), Y = requireGeneratePrime(), L = browserExports;
  dh = he;
  function q(br, rt) {
    return rt = rt || "utf8", Buffer$C.isBuffer(br) || (br = new Buffer$C(br, rt)), this._pub = new e(br), this;
  }
  function N(br, rt) {
    return rt = rt || "utf8", Buffer$C.isBuffer(br) || (br = new Buffer$C(br, rt)), this._priv = new e(br), this;
  }
  var F = {};
  function ae(br, rt) {
    var dr = rt.toString("hex"), _r = [dr, br.toString(16)].join("_");
    if (_r in F)
      return F[_r];
    var Bi = 0;
    if (br.isEven() || !Y.simpleSieve || !Y.fermatTest(br) || !v.test(br))
      return Bi += 1, dr === "02" || dr === "05" ? Bi += 8 : Bi += 4, F[_r] = Bi, Bi;
    v.test(br.shrn(1)) || (Bi += 2);
    var qi;
    switch (dr) {
      case "02":
        br.mod(w).cmp(T) && (Bi += 8);
        break;
      case "05":
        qi = br.mod(x), qi.cmp(C) && qi.cmp(D) && (Bi += 8);
        break;
      default:
        Bi += 4;
    }
    return F[_r] = Bi, Bi;
  }
  function he(br, rt, dr) {
    this.setGenerator(rt), this.__prime = new e(br), this._prime = e.mont(this.__prime), this._primeLen = br.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, dr ? (this.setPublicKey = q, this.setPrivateKey = N) : this._primeCode = 8;
  }
  Object.defineProperty(he.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = ae(this.__prime, this.__gen)), this._primeCode;
    }
  }), he.prototype.generateKeys = function() {
    return this._priv || (this._priv = new e(L(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, he.prototype.computeSecret = function(br) {
    br = new e(br), br = br.toRed(this._prime);
    var rt = br.redPow(this._priv).fromRed(), dr = new Buffer$C(rt.toArray()), _r = this.getPrime();
    if (dr.length < _r.length) {
      var Bi = new Buffer$C(_r.length - dr.length);
      Bi.fill(0), dr = Buffer$C.concat([Bi, dr]);
    }
    return dr;
  }, he.prototype.getPublicKey = function(br) {
    return tt(this._pub, br);
  }, he.prototype.getPrivateKey = function(br) {
    return tt(this._priv, br);
  }, he.prototype.getPrime = function(br) {
    return tt(this.__prime, br);
  }, he.prototype.getGenerator = function(br) {
    return tt(this._gen, br);
  }, he.prototype.setGenerator = function(br, rt) {
    return rt = rt || "utf8", Buffer$C.isBuffer(br) || (br = new Buffer$C(br, rt)), this.__gen = br, this._gen = new e(br), this;
  };
  function tt(br, rt) {
    var dr = new Buffer$C(br.toArray());
    return rt ? dr.toString(rt) : dr;
  }
  return dh;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$4;
  hasRequiredBrowser$2 = 1;
  var e = requireGeneratePrime(), t = require$$1$1, v = requireDh();
  function w(C) {
    var D = new Buffer$C(t[C].prime, "hex"), Y = new Buffer$C(t[C].gen, "hex");
    return new v(D, Y);
  }
  var T = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function x(C, D, Y, L) {
    return Buffer$C.isBuffer(D) || T[D] === void 0 ? x(C, "binary", D, Y) : (D = D || "binary", L = L || "binary", Y = Y || new Buffer$C([2]), Buffer$C.isBuffer(Y) || (Y = new Buffer$C(Y, L)), typeof C == "number" ? new v(e(C, Y), Y, !0) : (Buffer$C.isBuffer(C) || (C = new Buffer$C(C, D)), new v(C, Y, !0)));
  }
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = w, browser$4.createDiffieHellman = browser$4.DiffieHellman = x, browser$4;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} };
processNextickArgs.exports;
typeof process$1$1 > "u" || !process$1$1.version || process$1$1.version.indexOf("v0.") === 0 || process$1$1.version.indexOf("v1.") === 0 && process$1$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick } : processNextickArgs.exports = process$1$1;
function nextTick(e, t, v, w) {
  if (typeof e != "function")
    throw new TypeError('"callback" argument must be a function');
  var T = arguments.length, x, C;
  switch (T) {
    case 0:
    case 1:
      return process$1$1.nextTick(e);
    case 2:
      return process$1$1.nextTick(function() {
        e.call(null, t);
      });
    case 3:
      return process$1$1.nextTick(function() {
        e.call(null, t, v);
      });
    case 4:
      return process$1$1.nextTick(function() {
        e.call(null, t, v, w);
      });
    default:
      for (x = new Array(T - 1), C = 0; C < x.length; )
        x[C++] = arguments[C];
      return process$1$1.nextTick(function() {
        e.apply(null, x);
      });
  }
}
var processNextickArgsExports = processNextickArgs.exports, toString = {}.toString, isarray = Array.isArray || function(e) {
  return toString.call(e) == "[object Array]";
}, streamBrowser = eventsExports.EventEmitter, util$2 = {};
function isArray(e) {
  return Array.isArray ? Array.isArray(e) : objectToString(e) === "[object Array]";
}
util$2.isArray = isArray;
function isBoolean(e) {
  return typeof e == "boolean";
}
util$2.isBoolean = isBoolean;
function isNull(e) {
  return e === null;
}
util$2.isNull = isNull;
function isNullOrUndefined(e) {
  return e == null;
}
util$2.isNullOrUndefined = isNullOrUndefined;
function isNumber(e) {
  return typeof e == "number";
}
util$2.isNumber = isNumber;
function isString(e) {
  return typeof e == "string";
}
util$2.isString = isString;
function isSymbol(e) {
  return typeof e == "symbol";
}
util$2.isSymbol = isSymbol;
function isUndefined(e) {
  return e === void 0;
}
util$2.isUndefined = isUndefined;
function isRegExp(e) {
  return objectToString(e) === "[object RegExp]";
}
util$2.isRegExp = isRegExp;
function isObject(e) {
  return typeof e == "object" && e !== null;
}
util$2.isObject = isObject;
function isDate(e) {
  return objectToString(e) === "[object Date]";
}
util$2.isDate = isDate;
function isError(e) {
  return objectToString(e) === "[object Error]" || e instanceof Error;
}
util$2.isError = isError;
function isFunction(e) {
  return typeof e == "function";
}
util$2.isFunction = isFunction;
function isPrimitive(e) {
  return e === null || typeof e == "boolean" || typeof e == "number" || typeof e == "string" || typeof e == "symbol" || // ES6 symbol
  typeof e > "u";
}
util$2.isPrimitive = isPrimitive;
util$2.isBuffer = require$$1$2.Buffer.isBuffer;
function objectToString(e) {
  return Object.prototype.toString.call(e);
}
var BufferList = { exports: {} };
BufferList.exports;
var hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(e) {
    function t(x, C) {
      if (!(x instanceof C))
        throw new TypeError("Cannot call a class as a function");
    }
    var v = safeBufferExports.Buffer, w = util$3;
    function T(x, C, D) {
      x.copy(C, D);
    }
    e.exports = function() {
      function x() {
        t(this, x), this.head = null, this.tail = null, this.length = 0;
      }
      return x.prototype.push = function(C) {
        var D = { data: C, next: null };
        this.length > 0 ? this.tail.next = D : this.head = D, this.tail = D, ++this.length;
      }, x.prototype.unshift = function(C) {
        var D = { data: C, next: this.head };
        this.length === 0 && (this.tail = D), this.head = D, ++this.length;
      }, x.prototype.shift = function() {
        if (this.length !== 0) {
          var C = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, C;
        }
      }, x.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, x.prototype.join = function(C) {
        if (this.length === 0) return "";
        for (var D = this.head, Y = "" + D.data; D = D.next; )
          Y += C + D.data;
        return Y;
      }, x.prototype.concat = function(C) {
        if (this.length === 0) return v.alloc(0);
        for (var D = v.allocUnsafe(C >>> 0), Y = this.head, L = 0; Y; )
          T(Y.data, D, L), L += Y.data.length, Y = Y.next;
        return D;
      }, x;
    }(), w && w.inspect && w.inspect.custom && (e.exports.prototype[w.inspect.custom] = function() {
      var x = w.inspect({ length: this.length });
      return this.constructor.name + " " + x;
    });
  }(BufferList)), BufferList.exports;
}
var pna = processNextickArgsExports;
function destroy(e, t) {
  var v = this, w = this._readableState && this._readableState.destroyed, T = this._writableState && this._writableState.destroyed;
  return w || T ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, pna.nextTick(emitErrorNT, this, e)) : pna.nextTick(emitErrorNT, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(x) {
    !t && x ? v._writableState ? v._writableState.errorEmitted || (v._writableState.errorEmitted = !0, pna.nextTick(emitErrorNT, v, x)) : pna.nextTick(emitErrorNT, v, x) : t && t(x);
  }), this);
}
function undestroy() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT(e, t) {
  e.emit("error", t);
}
var destroy_1 = {
  destroy,
  undestroy
}, _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var e = processNextickArgsExports;
  _stream_writable = tt;
  function t(Mi) {
    var ki = this;
    this.next = null, this.entry = null, this.finish = function() {
      Oi(ki, Mi);
    };
  }
  var v = !process$1$1.browser && ["v0.10", "v0.9."].indexOf(process$1$1.version.slice(0, 5)) > -1 ? setImmediate : e.nextTick, w;
  tt.WritableState = ae;
  var T = Object.create(util$2);
  T.inherits = inherits_browserExports;
  var x = {
    deprecate: browser$a
  }, C = streamBrowser, D = safeBufferExports.Buffer, Y = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function L(Mi) {
    return D.from(Mi);
  }
  function q(Mi) {
    return D.isBuffer(Mi) || Mi instanceof Y;
  }
  var N = destroy_1;
  T.inherits(tt, C);
  function F() {
  }
  function ae(Mi, ki) {
    w = w || require_stream_duplex(), Mi = Mi || {};
    var yr = ki instanceof w;
    this.objectMode = !!Mi.objectMode, yr && (this.objectMode = this.objectMode || !!Mi.writableObjectMode);
    var xi = Mi.highWaterMark, Si = Mi.writableHighWaterMark, Ci = this.objectMode ? 16 : 16 * 1024;
    xi || xi === 0 ? this.highWaterMark = xi : yr && (Si || Si === 0) ? this.highWaterMark = Si : this.highWaterMark = Ci, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Ki = Mi.decodeStrings === !1;
    this.decodeStrings = !Ki, this.defaultEncoding = Mi.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Yi) {
      Vi(ki, Yi);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  ae.prototype.getBuffer = function() {
    for (var Mi = this.bufferedRequest, ki = []; Mi; )
      ki.push(Mi), Mi = Mi.next;
    return ki;
  }, function() {
    try {
      Object.defineProperty(ae.prototype, "buffer", {
        get: x.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var he;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (he = Function.prototype[Symbol.hasInstance], Object.defineProperty(tt, Symbol.hasInstance, {
    value: function(Mi) {
      return he.call(this, Mi) ? !0 : this !== tt ? !1 : Mi && Mi._writableState instanceof ae;
    }
  })) : he = function(Mi) {
    return Mi instanceof this;
  };
  function tt(Mi) {
    if (w = w || require_stream_duplex(), !he.call(tt, this) && !(this instanceof w))
      return new tt(Mi);
    this._writableState = new ae(Mi, this), this.writable = !0, Mi && (typeof Mi.write == "function" && (this._write = Mi.write), typeof Mi.writev == "function" && (this._writev = Mi.writev), typeof Mi.destroy == "function" && (this._destroy = Mi.destroy), typeof Mi.final == "function" && (this._final = Mi.final)), C.call(this);
  }
  tt.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function br(Mi, ki) {
    var yr = new Error("write after end");
    Mi.emit("error", yr), e.nextTick(ki, yr);
  }
  function rt(Mi, ki, yr, xi) {
    var Si = !0, Ci = !1;
    return yr === null ? Ci = new TypeError("May not write null values to stream") : typeof yr != "string" && yr !== void 0 && !ki.objectMode && (Ci = new TypeError("Invalid non-string/buffer chunk")), Ci && (Mi.emit("error", Ci), e.nextTick(xi, Ci), Si = !1), Si;
  }
  tt.prototype.write = function(Mi, ki, yr) {
    var xi = this._writableState, Si = !1, Ci = !xi.objectMode && q(Mi);
    return Ci && !D.isBuffer(Mi) && (Mi = L(Mi)), typeof ki == "function" && (yr = ki, ki = null), Ci ? ki = "buffer" : ki || (ki = xi.defaultEncoding), typeof yr != "function" && (yr = F), xi.ended ? br(this, yr) : (Ci || rt(this, xi, Mi, yr)) && (xi.pendingcb++, Si = _r(this, xi, Ci, Mi, ki, yr)), Si;
  }, tt.prototype.cork = function() {
    var Mi = this._writableState;
    Mi.corked++;
  }, tt.prototype.uncork = function() {
    var Mi = this._writableState;
    Mi.corked && (Mi.corked--, !Mi.writing && !Mi.corked && !Mi.bufferProcessing && Mi.bufferedRequest && Hi(this, Mi));
  }, tt.prototype.setDefaultEncoding = function(Mi) {
    if (typeof Mi == "string" && (Mi = Mi.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Mi + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + Mi);
    return this._writableState.defaultEncoding = Mi, this;
  };
  function dr(Mi, ki, yr) {
    return !Mi.objectMode && Mi.decodeStrings !== !1 && typeof ki == "string" && (ki = D.from(ki, yr)), ki;
  }
  Object.defineProperty(tt.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function _r(Mi, ki, yr, xi, Si, Ci) {
    if (!yr) {
      var Ki = dr(ki, xi, Si);
      xi !== Ki && (yr = !0, Si = "buffer", xi = Ki);
    }
    var Yi = ki.objectMode ? 1 : xi.length;
    ki.length += Yi;
    var Qi = ki.length < ki.highWaterMark;
    if (Qi || (ki.needDrain = !0), ki.writing || ki.corked) {
      var Zi = ki.lastBufferedRequest;
      ki.lastBufferedRequest = {
        chunk: xi,
        encoding: Si,
        isBuf: yr,
        callback: Ci,
        next: null
      }, Zi ? Zi.next = ki.lastBufferedRequest : ki.bufferedRequest = ki.lastBufferedRequest, ki.bufferedRequestCount += 1;
    } else
      Bi(Mi, ki, !1, Yi, xi, Si, Ci);
    return Qi;
  }
  function Bi(Mi, ki, yr, xi, Si, Ci, Ki) {
    ki.writelen = xi, ki.writecb = Ki, ki.writing = !0, ki.sync = !0, yr ? Mi._writev(Si, ki.onwrite) : Mi._write(Si, Ci, ki.onwrite), ki.sync = !1;
  }
  function qi(Mi, ki, yr, xi, Si) {
    --ki.pendingcb, yr ? (e.nextTick(Si, xi), e.nextTick(gr, Mi, ki), Mi._writableState.errorEmitted = !0, Mi.emit("error", xi)) : (Si(xi), Mi._writableState.errorEmitted = !0, Mi.emit("error", xi), gr(Mi, ki));
  }
  function Wi(Mi) {
    Mi.writing = !1, Mi.writecb = null, Mi.length -= Mi.writelen, Mi.writelen = 0;
  }
  function Vi(Mi, ki) {
    var yr = Mi._writableState, xi = yr.sync, Si = yr.writecb;
    if (Wi(yr), ki) qi(Mi, yr, xi, ki, Si);
    else {
      var Ci = pr(yr);
      !Ci && !yr.corked && !yr.bufferProcessing && yr.bufferedRequest && Hi(Mi, yr), xi ? v(Ti, Mi, yr, Ci, Si) : Ti(Mi, yr, Ci, Si);
    }
  }
  function Ti(Mi, ki, yr, xi) {
    yr || Li(Mi, ki), ki.pendingcb--, xi(), gr(Mi, ki);
  }
  function Li(Mi, ki) {
    ki.length === 0 && ki.needDrain && (ki.needDrain = !1, Mi.emit("drain"));
  }
  function Hi(Mi, ki) {
    ki.bufferProcessing = !0;
    var yr = ki.bufferedRequest;
    if (Mi._writev && yr && yr.next) {
      var xi = ki.bufferedRequestCount, Si = new Array(xi), Ci = ki.corkedRequestsFree;
      Ci.entry = yr;
      for (var Ki = 0, Yi = !0; yr; )
        Si[Ki] = yr, yr.isBuf || (Yi = !1), yr = yr.next, Ki += 1;
      Si.allBuffers = Yi, Bi(Mi, ki, !0, ki.length, Si, "", Ci.finish), ki.pendingcb++, ki.lastBufferedRequest = null, Ci.next ? (ki.corkedRequestsFree = Ci.next, Ci.next = null) : ki.corkedRequestsFree = new t(ki), ki.bufferedRequestCount = 0;
    } else {
      for (; yr; ) {
        var Qi = yr.chunk, Zi = yr.encoding, Ni = yr.callback, Fi = ki.objectMode ? 1 : Qi.length;
        if (Bi(Mi, ki, !1, Fi, Qi, Zi, Ni), yr = yr.next, ki.bufferedRequestCount--, ki.writing)
          break;
      }
      yr === null && (ki.lastBufferedRequest = null);
    }
    ki.bufferedRequest = yr, ki.bufferProcessing = !1;
  }
  tt.prototype._write = function(Mi, ki, yr) {
    yr(new Error("_write() is not implemented"));
  }, tt.prototype._writev = null, tt.prototype.end = function(Mi, ki, yr) {
    var xi = this._writableState;
    typeof Mi == "function" ? (yr = Mi, Mi = null, ki = null) : typeof ki == "function" && (yr = ki, ki = null), Mi != null && this.write(Mi, ki), xi.corked && (xi.corked = 1, this.uncork()), xi.ending || vr(this, xi, yr);
  };
  function pr(Mi) {
    return Mi.ending && Mi.length === 0 && Mi.bufferedRequest === null && !Mi.finished && !Mi.writing;
  }
  function Di(Mi, ki) {
    Mi._final(function(yr) {
      ki.pendingcb--, yr && Mi.emit("error", yr), ki.prefinished = !0, Mi.emit("prefinish"), gr(Mi, ki);
    });
  }
  function z(Mi, ki) {
    !ki.prefinished && !ki.finalCalled && (typeof Mi._final == "function" ? (ki.pendingcb++, ki.finalCalled = !0, e.nextTick(Di, Mi, ki)) : (ki.prefinished = !0, Mi.emit("prefinish")));
  }
  function gr(Mi, ki) {
    var yr = pr(ki);
    return yr && (z(Mi, ki), ki.pendingcb === 0 && (ki.finished = !0, Mi.emit("finish"))), yr;
  }
  function vr(Mi, ki, yr) {
    ki.ending = !0, gr(Mi, ki), yr && (ki.finished ? e.nextTick(yr) : Mi.once("finish", yr)), ki.ended = !0, Mi.writable = !1;
  }
  function Oi(Mi, ki, yr) {
    var xi = Mi.entry;
    for (Mi.entry = null; xi; ) {
      var Si = xi.callback;
      ki.pendingcb--, Si(yr), xi = xi.next;
    }
    ki.corkedRequestsFree.next = Mi;
  }
  return Object.defineProperty(tt.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Mi) {
      this._writableState && (this._writableState.destroyed = Mi);
    }
  }), tt.prototype.destroy = N.destroy, tt.prototype._undestroy = N.undestroy, tt.prototype._destroy = function(Mi, ki) {
    this.end(), ki(Mi);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var e = processNextickArgsExports, t = Object.keys || function(N) {
    var F = [];
    for (var ae in N)
      F.push(ae);
    return F;
  };
  _stream_duplex = Y;
  var v = Object.create(util$2);
  v.inherits = inherits_browserExports;
  var w = require_stream_readable(), T = require_stream_writable();
  v.inherits(Y, w);
  for (var x = t(T.prototype), C = 0; C < x.length; C++) {
    var D = x[C];
    Y.prototype[D] || (Y.prototype[D] = T.prototype[D]);
  }
  function Y(N) {
    if (!(this instanceof Y)) return new Y(N);
    w.call(this, N), T.call(this, N), N && N.readable === !1 && (this.readable = !1), N && N.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, N && N.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", L);
  }
  Object.defineProperty(Y.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function L() {
    this.allowHalfOpen || this._writableState.ended || e.nextTick(q, this);
  }
  function q(N) {
    N.end();
  }
  return Object.defineProperty(Y.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(N) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = N, this._writableState.destroyed = N);
    }
  }), Y.prototype._destroy = function(N, F) {
    this.push(null), this.end(), e.nextTick(F, N);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var e = processNextickArgsExports;
  _stream_readable = dr;
  var t = isarray, v;
  dr.ReadableState = rt, eventsExports.EventEmitter;
  var w = function(Ni, Fi) {
    return Ni.listeners(Fi).length;
  }, T = streamBrowser, x = safeBufferExports.Buffer, C = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function D(Ni) {
    return x.from(Ni);
  }
  function Y(Ni) {
    return x.isBuffer(Ni) || Ni instanceof C;
  }
  var L = Object.create(util$2);
  L.inherits = inherits_browserExports;
  var q = util$3, N = void 0;
  q && q.debuglog ? N = q.debuglog("stream") : N = function() {
  };
  var F = requireBufferList(), ae = destroy_1, he;
  L.inherits(dr, T);
  var tt = ["error", "close", "destroy", "pause", "resume"];
  function br(Ni, Fi, Xi) {
    if (typeof Ni.prependListener == "function") return Ni.prependListener(Fi, Xi);
    !Ni._events || !Ni._events[Fi] ? Ni.on(Fi, Xi) : t(Ni._events[Fi]) ? Ni._events[Fi].unshift(Xi) : Ni._events[Fi] = [Xi, Ni._events[Fi]];
  }
  function rt(Ni, Fi) {
    v = v || require_stream_duplex(), Ni = Ni || {};
    var Xi = Fi instanceof v;
    this.objectMode = !!Ni.objectMode, Xi && (this.objectMode = this.objectMode || !!Ni.readableObjectMode);
    var to = Ni.highWaterMark, zi = Ni.readableHighWaterMark, Gi = this.objectMode ? 16 : 16 * 1024;
    to || to === 0 ? this.highWaterMark = to : Xi && (zi || zi === 0) ? this.highWaterMark = zi : this.highWaterMark = Gi, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new F(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Ni.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Ni.encoding && (he || (he = string_decoder.StringDecoder), this.decoder = new he(Ni.encoding), this.encoding = Ni.encoding);
  }
  function dr(Ni) {
    if (v = v || require_stream_duplex(), !(this instanceof dr)) return new dr(Ni);
    this._readableState = new rt(Ni, this), this.readable = !0, Ni && (typeof Ni.read == "function" && (this._read = Ni.read), typeof Ni.destroy == "function" && (this._destroy = Ni.destroy)), T.call(this);
  }
  Object.defineProperty(dr.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Ni) {
      this._readableState && (this._readableState.destroyed = Ni);
    }
  }), dr.prototype.destroy = ae.destroy, dr.prototype._undestroy = ae.undestroy, dr.prototype._destroy = function(Ni, Fi) {
    this.push(null), Fi(Ni);
  }, dr.prototype.push = function(Ni, Fi) {
    var Xi = this._readableState, to;
    return Xi.objectMode ? to = !0 : typeof Ni == "string" && (Fi = Fi || Xi.defaultEncoding, Fi !== Xi.encoding && (Ni = x.from(Ni, Fi), Fi = ""), to = !0), _r(this, Ni, Fi, !1, to);
  }, dr.prototype.unshift = function(Ni) {
    return _r(this, Ni, null, !0, !1);
  };
  function _r(Ni, Fi, Xi, to, zi) {
    var Gi = Ni._readableState;
    if (Fi === null)
      Gi.reading = !1, Hi(Ni, Gi);
    else {
      var no;
      zi || (no = qi(Gi, Fi)), no ? Ni.emit("error", no) : Gi.objectMode || Fi && Fi.length > 0 ? (typeof Fi != "string" && !Gi.objectMode && Object.getPrototypeOf(Fi) !== x.prototype && (Fi = D(Fi)), to ? Gi.endEmitted ? Ni.emit("error", new Error("stream.unshift() after end event")) : Bi(Ni, Gi, Fi, !0) : Gi.ended ? Ni.emit("error", new Error("stream.push() after EOF")) : (Gi.reading = !1, Gi.decoder && !Xi ? (Fi = Gi.decoder.write(Fi), Gi.objectMode || Fi.length !== 0 ? Bi(Ni, Gi, Fi, !1) : z(Ni, Gi)) : Bi(Ni, Gi, Fi, !1))) : to || (Gi.reading = !1);
    }
    return Wi(Gi);
  }
  function Bi(Ni, Fi, Xi, to) {
    Fi.flowing && Fi.length === 0 && !Fi.sync ? (Ni.emit("data", Xi), Ni.read(0)) : (Fi.length += Fi.objectMode ? 1 : Xi.length, to ? Fi.buffer.unshift(Xi) : Fi.buffer.push(Xi), Fi.needReadable && pr(Ni)), z(Ni, Fi);
  }
  function qi(Ni, Fi) {
    var Xi;
    return !Y(Fi) && typeof Fi != "string" && Fi !== void 0 && !Ni.objectMode && (Xi = new TypeError("Invalid non-string/buffer chunk")), Xi;
  }
  function Wi(Ni) {
    return !Ni.ended && (Ni.needReadable || Ni.length < Ni.highWaterMark || Ni.length === 0);
  }
  dr.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, dr.prototype.setEncoding = function(Ni) {
    return he || (he = string_decoder.StringDecoder), this._readableState.decoder = new he(Ni), this._readableState.encoding = Ni, this;
  };
  var Vi = 8388608;
  function Ti(Ni) {
    return Ni >= Vi ? Ni = Vi : (Ni--, Ni |= Ni >>> 1, Ni |= Ni >>> 2, Ni |= Ni >>> 4, Ni |= Ni >>> 8, Ni |= Ni >>> 16, Ni++), Ni;
  }
  function Li(Ni, Fi) {
    return Ni <= 0 || Fi.length === 0 && Fi.ended ? 0 : Fi.objectMode ? 1 : Ni !== Ni ? Fi.flowing && Fi.length ? Fi.buffer.head.data.length : Fi.length : (Ni > Fi.highWaterMark && (Fi.highWaterMark = Ti(Ni)), Ni <= Fi.length ? Ni : Fi.ended ? Fi.length : (Fi.needReadable = !0, 0));
  }
  dr.prototype.read = function(Ni) {
    N("read", Ni), Ni = parseInt(Ni, 10);
    var Fi = this._readableState, Xi = Ni;
    if (Ni !== 0 && (Fi.emittedReadable = !1), Ni === 0 && Fi.needReadable && (Fi.length >= Fi.highWaterMark || Fi.ended))
      return N("read: emitReadable", Fi.length, Fi.ended), Fi.length === 0 && Fi.ended ? Yi(this) : pr(this), null;
    if (Ni = Li(Ni, Fi), Ni === 0 && Fi.ended)
      return Fi.length === 0 && Yi(this), null;
    var to = Fi.needReadable;
    N("need readable", to), (Fi.length === 0 || Fi.length - Ni < Fi.highWaterMark) && (to = !0, N("length less than watermark", to)), Fi.ended || Fi.reading ? (to = !1, N("reading or ended", to)) : to && (N("do read"), Fi.reading = !0, Fi.sync = !0, Fi.length === 0 && (Fi.needReadable = !0), this._read(Fi.highWaterMark), Fi.sync = !1, Fi.reading || (Ni = Li(Xi, Fi)));
    var zi;
    return Ni > 0 ? zi = xi(Ni, Fi) : zi = null, zi === null ? (Fi.needReadable = !0, Ni = 0) : Fi.length -= Ni, Fi.length === 0 && (Fi.ended || (Fi.needReadable = !0), Xi !== Ni && Fi.ended && Yi(this)), zi !== null && this.emit("data", zi), zi;
  };
  function Hi(Ni, Fi) {
    if (!Fi.ended) {
      if (Fi.decoder) {
        var Xi = Fi.decoder.end();
        Xi && Xi.length && (Fi.buffer.push(Xi), Fi.length += Fi.objectMode ? 1 : Xi.length);
      }
      Fi.ended = !0, pr(Ni);
    }
  }
  function pr(Ni) {
    var Fi = Ni._readableState;
    Fi.needReadable = !1, Fi.emittedReadable || (N("emitReadable", Fi.flowing), Fi.emittedReadable = !0, Fi.sync ? e.nextTick(Di, Ni) : Di(Ni));
  }
  function Di(Ni) {
    N("emit readable"), Ni.emit("readable"), yr(Ni);
  }
  function z(Ni, Fi) {
    Fi.readingMore || (Fi.readingMore = !0, e.nextTick(gr, Ni, Fi));
  }
  function gr(Ni, Fi) {
    for (var Xi = Fi.length; !Fi.reading && !Fi.flowing && !Fi.ended && Fi.length < Fi.highWaterMark && (N("maybeReadMore read 0"), Ni.read(0), Xi !== Fi.length); )
      Xi = Fi.length;
    Fi.readingMore = !1;
  }
  dr.prototype._read = function(Ni) {
    this.emit("error", new Error("_read() is not implemented"));
  }, dr.prototype.pipe = function(Ni, Fi) {
    var Xi = this, to = this._readableState;
    switch (to.pipesCount) {
      case 0:
        to.pipes = Ni;
        break;
      case 1:
        to.pipes = [to.pipes, Ni];
        break;
      default:
        to.pipes.push(Ni);
        break;
    }
    to.pipesCount += 1, N("pipe count=%d opts=%j", to.pipesCount, Fi);
    var zi = (!Fi || Fi.end !== !1) && Ni !== process$1$1.stdout && Ni !== process$1$1.stderr, Gi = zi ? so : mo;
    to.endEmitted ? e.nextTick(Gi) : Xi.once("end", Gi), Ni.on("unpipe", no);
    function no(Ro, _o) {
      N("onunpipe"), Ro === Xi && _o && _o.hasUnpiped === !1 && (_o.hasUnpiped = !0, ao());
    }
    function so() {
      N("onend"), Ni.end();
    }
    var ho = vr(Xi);
    Ni.on("drain", ho);
    var uo = !1;
    function ao() {
      N("cleanup"), Ni.removeListener("close", Do), Ni.removeListener("finish", Io), Ni.removeListener("drain", ho), Ni.removeListener("error", po), Ni.removeListener("unpipe", no), Xi.removeListener("end", so), Xi.removeListener("end", mo), Xi.removeListener("data", io), uo = !0, to.awaitDrain && (!Ni._writableState || Ni._writableState.needDrain) && ho();
    }
    var Bo = !1;
    Xi.on("data", io);
    function io(Ro) {
      N("ondata"), Bo = !1;
      var _o = Ni.write(Ro);
      _o === !1 && !Bo && ((to.pipesCount === 1 && to.pipes === Ni || to.pipesCount > 1 && Zi(to.pipes, Ni) !== -1) && !uo && (N("false write response, pause", to.awaitDrain), to.awaitDrain++, Bo = !0), Xi.pause());
    }
    function po(Ro) {
      N("onerror", Ro), mo(), Ni.removeListener("error", po), w(Ni, "error") === 0 && Ni.emit("error", Ro);
    }
    br(Ni, "error", po);
    function Do() {
      Ni.removeListener("finish", Io), mo();
    }
    Ni.once("close", Do);
    function Io() {
      N("onfinish"), Ni.removeListener("close", Do), mo();
    }
    Ni.once("finish", Io);
    function mo() {
      N("unpipe"), Xi.unpipe(Ni);
    }
    return Ni.emit("pipe", Xi), to.flowing || (N("pipe resume"), Xi.resume()), Ni;
  };
  function vr(Ni) {
    return function() {
      var Fi = Ni._readableState;
      N("pipeOnDrain", Fi.awaitDrain), Fi.awaitDrain && Fi.awaitDrain--, Fi.awaitDrain === 0 && w(Ni, "data") && (Fi.flowing = !0, yr(Ni));
    };
  }
  dr.prototype.unpipe = function(Ni) {
    var Fi = this._readableState, Xi = { hasUnpiped: !1 };
    if (Fi.pipesCount === 0) return this;
    if (Fi.pipesCount === 1)
      return Ni && Ni !== Fi.pipes ? this : (Ni || (Ni = Fi.pipes), Fi.pipes = null, Fi.pipesCount = 0, Fi.flowing = !1, Ni && Ni.emit("unpipe", this, Xi), this);
    if (!Ni) {
      var to = Fi.pipes, zi = Fi.pipesCount;
      Fi.pipes = null, Fi.pipesCount = 0, Fi.flowing = !1;
      for (var Gi = 0; Gi < zi; Gi++)
        to[Gi].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var no = Zi(Fi.pipes, Ni);
    return no === -1 ? this : (Fi.pipes.splice(no, 1), Fi.pipesCount -= 1, Fi.pipesCount === 1 && (Fi.pipes = Fi.pipes[0]), Ni.emit("unpipe", this, Xi), this);
  }, dr.prototype.on = function(Ni, Fi) {
    var Xi = T.prototype.on.call(this, Ni, Fi);
    if (Ni === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (Ni === "readable") {
      var to = this._readableState;
      !to.endEmitted && !to.readableListening && (to.readableListening = to.needReadable = !0, to.emittedReadable = !1, to.reading ? to.length && pr(this) : e.nextTick(Oi, this));
    }
    return Xi;
  }, dr.prototype.addListener = dr.prototype.on;
  function Oi(Ni) {
    N("readable nexttick read 0"), Ni.read(0);
  }
  dr.prototype.resume = function() {
    var Ni = this._readableState;
    return Ni.flowing || (N("resume"), Ni.flowing = !0, Mi(this, Ni)), this;
  };
  function Mi(Ni, Fi) {
    Fi.resumeScheduled || (Fi.resumeScheduled = !0, e.nextTick(ki, Ni, Fi));
  }
  function ki(Ni, Fi) {
    Fi.reading || (N("resume read 0"), Ni.read(0)), Fi.resumeScheduled = !1, Fi.awaitDrain = 0, Ni.emit("resume"), yr(Ni), Fi.flowing && !Fi.reading && Ni.read(0);
  }
  dr.prototype.pause = function() {
    return N("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (N("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function yr(Ni) {
    var Fi = Ni._readableState;
    for (N("flow", Fi.flowing); Fi.flowing && Ni.read() !== null; )
      ;
  }
  dr.prototype.wrap = function(Ni) {
    var Fi = this, Xi = this._readableState, to = !1;
    Ni.on("end", function() {
      if (N("wrapped end"), Xi.decoder && !Xi.ended) {
        var no = Xi.decoder.end();
        no && no.length && Fi.push(no);
      }
      Fi.push(null);
    }), Ni.on("data", function(no) {
      if (N("wrapped data"), Xi.decoder && (no = Xi.decoder.write(no)), !(Xi.objectMode && no == null) && !(!Xi.objectMode && (!no || !no.length))) {
        var so = Fi.push(no);
        so || (to = !0, Ni.pause());
      }
    });
    for (var zi in Ni)
      this[zi] === void 0 && typeof Ni[zi] == "function" && (this[zi] = /* @__PURE__ */ function(no) {
        return function() {
          return Ni[no].apply(Ni, arguments);
        };
      }(zi));
    for (var Gi = 0; Gi < tt.length; Gi++)
      Ni.on(tt[Gi], this.emit.bind(this, tt[Gi]));
    return this._read = function(no) {
      N("wrapped _read", no), to && (to = !1, Ni.resume());
    }, this;
  }, Object.defineProperty(dr.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), dr._fromList = xi;
  function xi(Ni, Fi) {
    if (Fi.length === 0) return null;
    var Xi;
    return Fi.objectMode ? Xi = Fi.buffer.shift() : !Ni || Ni >= Fi.length ? (Fi.decoder ? Xi = Fi.buffer.join("") : Fi.buffer.length === 1 ? Xi = Fi.buffer.head.data : Xi = Fi.buffer.concat(Fi.length), Fi.buffer.clear()) : Xi = Si(Ni, Fi.buffer, Fi.decoder), Xi;
  }
  function Si(Ni, Fi, Xi) {
    var to;
    return Ni < Fi.head.data.length ? (to = Fi.head.data.slice(0, Ni), Fi.head.data = Fi.head.data.slice(Ni)) : Ni === Fi.head.data.length ? to = Fi.shift() : to = Xi ? Ci(Ni, Fi) : Ki(Ni, Fi), to;
  }
  function Ci(Ni, Fi) {
    var Xi = Fi.head, to = 1, zi = Xi.data;
    for (Ni -= zi.length; Xi = Xi.next; ) {
      var Gi = Xi.data, no = Ni > Gi.length ? Gi.length : Ni;
      if (no === Gi.length ? zi += Gi : zi += Gi.slice(0, Ni), Ni -= no, Ni === 0) {
        no === Gi.length ? (++to, Xi.next ? Fi.head = Xi.next : Fi.head = Fi.tail = null) : (Fi.head = Xi, Xi.data = Gi.slice(no));
        break;
      }
      ++to;
    }
    return Fi.length -= to, zi;
  }
  function Ki(Ni, Fi) {
    var Xi = x.allocUnsafe(Ni), to = Fi.head, zi = 1;
    for (to.data.copy(Xi), Ni -= to.data.length; to = to.next; ) {
      var Gi = to.data, no = Ni > Gi.length ? Gi.length : Ni;
      if (Gi.copy(Xi, Xi.length - Ni, 0, no), Ni -= no, Ni === 0) {
        no === Gi.length ? (++zi, to.next ? Fi.head = to.next : Fi.head = Fi.tail = null) : (Fi.head = to, to.data = Gi.slice(no));
        break;
      }
      ++zi;
    }
    return Fi.length -= zi, Xi;
  }
  function Yi(Ni) {
    var Fi = Ni._readableState;
    if (Fi.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    Fi.endEmitted || (Fi.ended = !0, e.nextTick(Qi, Fi, Ni));
  }
  function Qi(Ni, Fi) {
    !Ni.endEmitted && Ni.length === 0 && (Ni.endEmitted = !0, Fi.readable = !1, Fi.emit("end"));
  }
  function Zi(Ni, Fi) {
    for (var Xi = 0, to = Ni.length; Xi < to; Xi++)
      if (Ni[Xi] === Fi) return Xi;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$1, Duplex = require_stream_duplex(), util$1 = Object.create(util$2);
util$1.inherits = inherits_browserExports;
util$1.inherits(Transform$1, Duplex);
function afterTransform(e, t) {
  var v = this._transformState;
  v.transforming = !1;
  var w = v.writecb;
  if (!w)
    return this.emit("error", new Error("write callback called multiple times"));
  v.writechunk = null, v.writecb = null, t != null && this.push(t), w(e);
  var T = this._readableState;
  T.reading = !1, (T.needReadable || T.length < T.highWaterMark) && this._read(T.highWaterMark);
}
function Transform$1(e) {
  if (!(this instanceof Transform$1)) return new Transform$1(e);
  Duplex.call(this, e), this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", prefinish);
}
function prefinish() {
  var e = this;
  typeof this._flush == "function" ? this._flush(function(t, v) {
    done(e, t, v);
  }) : done(this, null, null);
}
Transform$1.prototype.push = function(e, t) {
  return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, e, t);
};
Transform$1.prototype._transform = function(e, t, v) {
  throw new Error("_transform() is not implemented");
};
Transform$1.prototype._write = function(e, t, v) {
  var w = this._transformState;
  if (w.writecb = v, w.writechunk = e, w.writeencoding = t, !w.transforming) {
    var T = this._readableState;
    (w.needTransform || T.needReadable || T.length < T.highWaterMark) && this._read(T.highWaterMark);
  }
};
Transform$1.prototype._read = function(e) {
  var t = this._transformState;
  t.writechunk !== null && t.writecb && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
};
Transform$1.prototype._destroy = function(e, t) {
  var v = this;
  Duplex.prototype._destroy.call(this, e, function(w) {
    t(w), v.emit("close");
  });
};
function done(e, t, v) {
  if (t) return e.emit("error", t);
  if (v != null && e.push(v), e._writableState.length) throw new Error("Calling transform done when ws.length != 0");
  if (e._transformState.transforming) throw new Error("Calling transform done when still transforming");
  return e.push(null);
}
var _stream_passthrough = PassThrough, Transform = _stream_transform, util = Object.create(util$2);
util.inherits = inherits_browserExports;
util.inherits(PassThrough, Transform);
function PassThrough(e) {
  if (!(this instanceof PassThrough)) return new PassThrough(e);
  Transform.call(this, e);
}
PassThrough.prototype._transform = function(e, t, v) {
  v(null, e);
};
readableBrowser.exports;
(function(e, t) {
  t = e.exports = require_stream_readable(), t.Stream = t, t.Readable = t, t.Writable = require_stream_writable(), t.Duplex = require_stream_duplex(), t.Transform = _stream_transform, t.PassThrough = _stream_passthrough;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports, sign = { exports: {} }, bn = { exports: {} };
bn.exports;
(function(e) {
  (function(t, v) {
    function w(z, gr) {
      if (!z) throw new Error(gr || "Assertion failed");
    }
    function T(z, gr) {
      z.super_ = gr;
      var vr = function() {
      };
      vr.prototype = gr.prototype, z.prototype = new vr(), z.prototype.constructor = z;
    }
    function x(z, gr, vr) {
      if (x.isBN(z))
        return z;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, z !== null && ((gr === "le" || gr === "be") && (vr = gr, gr = 10), this._init(z || 0, gr || 10, vr || "be"));
    }
    typeof t == "object" ? t.exports = x : v.BN = x, x.BN = x, x.wordSize = 26;
    var C;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? C = window.Buffer : C = require$$1$2.Buffer;
    } catch {
    }
    x.isBN = function(z) {
      return z instanceof x ? !0 : z !== null && typeof z == "object" && z.constructor.wordSize === x.wordSize && Array.isArray(z.words);
    }, x.max = function(z, gr) {
      return z.cmp(gr) > 0 ? z : gr;
    }, x.min = function(z, gr) {
      return z.cmp(gr) < 0 ? z : gr;
    }, x.prototype._init = function(z, gr, vr) {
      if (typeof z == "number")
        return this._initNumber(z, gr, vr);
      if (typeof z == "object")
        return this._initArray(z, gr, vr);
      gr === "hex" && (gr = 16), w(gr === (gr | 0) && gr >= 2 && gr <= 36), z = z.toString().replace(/\s+/g, "");
      var Oi = 0;
      z[0] === "-" && (Oi++, this.negative = 1), Oi < z.length && (gr === 16 ? this._parseHex(z, Oi, vr) : (this._parseBase(z, gr, Oi), vr === "le" && this._initArray(this.toArray(), gr, vr)));
    }, x.prototype._initNumber = function(z, gr, vr) {
      z < 0 && (this.negative = 1, z = -z), z < 67108864 ? (this.words = [z & 67108863], this.length = 1) : z < 4503599627370496 ? (this.words = [
        z & 67108863,
        z / 67108864 & 67108863
      ], this.length = 2) : (w(z < 9007199254740992), this.words = [
        z & 67108863,
        z / 67108864 & 67108863,
        1
      ], this.length = 3), vr === "le" && this._initArray(this.toArray(), gr, vr);
    }, x.prototype._initArray = function(z, gr, vr) {
      if (w(typeof z.length == "number"), z.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(z.length / 3), this.words = new Array(this.length);
      for (var Oi = 0; Oi < this.length; Oi++)
        this.words[Oi] = 0;
      var Mi, ki, yr = 0;
      if (vr === "be")
        for (Oi = z.length - 1, Mi = 0; Oi >= 0; Oi -= 3)
          ki = z[Oi] | z[Oi - 1] << 8 | z[Oi - 2] << 16, this.words[Mi] |= ki << yr & 67108863, this.words[Mi + 1] = ki >>> 26 - yr & 67108863, yr += 24, yr >= 26 && (yr -= 26, Mi++);
      else if (vr === "le")
        for (Oi = 0, Mi = 0; Oi < z.length; Oi += 3)
          ki = z[Oi] | z[Oi + 1] << 8 | z[Oi + 2] << 16, this.words[Mi] |= ki << yr & 67108863, this.words[Mi + 1] = ki >>> 26 - yr & 67108863, yr += 24, yr >= 26 && (yr -= 26, Mi++);
      return this._strip();
    };
    function D(z, gr) {
      var vr = z.charCodeAt(gr);
      if (vr >= 48 && vr <= 57)
        return vr - 48;
      if (vr >= 65 && vr <= 70)
        return vr - 55;
      if (vr >= 97 && vr <= 102)
        return vr - 87;
      w(!1, "Invalid character in " + z);
    }
    function Y(z, gr, vr) {
      var Oi = D(z, vr);
      return vr - 1 >= gr && (Oi |= D(z, vr - 1) << 4), Oi;
    }
    x.prototype._parseHex = function(z, gr, vr) {
      this.length = Math.ceil((z.length - gr) / 6), this.words = new Array(this.length);
      for (var Oi = 0; Oi < this.length; Oi++)
        this.words[Oi] = 0;
      var Mi = 0, ki = 0, yr;
      if (vr === "be")
        for (Oi = z.length - 1; Oi >= gr; Oi -= 2)
          yr = Y(z, gr, Oi) << Mi, this.words[ki] |= yr & 67108863, Mi >= 18 ? (Mi -= 18, ki += 1, this.words[ki] |= yr >>> 26) : Mi += 8;
      else {
        var xi = z.length - gr;
        for (Oi = xi % 2 === 0 ? gr + 1 : gr; Oi < z.length; Oi += 2)
          yr = Y(z, gr, Oi) << Mi, this.words[ki] |= yr & 67108863, Mi >= 18 ? (Mi -= 18, ki += 1, this.words[ki] |= yr >>> 26) : Mi += 8;
      }
      this._strip();
    };
    function L(z, gr, vr, Oi) {
      for (var Mi = 0, ki = 0, yr = Math.min(z.length, vr), xi = gr; xi < yr; xi++) {
        var Si = z.charCodeAt(xi) - 48;
        Mi *= Oi, Si >= 49 ? ki = Si - 49 + 10 : Si >= 17 ? ki = Si - 17 + 10 : ki = Si, w(Si >= 0 && ki < Oi, "Invalid character"), Mi += ki;
      }
      return Mi;
    }
    x.prototype._parseBase = function(z, gr, vr) {
      this.words = [0], this.length = 1;
      for (var Oi = 0, Mi = 1; Mi <= 67108863; Mi *= gr)
        Oi++;
      Oi--, Mi = Mi / gr | 0;
      for (var ki = z.length - vr, yr = ki % Oi, xi = Math.min(ki, ki - yr) + vr, Si = 0, Ci = vr; Ci < xi; Ci += Oi)
        Si = L(z, Ci, Ci + Oi, gr), this.imuln(Mi), this.words[0] + Si < 67108864 ? this.words[0] += Si : this._iaddn(Si);
      if (yr !== 0) {
        var Ki = 1;
        for (Si = L(z, Ci, z.length, gr), Ci = 0; Ci < yr; Ci++)
          Ki *= gr;
        this.imuln(Ki), this.words[0] + Si < 67108864 ? this.words[0] += Si : this._iaddn(Si);
      }
      this._strip();
    }, x.prototype.copy = function(z) {
      z.words = new Array(this.length);
      for (var gr = 0; gr < this.length; gr++)
        z.words[gr] = this.words[gr];
      z.length = this.length, z.negative = this.negative, z.red = this.red;
    };
    function q(z, gr) {
      z.words = gr.words, z.length = gr.length, z.negative = gr.negative, z.red = gr.red;
    }
    if (x.prototype._move = function(z) {
      q(z, this);
    }, x.prototype.clone = function() {
      var z = new x(null);
      return this.copy(z), z;
    }, x.prototype._expand = function(z) {
      for (; this.length < z; )
        this.words[this.length++] = 0;
      return this;
    }, x.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, x.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        x.prototype[Symbol.for("nodejs.util.inspect.custom")] = N;
      } catch {
        x.prototype.inspect = N;
      }
    else
      x.prototype.inspect = N;
    function N() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], ae = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], he = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    x.prototype.toString = function(z, gr) {
      z = z || 10, gr = gr | 0 || 1;
      var vr;
      if (z === 16 || z === "hex") {
        vr = "";
        for (var Oi = 0, Mi = 0, ki = 0; ki < this.length; ki++) {
          var yr = this.words[ki], xi = ((yr << Oi | Mi) & 16777215).toString(16);
          Mi = yr >>> 24 - Oi & 16777215, Oi += 2, Oi >= 26 && (Oi -= 26, ki--), Mi !== 0 || ki !== this.length - 1 ? vr = F[6 - xi.length] + xi + vr : vr = xi + vr;
        }
        for (Mi !== 0 && (vr = Mi.toString(16) + vr); vr.length % gr !== 0; )
          vr = "0" + vr;
        return this.negative !== 0 && (vr = "-" + vr), vr;
      }
      if (z === (z | 0) && z >= 2 && z <= 36) {
        var Si = ae[z], Ci = he[z];
        vr = "";
        var Ki = this.clone();
        for (Ki.negative = 0; !Ki.isZero(); ) {
          var Yi = Ki.modrn(Ci).toString(z);
          Ki = Ki.idivn(Ci), Ki.isZero() ? vr = Yi + vr : vr = F[Si - Yi.length] + Yi + vr;
        }
        for (this.isZero() && (vr = "0" + vr); vr.length % gr !== 0; )
          vr = "0" + vr;
        return this.negative !== 0 && (vr = "-" + vr), vr;
      }
      w(!1, "Base should be between 2 and 36");
    }, x.prototype.toNumber = function() {
      var z = this.words[0];
      return this.length === 2 ? z += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? z += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && w(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -z : z;
    }, x.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, C && (x.prototype.toBuffer = function(z, gr) {
      return this.toArrayLike(C, z, gr);
    }), x.prototype.toArray = function(z, gr) {
      return this.toArrayLike(Array, z, gr);
    };
    var tt = function(z, gr) {
      return z.allocUnsafe ? z.allocUnsafe(gr) : new z(gr);
    };
    x.prototype.toArrayLike = function(z, gr, vr) {
      this._strip();
      var Oi = this.byteLength(), Mi = vr || Math.max(1, Oi);
      w(Oi <= Mi, "byte array longer than desired length"), w(Mi > 0, "Requested array length <= 0");
      var ki = tt(z, Mi), yr = gr === "le" ? "LE" : "BE";
      return this["_toArrayLike" + yr](ki, Oi), ki;
    }, x.prototype._toArrayLikeLE = function(z, gr) {
      for (var vr = 0, Oi = 0, Mi = 0, ki = 0; Mi < this.length; Mi++) {
        var yr = this.words[Mi] << ki | Oi;
        z[vr++] = yr & 255, vr < z.length && (z[vr++] = yr >> 8 & 255), vr < z.length && (z[vr++] = yr >> 16 & 255), ki === 6 ? (vr < z.length && (z[vr++] = yr >> 24 & 255), Oi = 0, ki = 0) : (Oi = yr >>> 24, ki += 2);
      }
      if (vr < z.length)
        for (z[vr++] = Oi; vr < z.length; )
          z[vr++] = 0;
    }, x.prototype._toArrayLikeBE = function(z, gr) {
      for (var vr = z.length - 1, Oi = 0, Mi = 0, ki = 0; Mi < this.length; Mi++) {
        var yr = this.words[Mi] << ki | Oi;
        z[vr--] = yr & 255, vr >= 0 && (z[vr--] = yr >> 8 & 255), vr >= 0 && (z[vr--] = yr >> 16 & 255), ki === 6 ? (vr >= 0 && (z[vr--] = yr >> 24 & 255), Oi = 0, ki = 0) : (Oi = yr >>> 24, ki += 2);
      }
      if (vr >= 0)
        for (z[vr--] = Oi; vr >= 0; )
          z[vr--] = 0;
    }, Math.clz32 ? x.prototype._countBits = function(z) {
      return 32 - Math.clz32(z);
    } : x.prototype._countBits = function(z) {
      var gr = z, vr = 0;
      return gr >= 4096 && (vr += 13, gr >>>= 13), gr >= 64 && (vr += 7, gr >>>= 7), gr >= 8 && (vr += 4, gr >>>= 4), gr >= 2 && (vr += 2, gr >>>= 2), vr + gr;
    }, x.prototype._zeroBits = function(z) {
      if (z === 0) return 26;
      var gr = z, vr = 0;
      return gr & 8191 || (vr += 13, gr >>>= 13), gr & 127 || (vr += 7, gr >>>= 7), gr & 15 || (vr += 4, gr >>>= 4), gr & 3 || (vr += 2, gr >>>= 2), gr & 1 || vr++, vr;
    }, x.prototype.bitLength = function() {
      var z = this.words[this.length - 1], gr = this._countBits(z);
      return (this.length - 1) * 26 + gr;
    };
    function br(z) {
      for (var gr = new Array(z.bitLength()), vr = 0; vr < gr.length; vr++) {
        var Oi = vr / 26 | 0, Mi = vr % 26;
        gr[vr] = z.words[Oi] >>> Mi & 1;
      }
      return gr;
    }
    x.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var z = 0, gr = 0; gr < this.length; gr++) {
        var vr = this._zeroBits(this.words[gr]);
        if (z += vr, vr !== 26) break;
      }
      return z;
    }, x.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, x.prototype.toTwos = function(z) {
      return this.negative !== 0 ? this.abs().inotn(z).iaddn(1) : this.clone();
    }, x.prototype.fromTwos = function(z) {
      return this.testn(z - 1) ? this.notn(z).iaddn(1).ineg() : this.clone();
    }, x.prototype.isNeg = function() {
      return this.negative !== 0;
    }, x.prototype.neg = function() {
      return this.clone().ineg();
    }, x.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, x.prototype.iuor = function(z) {
      for (; this.length < z.length; )
        this.words[this.length++] = 0;
      for (var gr = 0; gr < z.length; gr++)
        this.words[gr] = this.words[gr] | z.words[gr];
      return this._strip();
    }, x.prototype.ior = function(z) {
      return w((this.negative | z.negative) === 0), this.iuor(z);
    }, x.prototype.or = function(z) {
      return this.length > z.length ? this.clone().ior(z) : z.clone().ior(this);
    }, x.prototype.uor = function(z) {
      return this.length > z.length ? this.clone().iuor(z) : z.clone().iuor(this);
    }, x.prototype.iuand = function(z) {
      var gr;
      this.length > z.length ? gr = z : gr = this;
      for (var vr = 0; vr < gr.length; vr++)
        this.words[vr] = this.words[vr] & z.words[vr];
      return this.length = gr.length, this._strip();
    }, x.prototype.iand = function(z) {
      return w((this.negative | z.negative) === 0), this.iuand(z);
    }, x.prototype.and = function(z) {
      return this.length > z.length ? this.clone().iand(z) : z.clone().iand(this);
    }, x.prototype.uand = function(z) {
      return this.length > z.length ? this.clone().iuand(z) : z.clone().iuand(this);
    }, x.prototype.iuxor = function(z) {
      var gr, vr;
      this.length > z.length ? (gr = this, vr = z) : (gr = z, vr = this);
      for (var Oi = 0; Oi < vr.length; Oi++)
        this.words[Oi] = gr.words[Oi] ^ vr.words[Oi];
      if (this !== gr)
        for (; Oi < gr.length; Oi++)
          this.words[Oi] = gr.words[Oi];
      return this.length = gr.length, this._strip();
    }, x.prototype.ixor = function(z) {
      return w((this.negative | z.negative) === 0), this.iuxor(z);
    }, x.prototype.xor = function(z) {
      return this.length > z.length ? this.clone().ixor(z) : z.clone().ixor(this);
    }, x.prototype.uxor = function(z) {
      return this.length > z.length ? this.clone().iuxor(z) : z.clone().iuxor(this);
    }, x.prototype.inotn = function(z) {
      w(typeof z == "number" && z >= 0);
      var gr = Math.ceil(z / 26) | 0, vr = z % 26;
      this._expand(gr), vr > 0 && gr--;
      for (var Oi = 0; Oi < gr; Oi++)
        this.words[Oi] = ~this.words[Oi] & 67108863;
      return vr > 0 && (this.words[Oi] = ~this.words[Oi] & 67108863 >> 26 - vr), this._strip();
    }, x.prototype.notn = function(z) {
      return this.clone().inotn(z);
    }, x.prototype.setn = function(z, gr) {
      w(typeof z == "number" && z >= 0);
      var vr = z / 26 | 0, Oi = z % 26;
      return this._expand(vr + 1), gr ? this.words[vr] = this.words[vr] | 1 << Oi : this.words[vr] = this.words[vr] & ~(1 << Oi), this._strip();
    }, x.prototype.iadd = function(z) {
      var gr;
      if (this.negative !== 0 && z.negative === 0)
        return this.negative = 0, gr = this.isub(z), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && z.negative !== 0)
        return z.negative = 0, gr = this.isub(z), z.negative = 1, gr._normSign();
      var vr, Oi;
      this.length > z.length ? (vr = this, Oi = z) : (vr = z, Oi = this);
      for (var Mi = 0, ki = 0; ki < Oi.length; ki++)
        gr = (vr.words[ki] | 0) + (Oi.words[ki] | 0) + Mi, this.words[ki] = gr & 67108863, Mi = gr >>> 26;
      for (; Mi !== 0 && ki < vr.length; ki++)
        gr = (vr.words[ki] | 0) + Mi, this.words[ki] = gr & 67108863, Mi = gr >>> 26;
      if (this.length = vr.length, Mi !== 0)
        this.words[this.length] = Mi, this.length++;
      else if (vr !== this)
        for (; ki < vr.length; ki++)
          this.words[ki] = vr.words[ki];
      return this;
    }, x.prototype.add = function(z) {
      var gr;
      return z.negative !== 0 && this.negative === 0 ? (z.negative = 0, gr = this.sub(z), z.negative ^= 1, gr) : z.negative === 0 && this.negative !== 0 ? (this.negative = 0, gr = z.sub(this), this.negative = 1, gr) : this.length > z.length ? this.clone().iadd(z) : z.clone().iadd(this);
    }, x.prototype.isub = function(z) {
      if (z.negative !== 0) {
        z.negative = 0;
        var gr = this.iadd(z);
        return z.negative = 1, gr._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(z), this.negative = 1, this._normSign();
      var vr = this.cmp(z);
      if (vr === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var Oi, Mi;
      vr > 0 ? (Oi = this, Mi = z) : (Oi = z, Mi = this);
      for (var ki = 0, yr = 0; yr < Mi.length; yr++)
        gr = (Oi.words[yr] | 0) - (Mi.words[yr] | 0) + ki, ki = gr >> 26, this.words[yr] = gr & 67108863;
      for (; ki !== 0 && yr < Oi.length; yr++)
        gr = (Oi.words[yr] | 0) + ki, ki = gr >> 26, this.words[yr] = gr & 67108863;
      if (ki === 0 && yr < Oi.length && Oi !== this)
        for (; yr < Oi.length; yr++)
          this.words[yr] = Oi.words[yr];
      return this.length = Math.max(this.length, yr), Oi !== this && (this.negative = 1), this._strip();
    }, x.prototype.sub = function(z) {
      return this.clone().isub(z);
    };
    function rt(z, gr, vr) {
      vr.negative = gr.negative ^ z.negative;
      var Oi = z.length + gr.length | 0;
      vr.length = Oi, Oi = Oi - 1 | 0;
      var Mi = z.words[0] | 0, ki = gr.words[0] | 0, yr = Mi * ki, xi = yr & 67108863, Si = yr / 67108864 | 0;
      vr.words[0] = xi;
      for (var Ci = 1; Ci < Oi; Ci++) {
        for (var Ki = Si >>> 26, Yi = Si & 67108863, Qi = Math.min(Ci, gr.length - 1), Zi = Math.max(0, Ci - z.length + 1); Zi <= Qi; Zi++) {
          var Ni = Ci - Zi | 0;
          Mi = z.words[Ni] | 0, ki = gr.words[Zi] | 0, yr = Mi * ki + Yi, Ki += yr / 67108864 | 0, Yi = yr & 67108863;
        }
        vr.words[Ci] = Yi | 0, Si = Ki | 0;
      }
      return Si !== 0 ? vr.words[Ci] = Si | 0 : vr.length--, vr._strip();
    }
    var dr = function(z, gr, vr) {
      var Oi = z.words, Mi = gr.words, ki = vr.words, yr = 0, xi, Si, Ci, Ki = Oi[0] | 0, Yi = Ki & 8191, Qi = Ki >>> 13, Zi = Oi[1] | 0, Ni = Zi & 8191, Fi = Zi >>> 13, Xi = Oi[2] | 0, to = Xi & 8191, zi = Xi >>> 13, Gi = Oi[3] | 0, no = Gi & 8191, so = Gi >>> 13, ho = Oi[4] | 0, uo = ho & 8191, ao = ho >>> 13, Bo = Oi[5] | 0, io = Bo & 8191, po = Bo >>> 13, Do = Oi[6] | 0, Io = Do & 8191, mo = Do >>> 13, Ro = Oi[7] | 0, _o = Ro & 8191, yo = Ro >>> 13, To = Oi[8] | 0, xo = To & 8191, wo = To >>> 13, Ai = Oi[9] | 0, Pi = Ai & 8191, Ui = Ai >>> 13, Ji = Mi[0] | 0, eo = Ji & 8191, ro = Ji >>> 13, oo = Mi[1] | 0, bo = oo & 8191, lo = oo >>> 13, vo = Mi[2] | 0, go = vo & 8191, co = vo >>> 13, Lo = Mi[3] | 0, jo = Lo & 8191, $o = Lo >>> 13, qo = Mi[4] | 0, Uo = qo & 8191, So = qo >>> 13, Fo = Mi[5] | 0, Wo = Fo & 8191, Eo = Fo >>> 13, Ho = Mi[6] | 0, zo = Ho & 8191, Mo = Ho >>> 13, Go = Mi[7] | 0, Vo = Go & 8191, ko = Go >>> 13, Ko = Mi[8] | 0, Zo = Ko & 8191, Ao = Ko >>> 13, Yo = Mi[9] | 0, Po = Yo & 8191, No = Yo >>> 13;
      vr.negative = z.negative ^ gr.negative, vr.length = 19, xi = Math.imul(Yi, eo), Si = Math.imul(Yi, ro), Si = Si + Math.imul(Qi, eo) | 0, Ci = Math.imul(Qi, ro);
      var ha = (yr + xi | 0) + ((Si & 8191) << 13) | 0;
      yr = (Ci + (Si >>> 13) | 0) + (ha >>> 26) | 0, ha &= 67108863, xi = Math.imul(Ni, eo), Si = Math.imul(Ni, ro), Si = Si + Math.imul(Fi, eo) | 0, Ci = Math.imul(Fi, ro), xi = xi + Math.imul(Yi, bo) | 0, Si = Si + Math.imul(Yi, lo) | 0, Si = Si + Math.imul(Qi, bo) | 0, Ci = Ci + Math.imul(Qi, lo) | 0;
      var da = (yr + xi | 0) + ((Si & 8191) << 13) | 0;
      yr = (Ci + (Si >>> 13) | 0) + (da >>> 26) | 0, da &= 67108863, xi = Math.imul(to, eo), Si = Math.imul(to, ro), Si = Si + Math.imul(zi, eo) | 0, Ci = Math.imul(zi, ro), xi = xi + Math.imul(Ni, bo) | 0, Si = Si + Math.imul(Ni, lo) | 0, Si = Si + Math.imul(Fi, bo) | 0, Ci = Ci + Math.imul(Fi, lo) | 0, xi = xi + Math.imul(Yi, go) | 0, Si = Si + Math.imul(Yi, co) | 0, Si = Si + Math.imul(Qi, go) | 0, Ci = Ci + Math.imul(Qi, co) | 0;
      var pa = (yr + xi | 0) + ((Si & 8191) << 13) | 0;
      yr = (Ci + (Si >>> 13) | 0) + (pa >>> 26) | 0, pa &= 67108863, xi = Math.imul(no, eo), Si = Math.imul(no, ro), Si = Si + Math.imul(so, eo) | 0, Ci = Math.imul(so, ro), xi = xi + Math.imul(to, bo) | 0, Si = Si + Math.imul(to, lo) | 0, Si = Si + Math.imul(zi, bo) | 0, Ci = Ci + Math.imul(zi, lo) | 0, xi = xi + Math.imul(Ni, go) | 0, Si = Si + Math.imul(Ni, co) | 0, Si = Si + Math.imul(Fi, go) | 0, Ci = Ci + Math.imul(Fi, co) | 0, xi = xi + Math.imul(Yi, jo) | 0, Si = Si + Math.imul(Yi, $o) | 0, Si = Si + Math.imul(Qi, jo) | 0, Ci = Ci + Math.imul(Qi, $o) | 0;
      var ma = (yr + xi | 0) + ((Si & 8191) << 13) | 0;
      yr = (Ci + (Si >>> 13) | 0) + (ma >>> 26) | 0, ma &= 67108863, xi = Math.imul(uo, eo), Si = Math.imul(uo, ro), Si = Si + Math.imul(ao, eo) | 0, Ci = Math.imul(ao, ro), xi = xi + Math.imul(no, bo) | 0, Si = Si + Math.imul(no, lo) | 0, Si = Si + Math.imul(so, bo) | 0, Ci = Ci + Math.imul(so, lo) | 0, xi = xi + Math.imul(to, go) | 0, Si = Si + Math.imul(to, co) | 0, Si = Si + Math.imul(zi, go) | 0, Ci = Ci + Math.imul(zi, co) | 0, xi = xi + Math.imul(Ni, jo) | 0, Si = Si + Math.imul(Ni, $o) | 0, Si = Si + Math.imul(Fi, jo) | 0, Ci = Ci + Math.imul(Fi, $o) | 0, xi = xi + Math.imul(Yi, Uo) | 0, Si = Si + Math.imul(Yi, So) | 0, Si = Si + Math.imul(Qi, Uo) | 0, Ci = Ci + Math.imul(Qi, So) | 0;
      var ya = (yr + xi | 0) + ((Si & 8191) << 13) | 0;
      yr = (Ci + (Si >>> 13) | 0) + (ya >>> 26) | 0, ya &= 67108863, xi = Math.imul(io, eo), Si = Math.imul(io, ro), Si = Si + Math.imul(po, eo) | 0, Ci = Math.imul(po, ro), xi = xi + Math.imul(uo, bo) | 0, Si = Si + Math.imul(uo, lo) | 0, Si = Si + Math.imul(ao, bo) | 0, Ci = Ci + Math.imul(ao, lo) | 0, xi = xi + Math.imul(no, go) | 0, Si = Si + Math.imul(no, co) | 0, Si = Si + Math.imul(so, go) | 0, Ci = Ci + Math.imul(so, co) | 0, xi = xi + Math.imul(to, jo) | 0, Si = Si + Math.imul(to, $o) | 0, Si = Si + Math.imul(zi, jo) | 0, Ci = Ci + Math.imul(zi, $o) | 0, xi = xi + Math.imul(Ni, Uo) | 0, Si = Si + Math.imul(Ni, So) | 0, Si = Si + Math.imul(Fi, Uo) | 0, Ci = Ci + Math.imul(Fi, So) | 0, xi = xi + Math.imul(Yi, Wo) | 0, Si = Si + Math.imul(Yi, Eo) | 0, Si = Si + Math.imul(Qi, Wo) | 0, Ci = Ci + Math.imul(Qi, Eo) | 0;
      var ga = (yr + xi | 0) + ((Si & 8191) << 13) | 0;
      yr = (Ci + (Si >>> 13) | 0) + (ga >>> 26) | 0, ga &= 67108863, xi = Math.imul(Io, eo), Si = Math.imul(Io, ro), Si = Si + Math.imul(mo, eo) | 0, Ci = Math.imul(mo, ro), xi = xi + Math.imul(io, bo) | 0, Si = Si + Math.imul(io, lo) | 0, Si = Si + Math.imul(po, bo) | 0, Ci = Ci + Math.imul(po, lo) | 0, xi = xi + Math.imul(uo, go) | 0, Si = Si + Math.imul(uo, co) | 0, Si = Si + Math.imul(ao, go) | 0, Ci = Ci + Math.imul(ao, co) | 0, xi = xi + Math.imul(no, jo) | 0, Si = Si + Math.imul(no, $o) | 0, Si = Si + Math.imul(so, jo) | 0, Ci = Ci + Math.imul(so, $o) | 0, xi = xi + Math.imul(to, Uo) | 0, Si = Si + Math.imul(to, So) | 0, Si = Si + Math.imul(zi, Uo) | 0, Ci = Ci + Math.imul(zi, So) | 0, xi = xi + Math.imul(Ni, Wo) | 0, Si = Si + Math.imul(Ni, Eo) | 0, Si = Si + Math.imul(Fi, Wo) | 0, Ci = Ci + Math.imul(Fi, Eo) | 0, xi = xi + Math.imul(Yi, zo) | 0, Si = Si + Math.imul(Yi, Mo) | 0, Si = Si + Math.imul(Qi, zo) | 0, Ci = Ci + Math.imul(Qi, Mo) | 0;
      var ba = (yr + xi | 0) + ((Si & 8191) << 13) | 0;
      yr = (Ci + (Si >>> 13) | 0) + (ba >>> 26) | 0, ba &= 67108863, xi = Math.imul(_o, eo), Si = Math.imul(_o, ro), Si = Si + Math.imul(yo, eo) | 0, Ci = Math.imul(yo, ro), xi = xi + Math.imul(Io, bo) | 0, Si = Si + Math.imul(Io, lo) | 0, Si = Si + Math.imul(mo, bo) | 0, Ci = Ci + Math.imul(mo, lo) | 0, xi = xi + Math.imul(io, go) | 0, Si = Si + Math.imul(io, co) | 0, Si = Si + Math.imul(po, go) | 0, Ci = Ci + Math.imul(po, co) | 0, xi = xi + Math.imul(uo, jo) | 0, Si = Si + Math.imul(uo, $o) | 0, Si = Si + Math.imul(ao, jo) | 0, Ci = Ci + Math.imul(ao, $o) | 0, xi = xi + Math.imul(no, Uo) | 0, Si = Si + Math.imul(no, So) | 0, Si = Si + Math.imul(so, Uo) | 0, Ci = Ci + Math.imul(so, So) | 0, xi = xi + Math.imul(to, Wo) | 0, Si = Si + Math.imul(to, Eo) | 0, Si = Si + Math.imul(zi, Wo) | 0, Ci = Ci + Math.imul(zi, Eo) | 0, xi = xi + Math.imul(Ni, zo) | 0, Si = Si + Math.imul(Ni, Mo) | 0, Si = Si + Math.imul(Fi, zo) | 0, Ci = Ci + Math.imul(Fi, Mo) | 0, xi = xi + Math.imul(Yi, Vo) | 0, Si = Si + Math.imul(Yi, ko) | 0, Si = Si + Math.imul(Qi, Vo) | 0, Ci = Ci + Math.imul(Qi, ko) | 0;
      var va = (yr + xi | 0) + ((Si & 8191) << 13) | 0;
      yr = (Ci + (Si >>> 13) | 0) + (va >>> 26) | 0, va &= 67108863, xi = Math.imul(xo, eo), Si = Math.imul(xo, ro), Si = Si + Math.imul(wo, eo) | 0, Ci = Math.imul(wo, ro), xi = xi + Math.imul(_o, bo) | 0, Si = Si + Math.imul(_o, lo) | 0, Si = Si + Math.imul(yo, bo) | 0, Ci = Ci + Math.imul(yo, lo) | 0, xi = xi + Math.imul(Io, go) | 0, Si = Si + Math.imul(Io, co) | 0, Si = Si + Math.imul(mo, go) | 0, Ci = Ci + Math.imul(mo, co) | 0, xi = xi + Math.imul(io, jo) | 0, Si = Si + Math.imul(io, $o) | 0, Si = Si + Math.imul(po, jo) | 0, Ci = Ci + Math.imul(po, $o) | 0, xi = xi + Math.imul(uo, Uo) | 0, Si = Si + Math.imul(uo, So) | 0, Si = Si + Math.imul(ao, Uo) | 0, Ci = Ci + Math.imul(ao, So) | 0, xi = xi + Math.imul(no, Wo) | 0, Si = Si + Math.imul(no, Eo) | 0, Si = Si + Math.imul(so, Wo) | 0, Ci = Ci + Math.imul(so, Eo) | 0, xi = xi + Math.imul(to, zo) | 0, Si = Si + Math.imul(to, Mo) | 0, Si = Si + Math.imul(zi, zo) | 0, Ci = Ci + Math.imul(zi, Mo) | 0, xi = xi + Math.imul(Ni, Vo) | 0, Si = Si + Math.imul(Ni, ko) | 0, Si = Si + Math.imul(Fi, Vo) | 0, Ci = Ci + Math.imul(Fi, ko) | 0, xi = xi + Math.imul(Yi, Zo) | 0, Si = Si + Math.imul(Yi, Ao) | 0, Si = Si + Math.imul(Qi, Zo) | 0, Ci = Ci + Math.imul(Qi, Ao) | 0;
      var _a = (yr + xi | 0) + ((Si & 8191) << 13) | 0;
      yr = (Ci + (Si >>> 13) | 0) + (_a >>> 26) | 0, _a &= 67108863, xi = Math.imul(Pi, eo), Si = Math.imul(Pi, ro), Si = Si + Math.imul(Ui, eo) | 0, Ci = Math.imul(Ui, ro), xi = xi + Math.imul(xo, bo) | 0, Si = Si + Math.imul(xo, lo) | 0, Si = Si + Math.imul(wo, bo) | 0, Ci = Ci + Math.imul(wo, lo) | 0, xi = xi + Math.imul(_o, go) | 0, Si = Si + Math.imul(_o, co) | 0, Si = Si + Math.imul(yo, go) | 0, Ci = Ci + Math.imul(yo, co) | 0, xi = xi + Math.imul(Io, jo) | 0, Si = Si + Math.imul(Io, $o) | 0, Si = Si + Math.imul(mo, jo) | 0, Ci = Ci + Math.imul(mo, $o) | 0, xi = xi + Math.imul(io, Uo) | 0, Si = Si + Math.imul(io, So) | 0, Si = Si + Math.imul(po, Uo) | 0, Ci = Ci + Math.imul(po, So) | 0, xi = xi + Math.imul(uo, Wo) | 0, Si = Si + Math.imul(uo, Eo) | 0, Si = Si + Math.imul(ao, Wo) | 0, Ci = Ci + Math.imul(ao, Eo) | 0, xi = xi + Math.imul(no, zo) | 0, Si = Si + Math.imul(no, Mo) | 0, Si = Si + Math.imul(so, zo) | 0, Ci = Ci + Math.imul(so, Mo) | 0, xi = xi + Math.imul(to, Vo) | 0, Si = Si + Math.imul(to, ko) | 0, Si = Si + Math.imul(zi, Vo) | 0, Ci = Ci + Math.imul(zi, ko) | 0, xi = xi + Math.imul(Ni, Zo) | 0, Si = Si + Math.imul(Ni, Ao) | 0, Si = Si + Math.imul(Fi, Zo) | 0, Ci = Ci + Math.imul(Fi, Ao) | 0, xi = xi + Math.imul(Yi, Po) | 0, Si = Si + Math.imul(Yi, No) | 0, Si = Si + Math.imul(Qi, Po) | 0, Ci = Ci + Math.imul(Qi, No) | 0;
      var wa = (yr + xi | 0) + ((Si & 8191) << 13) | 0;
      yr = (Ci + (Si >>> 13) | 0) + (wa >>> 26) | 0, wa &= 67108863, xi = Math.imul(Pi, bo), Si = Math.imul(Pi, lo), Si = Si + Math.imul(Ui, bo) | 0, Ci = Math.imul(Ui, lo), xi = xi + Math.imul(xo, go) | 0, Si = Si + Math.imul(xo, co) | 0, Si = Si + Math.imul(wo, go) | 0, Ci = Ci + Math.imul(wo, co) | 0, xi = xi + Math.imul(_o, jo) | 0, Si = Si + Math.imul(_o, $o) | 0, Si = Si + Math.imul(yo, jo) | 0, Ci = Ci + Math.imul(yo, $o) | 0, xi = xi + Math.imul(Io, Uo) | 0, Si = Si + Math.imul(Io, So) | 0, Si = Si + Math.imul(mo, Uo) | 0, Ci = Ci + Math.imul(mo, So) | 0, xi = xi + Math.imul(io, Wo) | 0, Si = Si + Math.imul(io, Eo) | 0, Si = Si + Math.imul(po, Wo) | 0, Ci = Ci + Math.imul(po, Eo) | 0, xi = xi + Math.imul(uo, zo) | 0, Si = Si + Math.imul(uo, Mo) | 0, Si = Si + Math.imul(ao, zo) | 0, Ci = Ci + Math.imul(ao, Mo) | 0, xi = xi + Math.imul(no, Vo) | 0, Si = Si + Math.imul(no, ko) | 0, Si = Si + Math.imul(so, Vo) | 0, Ci = Ci + Math.imul(so, ko) | 0, xi = xi + Math.imul(to, Zo) | 0, Si = Si + Math.imul(to, Ao) | 0, Si = Si + Math.imul(zi, Zo) | 0, Ci = Ci + Math.imul(zi, Ao) | 0, xi = xi + Math.imul(Ni, Po) | 0, Si = Si + Math.imul(Ni, No) | 0, Si = Si + Math.imul(Fi, Po) | 0, Ci = Ci + Math.imul(Fi, No) | 0;
      var $a = (yr + xi | 0) + ((Si & 8191) << 13) | 0;
      yr = (Ci + (Si >>> 13) | 0) + ($a >>> 26) | 0, $a &= 67108863, xi = Math.imul(Pi, go), Si = Math.imul(Pi, co), Si = Si + Math.imul(Ui, go) | 0, Ci = Math.imul(Ui, co), xi = xi + Math.imul(xo, jo) | 0, Si = Si + Math.imul(xo, $o) | 0, Si = Si + Math.imul(wo, jo) | 0, Ci = Ci + Math.imul(wo, $o) | 0, xi = xi + Math.imul(_o, Uo) | 0, Si = Si + Math.imul(_o, So) | 0, Si = Si + Math.imul(yo, Uo) | 0, Ci = Ci + Math.imul(yo, So) | 0, xi = xi + Math.imul(Io, Wo) | 0, Si = Si + Math.imul(Io, Eo) | 0, Si = Si + Math.imul(mo, Wo) | 0, Ci = Ci + Math.imul(mo, Eo) | 0, xi = xi + Math.imul(io, zo) | 0, Si = Si + Math.imul(io, Mo) | 0, Si = Si + Math.imul(po, zo) | 0, Ci = Ci + Math.imul(po, Mo) | 0, xi = xi + Math.imul(uo, Vo) | 0, Si = Si + Math.imul(uo, ko) | 0, Si = Si + Math.imul(ao, Vo) | 0, Ci = Ci + Math.imul(ao, ko) | 0, xi = xi + Math.imul(no, Zo) | 0, Si = Si + Math.imul(no, Ao) | 0, Si = Si + Math.imul(so, Zo) | 0, Ci = Ci + Math.imul(so, Ao) | 0, xi = xi + Math.imul(to, Po) | 0, Si = Si + Math.imul(to, No) | 0, Si = Si + Math.imul(zi, Po) | 0, Ci = Ci + Math.imul(zi, No) | 0;
      var Sa = (yr + xi | 0) + ((Si & 8191) << 13) | 0;
      yr = (Ci + (Si >>> 13) | 0) + (Sa >>> 26) | 0, Sa &= 67108863, xi = Math.imul(Pi, jo), Si = Math.imul(Pi, $o), Si = Si + Math.imul(Ui, jo) | 0, Ci = Math.imul(Ui, $o), xi = xi + Math.imul(xo, Uo) | 0, Si = Si + Math.imul(xo, So) | 0, Si = Si + Math.imul(wo, Uo) | 0, Ci = Ci + Math.imul(wo, So) | 0, xi = xi + Math.imul(_o, Wo) | 0, Si = Si + Math.imul(_o, Eo) | 0, Si = Si + Math.imul(yo, Wo) | 0, Ci = Ci + Math.imul(yo, Eo) | 0, xi = xi + Math.imul(Io, zo) | 0, Si = Si + Math.imul(Io, Mo) | 0, Si = Si + Math.imul(mo, zo) | 0, Ci = Ci + Math.imul(mo, Mo) | 0, xi = xi + Math.imul(io, Vo) | 0, Si = Si + Math.imul(io, ko) | 0, Si = Si + Math.imul(po, Vo) | 0, Ci = Ci + Math.imul(po, ko) | 0, xi = xi + Math.imul(uo, Zo) | 0, Si = Si + Math.imul(uo, Ao) | 0, Si = Si + Math.imul(ao, Zo) | 0, Ci = Ci + Math.imul(ao, Ao) | 0, xi = xi + Math.imul(no, Po) | 0, Si = Si + Math.imul(no, No) | 0, Si = Si + Math.imul(so, Po) | 0, Ci = Ci + Math.imul(so, No) | 0;
      var Ea = (yr + xi | 0) + ((Si & 8191) << 13) | 0;
      yr = (Ci + (Si >>> 13) | 0) + (Ea >>> 26) | 0, Ea &= 67108863, xi = Math.imul(Pi, Uo), Si = Math.imul(Pi, So), Si = Si + Math.imul(Ui, Uo) | 0, Ci = Math.imul(Ui, So), xi = xi + Math.imul(xo, Wo) | 0, Si = Si + Math.imul(xo, Eo) | 0, Si = Si + Math.imul(wo, Wo) | 0, Ci = Ci + Math.imul(wo, Eo) | 0, xi = xi + Math.imul(_o, zo) | 0, Si = Si + Math.imul(_o, Mo) | 0, Si = Si + Math.imul(yo, zo) | 0, Ci = Ci + Math.imul(yo, Mo) | 0, xi = xi + Math.imul(Io, Vo) | 0, Si = Si + Math.imul(Io, ko) | 0, Si = Si + Math.imul(mo, Vo) | 0, Ci = Ci + Math.imul(mo, ko) | 0, xi = xi + Math.imul(io, Zo) | 0, Si = Si + Math.imul(io, Ao) | 0, Si = Si + Math.imul(po, Zo) | 0, Ci = Ci + Math.imul(po, Ao) | 0, xi = xi + Math.imul(uo, Po) | 0, Si = Si + Math.imul(uo, No) | 0, Si = Si + Math.imul(ao, Po) | 0, Ci = Ci + Math.imul(ao, No) | 0;
      var Ma = (yr + xi | 0) + ((Si & 8191) << 13) | 0;
      yr = (Ci + (Si >>> 13) | 0) + (Ma >>> 26) | 0, Ma &= 67108863, xi = Math.imul(Pi, Wo), Si = Math.imul(Pi, Eo), Si = Si + Math.imul(Ui, Wo) | 0, Ci = Math.imul(Ui, Eo), xi = xi + Math.imul(xo, zo) | 0, Si = Si + Math.imul(xo, Mo) | 0, Si = Si + Math.imul(wo, zo) | 0, Ci = Ci + Math.imul(wo, Mo) | 0, xi = xi + Math.imul(_o, Vo) | 0, Si = Si + Math.imul(_o, ko) | 0, Si = Si + Math.imul(yo, Vo) | 0, Ci = Ci + Math.imul(yo, ko) | 0, xi = xi + Math.imul(Io, Zo) | 0, Si = Si + Math.imul(Io, Ao) | 0, Si = Si + Math.imul(mo, Zo) | 0, Ci = Ci + Math.imul(mo, Ao) | 0, xi = xi + Math.imul(io, Po) | 0, Si = Si + Math.imul(io, No) | 0, Si = Si + Math.imul(po, Po) | 0, Ci = Ci + Math.imul(po, No) | 0;
      var ka = (yr + xi | 0) + ((Si & 8191) << 13) | 0;
      yr = (Ci + (Si >>> 13) | 0) + (ka >>> 26) | 0, ka &= 67108863, xi = Math.imul(Pi, zo), Si = Math.imul(Pi, Mo), Si = Si + Math.imul(Ui, zo) | 0, Ci = Math.imul(Ui, Mo), xi = xi + Math.imul(xo, Vo) | 0, Si = Si + Math.imul(xo, ko) | 0, Si = Si + Math.imul(wo, Vo) | 0, Ci = Ci + Math.imul(wo, ko) | 0, xi = xi + Math.imul(_o, Zo) | 0, Si = Si + Math.imul(_o, Ao) | 0, Si = Si + Math.imul(yo, Zo) | 0, Ci = Ci + Math.imul(yo, Ao) | 0, xi = xi + Math.imul(Io, Po) | 0, Si = Si + Math.imul(Io, No) | 0, Si = Si + Math.imul(mo, Po) | 0, Ci = Ci + Math.imul(mo, No) | 0;
      var Aa = (yr + xi | 0) + ((Si & 8191) << 13) | 0;
      yr = (Ci + (Si >>> 13) | 0) + (Aa >>> 26) | 0, Aa &= 67108863, xi = Math.imul(Pi, Vo), Si = Math.imul(Pi, ko), Si = Si + Math.imul(Ui, Vo) | 0, Ci = Math.imul(Ui, ko), xi = xi + Math.imul(xo, Zo) | 0, Si = Si + Math.imul(xo, Ao) | 0, Si = Si + Math.imul(wo, Zo) | 0, Ci = Ci + Math.imul(wo, Ao) | 0, xi = xi + Math.imul(_o, Po) | 0, Si = Si + Math.imul(_o, No) | 0, Si = Si + Math.imul(yo, Po) | 0, Ci = Ci + Math.imul(yo, No) | 0;
      var Ra = (yr + xi | 0) + ((Si & 8191) << 13) | 0;
      yr = (Ci + (Si >>> 13) | 0) + (Ra >>> 26) | 0, Ra &= 67108863, xi = Math.imul(Pi, Zo), Si = Math.imul(Pi, Ao), Si = Si + Math.imul(Ui, Zo) | 0, Ci = Math.imul(Ui, Ao), xi = xi + Math.imul(xo, Po) | 0, Si = Si + Math.imul(xo, No) | 0, Si = Si + Math.imul(wo, Po) | 0, Ci = Ci + Math.imul(wo, No) | 0;
      var Ua = (yr + xi | 0) + ((Si & 8191) << 13) | 0;
      yr = (Ci + (Si >>> 13) | 0) + (Ua >>> 26) | 0, Ua &= 67108863, xi = Math.imul(Pi, Po), Si = Math.imul(Pi, No), Si = Si + Math.imul(Ui, Po) | 0, Ci = Math.imul(Ui, No);
      var Fa = (yr + xi | 0) + ((Si & 8191) << 13) | 0;
      return yr = (Ci + (Si >>> 13) | 0) + (Fa >>> 26) | 0, Fa &= 67108863, ki[0] = ha, ki[1] = da, ki[2] = pa, ki[3] = ma, ki[4] = ya, ki[5] = ga, ki[6] = ba, ki[7] = va, ki[8] = _a, ki[9] = wa, ki[10] = $a, ki[11] = Sa, ki[12] = Ea, ki[13] = Ma, ki[14] = ka, ki[15] = Aa, ki[16] = Ra, ki[17] = Ua, ki[18] = Fa, yr !== 0 && (ki[19] = yr, vr.length++), vr;
    };
    Math.imul || (dr = rt);
    function _r(z, gr, vr) {
      vr.negative = gr.negative ^ z.negative, vr.length = z.length + gr.length;
      for (var Oi = 0, Mi = 0, ki = 0; ki < vr.length - 1; ki++) {
        var yr = Mi;
        Mi = 0;
        for (var xi = Oi & 67108863, Si = Math.min(ki, gr.length - 1), Ci = Math.max(0, ki - z.length + 1); Ci <= Si; Ci++) {
          var Ki = ki - Ci, Yi = z.words[Ki] | 0, Qi = gr.words[Ci] | 0, Zi = Yi * Qi, Ni = Zi & 67108863;
          yr = yr + (Zi / 67108864 | 0) | 0, Ni = Ni + xi | 0, xi = Ni & 67108863, yr = yr + (Ni >>> 26) | 0, Mi += yr >>> 26, yr &= 67108863;
        }
        vr.words[ki] = xi, Oi = yr, yr = Mi;
      }
      return Oi !== 0 ? vr.words[ki] = Oi : vr.length--, vr._strip();
    }
    function Bi(z, gr, vr) {
      return _r(z, gr, vr);
    }
    x.prototype.mulTo = function(z, gr) {
      var vr, Oi = this.length + z.length;
      return this.length === 10 && z.length === 10 ? vr = dr(this, z, gr) : Oi < 63 ? vr = rt(this, z, gr) : Oi < 1024 ? vr = _r(this, z, gr) : vr = Bi(this, z, gr), vr;
    }, x.prototype.mul = function(z) {
      var gr = new x(null);
      return gr.words = new Array(this.length + z.length), this.mulTo(z, gr);
    }, x.prototype.mulf = function(z) {
      var gr = new x(null);
      return gr.words = new Array(this.length + z.length), Bi(this, z, gr);
    }, x.prototype.imul = function(z) {
      return this.clone().mulTo(z, this);
    }, x.prototype.imuln = function(z) {
      var gr = z < 0;
      gr && (z = -z), w(typeof z == "number"), w(z < 67108864);
      for (var vr = 0, Oi = 0; Oi < this.length; Oi++) {
        var Mi = (this.words[Oi] | 0) * z, ki = (Mi & 67108863) + (vr & 67108863);
        vr >>= 26, vr += Mi / 67108864 | 0, vr += ki >>> 26, this.words[Oi] = ki & 67108863;
      }
      return vr !== 0 && (this.words[Oi] = vr, this.length++), gr ? this.ineg() : this;
    }, x.prototype.muln = function(z) {
      return this.clone().imuln(z);
    }, x.prototype.sqr = function() {
      return this.mul(this);
    }, x.prototype.isqr = function() {
      return this.imul(this.clone());
    }, x.prototype.pow = function(z) {
      var gr = br(z);
      if (gr.length === 0) return new x(1);
      for (var vr = this, Oi = 0; Oi < gr.length && gr[Oi] === 0; Oi++, vr = vr.sqr())
        ;
      if (++Oi < gr.length)
        for (var Mi = vr.sqr(); Oi < gr.length; Oi++, Mi = Mi.sqr())
          gr[Oi] !== 0 && (vr = vr.mul(Mi));
      return vr;
    }, x.prototype.iushln = function(z) {
      w(typeof z == "number" && z >= 0);
      var gr = z % 26, vr = (z - gr) / 26, Oi = 67108863 >>> 26 - gr << 26 - gr, Mi;
      if (gr !== 0) {
        var ki = 0;
        for (Mi = 0; Mi < this.length; Mi++) {
          var yr = this.words[Mi] & Oi, xi = (this.words[Mi] | 0) - yr << gr;
          this.words[Mi] = xi | ki, ki = yr >>> 26 - gr;
        }
        ki && (this.words[Mi] = ki, this.length++);
      }
      if (vr !== 0) {
        for (Mi = this.length - 1; Mi >= 0; Mi--)
          this.words[Mi + vr] = this.words[Mi];
        for (Mi = 0; Mi < vr; Mi++)
          this.words[Mi] = 0;
        this.length += vr;
      }
      return this._strip();
    }, x.prototype.ishln = function(z) {
      return w(this.negative === 0), this.iushln(z);
    }, x.prototype.iushrn = function(z, gr, vr) {
      w(typeof z == "number" && z >= 0);
      var Oi;
      gr ? Oi = (gr - gr % 26) / 26 : Oi = 0;
      var Mi = z % 26, ki = Math.min((z - Mi) / 26, this.length), yr = 67108863 ^ 67108863 >>> Mi << Mi, xi = vr;
      if (Oi -= ki, Oi = Math.max(0, Oi), xi) {
        for (var Si = 0; Si < ki; Si++)
          xi.words[Si] = this.words[Si];
        xi.length = ki;
      }
      if (ki !== 0) if (this.length > ki)
        for (this.length -= ki, Si = 0; Si < this.length; Si++)
          this.words[Si] = this.words[Si + ki];
      else
        this.words[0] = 0, this.length = 1;
      var Ci = 0;
      for (Si = this.length - 1; Si >= 0 && (Ci !== 0 || Si >= Oi); Si--) {
        var Ki = this.words[Si] | 0;
        this.words[Si] = Ci << 26 - Mi | Ki >>> Mi, Ci = Ki & yr;
      }
      return xi && Ci !== 0 && (xi.words[xi.length++] = Ci), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, x.prototype.ishrn = function(z, gr, vr) {
      return w(this.negative === 0), this.iushrn(z, gr, vr);
    }, x.prototype.shln = function(z) {
      return this.clone().ishln(z);
    }, x.prototype.ushln = function(z) {
      return this.clone().iushln(z);
    }, x.prototype.shrn = function(z) {
      return this.clone().ishrn(z);
    }, x.prototype.ushrn = function(z) {
      return this.clone().iushrn(z);
    }, x.prototype.testn = function(z) {
      w(typeof z == "number" && z >= 0);
      var gr = z % 26, vr = (z - gr) / 26, Oi = 1 << gr;
      if (this.length <= vr) return !1;
      var Mi = this.words[vr];
      return !!(Mi & Oi);
    }, x.prototype.imaskn = function(z) {
      w(typeof z == "number" && z >= 0);
      var gr = z % 26, vr = (z - gr) / 26;
      if (w(this.negative === 0, "imaskn works only with positive numbers"), this.length <= vr)
        return this;
      if (gr !== 0 && vr++, this.length = Math.min(vr, this.length), gr !== 0) {
        var Oi = 67108863 ^ 67108863 >>> gr << gr;
        this.words[this.length - 1] &= Oi;
      }
      return this._strip();
    }, x.prototype.maskn = function(z) {
      return this.clone().imaskn(z);
    }, x.prototype.iaddn = function(z) {
      return w(typeof z == "number"), w(z < 67108864), z < 0 ? this.isubn(-z) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= z ? (this.words[0] = z - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(z), this.negative = 1, this) : this._iaddn(z);
    }, x.prototype._iaddn = function(z) {
      this.words[0] += z;
      for (var gr = 0; gr < this.length && this.words[gr] >= 67108864; gr++)
        this.words[gr] -= 67108864, gr === this.length - 1 ? this.words[gr + 1] = 1 : this.words[gr + 1]++;
      return this.length = Math.max(this.length, gr + 1), this;
    }, x.prototype.isubn = function(z) {
      if (w(typeof z == "number"), w(z < 67108864), z < 0) return this.iaddn(-z);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(z), this.negative = 1, this;
      if (this.words[0] -= z, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var gr = 0; gr < this.length && this.words[gr] < 0; gr++)
          this.words[gr] += 67108864, this.words[gr + 1] -= 1;
      return this._strip();
    }, x.prototype.addn = function(z) {
      return this.clone().iaddn(z);
    }, x.prototype.subn = function(z) {
      return this.clone().isubn(z);
    }, x.prototype.iabs = function() {
      return this.negative = 0, this;
    }, x.prototype.abs = function() {
      return this.clone().iabs();
    }, x.prototype._ishlnsubmul = function(z, gr, vr) {
      var Oi = z.length + vr, Mi;
      this._expand(Oi);
      var ki, yr = 0;
      for (Mi = 0; Mi < z.length; Mi++) {
        ki = (this.words[Mi + vr] | 0) + yr;
        var xi = (z.words[Mi] | 0) * gr;
        ki -= xi & 67108863, yr = (ki >> 26) - (xi / 67108864 | 0), this.words[Mi + vr] = ki & 67108863;
      }
      for (; Mi < this.length - vr; Mi++)
        ki = (this.words[Mi + vr] | 0) + yr, yr = ki >> 26, this.words[Mi + vr] = ki & 67108863;
      if (yr === 0) return this._strip();
      for (w(yr === -1), yr = 0, Mi = 0; Mi < this.length; Mi++)
        ki = -(this.words[Mi] | 0) + yr, yr = ki >> 26, this.words[Mi] = ki & 67108863;
      return this.negative = 1, this._strip();
    }, x.prototype._wordDiv = function(z, gr) {
      var vr = this.length - z.length, Oi = this.clone(), Mi = z, ki = Mi.words[Mi.length - 1] | 0, yr = this._countBits(ki);
      vr = 26 - yr, vr !== 0 && (Mi = Mi.ushln(vr), Oi.iushln(vr), ki = Mi.words[Mi.length - 1] | 0);
      var xi = Oi.length - Mi.length, Si;
      if (gr !== "mod") {
        Si = new x(null), Si.length = xi + 1, Si.words = new Array(Si.length);
        for (var Ci = 0; Ci < Si.length; Ci++)
          Si.words[Ci] = 0;
      }
      var Ki = Oi.clone()._ishlnsubmul(Mi, 1, xi);
      Ki.negative === 0 && (Oi = Ki, Si && (Si.words[xi] = 1));
      for (var Yi = xi - 1; Yi >= 0; Yi--) {
        var Qi = (Oi.words[Mi.length + Yi] | 0) * 67108864 + (Oi.words[Mi.length + Yi - 1] | 0);
        for (Qi = Math.min(Qi / ki | 0, 67108863), Oi._ishlnsubmul(Mi, Qi, Yi); Oi.negative !== 0; )
          Qi--, Oi.negative = 0, Oi._ishlnsubmul(Mi, 1, Yi), Oi.isZero() || (Oi.negative ^= 1);
        Si && (Si.words[Yi] = Qi);
      }
      return Si && Si._strip(), Oi._strip(), gr !== "div" && vr !== 0 && Oi.iushrn(vr), {
        div: Si || null,
        mod: Oi
      };
    }, x.prototype.divmod = function(z, gr, vr) {
      if (w(!z.isZero()), this.isZero())
        return {
          div: new x(0),
          mod: new x(0)
        };
      var Oi, Mi, ki;
      return this.negative !== 0 && z.negative === 0 ? (ki = this.neg().divmod(z, gr), gr !== "mod" && (Oi = ki.div.neg()), gr !== "div" && (Mi = ki.mod.neg(), vr && Mi.negative !== 0 && Mi.iadd(z)), {
        div: Oi,
        mod: Mi
      }) : this.negative === 0 && z.negative !== 0 ? (ki = this.divmod(z.neg(), gr), gr !== "mod" && (Oi = ki.div.neg()), {
        div: Oi,
        mod: ki.mod
      }) : this.negative & z.negative ? (ki = this.neg().divmod(z.neg(), gr), gr !== "div" && (Mi = ki.mod.neg(), vr && Mi.negative !== 0 && Mi.isub(z)), {
        div: ki.div,
        mod: Mi
      }) : z.length > this.length || this.cmp(z) < 0 ? {
        div: new x(0),
        mod: this
      } : z.length === 1 ? gr === "div" ? {
        div: this.divn(z.words[0]),
        mod: null
      } : gr === "mod" ? {
        div: null,
        mod: new x(this.modrn(z.words[0]))
      } : {
        div: this.divn(z.words[0]),
        mod: new x(this.modrn(z.words[0]))
      } : this._wordDiv(z, gr);
    }, x.prototype.div = function(z) {
      return this.divmod(z, "div", !1).div;
    }, x.prototype.mod = function(z) {
      return this.divmod(z, "mod", !1).mod;
    }, x.prototype.umod = function(z) {
      return this.divmod(z, "mod", !0).mod;
    }, x.prototype.divRound = function(z) {
      var gr = this.divmod(z);
      if (gr.mod.isZero()) return gr.div;
      var vr = gr.div.negative !== 0 ? gr.mod.isub(z) : gr.mod, Oi = z.ushrn(1), Mi = z.andln(1), ki = vr.cmp(Oi);
      return ki < 0 || Mi === 1 && ki === 0 ? gr.div : gr.div.negative !== 0 ? gr.div.isubn(1) : gr.div.iaddn(1);
    }, x.prototype.modrn = function(z) {
      var gr = z < 0;
      gr && (z = -z), w(z <= 67108863);
      for (var vr = (1 << 26) % z, Oi = 0, Mi = this.length - 1; Mi >= 0; Mi--)
        Oi = (vr * Oi + (this.words[Mi] | 0)) % z;
      return gr ? -Oi : Oi;
    }, x.prototype.modn = function(z) {
      return this.modrn(z);
    }, x.prototype.idivn = function(z) {
      var gr = z < 0;
      gr && (z = -z), w(z <= 67108863);
      for (var vr = 0, Oi = this.length - 1; Oi >= 0; Oi--) {
        var Mi = (this.words[Oi] | 0) + vr * 67108864;
        this.words[Oi] = Mi / z | 0, vr = Mi % z;
      }
      return this._strip(), gr ? this.ineg() : this;
    }, x.prototype.divn = function(z) {
      return this.clone().idivn(z);
    }, x.prototype.egcd = function(z) {
      w(z.negative === 0), w(!z.isZero());
      var gr = this, vr = z.clone();
      gr.negative !== 0 ? gr = gr.umod(z) : gr = gr.clone();
      for (var Oi = new x(1), Mi = new x(0), ki = new x(0), yr = new x(1), xi = 0; gr.isEven() && vr.isEven(); )
        gr.iushrn(1), vr.iushrn(1), ++xi;
      for (var Si = vr.clone(), Ci = gr.clone(); !gr.isZero(); ) {
        for (var Ki = 0, Yi = 1; !(gr.words[0] & Yi) && Ki < 26; ++Ki, Yi <<= 1) ;
        if (Ki > 0)
          for (gr.iushrn(Ki); Ki-- > 0; )
            (Oi.isOdd() || Mi.isOdd()) && (Oi.iadd(Si), Mi.isub(Ci)), Oi.iushrn(1), Mi.iushrn(1);
        for (var Qi = 0, Zi = 1; !(vr.words[0] & Zi) && Qi < 26; ++Qi, Zi <<= 1) ;
        if (Qi > 0)
          for (vr.iushrn(Qi); Qi-- > 0; )
            (ki.isOdd() || yr.isOdd()) && (ki.iadd(Si), yr.isub(Ci)), ki.iushrn(1), yr.iushrn(1);
        gr.cmp(vr) >= 0 ? (gr.isub(vr), Oi.isub(ki), Mi.isub(yr)) : (vr.isub(gr), ki.isub(Oi), yr.isub(Mi));
      }
      return {
        a: ki,
        b: yr,
        gcd: vr.iushln(xi)
      };
    }, x.prototype._invmp = function(z) {
      w(z.negative === 0), w(!z.isZero());
      var gr = this, vr = z.clone();
      gr.negative !== 0 ? gr = gr.umod(z) : gr = gr.clone();
      for (var Oi = new x(1), Mi = new x(0), ki = vr.clone(); gr.cmpn(1) > 0 && vr.cmpn(1) > 0; ) {
        for (var yr = 0, xi = 1; !(gr.words[0] & xi) && yr < 26; ++yr, xi <<= 1) ;
        if (yr > 0)
          for (gr.iushrn(yr); yr-- > 0; )
            Oi.isOdd() && Oi.iadd(ki), Oi.iushrn(1);
        for (var Si = 0, Ci = 1; !(vr.words[0] & Ci) && Si < 26; ++Si, Ci <<= 1) ;
        if (Si > 0)
          for (vr.iushrn(Si); Si-- > 0; )
            Mi.isOdd() && Mi.iadd(ki), Mi.iushrn(1);
        gr.cmp(vr) >= 0 ? (gr.isub(vr), Oi.isub(Mi)) : (vr.isub(gr), Mi.isub(Oi));
      }
      var Ki;
      return gr.cmpn(1) === 0 ? Ki = Oi : Ki = Mi, Ki.cmpn(0) < 0 && Ki.iadd(z), Ki;
    }, x.prototype.gcd = function(z) {
      if (this.isZero()) return z.abs();
      if (z.isZero()) return this.abs();
      var gr = this.clone(), vr = z.clone();
      gr.negative = 0, vr.negative = 0;
      for (var Oi = 0; gr.isEven() && vr.isEven(); Oi++)
        gr.iushrn(1), vr.iushrn(1);
      do {
        for (; gr.isEven(); )
          gr.iushrn(1);
        for (; vr.isEven(); )
          vr.iushrn(1);
        var Mi = gr.cmp(vr);
        if (Mi < 0) {
          var ki = gr;
          gr = vr, vr = ki;
        } else if (Mi === 0 || vr.cmpn(1) === 0)
          break;
        gr.isub(vr);
      } while (!0);
      return vr.iushln(Oi);
    }, x.prototype.invm = function(z) {
      return this.egcd(z).a.umod(z);
    }, x.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, x.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, x.prototype.andln = function(z) {
      return this.words[0] & z;
    }, x.prototype.bincn = function(z) {
      w(typeof z == "number");
      var gr = z % 26, vr = (z - gr) / 26, Oi = 1 << gr;
      if (this.length <= vr)
        return this._expand(vr + 1), this.words[vr] |= Oi, this;
      for (var Mi = Oi, ki = vr; Mi !== 0 && ki < this.length; ki++) {
        var yr = this.words[ki] | 0;
        yr += Mi, Mi = yr >>> 26, yr &= 67108863, this.words[ki] = yr;
      }
      return Mi !== 0 && (this.words[ki] = Mi, this.length++), this;
    }, x.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, x.prototype.cmpn = function(z) {
      var gr = z < 0;
      if (this.negative !== 0 && !gr) return -1;
      if (this.negative === 0 && gr) return 1;
      this._strip();
      var vr;
      if (this.length > 1)
        vr = 1;
      else {
        gr && (z = -z), w(z <= 67108863, "Number is too big");
        var Oi = this.words[0] | 0;
        vr = Oi === z ? 0 : Oi < z ? -1 : 1;
      }
      return this.negative !== 0 ? -vr | 0 : vr;
    }, x.prototype.cmp = function(z) {
      if (this.negative !== 0 && z.negative === 0) return -1;
      if (this.negative === 0 && z.negative !== 0) return 1;
      var gr = this.ucmp(z);
      return this.negative !== 0 ? -gr | 0 : gr;
    }, x.prototype.ucmp = function(z) {
      if (this.length > z.length) return 1;
      if (this.length < z.length) return -1;
      for (var gr = 0, vr = this.length - 1; vr >= 0; vr--) {
        var Oi = this.words[vr] | 0, Mi = z.words[vr] | 0;
        if (Oi !== Mi) {
          Oi < Mi ? gr = -1 : Oi > Mi && (gr = 1);
          break;
        }
      }
      return gr;
    }, x.prototype.gtn = function(z) {
      return this.cmpn(z) === 1;
    }, x.prototype.gt = function(z) {
      return this.cmp(z) === 1;
    }, x.prototype.gten = function(z) {
      return this.cmpn(z) >= 0;
    }, x.prototype.gte = function(z) {
      return this.cmp(z) >= 0;
    }, x.prototype.ltn = function(z) {
      return this.cmpn(z) === -1;
    }, x.prototype.lt = function(z) {
      return this.cmp(z) === -1;
    }, x.prototype.lten = function(z) {
      return this.cmpn(z) <= 0;
    }, x.prototype.lte = function(z) {
      return this.cmp(z) <= 0;
    }, x.prototype.eqn = function(z) {
      return this.cmpn(z) === 0;
    }, x.prototype.eq = function(z) {
      return this.cmp(z) === 0;
    }, x.red = function(z) {
      return new pr(z);
    }, x.prototype.toRed = function(z) {
      return w(!this.red, "Already a number in reduction context"), w(this.negative === 0, "red works only with positives"), z.convertTo(this)._forceRed(z);
    }, x.prototype.fromRed = function() {
      return w(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, x.prototype._forceRed = function(z) {
      return this.red = z, this;
    }, x.prototype.forceRed = function(z) {
      return w(!this.red, "Already a number in reduction context"), this._forceRed(z);
    }, x.prototype.redAdd = function(z) {
      return w(this.red, "redAdd works only with red numbers"), this.red.add(this, z);
    }, x.prototype.redIAdd = function(z) {
      return w(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, z);
    }, x.prototype.redSub = function(z) {
      return w(this.red, "redSub works only with red numbers"), this.red.sub(this, z);
    }, x.prototype.redISub = function(z) {
      return w(this.red, "redISub works only with red numbers"), this.red.isub(this, z);
    }, x.prototype.redShl = function(z) {
      return w(this.red, "redShl works only with red numbers"), this.red.shl(this, z);
    }, x.prototype.redMul = function(z) {
      return w(this.red, "redMul works only with red numbers"), this.red._verify2(this, z), this.red.mul(this, z);
    }, x.prototype.redIMul = function(z) {
      return w(this.red, "redMul works only with red numbers"), this.red._verify2(this, z), this.red.imul(this, z);
    }, x.prototype.redSqr = function() {
      return w(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, x.prototype.redISqr = function() {
      return w(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, x.prototype.redSqrt = function() {
      return w(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, x.prototype.redInvm = function() {
      return w(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, x.prototype.redNeg = function() {
      return w(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, x.prototype.redPow = function(z) {
      return w(this.red && !z.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, z);
    };
    var qi = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Wi(z, gr) {
      this.name = z, this.p = new x(gr, 16), this.n = this.p.bitLength(), this.k = new x(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Wi.prototype._tmp = function() {
      var z = new x(null);
      return z.words = new Array(Math.ceil(this.n / 13)), z;
    }, Wi.prototype.ireduce = function(z) {
      var gr = z, vr;
      do
        this.split(gr, this.tmp), gr = this.imulK(gr), gr = gr.iadd(this.tmp), vr = gr.bitLength();
      while (vr > this.n);
      var Oi = vr < this.n ? -1 : gr.ucmp(this.p);
      return Oi === 0 ? (gr.words[0] = 0, gr.length = 1) : Oi > 0 ? gr.isub(this.p) : gr.strip !== void 0 ? gr.strip() : gr._strip(), gr;
    }, Wi.prototype.split = function(z, gr) {
      z.iushrn(this.n, 0, gr);
    }, Wi.prototype.imulK = function(z) {
      return z.imul(this.k);
    };
    function Vi() {
      Wi.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    T(Vi, Wi), Vi.prototype.split = function(z, gr) {
      for (var vr = 4194303, Oi = Math.min(z.length, 9), Mi = 0; Mi < Oi; Mi++)
        gr.words[Mi] = z.words[Mi];
      if (gr.length = Oi, z.length <= 9) {
        z.words[0] = 0, z.length = 1;
        return;
      }
      var ki = z.words[9];
      for (gr.words[gr.length++] = ki & vr, Mi = 10; Mi < z.length; Mi++) {
        var yr = z.words[Mi] | 0;
        z.words[Mi - 10] = (yr & vr) << 4 | ki >>> 22, ki = yr;
      }
      ki >>>= 22, z.words[Mi - 10] = ki, ki === 0 && z.length > 10 ? z.length -= 10 : z.length -= 9;
    }, Vi.prototype.imulK = function(z) {
      z.words[z.length] = 0, z.words[z.length + 1] = 0, z.length += 2;
      for (var gr = 0, vr = 0; vr < z.length; vr++) {
        var Oi = z.words[vr] | 0;
        gr += Oi * 977, z.words[vr] = gr & 67108863, gr = Oi * 64 + (gr / 67108864 | 0);
      }
      return z.words[z.length - 1] === 0 && (z.length--, z.words[z.length - 1] === 0 && z.length--), z;
    };
    function Ti() {
      Wi.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    T(Ti, Wi);
    function Li() {
      Wi.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    T(Li, Wi);
    function Hi() {
      Wi.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    T(Hi, Wi), Hi.prototype.imulK = function(z) {
      for (var gr = 0, vr = 0; vr < z.length; vr++) {
        var Oi = (z.words[vr] | 0) * 19 + gr, Mi = Oi & 67108863;
        Oi >>>= 26, z.words[vr] = Mi, gr = Oi;
      }
      return gr !== 0 && (z.words[z.length++] = gr), z;
    }, x._prime = function(z) {
      if (qi[z]) return qi[z];
      var gr;
      if (z === "k256")
        gr = new Vi();
      else if (z === "p224")
        gr = new Ti();
      else if (z === "p192")
        gr = new Li();
      else if (z === "p25519")
        gr = new Hi();
      else
        throw new Error("Unknown prime " + z);
      return qi[z] = gr, gr;
    };
    function pr(z) {
      if (typeof z == "string") {
        var gr = x._prime(z);
        this.m = gr.p, this.prime = gr;
      } else
        w(z.gtn(1), "modulus must be greater than 1"), this.m = z, this.prime = null;
    }
    pr.prototype._verify1 = function(z) {
      w(z.negative === 0, "red works only with positives"), w(z.red, "red works only with red numbers");
    }, pr.prototype._verify2 = function(z, gr) {
      w((z.negative | gr.negative) === 0, "red works only with positives"), w(
        z.red && z.red === gr.red,
        "red works only with red numbers"
      );
    }, pr.prototype.imod = function(z) {
      return this.prime ? this.prime.ireduce(z)._forceRed(this) : (q(z, z.umod(this.m)._forceRed(this)), z);
    }, pr.prototype.neg = function(z) {
      return z.isZero() ? z.clone() : this.m.sub(z)._forceRed(this);
    }, pr.prototype.add = function(z, gr) {
      this._verify2(z, gr);
      var vr = z.add(gr);
      return vr.cmp(this.m) >= 0 && vr.isub(this.m), vr._forceRed(this);
    }, pr.prototype.iadd = function(z, gr) {
      this._verify2(z, gr);
      var vr = z.iadd(gr);
      return vr.cmp(this.m) >= 0 && vr.isub(this.m), vr;
    }, pr.prototype.sub = function(z, gr) {
      this._verify2(z, gr);
      var vr = z.sub(gr);
      return vr.cmpn(0) < 0 && vr.iadd(this.m), vr._forceRed(this);
    }, pr.prototype.isub = function(z, gr) {
      this._verify2(z, gr);
      var vr = z.isub(gr);
      return vr.cmpn(0) < 0 && vr.iadd(this.m), vr;
    }, pr.prototype.shl = function(z, gr) {
      return this._verify1(z), this.imod(z.ushln(gr));
    }, pr.prototype.imul = function(z, gr) {
      return this._verify2(z, gr), this.imod(z.imul(gr));
    }, pr.prototype.mul = function(z, gr) {
      return this._verify2(z, gr), this.imod(z.mul(gr));
    }, pr.prototype.isqr = function(z) {
      return this.imul(z, z.clone());
    }, pr.prototype.sqr = function(z) {
      return this.mul(z, z);
    }, pr.prototype.sqrt = function(z) {
      if (z.isZero()) return z.clone();
      var gr = this.m.andln(3);
      if (w(gr % 2 === 1), gr === 3) {
        var vr = this.m.add(new x(1)).iushrn(2);
        return this.pow(z, vr);
      }
      for (var Oi = this.m.subn(1), Mi = 0; !Oi.isZero() && Oi.andln(1) === 0; )
        Mi++, Oi.iushrn(1);
      w(!Oi.isZero());
      var ki = new x(1).toRed(this), yr = ki.redNeg(), xi = this.m.subn(1).iushrn(1), Si = this.m.bitLength();
      for (Si = new x(2 * Si * Si).toRed(this); this.pow(Si, xi).cmp(yr) !== 0; )
        Si.redIAdd(yr);
      for (var Ci = this.pow(Si, Oi), Ki = this.pow(z, Oi.addn(1).iushrn(1)), Yi = this.pow(z, Oi), Qi = Mi; Yi.cmp(ki) !== 0; ) {
        for (var Zi = Yi, Ni = 0; Zi.cmp(ki) !== 0; Ni++)
          Zi = Zi.redSqr();
        w(Ni < Qi);
        var Fi = this.pow(Ci, new x(1).iushln(Qi - Ni - 1));
        Ki = Ki.redMul(Fi), Ci = Fi.redSqr(), Yi = Yi.redMul(Ci), Qi = Ni;
      }
      return Ki;
    }, pr.prototype.invm = function(z) {
      var gr = z._invmp(this.m);
      return gr.negative !== 0 ? (gr.negative = 0, this.imod(gr).redNeg()) : this.imod(gr);
    }, pr.prototype.pow = function(z, gr) {
      if (gr.isZero()) return new x(1).toRed(this);
      if (gr.cmpn(1) === 0) return z.clone();
      var vr = 4, Oi = new Array(1 << vr);
      Oi[0] = new x(1).toRed(this), Oi[1] = z;
      for (var Mi = 2; Mi < Oi.length; Mi++)
        Oi[Mi] = this.mul(Oi[Mi - 1], z);
      var ki = Oi[0], yr = 0, xi = 0, Si = gr.bitLength() % 26;
      for (Si === 0 && (Si = 26), Mi = gr.length - 1; Mi >= 0; Mi--) {
        for (var Ci = gr.words[Mi], Ki = Si - 1; Ki >= 0; Ki--) {
          var Yi = Ci >> Ki & 1;
          if (ki !== Oi[0] && (ki = this.sqr(ki)), Yi === 0 && yr === 0) {
            xi = 0;
            continue;
          }
          yr <<= 1, yr |= Yi, xi++, !(xi !== vr && (Mi !== 0 || Ki !== 0)) && (ki = this.mul(ki, Oi[yr]), xi = 0, yr = 0);
        }
        Si = 26;
      }
      return ki;
    }, pr.prototype.convertTo = function(z) {
      var gr = z.umod(this.m);
      return gr === z ? gr.clone() : gr;
    }, pr.prototype.convertFrom = function(z) {
      var gr = z.clone();
      return gr.red = null, gr;
    }, x.mont = function(z) {
      return new Di(z);
    };
    function Di(z) {
      pr.call(this, z), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new x(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    T(Di, pr), Di.prototype.convertTo = function(z) {
      return this.imod(z.ushln(this.shift));
    }, Di.prototype.convertFrom = function(z) {
      var gr = this.imod(z.mul(this.rinv));
      return gr.red = null, gr;
    }, Di.prototype.imul = function(z, gr) {
      if (z.isZero() || gr.isZero())
        return z.words[0] = 0, z.length = 1, z;
      var vr = z.imul(gr), Oi = vr.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Mi = vr.isub(Oi).iushrn(this.shift), ki = Mi;
      return Mi.cmp(this.m) >= 0 ? ki = Mi.isub(this.m) : Mi.cmpn(0) < 0 && (ki = Mi.iadd(this.m)), ki._forceRed(this);
    }, Di.prototype.mul = function(z, gr) {
      if (z.isZero() || gr.isZero()) return new x(0)._forceRed(this);
      var vr = z.mul(gr), Oi = vr.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Mi = vr.isub(Oi).iushrn(this.shift), ki = Mi;
      return Mi.cmp(this.m) >= 0 ? ki = Mi.isub(this.m) : Mi.cmpn(0) < 0 && (ki = Mi.iadd(this.m)), ki._forceRed(this);
    }, Di.prototype.invm = function(z) {
      var gr = this.imod(z._invmp(this.m).mul(this.r2));
      return gr._forceRed(this);
    };
  })(e, commonjsGlobal);
})(bn);
var bnExports = bn.exports, BN$a = bnExports, randomBytes$1 = browserExports, Buffer$7 = safeBufferExports$1.Buffer;
function getr(e) {
  var t = e.modulus.byteLength(), v;
  do
    v = new BN$a(randomBytes$1(t));
  while (v.cmp(e.modulus) >= 0 || !v.umod(e.prime1) || !v.umod(e.prime2));
  return v;
}
function blind(e) {
  var t = getr(e), v = t.toRed(BN$a.mont(e.modulus)).redPow(new BN$a(e.publicExponent)).fromRed();
  return { blinder: v, unblinder: t.invm(e.modulus) };
}
function crt$2(e, t) {
  var v = blind(t), w = t.modulus.byteLength(), T = new BN$a(e).mul(v.blinder).umod(t.modulus), x = T.toRed(BN$a.mont(t.prime1)), C = T.toRed(BN$a.mont(t.prime2)), D = t.coefficient, Y = t.prime1, L = t.prime2, q = x.redPow(t.exponent1).fromRed(), N = C.redPow(t.exponent2).fromRed(), F = q.isub(N).imul(D).umod(Y).imul(L);
  return N.iadd(F).imul(v.unblinder).umod(t.modulus).toArrayLike(Buffer$7, "be", w);
}
crt$2.getr = getr;
var browserifyRsa = crt$2, elliptic = {};
const name = "elliptic", version$1 = "6.6.1", description = "EC cryptography", main = "lib/elliptic.js", files = [
  "lib"
], scripts = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author = "Fedor Indutny <fedor@indutny.com>", license = "MIT", bugs = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage = "https://github.com/indutny/elliptic", devDependencies = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0 = {
  name,
  version: version$1,
  description,
  main,
  files,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  dependencies
};
var utils$l = {}, utils$k = {};
(function(e) {
  var t = e;
  function v(x, C) {
    if (Array.isArray(x))
      return x.slice();
    if (!x)
      return [];
    var D = [];
    if (typeof x != "string") {
      for (var Y = 0; Y < x.length; Y++)
        D[Y] = x[Y] | 0;
      return D;
    }
    if (C === "hex") {
      x = x.replace(/[^a-z0-9]+/ig, ""), x.length % 2 !== 0 && (x = "0" + x);
      for (var Y = 0; Y < x.length; Y += 2)
        D.push(parseInt(x[Y] + x[Y + 1], 16));
    } else
      for (var Y = 0; Y < x.length; Y++) {
        var L = x.charCodeAt(Y), q = L >> 8, N = L & 255;
        q ? D.push(q, N) : D.push(N);
      }
    return D;
  }
  t.toArray = v;
  function w(x) {
    return x.length === 1 ? "0" + x : x;
  }
  t.zero2 = w;
  function T(x) {
    for (var C = "", D = 0; D < x.length; D++)
      C += w(x[D].toString(16));
    return C;
  }
  t.toHex = T, t.encode = function(x, C) {
    return C === "hex" ? T(x) : x;
  };
})(utils$k);
(function(e) {
  var t = e, v = bnExports$1, w = minimalisticAssert, T = utils$k;
  t.assert = w, t.toArray = T.toArray, t.zero2 = T.zero2, t.toHex = T.toHex, t.encode = T.encode;
  function x(q, N, F) {
    var ae = new Array(Math.max(q.bitLength(), F) + 1), he;
    for (he = 0; he < ae.length; he += 1)
      ae[he] = 0;
    var tt = 1 << N + 1, br = q.clone();
    for (he = 0; he < ae.length; he++) {
      var rt, dr = br.andln(tt - 1);
      br.isOdd() ? (dr > (tt >> 1) - 1 ? rt = (tt >> 1) - dr : rt = dr, br.isubn(rt)) : rt = 0, ae[he] = rt, br.iushrn(1);
    }
    return ae;
  }
  t.getNAF = x;
  function C(q, N) {
    var F = [
      [],
      []
    ];
    q = q.clone(), N = N.clone();
    for (var ae = 0, he = 0, tt; q.cmpn(-ae) > 0 || N.cmpn(-he) > 0; ) {
      var br = q.andln(3) + ae & 3, rt = N.andln(3) + he & 3;
      br === 3 && (br = -1), rt === 3 && (rt = -1);
      var dr;
      br & 1 ? (tt = q.andln(7) + ae & 7, (tt === 3 || tt === 5) && rt === 2 ? dr = -br : dr = br) : dr = 0, F[0].push(dr);
      var _r;
      rt & 1 ? (tt = N.andln(7) + he & 7, (tt === 3 || tt === 5) && br === 2 ? _r = -rt : _r = rt) : _r = 0, F[1].push(_r), 2 * ae === dr + 1 && (ae = 1 - ae), 2 * he === _r + 1 && (he = 1 - he), q.iushrn(1), N.iushrn(1);
    }
    return F;
  }
  t.getJSF = C;
  function D(q, N, F) {
    var ae = "_" + N;
    q.prototype[N] = function() {
      return this[ae] !== void 0 ? this[ae] : this[ae] = F.call(this);
    };
  }
  t.cachedProperty = D;
  function Y(q) {
    return typeof q == "string" ? t.toArray(q, "hex") : q;
  }
  t.parseBytes = Y;
  function L(q) {
    return new v(q, "hex", "le");
  }
  t.intFromLE = L;
})(utils$l);
var curve = {}, BN$9 = bnExports$1, utils$j = utils$l, getNAF = utils$j.getNAF, getJSF = utils$j.getJSF, assert$d = utils$j.assert;
function BaseCurve(e, t) {
  this.type = e, this.p = new BN$9(t.p, 16), this.red = t.prime ? BN$9.red(t.prime) : BN$9.mont(this.p), this.zero = new BN$9(0).toRed(this.red), this.one = new BN$9(1).toRed(this.red), this.two = new BN$9(2).toRed(this.red), this.n = t.n && new BN$9(t.n, 16), this.g = t.g && this.pointFromJSON(t.g, t.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var v = this.n && this.p.div(this.n);
  !v || v.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base$1 = BaseCurve;
BaseCurve.prototype.point = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function(e, t) {
  assert$d(e.precomputed);
  var v = e._getDoubles(), w = getNAF(t, 1, this._bitLength), T = (1 << v.step + 1) - (v.step % 2 === 0 ? 2 : 1);
  T /= 3;
  var x = [], C, D;
  for (C = 0; C < w.length; C += v.step) {
    D = 0;
    for (var Y = C + v.step - 1; Y >= C; Y--)
      D = (D << 1) + w[Y];
    x.push(D);
  }
  for (var L = this.jpoint(null, null, null), q = this.jpoint(null, null, null), N = T; N > 0; N--) {
    for (C = 0; C < x.length; C++)
      D = x[C], D === N ? q = q.mixedAdd(v.points[C]) : D === -N && (q = q.mixedAdd(v.points[C].neg()));
    L = L.add(q);
  }
  return L.toP();
};
BaseCurve.prototype._wnafMul = function(e, t) {
  var v = 4, w = e._getNAFPoints(v);
  v = w.wnd;
  for (var T = w.points, x = getNAF(t, v, this._bitLength), C = this.jpoint(null, null, null), D = x.length - 1; D >= 0; D--) {
    for (var Y = 0; D >= 0 && x[D] === 0; D--)
      Y++;
    if (D >= 0 && Y++, C = C.dblp(Y), D < 0)
      break;
    var L = x[D];
    assert$d(L !== 0), e.type === "affine" ? L > 0 ? C = C.mixedAdd(T[L - 1 >> 1]) : C = C.mixedAdd(T[-L - 1 >> 1].neg()) : L > 0 ? C = C.add(T[L - 1 >> 1]) : C = C.add(T[-L - 1 >> 1].neg());
  }
  return e.type === "affine" ? C.toP() : C;
};
BaseCurve.prototype._wnafMulAdd = function(e, t, v, w, T) {
  var x = this._wnafT1, C = this._wnafT2, D = this._wnafT3, Y = 0, L, q, N;
  for (L = 0; L < w; L++) {
    N = t[L];
    var F = N._getNAFPoints(e);
    x[L] = F.wnd, C[L] = F.points;
  }
  for (L = w - 1; L >= 1; L -= 2) {
    var ae = L - 1, he = L;
    if (x[ae] !== 1 || x[he] !== 1) {
      D[ae] = getNAF(v[ae], x[ae], this._bitLength), D[he] = getNAF(v[he], x[he], this._bitLength), Y = Math.max(D[ae].length, Y), Y = Math.max(D[he].length, Y);
      continue;
    }
    var tt = [
      t[ae],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      t[he]
      /* 7 */
    ];
    t[ae].y.cmp(t[he].y) === 0 ? (tt[1] = t[ae].add(t[he]), tt[2] = t[ae].toJ().mixedAdd(t[he].neg())) : t[ae].y.cmp(t[he].y.redNeg()) === 0 ? (tt[1] = t[ae].toJ().mixedAdd(t[he]), tt[2] = t[ae].add(t[he].neg())) : (tt[1] = t[ae].toJ().mixedAdd(t[he]), tt[2] = t[ae].toJ().mixedAdd(t[he].neg()));
    var br = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], rt = getJSF(v[ae], v[he]);
    for (Y = Math.max(rt[0].length, Y), D[ae] = new Array(Y), D[he] = new Array(Y), q = 0; q < Y; q++) {
      var dr = rt[0][q] | 0, _r = rt[1][q] | 0;
      D[ae][q] = br[(dr + 1) * 3 + (_r + 1)], D[he][q] = 0, C[ae] = tt;
    }
  }
  var Bi = this.jpoint(null, null, null), qi = this._wnafT4;
  for (L = Y; L >= 0; L--) {
    for (var Wi = 0; L >= 0; ) {
      var Vi = !0;
      for (q = 0; q < w; q++)
        qi[q] = D[q][L] | 0, qi[q] !== 0 && (Vi = !1);
      if (!Vi)
        break;
      Wi++, L--;
    }
    if (L >= 0 && Wi++, Bi = Bi.dblp(Wi), L < 0)
      break;
    for (q = 0; q < w; q++) {
      var Ti = qi[q];
      Ti !== 0 && (Ti > 0 ? N = C[q][Ti - 1 >> 1] : Ti < 0 && (N = C[q][-Ti - 1 >> 1].neg()), N.type === "affine" ? Bi = Bi.mixedAdd(N) : Bi = Bi.add(N));
    }
  }
  for (L = 0; L < w; L++)
    C[L] = null;
  return T ? Bi : Bi.toP();
};
function BasePoint(e, t) {
  this.curve = e, this.type = t, this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function(e, t) {
  e = utils$j.toArray(e, t);
  var v = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * v) {
    e[0] === 6 ? assert$d(e[e.length - 1] % 2 === 0) : e[0] === 7 && assert$d(e[e.length - 1] % 2 === 1);
    var w = this.point(
      e.slice(1, 1 + v),
      e.slice(1 + v, 1 + 2 * v)
    );
    return w;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === v)
    return this.pointFromX(e.slice(1, 1 + v), e[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function(e) {
  return this.encode(e, !0);
};
BasePoint.prototype._encode = function(e) {
  var t = this.curve.p.byteLength(), v = this.getX().toArray("be", t);
  return e ? [this.getY().isEven() ? 2 : 3].concat(v) : [4].concat(v, this.getY().toArray("be", t));
};
BasePoint.prototype.encode = function(e, t) {
  return utils$j.encode(this._encode(t), e);
};
BasePoint.prototype.precompute = function(e) {
  if (this.precomputed)
    return this;
  var t = {
    doubles: null,
    naf: null,
    beta: null
  };
  return t.naf = this._getNAFPoints(8), t.doubles = this._getDoubles(4, e), t.beta = this._getBeta(), this.precomputed = t, this;
};
BasePoint.prototype._hasDoubles = function(e) {
  if (!this.precomputed)
    return !1;
  var t = this.precomputed.doubles;
  return t ? t.points.length >= Math.ceil((e.bitLength() + 1) / t.step) : !1;
};
BasePoint.prototype._getDoubles = function(e, t) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var v = [this], w = this, T = 0; T < t; T += e) {
    for (var x = 0; x < e; x++)
      w = w.dbl();
    v.push(w);
  }
  return {
    step: e,
    points: v
  };
};
BasePoint.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var t = [this], v = (1 << e) - 1, w = v === 1 ? null : this.dbl(), T = 1; T < v; T++)
    t[T] = t[T - 1].add(w);
  return {
    wnd: e,
    points: t
  };
};
BasePoint.prototype._getBeta = function() {
  return null;
};
BasePoint.prototype.dblp = function(e) {
  for (var t = this, v = 0; v < e; v++)
    t = t.dbl();
  return t;
};
var utils$i = utils$l, BN$8 = bnExports$1, inherits$4 = inherits_browserExports, Base$2 = base$1, assert$c = utils$i.assert;
function ShortCurve(e) {
  Base$2.call(this, "short", e), this.a = new BN$8(e.a, 16).toRed(this.red), this.b = new BN$8(e.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(e), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits$4(ShortCurve, Base$2);
var short = ShortCurve;
ShortCurve.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var t, v;
    if (e.beta)
      t = new BN$8(e.beta, 16).toRed(this.red);
    else {
      var w = this._getEndoRoots(this.p);
      t = w[0].cmp(w[1]) < 0 ? w[0] : w[1], t = t.toRed(this.red);
    }
    if (e.lambda)
      v = new BN$8(e.lambda, 16);
    else {
      var T = this._getEndoRoots(this.n);
      this.g.mul(T[0]).x.cmp(this.g.x.redMul(t)) === 0 ? v = T[0] : (v = T[1], assert$c(this.g.mul(v).x.cmp(this.g.x.redMul(t)) === 0));
    }
    var x;
    return e.basis ? x = e.basis.map(function(C) {
      return {
        a: new BN$8(C.a, 16),
        b: new BN$8(C.b, 16)
      };
    }) : x = this._getEndoBasis(v), {
      beta: t,
      lambda: v,
      basis: x
    };
  }
};
ShortCurve.prototype._getEndoRoots = function(e) {
  var t = e === this.p ? this.red : BN$8.mont(e), v = new BN$8(2).toRed(t).redInvm(), w = v.redNeg(), T = new BN$8(3).toRed(t).redNeg().redSqrt().redMul(v), x = w.redAdd(T).fromRed(), C = w.redSub(T).fromRed();
  return [x, C];
};
ShortCurve.prototype._getEndoBasis = function(e) {
  for (var t = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), v = e, w = this.n.clone(), T = new BN$8(1), x = new BN$8(0), C = new BN$8(0), D = new BN$8(1), Y, L, q, N, F, ae, he, tt = 0, br, rt; v.cmpn(0) !== 0; ) {
    var dr = w.div(v);
    br = w.sub(dr.mul(v)), rt = C.sub(dr.mul(T));
    var _r = D.sub(dr.mul(x));
    if (!q && br.cmp(t) < 0)
      Y = he.neg(), L = T, q = br.neg(), N = rt;
    else if (q && ++tt === 2)
      break;
    he = br, w = v, v = br, C = T, T = rt, D = x, x = _r;
  }
  F = br.neg(), ae = rt;
  var Bi = q.sqr().add(N.sqr()), qi = F.sqr().add(ae.sqr());
  return qi.cmp(Bi) >= 0 && (F = Y, ae = L), q.negative && (q = q.neg(), N = N.neg()), F.negative && (F = F.neg(), ae = ae.neg()), [
    { a: q, b: N },
    { a: F, b: ae }
  ];
};
ShortCurve.prototype._endoSplit = function(e) {
  var t = this.endo.basis, v = t[0], w = t[1], T = w.b.mul(e).divRound(this.n), x = v.b.neg().mul(e).divRound(this.n), C = T.mul(v.a), D = x.mul(w.a), Y = T.mul(v.b), L = x.mul(w.b), q = e.sub(C).sub(D), N = Y.add(L).neg();
  return { k1: q, k2: N };
};
ShortCurve.prototype.pointFromX = function(e, t) {
  e = new BN$8(e, 16), e.red || (e = e.toRed(this.red));
  var v = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), w = v.redSqrt();
  if (w.redSqr().redSub(v).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var T = w.fromRed().isOdd();
  return (t && !T || !t && T) && (w = w.redNeg()), this.point(e, w);
};
ShortCurve.prototype.validate = function(e) {
  if (e.inf)
    return !0;
  var t = e.x, v = e.y, w = this.a.redMul(t), T = t.redSqr().redMul(t).redIAdd(w).redIAdd(this.b);
  return v.redSqr().redISub(T).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function(e, t, v) {
  for (var w = this._endoWnafT1, T = this._endoWnafT2, x = 0; x < e.length; x++) {
    var C = this._endoSplit(t[x]), D = e[x], Y = D._getBeta();
    C.k1.negative && (C.k1.ineg(), D = D.neg(!0)), C.k2.negative && (C.k2.ineg(), Y = Y.neg(!0)), w[x * 2] = D, w[x * 2 + 1] = Y, T[x * 2] = C.k1, T[x * 2 + 1] = C.k2;
  }
  for (var L = this._wnafMulAdd(1, w, T, x * 2, v), q = 0; q < x * 2; q++)
    w[q] = null, T[q] = null;
  return L;
};
function Point$2(e, t, v, w) {
  Base$2.BasePoint.call(this, e, "affine"), t === null && v === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$8(t, 16), this.y = new BN$8(v, 16), w && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits$4(Point$2, Base$2.BasePoint);
ShortCurve.prototype.point = function(e, t, v) {
  return new Point$2(this, e, t, v);
};
ShortCurve.prototype.pointFromJSON = function(e, t) {
  return Point$2.fromJSON(this, e, t);
};
Point$2.prototype._getBeta = function() {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var v = this.curve, w = function(T) {
        return v.point(T.x.redMul(v.endo.beta), T.y);
      };
      e.beta = t, t.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(w)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(w)
        }
      };
    }
    return t;
  }
};
Point$2.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point$2.fromJSON = function(e, t, v) {
  typeof t == "string" && (t = JSON.parse(t));
  var w = e.point(t[0], t[1], v);
  if (!t[2])
    return w;
  function T(C) {
    return e.point(C[0], C[1], v);
  }
  var x = t[2];
  return w.precomputed = {
    beta: null,
    doubles: x.doubles && {
      step: x.doubles.step,
      points: [w].concat(x.doubles.points.map(T))
    },
    naf: x.naf && {
      wnd: x.naf.wnd,
      points: [w].concat(x.naf.points.map(T))
    }
  }, w;
};
Point$2.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function() {
  return this.inf;
};
Point$2.prototype.add = function(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var t = this.y.redSub(e.y);
  t.cmpn(0) !== 0 && (t = t.redMul(this.x.redSub(e.x).redInvm()));
  var v = t.redSqr().redISub(this.x).redISub(e.x), w = t.redMul(this.x.redSub(v)).redISub(this.y);
  return this.curve.point(v, w);
};
Point$2.prototype.dbl = function() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var t = this.curve.a, v = this.x.redSqr(), w = e.redInvm(), T = v.redAdd(v).redIAdd(v).redIAdd(t).redMul(w), x = T.redSqr().redISub(this.x.redAdd(this.x)), C = T.redMul(this.x.redSub(x)).redISub(this.y);
  return this.curve.point(x, C);
};
Point$2.prototype.getX = function() {
  return this.x.fromRed();
};
Point$2.prototype.getY = function() {
  return this.y.fromRed();
};
Point$2.prototype.mul = function(e) {
  return e = new BN$8(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
Point$2.prototype.mulAdd = function(e, t, v) {
  var w = [this, t], T = [e, v];
  return this.curve.endo ? this.curve._endoWnafMulAdd(w, T) : this.curve._wnafMulAdd(1, w, T, 2);
};
Point$2.prototype.jmulAdd = function(e, t, v) {
  var w = [this, t], T = [e, v];
  return this.curve.endo ? this.curve._endoWnafMulAdd(w, T, !0) : this.curve._wnafMulAdd(1, w, T, 2, !0);
};
Point$2.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
Point$2.prototype.neg = function(e) {
  if (this.inf)
    return this;
  var t = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var v = this.precomputed, w = function(T) {
      return T.neg();
    };
    t.precomputed = {
      naf: v.naf && {
        wnd: v.naf.wnd,
        points: v.naf.points.map(w)
      },
      doubles: v.doubles && {
        step: v.doubles.step,
        points: v.doubles.points.map(w)
      }
    };
  }
  return t;
};
Point$2.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function JPoint(e, t, v, w) {
  Base$2.BasePoint.call(this, e, "jacobian"), t === null && v === null && w === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$8(0)) : (this.x = new BN$8(t, 16), this.y = new BN$8(v, 16), this.z = new BN$8(w, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits$4(JPoint, Base$2.BasePoint);
ShortCurve.prototype.jpoint = function(e, t, v) {
  return new JPoint(this, e, t, v);
};
JPoint.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), t = e.redSqr(), v = this.x.redMul(t), w = this.y.redMul(t).redMul(e);
  return this.curve.point(v, w);
};
JPoint.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var t = e.z.redSqr(), v = this.z.redSqr(), w = this.x.redMul(t), T = e.x.redMul(v), x = this.y.redMul(t.redMul(e.z)), C = e.y.redMul(v.redMul(this.z)), D = w.redSub(T), Y = x.redSub(C);
  if (D.cmpn(0) === 0)
    return Y.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var L = D.redSqr(), q = L.redMul(D), N = w.redMul(L), F = Y.redSqr().redIAdd(q).redISub(N).redISub(N), ae = Y.redMul(N.redISub(F)).redISub(x.redMul(q)), he = this.z.redMul(e.z).redMul(D);
  return this.curve.jpoint(F, ae, he);
};
JPoint.prototype.mixedAdd = function(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var t = this.z.redSqr(), v = this.x, w = e.x.redMul(t), T = this.y, x = e.y.redMul(t).redMul(this.z), C = v.redSub(w), D = T.redSub(x);
  if (C.cmpn(0) === 0)
    return D.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var Y = C.redSqr(), L = Y.redMul(C), q = v.redMul(Y), N = D.redSqr().redIAdd(L).redISub(q).redISub(q), F = D.redMul(q.redISub(N)).redISub(T.redMul(L)), ae = this.z.redMul(C);
  return this.curve.jpoint(N, F, ae);
};
JPoint.prototype.dblp = function(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var t;
  if (this.curve.zeroA || this.curve.threeA) {
    var v = this;
    for (t = 0; t < e; t++)
      v = v.dbl();
    return v;
  }
  var w = this.curve.a, T = this.curve.tinv, x = this.x, C = this.y, D = this.z, Y = D.redSqr().redSqr(), L = C.redAdd(C);
  for (t = 0; t < e; t++) {
    var q = x.redSqr(), N = L.redSqr(), F = N.redSqr(), ae = q.redAdd(q).redIAdd(q).redIAdd(w.redMul(Y)), he = x.redMul(N), tt = ae.redSqr().redISub(he.redAdd(he)), br = he.redISub(tt), rt = ae.redMul(br);
    rt = rt.redIAdd(rt).redISub(F);
    var dr = L.redMul(D);
    t + 1 < e && (Y = Y.redMul(F)), x = tt, D = dr, L = rt;
  }
  return this.curve.jpoint(x, L.redMul(T), D);
};
JPoint.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint.prototype._zeroDbl = function() {
  var e, t, v;
  if (this.zOne) {
    var w = this.x.redSqr(), T = this.y.redSqr(), x = T.redSqr(), C = this.x.redAdd(T).redSqr().redISub(w).redISub(x);
    C = C.redIAdd(C);
    var D = w.redAdd(w).redIAdd(w), Y = D.redSqr().redISub(C).redISub(C), L = x.redIAdd(x);
    L = L.redIAdd(L), L = L.redIAdd(L), e = Y, t = D.redMul(C.redISub(Y)).redISub(L), v = this.y.redAdd(this.y);
  } else {
    var q = this.x.redSqr(), N = this.y.redSqr(), F = N.redSqr(), ae = this.x.redAdd(N).redSqr().redISub(q).redISub(F);
    ae = ae.redIAdd(ae);
    var he = q.redAdd(q).redIAdd(q), tt = he.redSqr(), br = F.redIAdd(F);
    br = br.redIAdd(br), br = br.redIAdd(br), e = tt.redISub(ae).redISub(ae), t = he.redMul(ae.redISub(e)).redISub(br), v = this.y.redMul(this.z), v = v.redIAdd(v);
  }
  return this.curve.jpoint(e, t, v);
};
JPoint.prototype._threeDbl = function() {
  var e, t, v;
  if (this.zOne) {
    var w = this.x.redSqr(), T = this.y.redSqr(), x = T.redSqr(), C = this.x.redAdd(T).redSqr().redISub(w).redISub(x);
    C = C.redIAdd(C);
    var D = w.redAdd(w).redIAdd(w).redIAdd(this.curve.a), Y = D.redSqr().redISub(C).redISub(C);
    e = Y;
    var L = x.redIAdd(x);
    L = L.redIAdd(L), L = L.redIAdd(L), t = D.redMul(C.redISub(Y)).redISub(L), v = this.y.redAdd(this.y);
  } else {
    var q = this.z.redSqr(), N = this.y.redSqr(), F = this.x.redMul(N), ae = this.x.redSub(q).redMul(this.x.redAdd(q));
    ae = ae.redAdd(ae).redIAdd(ae);
    var he = F.redIAdd(F);
    he = he.redIAdd(he);
    var tt = he.redAdd(he);
    e = ae.redSqr().redISub(tt), v = this.y.redAdd(this.z).redSqr().redISub(N).redISub(q);
    var br = N.redSqr();
    br = br.redIAdd(br), br = br.redIAdd(br), br = br.redIAdd(br), t = ae.redMul(he.redISub(e)).redISub(br);
  }
  return this.curve.jpoint(e, t, v);
};
JPoint.prototype._dbl = function() {
  var e = this.curve.a, t = this.x, v = this.y, w = this.z, T = w.redSqr().redSqr(), x = t.redSqr(), C = v.redSqr(), D = x.redAdd(x).redIAdd(x).redIAdd(e.redMul(T)), Y = t.redAdd(t);
  Y = Y.redIAdd(Y);
  var L = Y.redMul(C), q = D.redSqr().redISub(L.redAdd(L)), N = L.redISub(q), F = C.redSqr();
  F = F.redIAdd(F), F = F.redIAdd(F), F = F.redIAdd(F);
  var ae = D.redMul(N).redISub(F), he = v.redAdd(v).redMul(w);
  return this.curve.jpoint(q, ae, he);
};
JPoint.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), t = this.y.redSqr(), v = this.z.redSqr(), w = t.redSqr(), T = e.redAdd(e).redIAdd(e), x = T.redSqr(), C = this.x.redAdd(t).redSqr().redISub(e).redISub(w);
  C = C.redIAdd(C), C = C.redAdd(C).redIAdd(C), C = C.redISub(x);
  var D = C.redSqr(), Y = w.redIAdd(w);
  Y = Y.redIAdd(Y), Y = Y.redIAdd(Y), Y = Y.redIAdd(Y);
  var L = T.redIAdd(C).redSqr().redISub(x).redISub(D).redISub(Y), q = t.redMul(L);
  q = q.redIAdd(q), q = q.redIAdd(q);
  var N = this.x.redMul(D).redISub(q);
  N = N.redIAdd(N), N = N.redIAdd(N);
  var F = this.y.redMul(L.redMul(Y.redISub(L)).redISub(C.redMul(D)));
  F = F.redIAdd(F), F = F.redIAdd(F), F = F.redIAdd(F);
  var ae = this.z.redAdd(C).redSqr().redISub(v).redISub(D);
  return this.curve.jpoint(N, F, ae);
};
JPoint.prototype.mul = function(e, t) {
  return e = new BN$8(e, t), this.curve._wnafMul(this, e);
};
JPoint.prototype.eq = function(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var t = this.z.redSqr(), v = e.z.redSqr();
  if (this.x.redMul(v).redISub(e.x.redMul(t)).cmpn(0) !== 0)
    return !1;
  var w = t.redMul(this.z), T = v.redMul(e.z);
  return this.y.redMul(T).redISub(e.y.redMul(w)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function(e) {
  var t = this.z.redSqr(), v = e.toRed(this.curve.red).redMul(t);
  if (this.x.cmp(v) === 0)
    return !0;
  for (var w = e.clone(), T = this.curve.redN.redMul(t); ; ) {
    if (w.iadd(this.curve.n), w.cmp(this.curve.p) >= 0)
      return !1;
    if (v.redIAdd(T), this.x.cmp(v) === 0)
      return !0;
  }
};
JPoint.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var BN$7 = bnExports$1, inherits$3 = inherits_browserExports, Base$1 = base$1, utils$h = utils$l;
function MontCurve(e) {
  Base$1.call(this, "mont", e), this.a = new BN$7(e.a, 16).toRed(this.red), this.b = new BN$7(e.b, 16).toRed(this.red), this.i4 = new BN$7(4).toRed(this.red).redInvm(), this.two = new BN$7(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$3(MontCurve, Base$1);
var mont = MontCurve;
MontCurve.prototype.validate = function(e) {
  var t = e.normalize().x, v = t.redSqr(), w = v.redMul(t).redAdd(v.redMul(this.a)).redAdd(t), T = w.redSqrt();
  return T.redSqr().cmp(w) === 0;
};
function Point$1(e, t, v) {
  Base$1.BasePoint.call(this, e, "projective"), t === null && v === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN$7(t, 16), this.z = new BN$7(v, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
inherits$3(Point$1, Base$1.BasePoint);
MontCurve.prototype.decodePoint = function(e, t) {
  return this.point(utils$h.toArray(e, t), 1);
};
MontCurve.prototype.point = function(e, t) {
  return new Point$1(this, e, t);
};
MontCurve.prototype.pointFromJSON = function(e) {
  return Point$1.fromJSON(this, e);
};
Point$1.prototype.precompute = function() {
};
Point$1.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$1.fromJSON = function(e, t) {
  return new Point$1(e, t[0], t[1] || e.one);
};
Point$1.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
Point$1.prototype.dbl = function() {
  var e = this.x.redAdd(this.z), t = e.redSqr(), v = this.x.redSub(this.z), w = v.redSqr(), T = t.redSub(w), x = t.redMul(w), C = T.redMul(w.redAdd(this.curve.a24.redMul(T)));
  return this.curve.point(x, C);
};
Point$1.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.diffAdd = function(e, t) {
  var v = this.x.redAdd(this.z), w = this.x.redSub(this.z), T = e.x.redAdd(e.z), x = e.x.redSub(e.z), C = x.redMul(v), D = T.redMul(w), Y = t.z.redMul(C.redAdd(D).redSqr()), L = t.x.redMul(C.redISub(D).redSqr());
  return this.curve.point(Y, L);
};
Point$1.prototype.mul = function(e) {
  for (var t = e.clone(), v = this, w = this.curve.point(null, null), T = this, x = []; t.cmpn(0) !== 0; t.iushrn(1))
    x.push(t.andln(1));
  for (var C = x.length - 1; C >= 0; C--)
    x[C] === 0 ? (v = v.diffAdd(w, T), w = w.dbl()) : (w = v.diffAdd(w, T), v = v.dbl());
  return w;
};
Point$1.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.eq = function(e) {
  return this.getX().cmp(e.getX()) === 0;
};
Point$1.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Point$1.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var utils$g = utils$l, BN$6 = bnExports$1, inherits$2 = inherits_browserExports, Base = base$1, assert$b = utils$g.assert;
function EdwardsCurve(e) {
  this.twisted = (e.a | 0) !== 1, this.mOneA = this.twisted && (e.a | 0) === -1, this.extended = this.mOneA, Base.call(this, "edwards", e), this.a = new BN$6(e.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN$6(e.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN$6(e.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert$b(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (e.c | 0) === 1;
}
inherits$2(EdwardsCurve, Base);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function(e) {
  return this.mOneA ? e.redNeg() : this.a.redMul(e);
};
EdwardsCurve.prototype._mulC = function(e) {
  return this.oneC ? e : this.c.redMul(e);
};
EdwardsCurve.prototype.jpoint = function(e, t, v, w) {
  return this.point(e, t, v, w);
};
EdwardsCurve.prototype.pointFromX = function(e, t) {
  e = new BN$6(e, 16), e.red || (e = e.toRed(this.red));
  var v = e.redSqr(), w = this.c2.redSub(this.a.redMul(v)), T = this.one.redSub(this.c2.redMul(this.d).redMul(v)), x = w.redMul(T.redInvm()), C = x.redSqrt();
  if (C.redSqr().redSub(x).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var D = C.fromRed().isOdd();
  return (t && !D || !t && D) && (C = C.redNeg()), this.point(e, C);
};
EdwardsCurve.prototype.pointFromY = function(e, t) {
  e = new BN$6(e, 16), e.red || (e = e.toRed(this.red));
  var v = e.redSqr(), w = v.redSub(this.c2), T = v.redMul(this.d).redMul(this.c2).redSub(this.a), x = w.redMul(T.redInvm());
  if (x.cmp(this.zero) === 0) {
    if (t)
      throw new Error("invalid point");
    return this.point(this.zero, e);
  }
  var C = x.redSqrt();
  if (C.redSqr().redSub(x).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return C.fromRed().isOdd() !== t && (C = C.redNeg()), this.point(C, e);
};
EdwardsCurve.prototype.validate = function(e) {
  if (e.isInfinity())
    return !0;
  e.normalize();
  var t = e.x.redSqr(), v = e.y.redSqr(), w = t.redMul(this.a).redAdd(v), T = this.c2.redMul(this.one.redAdd(this.d.redMul(t).redMul(v)));
  return w.cmp(T) === 0;
};
function Point(e, t, v, w, T) {
  Base.BasePoint.call(this, e, "projective"), t === null && v === null && w === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN$6(t, 16), this.y = new BN$6(v, 16), this.z = w ? new BN$6(w, 16) : this.curve.one, this.t = T && new BN$6(T, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
inherits$2(Point, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function(e) {
  return Point.fromJSON(this, e);
};
EdwardsCurve.prototype.point = function(e, t, v, w) {
  return new Point(this, e, t, v, w);
};
Point.fromJSON = function(e, t) {
  return new Point(e, t[0], t[1], t[2]);
};
Point.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function() {
  var e = this.x.redSqr(), t = this.y.redSqr(), v = this.z.redSqr();
  v = v.redIAdd(v);
  var w = this.curve._mulA(e), T = this.x.redAdd(this.y).redSqr().redISub(e).redISub(t), x = w.redAdd(t), C = x.redSub(v), D = w.redSub(t), Y = T.redMul(C), L = x.redMul(D), q = T.redMul(D), N = C.redMul(x);
  return this.curve.point(Y, L, N, q);
};
Point.prototype._projDbl = function() {
  var e = this.x.redAdd(this.y).redSqr(), t = this.x.redSqr(), v = this.y.redSqr(), w, T, x, C, D, Y;
  if (this.curve.twisted) {
    C = this.curve._mulA(t);
    var L = C.redAdd(v);
    this.zOne ? (w = e.redSub(t).redSub(v).redMul(L.redSub(this.curve.two)), T = L.redMul(C.redSub(v)), x = L.redSqr().redSub(L).redSub(L)) : (D = this.z.redSqr(), Y = L.redSub(D).redISub(D), w = e.redSub(t).redISub(v).redMul(Y), T = L.redMul(C.redSub(v)), x = L.redMul(Y));
  } else
    C = t.redAdd(v), D = this.curve._mulC(this.z).redSqr(), Y = C.redSub(D).redSub(D), w = this.curve._mulC(e.redISub(C)).redMul(Y), T = this.curve._mulC(C).redMul(t.redISub(v)), x = C.redMul(Y);
  return this.curve.point(w, T, x);
};
Point.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
Point.prototype._extAdd = function(e) {
  var t = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), v = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), w = this.t.redMul(this.curve.dd).redMul(e.t), T = this.z.redMul(e.z.redAdd(e.z)), x = v.redSub(t), C = T.redSub(w), D = T.redAdd(w), Y = v.redAdd(t), L = x.redMul(C), q = D.redMul(Y), N = x.redMul(Y), F = C.redMul(D);
  return this.curve.point(L, q, F, N);
};
Point.prototype._projAdd = function(e) {
  var t = this.z.redMul(e.z), v = t.redSqr(), w = this.x.redMul(e.x), T = this.y.redMul(e.y), x = this.curve.d.redMul(w).redMul(T), C = v.redSub(x), D = v.redAdd(x), Y = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(w).redISub(T), L = t.redMul(C).redMul(Y), q, N;
  return this.curve.twisted ? (q = t.redMul(D).redMul(T.redSub(this.curve._mulA(w))), N = C.redMul(D)) : (q = t.redMul(D).redMul(T.redSub(w)), N = this.curve._mulC(C).redMul(D)), this.curve.point(L, q, N);
};
Point.prototype.add = function(e) {
  return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
};
Point.prototype.mul = function(e) {
  return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
};
Point.prototype.mulAdd = function(e, t, v) {
  return this.curve._wnafMulAdd(1, [this, t], [e, v], 2, !1);
};
Point.prototype.jmulAdd = function(e, t, v) {
  return this.curve._wnafMulAdd(1, [this, t], [e, v], 2, !0);
};
Point.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var e = this.z.redInvm();
  return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this;
};
Point.prototype.neg = function() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
Point.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
Point.prototype.eq = function(e) {
  return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
};
Point.prototype.eqXToP = function(e) {
  var t = e.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(t) === 0)
    return !0;
  for (var v = e.clone(), w = this.curve.redN.redMul(this.z); ; ) {
    if (v.iadd(this.curve.n), v.cmp(this.curve.p) >= 0)
      return !1;
    if (t.redIAdd(w), this.x.cmp(t) === 0)
      return !0;
  }
};
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;
(function(e) {
  var t = e;
  t.base = base$1, t.short = short, t.mont = mont, t.edwards = edwards;
})(curve);
var curves$1 = {}, hash$2 = {}, utils$f = {}, assert$a = minimalisticAssert, inherits$1 = inherits_browserExports;
utils$f.inherits = inherits$1;
function isSurrogatePair(e, t) {
  return (e.charCodeAt(t) & 64512) !== 55296 || t < 0 || t + 1 >= e.length ? !1 : (e.charCodeAt(t + 1) & 64512) === 56320;
}
function toArray(e, t) {
  if (Array.isArray(e))
    return e.slice();
  if (!e)
    return [];
  var v = [];
  if (typeof e == "string")
    if (t) {
      if (t === "hex")
        for (e = e.replace(/[^a-z0-9]+/ig, ""), e.length % 2 !== 0 && (e = "0" + e), T = 0; T < e.length; T += 2)
          v.push(parseInt(e[T] + e[T + 1], 16));
    } else for (var w = 0, T = 0; T < e.length; T++) {
      var x = e.charCodeAt(T);
      x < 128 ? v[w++] = x : x < 2048 ? (v[w++] = x >> 6 | 192, v[w++] = x & 63 | 128) : isSurrogatePair(e, T) ? (x = 65536 + ((x & 1023) << 10) + (e.charCodeAt(++T) & 1023), v[w++] = x >> 18 | 240, v[w++] = x >> 12 & 63 | 128, v[w++] = x >> 6 & 63 | 128, v[w++] = x & 63 | 128) : (v[w++] = x >> 12 | 224, v[w++] = x >> 6 & 63 | 128, v[w++] = x & 63 | 128);
    }
  else
    for (T = 0; T < e.length; T++)
      v[T] = e[T] | 0;
  return v;
}
utils$f.toArray = toArray;
function toHex(e) {
  for (var t = "", v = 0; v < e.length; v++)
    t += zero2(e[v].toString(16));
  return t;
}
utils$f.toHex = toHex;
function htonl(e) {
  var t = e >>> 24 | e >>> 8 & 65280 | e << 8 & 16711680 | (e & 255) << 24;
  return t >>> 0;
}
utils$f.htonl = htonl;
function toHex32(e, t) {
  for (var v = "", w = 0; w < e.length; w++) {
    var T = e[w];
    t === "little" && (T = htonl(T)), v += zero8(T.toString(16));
  }
  return v;
}
utils$f.toHex32 = toHex32;
function zero2(e) {
  return e.length === 1 ? "0" + e : e;
}
utils$f.zero2 = zero2;
function zero8(e) {
  return e.length === 7 ? "0" + e : e.length === 6 ? "00" + e : e.length === 5 ? "000" + e : e.length === 4 ? "0000" + e : e.length === 3 ? "00000" + e : e.length === 2 ? "000000" + e : e.length === 1 ? "0000000" + e : e;
}
utils$f.zero8 = zero8;
function join32(e, t, v, w) {
  var T = v - t;
  assert$a(T % 4 === 0);
  for (var x = new Array(T / 4), C = 0, D = t; C < x.length; C++, D += 4) {
    var Y;
    w === "big" ? Y = e[D] << 24 | e[D + 1] << 16 | e[D + 2] << 8 | e[D + 3] : Y = e[D + 3] << 24 | e[D + 2] << 16 | e[D + 1] << 8 | e[D], x[C] = Y >>> 0;
  }
  return x;
}
utils$f.join32 = join32;
function split32(e, t) {
  for (var v = new Array(e.length * 4), w = 0, T = 0; w < e.length; w++, T += 4) {
    var x = e[w];
    t === "big" ? (v[T] = x >>> 24, v[T + 1] = x >>> 16 & 255, v[T + 2] = x >>> 8 & 255, v[T + 3] = x & 255) : (v[T + 3] = x >>> 24, v[T + 2] = x >>> 16 & 255, v[T + 1] = x >>> 8 & 255, v[T] = x & 255);
  }
  return v;
}
utils$f.split32 = split32;
function rotr32$1(e, t) {
  return e >>> t | e << 32 - t;
}
utils$f.rotr32 = rotr32$1;
function rotl32$2(e, t) {
  return e << t | e >>> 32 - t;
}
utils$f.rotl32 = rotl32$2;
function sum32$3(e, t) {
  return e + t >>> 0;
}
utils$f.sum32 = sum32$3;
function sum32_3$1(e, t, v) {
  return e + t + v >>> 0;
}
utils$f.sum32_3 = sum32_3$1;
function sum32_4$2(e, t, v, w) {
  return e + t + v + w >>> 0;
}
utils$f.sum32_4 = sum32_4$2;
function sum32_5$2(e, t, v, w, T) {
  return e + t + v + w + T >>> 0;
}
utils$f.sum32_5 = sum32_5$2;
function sum64$1(e, t, v, w) {
  var T = e[t], x = e[t + 1], C = w + x >>> 0, D = (C < w ? 1 : 0) + v + T;
  e[t] = D >>> 0, e[t + 1] = C;
}
utils$f.sum64 = sum64$1;
function sum64_hi$1(e, t, v, w) {
  var T = t + w >>> 0, x = (T < t ? 1 : 0) + e + v;
  return x >>> 0;
}
utils$f.sum64_hi = sum64_hi$1;
function sum64_lo$1(e, t, v, w) {
  var T = t + w;
  return T >>> 0;
}
utils$f.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(e, t, v, w, T, x, C, D) {
  var Y = 0, L = t;
  L = L + w >>> 0, Y += L < t ? 1 : 0, L = L + x >>> 0, Y += L < x ? 1 : 0, L = L + D >>> 0, Y += L < D ? 1 : 0;
  var q = e + v + T + C + Y;
  return q >>> 0;
}
utils$f.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(e, t, v, w, T, x, C, D) {
  var Y = t + w + x + D;
  return Y >>> 0;
}
utils$f.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(e, t, v, w, T, x, C, D, Y, L) {
  var q = 0, N = t;
  N = N + w >>> 0, q += N < t ? 1 : 0, N = N + x >>> 0, q += N < x ? 1 : 0, N = N + D >>> 0, q += N < D ? 1 : 0, N = N + L >>> 0, q += N < L ? 1 : 0;
  var F = e + v + T + C + Y + q;
  return F >>> 0;
}
utils$f.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(e, t, v, w, T, x, C, D, Y, L) {
  var q = t + w + x + D + L;
  return q >>> 0;
}
utils$f.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(e, t, v) {
  var w = t << 32 - v | e >>> v;
  return w >>> 0;
}
utils$f.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(e, t, v) {
  var w = e << 32 - v | t >>> v;
  return w >>> 0;
}
utils$f.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(e, t, v) {
  return e >>> v;
}
utils$f.shr64_hi = shr64_hi$1;
function shr64_lo$1(e, t, v) {
  var w = e << 32 - v | t >>> v;
  return w >>> 0;
}
utils$f.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$e = utils$f, assert$9 = minimalisticAssert;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function(e, t) {
  if (e = utils$e.toArray(e, t), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
    e = this.pending;
    var v = e.length % this._delta8;
    this.pending = e.slice(e.length - v, e.length), this.pending.length === 0 && (this.pending = null), e = utils$e.join32(e, 0, e.length - v, this.endian);
    for (var w = 0; w < e.length; w += this._delta32)
      this._update(e, w, w + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function(e) {
  return this.update(this._pad()), assert$9(this.pending === null), this._digest(e);
};
BlockHash$4.prototype._pad = function() {
  var e = this.pendingTotal, t = this._delta8, v = t - (e + this.padLength) % t, w = new Array(v + this.padLength);
  w[0] = 128;
  for (var T = 1; T < v; T++)
    w[T] = 0;
  if (e <<= 3, this.endian === "big") {
    for (var x = 8; x < this.padLength; x++)
      w[T++] = 0;
    w[T++] = 0, w[T++] = 0, w[T++] = 0, w[T++] = 0, w[T++] = e >>> 24 & 255, w[T++] = e >>> 16 & 255, w[T++] = e >>> 8 & 255, w[T++] = e & 255;
  } else
    for (w[T++] = e & 255, w[T++] = e >>> 8 & 255, w[T++] = e >>> 16 & 255, w[T++] = e >>> 24 & 255, w[T++] = 0, w[T++] = 0, w[T++] = 0, w[T++] = 0, x = 8; x < this.padLength; x++)
      w[T++] = 0;
  return w;
};
var sha = {}, common$4 = {}, utils$d = utils$f, rotr32 = utils$d.rotr32;
function ft_1$1(e, t, v, w) {
  if (e === 0)
    return ch32$1(t, v, w);
  if (e === 1 || e === 3)
    return p32(t, v, w);
  if (e === 2)
    return maj32$1(t, v, w);
}
common$4.ft_1 = ft_1$1;
function ch32$1(e, t, v) {
  return e & t ^ ~e & v;
}
common$4.ch32 = ch32$1;
function maj32$1(e, t, v) {
  return e & t ^ e & v ^ t & v;
}
common$4.maj32 = maj32$1;
function p32(e, t, v) {
  return e ^ t ^ v;
}
common$4.p32 = p32;
function s0_256$1(e) {
  return rotr32(e, 2) ^ rotr32(e, 13) ^ rotr32(e, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(e) {
  return rotr32(e, 6) ^ rotr32(e, 11) ^ rotr32(e, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(e) {
  return rotr32(e, 7) ^ rotr32(e, 18) ^ e >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(e) {
  return rotr32(e, 17) ^ rotr32(e, 19) ^ e >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$c = utils$f, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$c.rotl32, sum32$2 = utils$c.sum32, sum32_5$1 = utils$c.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
utils$c.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function(e, t) {
  for (var v = this.W, w = 0; w < 16; w++)
    v[w] = e[t + w];
  for (; w < v.length; w++)
    v[w] = rotl32$1(v[w - 3] ^ v[w - 8] ^ v[w - 14] ^ v[w - 16], 1);
  var T = this.h[0], x = this.h[1], C = this.h[2], D = this.h[3], Y = this.h[4];
  for (w = 0; w < v.length; w++) {
    var L = ~~(w / 20), q = sum32_5$1(rotl32$1(T, 5), ft_1(L, x, C, D), Y, v[w], sha1_K[L]);
    Y = D, D = C, C = rotl32$1(x, 30), x = T, T = q;
  }
  this.h[0] = sum32$2(this.h[0], T), this.h[1] = sum32$2(this.h[1], x), this.h[2] = sum32$2(this.h[2], C), this.h[3] = sum32$2(this.h[3], D), this.h[4] = sum32$2(this.h[4], Y);
};
SHA1.prototype._digest = function(e) {
  return e === "hex" ? utils$c.toHex32(this.h, "big") : utils$c.split32(this.h, "big");
};
var utils$b = utils$f, common$2 = common$5, shaCommon = common$4, assert$8 = minimalisticAssert, sum32$1 = utils$b.sum32, sum32_4$1 = utils$b.sum32_4, sum32_5 = utils$b.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = sha256_K, this.W = new Array(64);
}
utils$b.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function(e, t) {
  for (var v = this.W, w = 0; w < 16; w++)
    v[w] = e[t + w];
  for (; w < v.length; w++)
    v[w] = sum32_4$1(g1_256(v[w - 2]), v[w - 7], g0_256(v[w - 15]), v[w - 16]);
  var T = this.h[0], x = this.h[1], C = this.h[2], D = this.h[3], Y = this.h[4], L = this.h[5], q = this.h[6], N = this.h[7];
  for (assert$8(this.k.length === v.length), w = 0; w < v.length; w++) {
    var F = sum32_5(N, s1_256(Y), ch32(Y, L, q), this.k[w], v[w]), ae = sum32$1(s0_256(T), maj32(T, x, C));
    N = q, q = L, L = Y, Y = sum32$1(D, F), D = C, C = x, x = T, T = sum32$1(F, ae);
  }
  this.h[0] = sum32$1(this.h[0], T), this.h[1] = sum32$1(this.h[1], x), this.h[2] = sum32$1(this.h[2], C), this.h[3] = sum32$1(this.h[3], D), this.h[4] = sum32$1(this.h[4], Y), this.h[5] = sum32$1(this.h[5], L), this.h[6] = sum32$1(this.h[6], q), this.h[7] = sum32$1(this.h[7], N);
};
SHA256$1.prototype._digest = function(e) {
  return e === "hex" ? utils$b.toHex32(this.h, "big") : utils$b.split32(this.h, "big");
};
var utils$a = utils$f, SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$a.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function(e) {
  return e === "hex" ? utils$a.toHex32(this.h.slice(0, 7), "big") : utils$a.split32(this.h.slice(0, 7), "big");
};
var utils$9 = utils$f, common$1 = common$5, assert$7 = minimalisticAssert, rotr64_hi = utils$9.rotr64_hi, rotr64_lo = utils$9.rotr64_lo, shr64_hi = utils$9.shr64_hi, shr64_lo = utils$9.shr64_lo, sum64 = utils$9.sum64, sum64_hi = utils$9.sum64_hi, sum64_lo = utils$9.sum64_lo, sum64_4_hi = utils$9.sum64_4_hi, sum64_4_lo = utils$9.sum64_4_lo, sum64_5_hi = utils$9.sum64_5_hi, sum64_5_lo = utils$9.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = sha512_K, this.W = new Array(160);
}
utils$9.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function(e, t) {
  for (var v = this.W, w = 0; w < 32; w++)
    v[w] = e[t + w];
  for (; w < v.length; w += 2) {
    var T = g1_512_hi(v[w - 4], v[w - 3]), x = g1_512_lo(v[w - 4], v[w - 3]), C = v[w - 14], D = v[w - 13], Y = g0_512_hi(v[w - 30], v[w - 29]), L = g0_512_lo(v[w - 30], v[w - 29]), q = v[w - 32], N = v[w - 31];
    v[w] = sum64_4_hi(
      T,
      x,
      C,
      D,
      Y,
      L,
      q,
      N
    ), v[w + 1] = sum64_4_lo(
      T,
      x,
      C,
      D,
      Y,
      L,
      q,
      N
    );
  }
};
SHA512$1.prototype._update = function(e, t) {
  this._prepareBlock(e, t);
  var v = this.W, w = this.h[0], T = this.h[1], x = this.h[2], C = this.h[3], D = this.h[4], Y = this.h[5], L = this.h[6], q = this.h[7], N = this.h[8], F = this.h[9], ae = this.h[10], he = this.h[11], tt = this.h[12], br = this.h[13], rt = this.h[14], dr = this.h[15];
  assert$7(this.k.length === v.length);
  for (var _r = 0; _r < v.length; _r += 2) {
    var Bi = rt, qi = dr, Wi = s1_512_hi(N, F), Vi = s1_512_lo(N, F), Ti = ch64_hi(N, F, ae, he, tt), Li = ch64_lo(N, F, ae, he, tt, br), Hi = this.k[_r], pr = this.k[_r + 1], Di = v[_r], z = v[_r + 1], gr = sum64_5_hi(
      Bi,
      qi,
      Wi,
      Vi,
      Ti,
      Li,
      Hi,
      pr,
      Di,
      z
    ), vr = sum64_5_lo(
      Bi,
      qi,
      Wi,
      Vi,
      Ti,
      Li,
      Hi,
      pr,
      Di,
      z
    );
    Bi = s0_512_hi(w, T), qi = s0_512_lo(w, T), Wi = maj64_hi(w, T, x, C, D), Vi = maj64_lo(w, T, x, C, D, Y);
    var Oi = sum64_hi(Bi, qi, Wi, Vi), Mi = sum64_lo(Bi, qi, Wi, Vi);
    rt = tt, dr = br, tt = ae, br = he, ae = N, he = F, N = sum64_hi(L, q, gr, vr), F = sum64_lo(q, q, gr, vr), L = D, q = Y, D = x, Y = C, x = w, C = T, w = sum64_hi(gr, vr, Oi, Mi), T = sum64_lo(gr, vr, Oi, Mi);
  }
  sum64(this.h, 0, w, T), sum64(this.h, 2, x, C), sum64(this.h, 4, D, Y), sum64(this.h, 6, L, q), sum64(this.h, 8, N, F), sum64(this.h, 10, ae, he), sum64(this.h, 12, tt, br), sum64(this.h, 14, rt, dr);
};
SHA512$1.prototype._digest = function(e) {
  return e === "hex" ? utils$9.toHex32(this.h, "big") : utils$9.split32(this.h, "big");
};
function ch64_hi(e, t, v, w, T) {
  var x = e & v ^ ~e & T;
  return x < 0 && (x += 4294967296), x;
}
function ch64_lo(e, t, v, w, T, x) {
  var C = t & w ^ ~t & x;
  return C < 0 && (C += 4294967296), C;
}
function maj64_hi(e, t, v, w, T) {
  var x = e & v ^ e & T ^ v & T;
  return x < 0 && (x += 4294967296), x;
}
function maj64_lo(e, t, v, w, T, x) {
  var C = t & w ^ t & x ^ w & x;
  return C < 0 && (C += 4294967296), C;
}
function s0_512_hi(e, t) {
  var v = rotr64_hi(e, t, 28), w = rotr64_hi(t, e, 2), T = rotr64_hi(t, e, 7), x = v ^ w ^ T;
  return x < 0 && (x += 4294967296), x;
}
function s0_512_lo(e, t) {
  var v = rotr64_lo(e, t, 28), w = rotr64_lo(t, e, 2), T = rotr64_lo(t, e, 7), x = v ^ w ^ T;
  return x < 0 && (x += 4294967296), x;
}
function s1_512_hi(e, t) {
  var v = rotr64_hi(e, t, 14), w = rotr64_hi(e, t, 18), T = rotr64_hi(t, e, 9), x = v ^ w ^ T;
  return x < 0 && (x += 4294967296), x;
}
function s1_512_lo(e, t) {
  var v = rotr64_lo(e, t, 14), w = rotr64_lo(e, t, 18), T = rotr64_lo(t, e, 9), x = v ^ w ^ T;
  return x < 0 && (x += 4294967296), x;
}
function g0_512_hi(e, t) {
  var v = rotr64_hi(e, t, 1), w = rotr64_hi(e, t, 8), T = shr64_hi(e, t, 7), x = v ^ w ^ T;
  return x < 0 && (x += 4294967296), x;
}
function g0_512_lo(e, t) {
  var v = rotr64_lo(e, t, 1), w = rotr64_lo(e, t, 8), T = shr64_lo(e, t, 7), x = v ^ w ^ T;
  return x < 0 && (x += 4294967296), x;
}
function g1_512_hi(e, t) {
  var v = rotr64_hi(e, t, 19), w = rotr64_hi(t, e, 29), T = shr64_hi(e, t, 6), x = v ^ w ^ T;
  return x < 0 && (x += 4294967296), x;
}
function g1_512_lo(e, t) {
  var v = rotr64_lo(e, t, 19), w = rotr64_lo(t, e, 29), T = shr64_lo(e, t, 6), x = v ^ w ^ T;
  return x < 0 && (x += 4294967296), x;
}
var utils$8 = utils$f, SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$8.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function(e) {
  return e === "hex" ? utils$8.toHex32(this.h.slice(0, 12), "big") : utils$8.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {}, utils$7 = utils$f, common = common$5, rotl32 = utils$7.rotl32, sum32 = utils$7.sum32, sum32_3 = utils$7.sum32_3, sum32_4 = utils$7.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
utils$7.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function(e, t) {
  for (var v = this.h[0], w = this.h[1], T = this.h[2], x = this.h[3], C = this.h[4], D = v, Y = w, L = T, q = x, N = C, F = 0; F < 80; F++) {
    var ae = sum32(
      rotl32(
        sum32_4(v, f(F, w, T, x), e[r[F] + t], K(F)),
        s[F]
      ),
      C
    );
    v = C, C = x, x = rotl32(T, 10), T = w, w = ae, ae = sum32(
      rotl32(
        sum32_4(D, f(79 - F, Y, L, q), e[rh[F] + t], Kh(F)),
        sh[F]
      ),
      N
    ), D = N, N = q, q = rotl32(L, 10), L = Y, Y = ae;
  }
  ae = sum32_3(this.h[1], T, q), this.h[1] = sum32_3(this.h[2], x, N), this.h[2] = sum32_3(this.h[3], C, D), this.h[3] = sum32_3(this.h[4], v, Y), this.h[4] = sum32_3(this.h[0], w, L), this.h[0] = ae;
};
RIPEMD160.prototype._digest = function(e) {
  return e === "hex" ? utils$7.toHex32(this.h, "little") : utils$7.split32(this.h, "little");
};
function f(e, t, v, w) {
  return e <= 15 ? t ^ v ^ w : e <= 31 ? t & v | ~t & w : e <= 47 ? (t | ~v) ^ w : e <= 63 ? t & w | v & ~w : t ^ (v | ~w);
}
function K(e) {
  return e <= 15 ? 0 : e <= 31 ? 1518500249 : e <= 47 ? 1859775393 : e <= 63 ? 2400959708 : 2840853838;
}
function Kh(e) {
  return e <= 15 ? 1352829926 : e <= 31 ? 1548603684 : e <= 47 ? 1836072691 : e <= 63 ? 2053994217 : 0;
}
var r = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], s = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], utils$6 = utils$f, assert$6 = minimalisticAssert;
function Hmac$1(e, t, v) {
  if (!(this instanceof Hmac$1))
    return new Hmac$1(e, t, v);
  this.Hash = e, this.blockSize = e.blockSize / 8, this.outSize = e.outSize / 8, this.inner = null, this.outer = null, this._init(utils$6.toArray(t, v));
}
var hmac = Hmac$1;
Hmac$1.prototype._init = function(e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()), assert$6(e.length <= this.blockSize);
  for (var t = e.length; t < this.blockSize; t++)
    e.push(0);
  for (t = 0; t < e.length; t++)
    e[t] ^= 54;
  for (this.inner = new this.Hash().update(e), t = 0; t < e.length; t++)
    e[t] ^= 106;
  this.outer = new this.Hash().update(e);
};
Hmac$1.prototype.update = function(e, t) {
  return this.inner.update(e, t), this;
};
Hmac$1.prototype.digest = function(e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function(e) {
  var t = e;
  t.utils = utils$f, t.common = common$5, t.sha = sha, t.ripemd = ripemd, t.hmac = hmac, t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
})(hash$2);
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
(function(e) {
  var t = e, v = hash$2, w = curve, T = utils$l, x = T.assert;
  function C(L) {
    L.type === "short" ? this.curve = new w.short(L) : L.type === "edwards" ? this.curve = new w.edwards(L) : this.curve = new w.mont(L), this.g = this.curve.g, this.n = this.curve.n, this.hash = L.hash, x(this.g.validate(), "Invalid curve"), x(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  t.PresetCurve = C;
  function D(L, q) {
    Object.defineProperty(t, L, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var N = new C(q);
        return Object.defineProperty(t, L, {
          configurable: !0,
          enumerable: !0,
          value: N
        }), N;
      }
    });
  }
  D("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: v.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), D("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: v.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), D("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: v.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), D("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: v.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), D("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: v.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), D("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: v.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), D("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: v.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var Y;
  try {
    Y = requireSecp256k1();
  } catch {
    Y = void 0;
  }
  D("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: v.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      Y
    ]
  });
})(curves$1);
var hash$1 = hash$2, utils$5 = utils$k, assert$5 = minimalisticAssert;
function HmacDRBG(e) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(e);
  this.hash = e.hash, this.predResist = !!e.predResist, this.outLen = this.hash.outSize, this.minEntropy = e.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var t = utils$5.toArray(e.entropy, e.entropyEnc || "hex"), v = utils$5.toArray(e.nonce, e.nonceEnc || "hex"), w = utils$5.toArray(e.pers, e.persEnc || "hex");
  assert$5(
    t.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(t, v, w);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function(e, t, v) {
  var w = e.concat(t).concat(v);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var T = 0; T < this.V.length; T++)
    this.K[T] = 0, this.V[T] = 1;
  this._update(w), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function() {
  return new hash$1.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function(e) {
  var t = this._hmac().update(this.V).update([0]);
  e && (t = t.update(e)), this.K = t.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG.prototype.reseed = function(e, t, v, w) {
  typeof t != "string" && (w = v, v = t, t = null), e = utils$5.toArray(e, t), v = utils$5.toArray(v, w), assert$5(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(v || [])), this._reseed = 1;
};
HmacDRBG.prototype.generate = function(e, t, v, w) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof t != "string" && (w = v, v = t, t = null), v && (v = utils$5.toArray(v, w || "hex"), this._update(v));
  for (var T = []; T.length < e; )
    this.V = this._hmac().update(this.V).digest(), T = T.concat(this.V);
  var x = T.slice(0, e);
  return this._update(v), this._reseed++, utils$5.encode(x, t);
};
var BN$5 = bnExports$1, utils$4 = utils$l, assert$4 = utils$4.assert;
function KeyPair$2(e, t) {
  this.ec = e, this.priv = null, this.pub = null, t.priv && this._importPrivate(t.priv, t.privEnc), t.pub && this._importPublic(t.pub, t.pubEnc);
}
var key$1 = KeyPair$2;
KeyPair$2.fromPublic = function(e, t, v) {
  return t instanceof KeyPair$2 ? t : new KeyPair$2(e, {
    pub: t,
    pubEnc: v
  });
};
KeyPair$2.fromPrivate = function(e, t, v) {
  return t instanceof KeyPair$2 ? t : new KeyPair$2(e, {
    priv: t,
    privEnc: v
  });
};
KeyPair$2.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair$2.prototype.getPublic = function(e, t) {
  return typeof e == "string" && (t = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), t ? this.pub.encode(t, e) : this.pub;
};
KeyPair$2.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair$2.prototype._importPrivate = function(e, t) {
  this.priv = new BN$5(e, t || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$2.prototype._importPublic = function(e, t) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? assert$4(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$4(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, t);
};
KeyPair$2.prototype.derive = function(e) {
  return e.validate() || assert$4(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
KeyPair$2.prototype.sign = function(e, t, v) {
  return this.ec.sign(e, this, t, v);
};
KeyPair$2.prototype.verify = function(e, t, v) {
  return this.ec.verify(e, t, this, void 0, v);
};
KeyPair$2.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$4 = bnExports$1, utils$3 = utils$l, assert$3 = utils$3.assert;
function Signature$2(e, t) {
  if (e instanceof Signature$2)
    return e;
  this._importDER(e, t) || (assert$3(e.r && e.s, "Signature without r or s"), this.r = new BN$4(e.r, 16), this.s = new BN$4(e.s, 16), e.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = e.recoveryParam);
}
var signature$1 = Signature$2;
function Position() {
  this.place = 0;
}
function getLength(e, t) {
  var v = e[t.place++];
  if (!(v & 128))
    return v;
  var w = v & 15;
  if (w === 0 || w > 4 || e[t.place] === 0)
    return !1;
  for (var T = 0, x = 0, C = t.place; x < w; x++, C++)
    T <<= 8, T |= e[C], T >>>= 0;
  return T <= 127 ? !1 : (t.place = C, T);
}
function rmPadding(e) {
  for (var t = 0, v = e.length - 1; !e[t] && !(e[t + 1] & 128) && t < v; )
    t++;
  return t === 0 ? e : e.slice(t);
}
Signature$2.prototype._importDER = function(e, t) {
  e = utils$3.toArray(e, t);
  var v = new Position();
  if (e[v.place++] !== 48)
    return !1;
  var w = getLength(e, v);
  if (w === !1 || w + v.place !== e.length || e[v.place++] !== 2)
    return !1;
  var T = getLength(e, v);
  if (T === !1 || e[v.place] & 128)
    return !1;
  var x = e.slice(v.place, T + v.place);
  if (v.place += T, e[v.place++] !== 2)
    return !1;
  var C = getLength(e, v);
  if (C === !1 || e.length !== C + v.place || e[v.place] & 128)
    return !1;
  var D = e.slice(v.place, C + v.place);
  if (x[0] === 0)
    if (x[1] & 128)
      x = x.slice(1);
    else
      return !1;
  if (D[0] === 0)
    if (D[1] & 128)
      D = D.slice(1);
    else
      return !1;
  return this.r = new BN$4(x), this.s = new BN$4(D), this.recoveryParam = null, !0;
};
function constructLength(e, t) {
  if (t < 128) {
    e.push(t);
    return;
  }
  var v = 1 + (Math.log(t) / Math.LN2 >>> 3);
  for (e.push(v | 128); --v; )
    e.push(t >>> (v << 3) & 255);
  e.push(t);
}
Signature$2.prototype.toDER = function(e) {
  var t = this.r.toArray(), v = this.s.toArray();
  for (t[0] & 128 && (t = [0].concat(t)), v[0] & 128 && (v = [0].concat(v)), t = rmPadding(t), v = rmPadding(v); !v[0] && !(v[1] & 128); )
    v = v.slice(1);
  var w = [2];
  constructLength(w, t.length), w = w.concat(t), w.push(2), constructLength(w, v.length);
  var T = w.concat(v), x = [48];
  return constructLength(x, T.length), x = x.concat(T), utils$3.encode(x, e);
};
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var e = bnExports$1, t = hmacDrbg, v = utils$l, w = curves$1, T = requireBrorand(), x = v.assert, C = key$1, D = signature$1;
  function Y(L) {
    if (!(this instanceof Y))
      return new Y(L);
    typeof L == "string" && (x(
      Object.prototype.hasOwnProperty.call(w, L),
      "Unknown curve " + L
    ), L = w[L]), L instanceof w.PresetCurve && (L = { curve: L }), this.curve = L.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = L.curve.g, this.g.precompute(L.curve.n.bitLength() + 1), this.hash = L.hash || L.curve.hash;
  }
  return ec = Y, Y.prototype.keyPair = function(L) {
    return new C(this, L);
  }, Y.prototype.keyFromPrivate = function(L, q) {
    return C.fromPrivate(this, L, q);
  }, Y.prototype.keyFromPublic = function(L, q) {
    return C.fromPublic(this, L, q);
  }, Y.prototype.genKeyPair = function(L) {
    L || (L = {});
    for (var q = new t({
      hash: this.hash,
      pers: L.pers,
      persEnc: L.persEnc || "utf8",
      entropy: L.entropy || T(this.hash.hmacStrength),
      entropyEnc: L.entropy && L.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), N = this.n.byteLength(), F = this.n.sub(new e(2)); ; ) {
      var ae = new e(q.generate(N));
      if (!(ae.cmp(F) > 0))
        return ae.iaddn(1), this.keyFromPrivate(ae);
    }
  }, Y.prototype._truncateToN = function(L, q, N) {
    var F;
    if (e.isBN(L) || typeof L == "number")
      L = new e(L, 16), F = L.byteLength();
    else if (typeof L == "object")
      F = L.length, L = new e(L, 16);
    else {
      var ae = L.toString();
      F = ae.length + 1 >>> 1, L = new e(ae, 16);
    }
    typeof N != "number" && (N = F * 8);
    var he = N - this.n.bitLength();
    return he > 0 && (L = L.ushrn(he)), !q && L.cmp(this.n) >= 0 ? L.sub(this.n) : L;
  }, Y.prototype.sign = function(L, q, N, F) {
    if (typeof N == "object" && (F = N, N = null), F || (F = {}), typeof L != "string" && typeof L != "number" && !e.isBN(L)) {
      x(
        typeof L == "object" && L && typeof L.length == "number",
        "Expected message to be an array-like, a hex string, or a BN instance"
      ), x(L.length >>> 0 === L.length);
      for (var ae = 0; ae < L.length; ae++) x((L[ae] & 255) === L[ae]);
    }
    q = this.keyFromPrivate(q, N), L = this._truncateToN(L, !1, F.msgBitLength), x(!L.isNeg(), "Can not sign a negative message");
    var he = this.n.byteLength(), tt = q.getPrivate().toArray("be", he), br = L.toArray("be", he);
    x(new e(br).eq(L), "Can not sign message");
    for (var rt = new t({
      hash: this.hash,
      entropy: tt,
      nonce: br,
      pers: F.pers,
      persEnc: F.persEnc || "utf8"
    }), dr = this.n.sub(new e(1)), _r = 0; ; _r++) {
      var Bi = F.k ? F.k(_r) : new e(rt.generate(this.n.byteLength()));
      if (Bi = this._truncateToN(Bi, !0), !(Bi.cmpn(1) <= 0 || Bi.cmp(dr) >= 0)) {
        var qi = this.g.mul(Bi);
        if (!qi.isInfinity()) {
          var Wi = qi.getX(), Vi = Wi.umod(this.n);
          if (Vi.cmpn(0) !== 0) {
            var Ti = Bi.invm(this.n).mul(Vi.mul(q.getPrivate()).iadd(L));
            if (Ti = Ti.umod(this.n), Ti.cmpn(0) !== 0) {
              var Li = (qi.getY().isOdd() ? 1 : 0) | (Wi.cmp(Vi) !== 0 ? 2 : 0);
              return F.canonical && Ti.cmp(this.nh) > 0 && (Ti = this.n.sub(Ti), Li ^= 1), new D({ r: Vi, s: Ti, recoveryParam: Li });
            }
          }
        }
      }
    }
  }, Y.prototype.verify = function(L, q, N, F, ae) {
    ae || (ae = {}), L = this._truncateToN(L, !1, ae.msgBitLength), N = this.keyFromPublic(N, F), q = new D(q, "hex");
    var he = q.r, tt = q.s;
    if (he.cmpn(1) < 0 || he.cmp(this.n) >= 0 || tt.cmpn(1) < 0 || tt.cmp(this.n) >= 0)
      return !1;
    var br = tt.invm(this.n), rt = br.mul(L).umod(this.n), dr = br.mul(he).umod(this.n), _r;
    return this.curve._maxwellTrick ? (_r = this.g.jmulAdd(rt, N.getPublic(), dr), _r.isInfinity() ? !1 : _r.eqXToP(he)) : (_r = this.g.mulAdd(rt, N.getPublic(), dr), _r.isInfinity() ? !1 : _r.getX().umod(this.n).cmp(he) === 0);
  }, Y.prototype.recoverPubKey = function(L, q, N, F) {
    x((3 & N) === N, "The recovery param is more than two bits"), q = new D(q, F);
    var ae = this.n, he = new e(L), tt = q.r, br = q.s, rt = N & 1, dr = N >> 1;
    if (tt.cmp(this.curve.p.umod(this.curve.n)) >= 0 && dr)
      throw new Error("Unable to find sencond key candinate");
    dr ? tt = this.curve.pointFromX(tt.add(this.curve.n), rt) : tt = this.curve.pointFromX(tt, rt);
    var _r = q.r.invm(ae), Bi = ae.sub(he).mul(_r).umod(ae), qi = br.mul(_r).umod(ae);
    return this.g.mulAdd(Bi, tt, qi);
  }, Y.prototype.getKeyRecoveryParam = function(L, q, N, F) {
    if (q = new D(q, F), q.recoveryParam !== null)
      return q.recoveryParam;
    for (var ae = 0; ae < 4; ae++) {
      var he;
      try {
        he = this.recoverPubKey(L, q, ae);
      } catch {
        continue;
      }
      if (he.eq(N))
        return ae;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var utils$2 = utils$l, assert$2 = utils$2.assert, parseBytes$2 = utils$2.parseBytes, cachedProperty$1 = utils$2.cachedProperty;
function KeyPair$1(e, t) {
  this.eddsa = e, this._secret = parseBytes$2(t.secret), e.isPoint(t.pub) ? this._pub = t.pub : this._pubBytes = parseBytes$2(t.pub);
}
KeyPair$1.fromPublic = function(e, t) {
  return t instanceof KeyPair$1 ? t : new KeyPair$1(e, { pub: t });
};
KeyPair$1.fromSecret = function(e, t) {
  return t instanceof KeyPair$1 ? t : new KeyPair$1(e, { secret: t });
};
KeyPair$1.prototype.secret = function() {
  return this._secret;
};
cachedProperty$1(KeyPair$1, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$1, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$1, "privBytes", function() {
  var e = this.eddsa, t = this.hash(), v = e.encodingLength - 1, w = t.slice(0, e.encodingLength);
  return w[0] &= 248, w[v] &= 127, w[v] |= 64, w;
});
cachedProperty$1(KeyPair$1, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$1, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$1, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$1.prototype.sign = function(e) {
  return assert$2(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
};
KeyPair$1.prototype.verify = function(e, t) {
  return this.eddsa.verify(e, t, this);
};
KeyPair$1.prototype.getSecret = function(e) {
  return assert$2(this._secret, "KeyPair is public only"), utils$2.encode(this.secret(), e);
};
KeyPair$1.prototype.getPublic = function(e) {
  return utils$2.encode(this.pubBytes(), e);
};
var key = KeyPair$1, BN$3 = bnExports$1, utils$1 = utils$l, assert$1 = utils$1.assert, cachedProperty = utils$1.cachedProperty, parseBytes$1 = utils$1.parseBytes;
function Signature$1(e, t) {
  this.eddsa = e, typeof t != "object" && (t = parseBytes$1(t)), Array.isArray(t) && (assert$1(t.length === e.encodingLength * 2, "Signature has invalid size"), t = {
    R: t.slice(0, e.encodingLength),
    S: t.slice(e.encodingLength)
  }), assert$1(t.R && t.S, "Signature without R or S"), e.isPoint(t.R) && (this._R = t.R), t.S instanceof BN$3 && (this._S = t.S), this._Rencoded = Array.isArray(t.R) ? t.R : t.Rencoded, this._Sencoded = Array.isArray(t.S) ? t.S : t.Sencoded;
}
cachedProperty(Signature$1, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$1, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$1, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$1, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
Signature$1.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$1.prototype.toHex = function() {
  return utils$1.encode(this.toBytes(), "hex").toUpperCase();
};
var signature = Signature$1, hash = hash$2, curves = curves$1, utils = utils$l, assert = utils.assert, parseBytes = utils.parseBytes, KeyPair = key, Signature = signature;
function EDDSA(e) {
  if (assert(e === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
    return new EDDSA(e);
  e = curves[e].curve, this.curve = e, this.g = e.g, this.g.precompute(e.n.bitLength() + 1), this.pointClass = e.point().constructor, this.encodingLength = Math.ceil(e.n.bitLength() / 8), this.hash = hash.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function(e, t) {
  e = parseBytes(e);
  var v = this.keyFromSecret(t), w = this.hashInt(v.messagePrefix(), e), T = this.g.mul(w), x = this.encodePoint(T), C = this.hashInt(x, v.pubBytes(), e).mul(v.priv()), D = w.add(C).umod(this.curve.n);
  return this.makeSignature({ R: T, S: D, Rencoded: x });
};
EDDSA.prototype.verify = function(e, t, v) {
  if (e = parseBytes(e), t = this.makeSignature(t), t.S().gte(t.eddsa.curve.n) || t.S().isNeg())
    return !1;
  var w = this.keyFromPublic(v), T = this.hashInt(t.Rencoded(), w.pubBytes(), e), x = this.g.mul(t.S()), C = t.R().add(w.pub().mul(T));
  return C.eq(x);
};
EDDSA.prototype.hashInt = function() {
  for (var e = this.hash(), t = 0; t < arguments.length; t++)
    e.update(arguments[t]);
  return utils.intFromLE(e.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function(e) {
  return KeyPair.fromPublic(this, e);
};
EDDSA.prototype.keyFromSecret = function(e) {
  return KeyPair.fromSecret(this, e);
};
EDDSA.prototype.makeSignature = function(e) {
  return e instanceof Signature ? e : new Signature(this, e);
};
EDDSA.prototype.encodePoint = function(e) {
  var t = e.getY().toArray("le", this.encodingLength);
  return t[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, t;
};
EDDSA.prototype.decodePoint = function(e) {
  e = utils.parseBytes(e);
  var t = e.length - 1, v = e.slice(0, t).concat(e[t] & -129), w = (e[t] & 128) !== 0, T = utils.intFromLE(v);
  return this.curve.pointFromY(T, w);
};
EDDSA.prototype.encodeInt = function(e) {
  return e.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function(e) {
  return utils.intFromLE(e);
};
EDDSA.prototype.isPoint = function(e) {
  return e instanceof this.pointClass;
};
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(e) {
    var t = e;
    t.version = require$$0.version, t.utils = utils$l, t.rand = requireBrorand(), t.curve = curve, t.curves = curves$1, t.ec = requireEc(), t.eddsa = eddsa;
  }(elliptic)), elliptic;
}
var asn1$3 = {}, asn1$2 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(e, t) {
      if (e.indexOf) return e.indexOf(t);
      for (var v = 0; v < e.length; v++)
        if (e[v] === t) return v;
      return -1;
    }, Object_keys = function(e) {
      if (Object.keys) return Object.keys(e);
      var t = [];
      for (var v in e) t.push(v);
      return t;
    }, forEach = function(e, t) {
      if (e.forEach) return e.forEach(t);
      for (var v = 0; v < e.length; v++)
        t(e[v], v, e);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(e, t, v) {
          Object.defineProperty(e, t, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: v
          });
        };
      } catch {
        return function(e, t, v) {
          e[t] = v;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(e) {
      if (!(this instanceof Script)) return new Script(e);
      this.code = e;
    };
    Script.prototype.runInContext = function(e) {
      if (!(e instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var t = document.createElement("iframe");
      t.style || (t.style = {}), t.style.display = "none", document.body.appendChild(t);
      var v = t.contentWindow, w = v.eval, T = v.execScript;
      !w && T && (T.call(v, "null"), w = v.eval), forEach(Object_keys(e), function(D) {
        v[D] = e[D];
      }), forEach(globals, function(D) {
        e[D] && (v[D] = e[D]);
      });
      var x = Object_keys(v), C = w.call(v, this.code);
      return forEach(Object_keys(v), function(D) {
        (D in e || indexOf(x, D) === -1) && (e[D] = v[D]);
      }), forEach(globals, function(D) {
        D in e || defineProp(e, D, v[D]);
      }), document.body.removeChild(t), C;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(e) {
      var t = Script.createContext(e), v = this.runInContext(t);
      return e && forEach(Object_keys(t), function(w) {
        e[w] = t[w];
      }), v;
    }, forEach(Object_keys(Script.prototype), function(e) {
      exports[e] = Script[e] = function(t) {
        var v = Script(t);
        return v[e].apply(v, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(e) {
      return e instanceof Context;
    }, exports.createScript = function(e) {
      return exports.Script(e);
    }, exports.createContext = Script.createContext = function(e) {
      var t = new Context();
      return typeof e == "object" && forEach(Object_keys(e), function(v) {
        t[v] = e[v];
      }), t;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(e) {
    var t = requireAsn1(), v = inherits_browserExports, w = e;
    w.define = function(x, C) {
      return new T(x, C);
    };
    function T(x, C) {
      this.name = x, this.body = C, this.decoders = {}, this.encoders = {};
    }
    T.prototype._createNamed = function(x) {
      var C;
      try {
        C = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        C = function(D) {
          this._initNamed(D);
        };
      }
      return v(C, x), C.prototype._initNamed = function(D) {
        x.call(this, D);
      }, new C(this);
    }, T.prototype._getDecoder = function(x) {
      return x = x || "der", this.decoders.hasOwnProperty(x) || (this.decoders[x] = this._createNamed(t.decoders[x])), this.decoders[x];
    }, T.prototype.decode = function(x, C, D) {
      return this._getDecoder(C).decode(x, D);
    }, T.prototype._getEncoder = function(x) {
      return x = x || "der", this.encoders.hasOwnProperty(x) || (this.encoders[x] = this._createNamed(t.encoders[x])), this.encoders[x];
    }, T.prototype.encode = function(x, C, D) {
      return this._getEncoder(C).encode(x, D);
    };
  }(api)), api;
}
var base = {}, reporter = {}, inherits = inherits_browserExports;
function Reporter(e) {
  this._reporterState = {
    obj: null,
    path: [],
    options: e || {},
    errors: []
  };
}
reporter.Reporter = Reporter;
Reporter.prototype.isError = function e(t) {
  return t instanceof ReporterError;
};
Reporter.prototype.save = function e() {
  var t = this._reporterState;
  return { obj: t.obj, pathLen: t.path.length };
};
Reporter.prototype.restore = function e(t) {
  var v = this._reporterState;
  v.obj = t.obj, v.path = v.path.slice(0, t.pathLen);
};
Reporter.prototype.enterKey = function e(t) {
  return this._reporterState.path.push(t);
};
Reporter.prototype.exitKey = function e(t) {
  var v = this._reporterState;
  v.path = v.path.slice(0, t - 1);
};
Reporter.prototype.leaveKey = function e(t, v, w) {
  var T = this._reporterState;
  this.exitKey(t), T.obj !== null && (T.obj[v] = w);
};
Reporter.prototype.path = function e() {
  return this._reporterState.path.join("/");
};
Reporter.prototype.enterObject = function e() {
  var t = this._reporterState, v = t.obj;
  return t.obj = {}, v;
};
Reporter.prototype.leaveObject = function e(t) {
  var v = this._reporterState, w = v.obj;
  return v.obj = t, w;
};
Reporter.prototype.error = function e(t) {
  var v, w = this._reporterState, T = t instanceof ReporterError;
  if (T ? v = t : v = new ReporterError(w.path.map(function(x) {
    return "[" + JSON.stringify(x) + "]";
  }).join(""), t.message || t, t.stack), !w.options.partial)
    throw v;
  return T || w.errors.push(v), v;
};
Reporter.prototype.wrapResult = function e(t) {
  var v = this._reporterState;
  return v.options.partial ? {
    result: this.isError(t) ? null : t,
    errors: v.errors
  } : t;
};
function ReporterError(e, t) {
  this.path = e, this.rethrow(t);
}
inherits(ReporterError, Error);
ReporterError.prototype.rethrow = function e(t) {
  if (this.message = t + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError), !this.stack)
    try {
      throw new Error(this.message);
    } catch (v) {
      this.stack = v.stack;
    }
  return this;
};
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var e = inherits_browserExports, t = requireBase().Reporter, v = require$$1$2.Buffer;
  function w(x, C) {
    if (t.call(this, C), !v.isBuffer(x)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = x, this.offset = 0, this.length = x.length;
  }
  e(w, t), buffer.DecoderBuffer = w, w.prototype.save = function() {
    return { offset: this.offset, reporter: t.prototype.save.call(this) };
  }, w.prototype.restore = function(x) {
    var C = new w(this.base);
    return C.offset = x.offset, C.length = this.offset, this.offset = x.offset, t.prototype.restore.call(this, x.reporter), C;
  }, w.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, w.prototype.readUInt8 = function(x) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(x || "DecoderBuffer overrun");
  }, w.prototype.skip = function(x, C) {
    if (!(this.offset + x <= this.length))
      return this.error(C || "DecoderBuffer overrun");
    var D = new w(this.base);
    return D._reporterState = this._reporterState, D.offset = this.offset, D.length = this.offset + x, this.offset += x, D;
  }, w.prototype.raw = function(x) {
    return this.base.slice(x ? x.offset : this.offset, this.length);
  };
  function T(x, C) {
    if (Array.isArray(x))
      this.length = 0, this.value = x.map(function(D) {
        return D instanceof T || (D = new T(D, C)), this.length += D.length, D;
      }, this);
    else if (typeof x == "number") {
      if (!(0 <= x && x <= 255))
        return C.error("non-byte EncoderBuffer value");
      this.value = x, this.length = 1;
    } else if (typeof x == "string")
      this.value = x, this.length = v.byteLength(x);
    else if (v.isBuffer(x))
      this.value = x, this.length = x.length;
    else
      return C.error("Unsupported type: " + typeof x);
  }
  return buffer.EncoderBuffer = T, T.prototype.join = function(x, C) {
    return x || (x = new v(this.length)), C || (C = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(D) {
      D.join(x, C), C += D.length;
    }) : (typeof this.value == "number" ? x[C] = this.value : typeof this.value == "string" ? x.write(this.value, C) : v.isBuffer(this.value) && this.value.copy(x, C), C += this.length)), x;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var e = requireBase().Reporter, t = requireBase().EncoderBuffer, v = requireBase().DecoderBuffer, w = minimalisticAssert, T = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], x = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(T), C = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function D(L, q) {
    var N = {};
    this._baseState = N, N.enc = L, N.parent = q || null, N.children = null, N.tag = null, N.args = null, N.reverseArgs = null, N.choice = null, N.optional = !1, N.any = !1, N.obj = !1, N.use = null, N.useDecoder = null, N.key = null, N.default = null, N.explicit = null, N.implicit = null, N.contains = null, N.parent || (N.children = [], this._wrap());
  }
  node = D;
  var Y = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return D.prototype.clone = function() {
    var L = this._baseState, q = {};
    Y.forEach(function(F) {
      q[F] = L[F];
    });
    var N = new this.constructor(q.parent);
    return N._baseState = q, N;
  }, D.prototype._wrap = function() {
    var L = this._baseState;
    x.forEach(function(q) {
      this[q] = function() {
        var N = new this.constructor(this);
        return L.children.push(N), N[q].apply(N, arguments);
      };
    }, this);
  }, D.prototype._init = function(L) {
    var q = this._baseState;
    w(q.parent === null), L.call(this), q.children = q.children.filter(function(N) {
      return N._baseState.parent === this;
    }, this), w.equal(q.children.length, 1, "Root node can have only one child");
  }, D.prototype._useArgs = function(L) {
    var q = this._baseState, N = L.filter(function(F) {
      return F instanceof this.constructor;
    }, this);
    L = L.filter(function(F) {
      return !(F instanceof this.constructor);
    }, this), N.length !== 0 && (w(q.children === null), q.children = N, N.forEach(function(F) {
      F._baseState.parent = this;
    }, this)), L.length !== 0 && (w(q.args === null), q.args = L, q.reverseArgs = L.map(function(F) {
      if (typeof F != "object" || F.constructor !== Object)
        return F;
      var ae = {};
      return Object.keys(F).forEach(function(he) {
        he == (he | 0) && (he |= 0);
        var tt = F[he];
        ae[tt] = he;
      }), ae;
    }));
  }, C.forEach(function(L) {
    D.prototype[L] = function() {
      var q = this._baseState;
      throw new Error(L + " not implemented for encoding: " + q.enc);
    };
  }), T.forEach(function(L) {
    D.prototype[L] = function() {
      var q = this._baseState, N = Array.prototype.slice.call(arguments);
      return w(q.tag === null), q.tag = L, this._useArgs(N), this;
    };
  }), D.prototype.use = function(L) {
    w(L);
    var q = this._baseState;
    return w(q.use === null), q.use = L, this;
  }, D.prototype.optional = function() {
    var L = this._baseState;
    return L.optional = !0, this;
  }, D.prototype.def = function(L) {
    var q = this._baseState;
    return w(q.default === null), q.default = L, q.optional = !0, this;
  }, D.prototype.explicit = function(L) {
    var q = this._baseState;
    return w(q.explicit === null && q.implicit === null), q.explicit = L, this;
  }, D.prototype.implicit = function(L) {
    var q = this._baseState;
    return w(q.explicit === null && q.implicit === null), q.implicit = L, this;
  }, D.prototype.obj = function() {
    var L = this._baseState, q = Array.prototype.slice.call(arguments);
    return L.obj = !0, q.length !== 0 && this._useArgs(q), this;
  }, D.prototype.key = function(L) {
    var q = this._baseState;
    return w(q.key === null), q.key = L, this;
  }, D.prototype.any = function() {
    var L = this._baseState;
    return L.any = !0, this;
  }, D.prototype.choice = function(L) {
    var q = this._baseState;
    return w(q.choice === null), q.choice = L, this._useArgs(Object.keys(L).map(function(N) {
      return L[N];
    })), this;
  }, D.prototype.contains = function(L) {
    var q = this._baseState;
    return w(q.use === null), q.contains = L, this;
  }, D.prototype._decode = function(L, q) {
    var N = this._baseState;
    if (N.parent === null)
      return L.wrapResult(N.children[0]._decode(L, q));
    var F = N.default, ae = !0, he = null;
    if (N.key !== null && (he = L.enterKey(N.key)), N.optional) {
      var tt = null;
      if (N.explicit !== null ? tt = N.explicit : N.implicit !== null ? tt = N.implicit : N.tag !== null && (tt = N.tag), tt === null && !N.any) {
        var br = L.save();
        try {
          N.choice === null ? this._decodeGeneric(N.tag, L, q) : this._decodeChoice(L, q), ae = !0;
        } catch {
          ae = !1;
        }
        L.restore(br);
      } else if (ae = this._peekTag(L, tt, N.any), L.isError(ae))
        return ae;
    }
    var rt;
    if (N.obj && ae && (rt = L.enterObject()), ae) {
      if (N.explicit !== null) {
        var dr = this._decodeTag(L, N.explicit);
        if (L.isError(dr))
          return dr;
        L = dr;
      }
      var _r = L.offset;
      if (N.use === null && N.choice === null) {
        if (N.any)
          var br = L.save();
        var Bi = this._decodeTag(
          L,
          N.implicit !== null ? N.implicit : N.tag,
          N.any
        );
        if (L.isError(Bi))
          return Bi;
        N.any ? F = L.raw(br) : L = Bi;
      }
      if (q && q.track && N.tag !== null && q.track(L.path(), _r, L.length, "tagged"), q && q.track && N.tag !== null && q.track(L.path(), L.offset, L.length, "content"), N.any ? F = F : N.choice === null ? F = this._decodeGeneric(N.tag, L, q) : F = this._decodeChoice(L, q), L.isError(F))
        return F;
      if (!N.any && N.choice === null && N.children !== null && N.children.forEach(function(Wi) {
        Wi._decode(L, q);
      }), N.contains && (N.tag === "octstr" || N.tag === "bitstr")) {
        var qi = new v(F);
        F = this._getUse(N.contains, L._reporterState.obj)._decode(qi, q);
      }
    }
    return N.obj && ae && (F = L.leaveObject(rt)), N.key !== null && (F !== null || ae === !0) ? L.leaveKey(he, N.key, F) : he !== null && L.exitKey(he), F;
  }, D.prototype._decodeGeneric = function(L, q, N) {
    var F = this._baseState;
    return L === "seq" || L === "set" ? null : L === "seqof" || L === "setof" ? this._decodeList(q, L, F.args[0], N) : /str$/.test(L) ? this._decodeStr(q, L, N) : L === "objid" && F.args ? this._decodeObjid(q, F.args[0], F.args[1], N) : L === "objid" ? this._decodeObjid(q, null, null, N) : L === "gentime" || L === "utctime" ? this._decodeTime(q, L, N) : L === "null_" ? this._decodeNull(q, N) : L === "bool" ? this._decodeBool(q, N) : L === "objDesc" ? this._decodeStr(q, L, N) : L === "int" || L === "enum" ? this._decodeInt(q, F.args && F.args[0], N) : F.use !== null ? this._getUse(F.use, q._reporterState.obj)._decode(q, N) : q.error("unknown tag: " + L);
  }, D.prototype._getUse = function(L, q) {
    var N = this._baseState;
    return N.useDecoder = this._use(L, q), w(N.useDecoder._baseState.parent === null), N.useDecoder = N.useDecoder._baseState.children[0], N.implicit !== N.useDecoder._baseState.implicit && (N.useDecoder = N.useDecoder.clone(), N.useDecoder._baseState.implicit = N.implicit), N.useDecoder;
  }, D.prototype._decodeChoice = function(L, q) {
    var N = this._baseState, F = null, ae = !1;
    return Object.keys(N.choice).some(function(he) {
      var tt = L.save(), br = N.choice[he];
      try {
        var rt = br._decode(L, q);
        if (L.isError(rt))
          return !1;
        F = { type: he, value: rt }, ae = !0;
      } catch {
        return L.restore(tt), !1;
      }
      return !0;
    }, this), ae ? F : L.error("Choice not matched");
  }, D.prototype._createEncoderBuffer = function(L) {
    return new t(L, this.reporter);
  }, D.prototype._encode = function(L, q, N) {
    var F = this._baseState;
    if (!(F.default !== null && F.default === L)) {
      var ae = this._encodeValue(L, q, N);
      if (ae !== void 0 && !this._skipDefault(ae, q, N))
        return ae;
    }
  }, D.prototype._encodeValue = function(L, q, N) {
    var F = this._baseState;
    if (F.parent === null)
      return F.children[0]._encode(L, q || new e());
    var br = null;
    if (this.reporter = q, F.optional && L === void 0)
      if (F.default !== null)
        L = F.default;
      else
        return;
    var ae = null, he = !1;
    if (F.any)
      br = this._createEncoderBuffer(L);
    else if (F.choice)
      br = this._encodeChoice(L, q);
    else if (F.contains)
      ae = this._getUse(F.contains, N)._encode(L, q), he = !0;
    else if (F.children)
      ae = F.children.map(function(_r) {
        if (_r._baseState.tag === "null_")
          return _r._encode(null, q, L);
        if (_r._baseState.key === null)
          return q.error("Child should have a key");
        var Bi = q.enterKey(_r._baseState.key);
        if (typeof L != "object")
          return q.error("Child expected, but input is not object");
        var qi = _r._encode(L[_r._baseState.key], q, L);
        return q.leaveKey(Bi), qi;
      }, this).filter(function(_r) {
        return _r;
      }), ae = this._createEncoderBuffer(ae);
    else if (F.tag === "seqof" || F.tag === "setof") {
      if (!(F.args && F.args.length === 1))
        return q.error("Too many args for : " + F.tag);
      if (!Array.isArray(L))
        return q.error("seqof/setof, but data is not Array");
      var tt = this.clone();
      tt._baseState.implicit = null, ae = this._createEncoderBuffer(L.map(function(_r) {
        var Bi = this._baseState;
        return this._getUse(Bi.args[0], L)._encode(_r, q);
      }, tt));
    } else F.use !== null ? br = this._getUse(F.use, N)._encode(L, q) : (ae = this._encodePrimitive(F.tag, L), he = !0);
    var br;
    if (!F.any && F.choice === null) {
      var rt = F.implicit !== null ? F.implicit : F.tag, dr = F.implicit === null ? "universal" : "context";
      rt === null ? F.use === null && q.error("Tag could be omitted only for .use()") : F.use === null && (br = this._encodeComposite(rt, he, dr, ae));
    }
    return F.explicit !== null && (br = this._encodeComposite(F.explicit, !1, "context", br)), br;
  }, D.prototype._encodeChoice = function(L, q) {
    var N = this._baseState, F = N.choice[L.type];
    return F || w(
      !1,
      L.type + " not found in " + JSON.stringify(Object.keys(N.choice))
    ), F._encode(L.value, q);
  }, D.prototype._encodePrimitive = function(L, q) {
    var N = this._baseState;
    if (/str$/.test(L))
      return this._encodeStr(q, L);
    if (L === "objid" && N.args)
      return this._encodeObjid(q, N.reverseArgs[0], N.args[1]);
    if (L === "objid")
      return this._encodeObjid(q, null, null);
    if (L === "gentime" || L === "utctime")
      return this._encodeTime(q, L);
    if (L === "null_")
      return this._encodeNull();
    if (L === "int" || L === "enum")
      return this._encodeInt(q, N.args && N.reverseArgs[0]);
    if (L === "bool")
      return this._encodeBool(q);
    if (L === "objDesc")
      return this._encodeStr(q, L);
    throw new Error("Unsupported tag: " + L);
  }, D.prototype._isNumstr = function(L) {
    return /^[0-9 ]*$/.test(L);
  }, D.prototype._isPrintstr = function(L) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(L);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(e) {
    var t = e;
    t.Reporter = reporter.Reporter, t.DecoderBuffer = requireBuffer().DecoderBuffer, t.EncoderBuffer = requireBuffer().EncoderBuffer, t.Node = requireNode();
  }(base)), base;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(e) {
    var t = requireConstants();
    e.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, e.tagClassByName = t._reverse(e.tagClass), e.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, e.tagByName = t._reverse(e.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(e) {
    var t = e;
    t._reverse = function(v) {
      var w = {};
      return Object.keys(v).forEach(function(T) {
        (T | 0) == T && (T = T | 0);
        var x = v[T];
        w[x] = T;
      }), w;
    }, t.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var e = inherits_browserExports, t = requireAsn1(), v = t.base, w = t.bignum, T = t.constants.der;
  function x(L) {
    this.enc = "der", this.name = L.name, this.entity = L, this.tree = new C(), this.tree._init(L.body);
  }
  der_1$1 = x, x.prototype.decode = function(L, q) {
    return L instanceof v.DecoderBuffer || (L = new v.DecoderBuffer(L, q)), this.tree._decode(L, q);
  };
  function C(L) {
    v.Node.call(this, "der", L);
  }
  e(C, v.Node), C.prototype._peekTag = function(L, q, N) {
    if (L.isEmpty())
      return !1;
    var F = L.save(), ae = D(L, 'Failed to peek tag: "' + q + '"');
    return L.isError(ae) ? ae : (L.restore(F), ae.tag === q || ae.tagStr === q || ae.tagStr + "of" === q || N);
  }, C.prototype._decodeTag = function(L, q, N) {
    var F = D(
      L,
      'Failed to decode tag of "' + q + '"'
    );
    if (L.isError(F))
      return F;
    var ae = Y(
      L,
      F.primitive,
      'Failed to get length of "' + q + '"'
    );
    if (L.isError(ae))
      return ae;
    if (!N && F.tag !== q && F.tagStr !== q && F.tagStr + "of" !== q)
      return L.error('Failed to match tag: "' + q + '"');
    if (F.primitive || ae !== null)
      return L.skip(ae, 'Failed to match body of: "' + q + '"');
    var he = L.save(), tt = this._skipUntilEnd(
      L,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return L.isError(tt) ? tt : (ae = L.offset - he.offset, L.restore(he), L.skip(ae, 'Failed to match body of: "' + q + '"'));
  }, C.prototype._skipUntilEnd = function(L, q) {
    for (; ; ) {
      var N = D(L, q);
      if (L.isError(N))
        return N;
      var F = Y(L, N.primitive, q);
      if (L.isError(F))
        return F;
      var ae;
      if (N.primitive || F !== null ? ae = L.skip(F) : ae = this._skipUntilEnd(L, q), L.isError(ae))
        return ae;
      if (N.tagStr === "end")
        break;
    }
  }, C.prototype._decodeList = function(L, q, N, F) {
    for (var ae = []; !L.isEmpty(); ) {
      var he = this._peekTag(L, "end");
      if (L.isError(he))
        return he;
      var tt = N.decode(L, "der", F);
      if (L.isError(tt) && he)
        break;
      ae.push(tt);
    }
    return ae;
  }, C.prototype._decodeStr = function(L, q) {
    if (q === "bitstr") {
      var N = L.readUInt8();
      return L.isError(N) ? N : { unused: N, data: L.raw() };
    } else if (q === "bmpstr") {
      var F = L.raw();
      if (F.length % 2 === 1)
        return L.error("Decoding of string type: bmpstr length mismatch");
      for (var ae = "", he = 0; he < F.length / 2; he++)
        ae += String.fromCharCode(F.readUInt16BE(he * 2));
      return ae;
    } else if (q === "numstr") {
      var tt = L.raw().toString("ascii");
      return this._isNumstr(tt) ? tt : L.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (q === "octstr" || q === "objDesc")
        return L.raw();
      if (q === "printstr") {
        var br = L.raw().toString("ascii");
        return this._isPrintstr(br) ? br : L.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(q) ? L.raw().toString() : L.error("Decoding of string type: " + q + " unsupported");
    }
  }, C.prototype._decodeObjid = function(L, q, N) {
    for (var F, ae = [], he = 0; !L.isEmpty(); ) {
      var tt = L.readUInt8();
      he <<= 7, he |= tt & 127, tt & 128 || (ae.push(he), he = 0);
    }
    tt & 128 && ae.push(he);
    var br = ae[0] / 40 | 0, rt = ae[0] % 40;
    if (N ? F = ae : F = [br, rt].concat(ae.slice(1)), q) {
      var dr = q[F.join(" ")];
      dr === void 0 && (dr = q[F.join(".")]), dr !== void 0 && (F = dr);
    }
    return F;
  }, C.prototype._decodeTime = function(L, q) {
    var N = L.raw().toString();
    if (q === "gentime")
      var F = N.slice(0, 4) | 0, ae = N.slice(4, 6) | 0, he = N.slice(6, 8) | 0, tt = N.slice(8, 10) | 0, br = N.slice(10, 12) | 0, rt = N.slice(12, 14) | 0;
    else if (q === "utctime") {
      var F = N.slice(0, 2) | 0, ae = N.slice(2, 4) | 0, he = N.slice(4, 6) | 0, tt = N.slice(6, 8) | 0, br = N.slice(8, 10) | 0, rt = N.slice(10, 12) | 0;
      F < 70 ? F = 2e3 + F : F = 1900 + F;
    } else
      return L.error("Decoding " + q + " time is not supported yet");
    return Date.UTC(F, ae - 1, he, tt, br, rt, 0);
  }, C.prototype._decodeNull = function(L) {
    return null;
  }, C.prototype._decodeBool = function(L) {
    var q = L.readUInt8();
    return L.isError(q) ? q : q !== 0;
  }, C.prototype._decodeInt = function(L, q) {
    var N = L.raw(), F = new w(N);
    return q && (F = q[F.toString(10)] || F), F;
  }, C.prototype._use = function(L, q) {
    return typeof L == "function" && (L = L(q)), L._getDecoder("der").tree;
  };
  function D(L, q) {
    var N = L.readUInt8(q);
    if (L.isError(N))
      return N;
    var F = T.tagClass[N >> 6], ae = (N & 32) === 0;
    if ((N & 31) === 31) {
      var he = N;
      for (N = 0; (he & 128) === 128; ) {
        if (he = L.readUInt8(q), L.isError(he))
          return he;
        N <<= 7, N |= he & 127;
      }
    } else
      N &= 31;
    var tt = T.tag[N];
    return {
      cls: F,
      primitive: ae,
      tag: N,
      tagStr: tt
    };
  }
  function Y(L, q, N) {
    var F = L.readUInt8(N);
    if (L.isError(F))
      return F;
    if (!q && F === 128)
      return null;
    if (!(F & 128))
      return F;
    var ae = F & 127;
    if (ae > 4)
      return L.error("length octect is too long");
    F = 0;
    for (var he = 0; he < ae; he++) {
      F <<= 8;
      var tt = L.readUInt8(N);
      if (L.isError(tt))
        return tt;
      F |= tt;
    }
    return F;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var e = inherits_browserExports, t = require$$1$2.Buffer, v = requireDer$1();
  function w(T) {
    v.call(this, T), this.enc = "pem";
  }
  return e(w, v), pem$1 = w, w.prototype.decode = function(T, x) {
    for (var C = T.toString().split(/[\r\n]+/g), D = x.label.toUpperCase(), Y = /^-----(BEGIN|END) ([^-]+)-----$/, L = -1, q = -1, N = 0; N < C.length; N++) {
      var F = C[N].match(Y);
      if (F !== null && F[2] === D)
        if (L === -1) {
          if (F[1] !== "BEGIN")
            break;
          L = N;
        } else {
          if (F[1] !== "END")
            break;
          q = N;
          break;
        }
    }
    if (L === -1 || q === -1)
      throw new Error("PEM section not found for: " + D);
    var ae = C.slice(L + 1, q).join("");
    ae.replace(/[^a-z0-9\+\/=]+/gi, "");
    var he = new t(ae, "base64");
    return v.prototype.decode.call(this, he, x);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(e) {
    var t = e;
    t.der = requireDer$1(), t.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var e = inherits_browserExports, t = require$$1$2.Buffer, v = requireAsn1(), w = v.base, T = v.constants.der;
  function x(L) {
    this.enc = "der", this.name = L.name, this.entity = L, this.tree = new C(), this.tree._init(L.body);
  }
  der_1 = x, x.prototype.encode = function(L, q) {
    return this.tree._encode(L, q).join();
  };
  function C(L) {
    w.Node.call(this, "der", L);
  }
  e(C, w.Node), C.prototype._encodeComposite = function(L, q, N, F) {
    var ae = Y(L, q, N, this.reporter);
    if (F.length < 128) {
      var br = new t(2);
      return br[0] = ae, br[1] = F.length, this._createEncoderBuffer([br, F]);
    }
    for (var he = 1, tt = F.length; tt >= 256; tt >>= 8)
      he++;
    var br = new t(2 + he);
    br[0] = ae, br[1] = 128 | he;
    for (var tt = 1 + he, rt = F.length; rt > 0; tt--, rt >>= 8)
      br[tt] = rt & 255;
    return this._createEncoderBuffer([br, F]);
  }, C.prototype._encodeStr = function(L, q) {
    if (q === "bitstr")
      return this._createEncoderBuffer([L.unused | 0, L.data]);
    if (q === "bmpstr") {
      for (var N = new t(L.length * 2), F = 0; F < L.length; F++)
        N.writeUInt16BE(L.charCodeAt(F), F * 2);
      return this._createEncoderBuffer(N);
    } else return q === "numstr" ? this._isNumstr(L) ? this._createEncoderBuffer(L) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : q === "printstr" ? this._isPrintstr(L) ? this._createEncoderBuffer(L) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(q) ? this._createEncoderBuffer(L) : q === "objDesc" ? this._createEncoderBuffer(L) : this.reporter.error("Encoding of string type: " + q + " unsupported");
  }, C.prototype._encodeObjid = function(L, q, N) {
    if (typeof L == "string") {
      if (!q)
        return this.reporter.error("string objid given, but no values map found");
      if (!q.hasOwnProperty(L))
        return this.reporter.error("objid not found in values map");
      L = q[L].split(/[\s\.]+/g);
      for (var F = 0; F < L.length; F++)
        L[F] |= 0;
    } else if (Array.isArray(L)) {
      L = L.slice();
      for (var F = 0; F < L.length; F++)
        L[F] |= 0;
    }
    if (!Array.isArray(L))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(L));
    if (!N) {
      if (L[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      L.splice(0, 2, L[0] * 40 + L[1]);
    }
    for (var ae = 0, F = 0; F < L.length; F++) {
      var he = L[F];
      for (ae++; he >= 128; he >>= 7)
        ae++;
    }
    for (var tt = new t(ae), br = tt.length - 1, F = L.length - 1; F >= 0; F--) {
      var he = L[F];
      for (tt[br--] = he & 127; (he >>= 7) > 0; )
        tt[br--] = 128 | he & 127;
    }
    return this._createEncoderBuffer(tt);
  };
  function D(L) {
    return L < 10 ? "0" + L : L;
  }
  C.prototype._encodeTime = function(L, q) {
    var N, F = new Date(L);
    return q === "gentime" ? N = [
      D(F.getFullYear()),
      D(F.getUTCMonth() + 1),
      D(F.getUTCDate()),
      D(F.getUTCHours()),
      D(F.getUTCMinutes()),
      D(F.getUTCSeconds()),
      "Z"
    ].join("") : q === "utctime" ? N = [
      D(F.getFullYear() % 100),
      D(F.getUTCMonth() + 1),
      D(F.getUTCDate()),
      D(F.getUTCHours()),
      D(F.getUTCMinutes()),
      D(F.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + q + " time is not supported yet"), this._encodeStr(N, "octstr");
  }, C.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, C.prototype._encodeInt = function(L, q) {
    if (typeof L == "string") {
      if (!q)
        return this.reporter.error("String int or enum given, but no values map");
      if (!q.hasOwnProperty(L))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(L));
      L = q[L];
    }
    if (typeof L != "number" && !t.isBuffer(L)) {
      var N = L.toArray();
      !L.sign && N[0] & 128 && N.unshift(0), L = new t(N);
    }
    if (t.isBuffer(L)) {
      var F = L.length;
      L.length === 0 && F++;
      var ae = new t(F);
      return L.copy(ae), L.length === 0 && (ae[0] = 0), this._createEncoderBuffer(ae);
    }
    if (L < 128)
      return this._createEncoderBuffer(L);
    if (L < 256)
      return this._createEncoderBuffer([0, L]);
    for (var F = 1, he = L; he >= 256; he >>= 8)
      F++;
    for (var ae = new Array(F), he = ae.length - 1; he >= 0; he--)
      ae[he] = L & 255, L >>= 8;
    return ae[0] & 128 && ae.unshift(0), this._createEncoderBuffer(new t(ae));
  }, C.prototype._encodeBool = function(L) {
    return this._createEncoderBuffer(L ? 255 : 0);
  }, C.prototype._use = function(L, q) {
    return typeof L == "function" && (L = L(q)), L._getEncoder("der").tree;
  }, C.prototype._skipDefault = function(L, q, N) {
    var F = this._baseState, ae;
    if (F.default === null)
      return !1;
    var he = L.join();
    if (F.defaultBuffer === void 0 && (F.defaultBuffer = this._encodeValue(F.default, q, N).join()), he.length !== F.defaultBuffer.length)
      return !1;
    for (ae = 0; ae < he.length; ae++)
      if (he[ae] !== F.defaultBuffer[ae])
        return !1;
    return !0;
  };
  function Y(L, q, N, F) {
    var ae;
    if (L === "seqof" ? L = "seq" : L === "setof" && (L = "set"), T.tagByName.hasOwnProperty(L))
      ae = T.tagByName[L];
    else if (typeof L == "number" && (L | 0) === L)
      ae = L;
    else
      return F.error("Unknown tag: " + L);
    return ae >= 31 ? F.error("Multi-octet tag encoding unsupported") : (q || (ae |= 32), ae |= T.tagClassByName[N || "universal"] << 6, ae);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var e = inherits_browserExports, t = requireDer();
  function v(w) {
    t.call(this, w), this.enc = "pem";
  }
  return e(v, t), pem = v, v.prototype.encode = function(w, T) {
    for (var x = t.prototype.encode.call(this, w), C = x.toString("base64"), D = ["-----BEGIN " + T.label + "-----"], Y = 0; Y < C.length; Y += 64)
      D.push(C.slice(Y, Y + 64));
    return D.push("-----END " + T.label + "-----"), D.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(e) {
    var t = e;
    t.der = requireDer(), t.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1;
function requireAsn1() {
  return hasRequiredAsn1 || (hasRequiredAsn1 = 1, function(e) {
    var t = e;
    t.bignum = bnExports$1, t.define = requireApi().define, t.base = requireBase(), t.constants = requireConstants(), t.decoders = requireDecoders(), t.encoders = requireEncoders();
  }(asn1$2)), asn1$2;
}
var asn = requireAsn1(), Time = asn.define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
}), AttributeTypeValue = asn.define("AttributeTypeValue", function() {
  this.seq().obj(
    this.key("type").objid(),
    this.key("value").any()
  );
}), AlgorithmIdentifier$1 = asn.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("parameters").optional(),
    this.key("curve").objid().optional()
  );
}), SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier$1),
    this.key("subjectPublicKey").bitstr()
  );
}), RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
  this.setof(AttributeTypeValue);
}), RDNSequence = asn.define("RDNSequence", function() {
  this.seqof(RelativeDistinguishedName);
}), Name = asn.define("Name", function() {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  });
}), Validity = asn.define("Validity", function() {
  this.seq().obj(
    this.key("notBefore").use(Time),
    this.key("notAfter").use(Time)
  );
}), Extension = asn.define("Extension", function() {
  this.seq().obj(
    this.key("extnID").objid(),
    this.key("critical").bool().def(!1),
    this.key("extnValue").octstr()
  );
}), TBSCertificate = asn.define("TBSCertificate", function() {
  this.seq().obj(
    this.key("version").explicit(0).int().optional(),
    this.key("serialNumber").int(),
    this.key("signature").use(AlgorithmIdentifier$1),
    this.key("issuer").use(Name),
    this.key("validity").use(Validity),
    this.key("subject").use(Name),
    this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
    this.key("issuerUniqueID").implicit(1).bitstr().optional(),
    this.key("subjectUniqueID").implicit(2).bitstr().optional(),
    this.key("extensions").explicit(3).seqof(Extension).optional()
  );
}), X509Certificate = asn.define("X509Certificate", function() {
  this.seq().obj(
    this.key("tbsCertificate").use(TBSCertificate),
    this.key("signatureAlgorithm").use(AlgorithmIdentifier$1),
    this.key("signatureValue").bitstr()
  );
}), certificate = X509Certificate, asn1$1 = requireAsn1();
asn1$3.certificate = certificate;
var RSAPrivateKey = asn1$1.define("RSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("modulus").int(),
    this.key("publicExponent").int(),
    this.key("privateExponent").int(),
    this.key("prime1").int(),
    this.key("prime2").int(),
    this.key("exponent1").int(),
    this.key("exponent2").int(),
    this.key("coefficient").int()
  );
});
asn1$3.RSAPrivateKey = RSAPrivateKey;
var RSAPublicKey = asn1$1.define("RSAPublicKey", function() {
  this.seq().obj(
    this.key("modulus").int(),
    this.key("publicExponent").int()
  );
});
asn1$3.RSAPublicKey = RSAPublicKey;
var AlgorithmIdentifier = asn1$1.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("none").null_().optional(),
    this.key("curve").objid().optional(),
    this.key("params").seq().obj(
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int()
    ).optional()
  );
}), PublicKey = asn1$1.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPublicKey").bitstr()
  );
});
asn1$3.PublicKey = PublicKey;
var PrivateKeyInfo = asn1$1.define("PrivateKeyInfo", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1$1.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").seq().obj(
      this.key("id").objid(),
      this.key("decrypt").seq().obj(
        this.key("kde").seq().obj(
          this.key("id").objid(),
          this.key("kdeparams").seq().obj(
            this.key("salt").octstr(),
            this.key("iters").int()
          )
        ),
        this.key("cipher").seq().obj(
          this.key("algo").objid(),
          this.key("iv").octstr()
        )
      )
    ),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
var DSAPrivateKey = asn1$1.define("DSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("p").int(),
    this.key("q").int(),
    this.key("g").int(),
    this.key("pub_key").int(),
    this.key("priv_key").int()
  );
});
asn1$3.DSAPrivateKey = DSAPrivateKey;
asn1$3.DSAparam = asn1$1.define("DSAparam", function() {
  this.int();
});
var ECParameters = asn1$1.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
}), ECPrivateKey = asn1$1.define("ECPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("privateKey").octstr(),
    this.key("parameters").optional().explicit(0).use(ECParameters),
    this.key("publicKey").optional().explicit(1).bitstr()
  );
});
asn1$3.ECPrivateKey = ECPrivateKey;
asn1$3.signature = asn1$1.define("signature", function() {
  this.seq().obj(
    this.key("r").int(),
    this.key("s").int()
  );
});
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, evp = evp_bytestokey, ciphers$1 = browser$5, Buffer$6 = safeBufferExports$1.Buffer, fixProc$1 = function(e, t) {
  var v = e.toString(), w = v.match(findProc), T;
  if (w) {
    var x = "aes" + w[1], C = Buffer$6.from(w[2], "hex"), D = Buffer$6.from(w[3].replace(/[\r\n]/g, ""), "base64"), Y = evp(t, C.slice(0, 8), parseInt(w[1], 10)).key, L = [], q = ciphers$1.createDecipheriv(x, Y, C);
    L.push(q.update(D)), L.push(q.final()), T = Buffer$6.concat(L);
  } else {
    var N = v.match(fullRegex);
    T = Buffer$6.from(N[2].replace(/[\r\n]/g, ""), "base64");
  }
  var F = v.match(startRegex)[1];
  return {
    tag: F,
    data: T
  };
}, asn1 = asn1$3, aesid = require$$1, fixProc = fixProc$1, ciphers = browser$5, compat = browser$7, Buffer$5 = safeBufferExports$1.Buffer;
function decrypt(e, t) {
  var v = e.algorithm.decrypt.kde.kdeparams.salt, w = parseInt(e.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), T = aesid[e.algorithm.decrypt.cipher.algo.join(".")], x = e.algorithm.decrypt.cipher.iv, C = e.subjectPrivateKey, D = parseInt(T.split("-")[1], 10) / 8, Y = compat.pbkdf2Sync(t, v, w, D, "sha1"), L = ciphers.createDecipheriv(T, Y, x), q = [];
  return q.push(L.update(C)), q.push(L.final()), Buffer$5.concat(q);
}
function parseKeys$2(e) {
  var t;
  typeof e == "object" && !Buffer$5.isBuffer(e) && (t = e.passphrase, e = e.key), typeof e == "string" && (e = Buffer$5.from(e));
  var v = fixProc(e, t), w = v.tag, T = v.data, x, C;
  switch (w) {
    case "CERTIFICATE":
      C = asn1.certificate.decode(T, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      switch (C || (C = asn1.PublicKey.decode(T, "der")), x = C.algorithm.algorithm.join("."), x) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPublicKey.decode(C.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          return C.subjectPrivateKey = C.subjectPublicKey, {
            type: "ec",
            data: C
          };
        case "1.2.840.10040.4.1":
          return C.algorithm.params.pub_key = asn1.DSAparam.decode(C.subjectPublicKey.data, "der"), {
            type: "dsa",
            data: C.algorithm.params
          };
        default:
          throw new Error("unknown key id " + x);
      }
    case "ENCRYPTED PRIVATE KEY":
      T = asn1.EncryptedPrivateKey.decode(T, "der"), T = decrypt(T, t);
    case "PRIVATE KEY":
      switch (C = asn1.PrivateKey.decode(T, "der"), x = C.algorithm.algorithm.join("."), x) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPrivateKey.decode(C.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: C.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(C.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          return C.algorithm.params.priv_key = asn1.DSAparam.decode(C.subjectPrivateKey, "der"), {
            type: "dsa",
            params: C.algorithm.params
          };
        default:
          throw new Error("unknown key id " + x);
      }
    case "RSA PUBLIC KEY":
      return asn1.RSAPublicKey.decode(T, "der");
    case "RSA PRIVATE KEY":
      return asn1.RSAPrivateKey.decode(T, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: asn1.DSAPrivateKey.decode(T, "der")
      };
    case "EC PRIVATE KEY":
      return T = asn1.ECPrivateKey.decode(T, "der"), {
        curve: T.parameters.value,
        privateKey: T.privateKey
      };
    default:
      throw new Error("unknown key type " + w);
  }
}
parseKeys$2.signature = asn1.signature;
var parseAsn1 = parseKeys$2;
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
sign.exports;
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  var e = safeBufferExports$1.Buffer, t = browser$8, v = browserifyRsa, w = requireElliptic().ec, T = bnExports, x = parseAsn1, C = require$$4, D = 1;
  function Y(rt, dr, _r, Bi, qi) {
    var Wi = x(dr);
    if (Wi.curve) {
      if (Bi !== "ecdsa" && Bi !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return L(rt, Wi);
    } else if (Wi.type === "dsa") {
      if (Bi !== "dsa")
        throw new Error("wrong private key type");
      return q(rt, Wi, _r);
    }
    if (Bi !== "rsa" && Bi !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (dr.padding !== void 0 && dr.padding !== D)
      throw new Error("illegal or unsupported padding mode");
    rt = e.concat([qi, rt]);
    for (var Vi = Wi.modulus.byteLength(), Ti = [0, 1]; rt.length + Ti.length + 1 < Vi; )
      Ti.push(255);
    Ti.push(0);
    for (var Li = -1; ++Li < rt.length; )
      Ti.push(rt[Li]);
    var Hi = v(Ti, Wi);
    return Hi;
  }
  function L(rt, dr) {
    var _r = C[dr.curve.join(".")];
    if (!_r)
      throw new Error("unknown curve " + dr.curve.join("."));
    var Bi = new w(_r), qi = Bi.keyFromPrivate(dr.privateKey), Wi = qi.sign(rt);
    return e.from(Wi.toDER());
  }
  function q(rt, dr, _r) {
    for (var Bi = dr.params.priv_key, qi = dr.params.p, Wi = dr.params.q, Vi = dr.params.g, Ti = new T(0), Li, Hi = ae(rt, Wi).mod(Wi), pr = !1, Di = F(Bi, Wi, rt, _r); pr === !1; )
      Li = tt(Wi, Di, _r), Ti = br(Vi, Li, qi, Wi), pr = Li.invm(Wi).imul(Hi.add(Bi.mul(Ti))).mod(Wi), pr.cmpn(0) === 0 && (pr = !1, Ti = new T(0));
    return N(Ti, pr);
  }
  function N(rt, dr) {
    rt = rt.toArray(), dr = dr.toArray(), rt[0] & 128 && (rt = [0].concat(rt)), dr[0] & 128 && (dr = [0].concat(dr));
    var _r = rt.length + dr.length + 4, Bi = [
      48,
      _r,
      2,
      rt.length
    ];
    return Bi = Bi.concat(rt, [2, dr.length], dr), e.from(Bi);
  }
  function F(rt, dr, _r, Bi) {
    if (rt = e.from(rt.toArray()), rt.length < dr.byteLength()) {
      var qi = e.alloc(dr.byteLength() - rt.length);
      rt = e.concat([qi, rt]);
    }
    var Wi = _r.length, Vi = he(_r, dr), Ti = e.alloc(Wi);
    Ti.fill(1);
    var Li = e.alloc(Wi);
    return Li = t(Bi, Li).update(Ti).update(e.from([0])).update(rt).update(Vi).digest(), Ti = t(Bi, Li).update(Ti).digest(), Li = t(Bi, Li).update(Ti).update(e.from([1])).update(rt).update(Vi).digest(), Ti = t(Bi, Li).update(Ti).digest(), { k: Li, v: Ti };
  }
  function ae(rt, dr) {
    var _r = new T(rt), Bi = (rt.length << 3) - dr.bitLength();
    return Bi > 0 && _r.ishrn(Bi), _r;
  }
  function he(rt, dr) {
    rt = ae(rt, dr), rt = rt.mod(dr);
    var _r = e.from(rt.toArray());
    if (_r.length < dr.byteLength()) {
      var Bi = e.alloc(dr.byteLength() - _r.length);
      _r = e.concat([Bi, _r]);
    }
    return _r;
  }
  function tt(rt, dr, _r) {
    var Bi, qi;
    do {
      for (Bi = e.alloc(0); Bi.length * 8 < rt.bitLength(); )
        dr.v = t(_r, dr.k).update(dr.v).digest(), Bi = e.concat([Bi, dr.v]);
      qi = ae(Bi, rt), dr.k = t(_r, dr.k).update(dr.v).update(e.from([0])).digest(), dr.v = t(_r, dr.k).update(dr.v).digest();
    } while (qi.cmp(rt) !== -1);
    return qi;
  }
  function br(rt, dr, _r, Bi) {
    return rt.toRed(T.mont(_r)).redPow(dr).fromRed().mod(Bi);
  }
  return sign.exports = Y, sign.exports.getKey = F, sign.exports.makeKey = tt, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1;
  hasRequiredVerify = 1;
  var e = safeBufferExports$1.Buffer, t = bnExports, v = requireElliptic().ec, w = parseAsn1, T = require$$4;
  function x(L, q, N, F, ae) {
    var he = w(N);
    if (he.type === "ec") {
      if (F !== "ecdsa" && F !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return C(L, q, he);
    } else if (he.type === "dsa") {
      if (F !== "dsa")
        throw new Error("wrong public key type");
      return D(L, q, he);
    }
    if (F !== "rsa" && F !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    q = e.concat([ae, q]);
    for (var tt = he.modulus.byteLength(), br = [1], rt = 0; q.length + br.length + 2 < tt; )
      br.push(255), rt += 1;
    br.push(0);
    for (var dr = -1; ++dr < q.length; )
      br.push(q[dr]);
    br = e.from(br);
    var _r = t.mont(he.modulus);
    L = new t(L).toRed(_r), L = L.redPow(new t(he.publicExponent)), L = e.from(L.fromRed().toArray());
    var Bi = rt < 8 ? 1 : 0;
    for (tt = Math.min(L.length, br.length), L.length !== br.length && (Bi = 1), dr = -1; ++dr < tt; )
      Bi |= L[dr] ^ br[dr];
    return Bi === 0;
  }
  function C(L, q, N) {
    var F = T[N.data.algorithm.curve.join(".")];
    if (!F)
      throw new Error("unknown curve " + N.data.algorithm.curve.join("."));
    var ae = new v(F), he = N.data.subjectPrivateKey.data;
    return ae.verify(q, L, he);
  }
  function D(L, q, N) {
    var F = N.data.p, ae = N.data.q, he = N.data.g, tt = N.data.pub_key, br = w.signature.decode(L, "der"), rt = br.s, dr = br.r;
    Y(rt, ae), Y(dr, ae);
    var _r = t.mont(F), Bi = rt.invm(ae), qi = he.toRed(_r).redPow(new t(q).mul(Bi).mod(ae)).fromRed().mul(tt.toRed(_r).redPow(dr.mul(Bi).mod(ae)).fromRed()).mod(F).mod(ae);
    return qi.cmp(dr) === 0;
  }
  function Y(L, q) {
    if (L.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (L.cmp(q) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = x, verify_1;
}
var browser$3, hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$3;
  hasRequiredBrowser$1 = 1;
  var e = safeBufferExports$1.Buffer, t = browser$9, v = readableBrowserExports, w = inherits_browserExports, T = requireSign(), x = requireVerify(), C = require$$6;
  Object.keys(C).forEach(function(N) {
    C[N].id = e.from(C[N].id, "hex"), C[N.toLowerCase()] = C[N];
  });
  function D(N) {
    v.Writable.call(this);
    var F = C[N];
    if (!F)
      throw new Error("Unknown message digest");
    this._hashType = F.hash, this._hash = t(F.hash), this._tag = F.id, this._signType = F.sign;
  }
  w(D, v.Writable), D.prototype._write = function(N, F, ae) {
    this._hash.update(N), ae();
  }, D.prototype.update = function(N, F) {
    return this._hash.update(typeof N == "string" ? e.from(N, F) : N), this;
  }, D.prototype.sign = function(N, F) {
    this.end();
    var ae = this._hash.digest(), he = T(ae, N, this._hashType, this._signType, this._tag);
    return F ? he.toString(F) : he;
  };
  function Y(N) {
    v.Writable.call(this);
    var F = C[N];
    if (!F)
      throw new Error("Unknown message digest");
    this._hash = t(F.hash), this._tag = F.id, this._signType = F.sign;
  }
  w(Y, v.Writable), Y.prototype._write = function(N, F, ae) {
    this._hash.update(N), ae();
  }, Y.prototype.update = function(N, F) {
    return this._hash.update(typeof N == "string" ? e.from(N, F) : N), this;
  }, Y.prototype.verify = function(N, F, ae) {
    var he = typeof F == "string" ? e.from(F, ae) : F;
    this.end();
    var tt = this._hash.digest();
    return x(he, tt, N, this._signType, this._tag);
  };
  function L(N) {
    return new D(N);
  }
  function q(N) {
    return new Y(N);
  }
  return browser$3 = {
    Sign: L,
    Verify: q,
    createSign: L,
    createVerify: q
  }, browser$3;
}
var browser$2, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser$2;
  hasRequiredBrowser = 1;
  var e = requireElliptic(), t = bnExports$1;
  browser$2 = function(x) {
    return new w(x);
  };
  var v = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  v.p224 = v.secp224r1, v.p256 = v.secp256r1 = v.prime256v1, v.p192 = v.secp192r1 = v.prime192v1, v.p384 = v.secp384r1, v.p521 = v.secp521r1;
  function w(x) {
    this.curveType = v[x], this.curveType || (this.curveType = {
      name: x
    }), this.curve = new e.ec(this.curveType.name), this.keys = void 0;
  }
  w.prototype.generateKeys = function(x, C) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(x, C);
  }, w.prototype.computeSecret = function(x, C, D) {
    C = C || "utf8", Buffer$C.isBuffer(x) || (x = new Buffer$C(x, C));
    var Y = this.curve.keyFromPublic(x).getPublic(), L = Y.mul(this.keys.getPrivate()).getX();
    return T(L, D, this.curveType.byteLength);
  }, w.prototype.getPublicKey = function(x, C) {
    var D = this.keys.getPublic(C === "compressed", !0);
    return C === "hybrid" && (D[D.length - 1] % 2 ? D[0] = 7 : D[0] = 6), T(D, x);
  }, w.prototype.getPrivateKey = function(x) {
    return T(this.keys.getPrivate(), x);
  }, w.prototype.setPublicKey = function(x, C) {
    return C = C || "utf8", Buffer$C.isBuffer(x) || (x = new Buffer$C(x, C)), this.keys._importPublic(x), this;
  }, w.prototype.setPrivateKey = function(x, C) {
    C = C || "utf8", Buffer$C.isBuffer(x) || (x = new Buffer$C(x, C));
    var D = new t(x);
    return D = D.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(D), this;
  };
  function T(x, C, D) {
    Array.isArray(x) || (x = x.toArray());
    var Y = new Buffer$C(x);
    if (D && Y.length < D) {
      var L = new Buffer$C(D - Y.length);
      L.fill(0), Y = Buffer$C.concat([L, Y]);
    }
    return C ? Y.toString(C) : Y;
  }
  return browser$2;
}
var browser$1 = {}, createHash$2 = browser$9, Buffer$4 = safeBufferExports$1.Buffer, mgf$2 = function(e, t) {
  for (var v = Buffer$4.alloc(0), w = 0, T; v.length < t; )
    T = i2ops(w++), v = Buffer$4.concat([v, createHash$2("sha1").update(e).update(T).digest()]);
  return v.slice(0, t);
};
function i2ops(e) {
  var t = Buffer$4.allocUnsafe(4);
  return t.writeUInt32BE(e, 0), t;
}
var xor$2 = function e(t, v) {
  for (var w = t.length, T = -1; ++T < w; )
    t[T] ^= v[T];
  return t;
}, BN$2 = bnExports$1, Buffer$3 = safeBufferExports$1.Buffer;
function withPublic$2(e, t) {
  return Buffer$3.from(e.toRed(BN$2.mont(t.modulus)).redPow(new BN$2(t.publicExponent)).fromRed().toArray());
}
var withPublic_1 = withPublic$2, parseKeys$1 = parseAsn1, randomBytes = browserExports, createHash$1 = browser$9, mgf$1 = mgf$2, xor$1 = xor$2, BN$1 = bnExports$1, withPublic$1 = withPublic_1, crt$1 = browserifyRsa, Buffer$2 = safeBufferExports$1.Buffer, publicEncrypt = function e(t, v, w) {
  var T;
  t.padding ? T = t.padding : w ? T = 1 : T = 4;
  var x = parseKeys$1(t), C;
  if (T === 4)
    C = oaep$1(x, v);
  else if (T === 1)
    C = pkcs1$1(x, v, w);
  else if (T === 3) {
    if (C = new BN$1(v), C.cmp(x.modulus) >= 0)
      throw new Error("data too long for modulus");
  } else
    throw new Error("unknown padding");
  return w ? crt$1(C, x) : withPublic$1(C, x);
};
function oaep$1(e, t) {
  var v = e.modulus.byteLength(), w = t.length, T = createHash$1("sha1").update(Buffer$2.alloc(0)).digest(), x = T.length, C = 2 * x;
  if (w > v - C - 2)
    throw new Error("message too long");
  var D = Buffer$2.alloc(v - w - C - 2), Y = v - x - 1, L = randomBytes(x), q = xor$1(Buffer$2.concat([T, D, Buffer$2.alloc(1, 1), t], Y), mgf$1(L, Y)), N = xor$1(L, mgf$1(q, x));
  return new BN$1(Buffer$2.concat([Buffer$2.alloc(1), N, q], v));
}
function pkcs1$1(e, t, v) {
  var w = t.length, T = e.modulus.byteLength();
  if (w > T - 11)
    throw new Error("message too long");
  var x;
  return v ? x = Buffer$2.alloc(T - w - 3, 255) : x = nonZero(T - w - 3), new BN$1(Buffer$2.concat([Buffer$2.from([0, v ? 1 : 2]), x, Buffer$2.alloc(1), t], T));
}
function nonZero(e) {
  for (var t = Buffer$2.allocUnsafe(e), v = 0, w = randomBytes(e * 2), T = 0, x; v < e; )
    T === w.length && (w = randomBytes(e * 2), T = 0), x = w[T++], x && (t[v++] = x);
  return t;
}
var parseKeys = parseAsn1, mgf = mgf$2, xor = xor$2, BN = bnExports$1, crt = browserifyRsa, createHash = browser$9, withPublic = withPublic_1, Buffer$1 = safeBufferExports$1.Buffer, privateDecrypt = function e(t, v, w) {
  var T;
  t.padding ? T = t.padding : w ? T = 1 : T = 4;
  var x = parseKeys(t), C = x.modulus.byteLength();
  if (v.length > C || new BN(v).cmp(x.modulus) >= 0)
    throw new Error("decryption error");
  var D;
  w ? D = withPublic(new BN(v), x) : D = crt(v, x);
  var Y = Buffer$1.alloc(C - D.length);
  if (D = Buffer$1.concat([Y, D], C), T === 4)
    return oaep(x, D);
  if (T === 1)
    return pkcs1(x, D, w);
  if (T === 3)
    return D;
  throw new Error("unknown padding");
};
function oaep(e, t) {
  var v = e.modulus.byteLength(), w = createHash("sha1").update(Buffer$1.alloc(0)).digest(), T = w.length;
  if (t[0] !== 0)
    throw new Error("decryption error");
  var x = t.slice(1, T + 1), C = t.slice(T + 1), D = xor(x, mgf(C, T)), Y = xor(C, mgf(D, v - T - 1));
  if (compare(w, Y.slice(0, T)))
    throw new Error("decryption error");
  for (var L = T; Y[L] === 0; )
    L++;
  if (Y[L++] !== 1)
    throw new Error("decryption error");
  return Y.slice(L);
}
function pkcs1(e, t, v) {
  for (var w = t.slice(0, 2), T = 2, x = 0; t[T++] !== 0; )
    if (T >= t.length) {
      x++;
      break;
    }
  var C = t.slice(2, T - 1);
  if ((w.toString("hex") !== "0002" && !v || w.toString("hex") !== "0001" && v) && x++, C.length < 8 && x++, x)
    throw new Error("decryption error");
  return t.slice(T);
}
function compare(e, t) {
  e = Buffer$1.from(e), t = Buffer$1.from(t);
  var v = 0, w = e.length;
  e.length !== t.length && (v++, w = Math.min(e.length, t.length));
  for (var T = -1; ++T < w; )
    v += e[T] ^ t[T];
  return v;
}
(function(e) {
  e.publicEncrypt = publicEncrypt, e.privateDecrypt = privateDecrypt, e.privateEncrypt = function(t, v) {
    return e.publicEncrypt(t, v, !0);
  }, e.publicDecrypt = function(t, v) {
    return e.privateDecrypt(t, v, !0);
  };
})(browser$1);
var browser = {};
function oldBrowser() {
  throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
}
var safeBuffer = safeBufferExports$1, randombytes = browserExports, Buffer = safeBuffer.Buffer, kBufferMaxLength = safeBuffer.kMaxLength, crypto = commonjsGlobal.crypto || commonjsGlobal.msCrypto, kMaxUint32 = Math.pow(2, 32) - 1;
function assertOffset(e, t) {
  if (typeof e != "number" || e !== e)
    throw new TypeError("offset must be a number");
  if (e > kMaxUint32 || e < 0)
    throw new TypeError("offset must be a uint32");
  if (e > kBufferMaxLength || e > t)
    throw new RangeError("offset out of range");
}
function assertSize(e, t, v) {
  if (typeof e != "number" || e !== e)
    throw new TypeError("size must be a number");
  if (e > kMaxUint32 || e < 0)
    throw new TypeError("size must be a uint32");
  if (e + t > v || e > kBufferMaxLength)
    throw new RangeError("buffer too small");
}
crypto && crypto.getRandomValues || !process$1$1.browser ? (browser.randomFill = randomFill, browser.randomFillSync = randomFillSync) : (browser.randomFill = oldBrowser, browser.randomFillSync = oldBrowser);
function randomFill(e, t, v, w) {
  if (!Buffer.isBuffer(e) && !(e instanceof commonjsGlobal.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  if (typeof t == "function")
    w = t, t = 0, v = e.length;
  else if (typeof v == "function")
    w = v, v = e.length - t;
  else if (typeof w != "function")
    throw new TypeError('"cb" argument must be a function');
  return assertOffset(t, e.length), assertSize(v, t, e.length), actualFill(e, t, v, w);
}
function actualFill(e, t, v, w) {
  if (process$1$1.browser) {
    var T = e.buffer, x = new Uint8Array(T, t, v);
    if (crypto.getRandomValues(x), w) {
      process$1$1.nextTick(function() {
        w(null, e);
      });
      return;
    }
    return e;
  }
  if (w) {
    randombytes(v, function(D, Y) {
      if (D)
        return w(D);
      Y.copy(e, t), w(null, e);
    });
    return;
  }
  var C = randombytes(v);
  return C.copy(e, t), e;
}
function randomFillSync(e, t, v) {
  if (typeof t > "u" && (t = 0), !Buffer.isBuffer(e) && !(e instanceof commonjsGlobal.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  return assertOffset(t, e.length), v === void 0 && (v = e.length - t), assertSize(v, t, e.length), actualFill(e, t, v);
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = browserExports, cryptoBrowserify.createHash = cryptoBrowserify.Hash = browser$9, cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = browser$8;
  var e = algos, t = Object.keys(e), v = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
  ].concat(t);
  cryptoBrowserify.getHashes = function() {
    return v;
  };
  var w = browser$7;
  cryptoBrowserify.pbkdf2 = w.pbkdf2, cryptoBrowserify.pbkdf2Sync = w.pbkdf2Sync;
  var T = browser$6;
  cryptoBrowserify.Cipher = T.Cipher, cryptoBrowserify.createCipher = T.createCipher, cryptoBrowserify.Cipheriv = T.Cipheriv, cryptoBrowserify.createCipheriv = T.createCipheriv, cryptoBrowserify.Decipher = T.Decipher, cryptoBrowserify.createDecipher = T.createDecipher, cryptoBrowserify.Decipheriv = T.Decipheriv, cryptoBrowserify.createDecipheriv = T.createDecipheriv, cryptoBrowserify.getCiphers = T.getCiphers, cryptoBrowserify.listCiphers = T.listCiphers;
  var x = requireBrowser$2();
  cryptoBrowserify.DiffieHellmanGroup = x.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = x.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = x.getDiffieHellman, cryptoBrowserify.createDiffieHellman = x.createDiffieHellman, cryptoBrowserify.DiffieHellman = x.DiffieHellman;
  var C = requireBrowser$1();
  cryptoBrowserify.createSign = C.createSign, cryptoBrowserify.Sign = C.Sign, cryptoBrowserify.createVerify = C.createVerify, cryptoBrowserify.Verify = C.Verify, cryptoBrowserify.createECDH = requireBrowser();
  var D = browser$1;
  cryptoBrowserify.publicEncrypt = D.publicEncrypt, cryptoBrowserify.privateEncrypt = D.privateEncrypt, cryptoBrowserify.publicDecrypt = D.publicDecrypt, cryptoBrowserify.privateDecrypt = D.privateDecrypt;
  var Y = browser;
  return cryptoBrowserify.randomFill = Y.randomFill, cryptoBrowserify.randomFillSync = Y.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
var cryptoBrowserifyExports = requireCryptoBrowserify();
class Base64 {
  encode(t, v) {
    return typeof t == "string" ? Buffer$C.from(t, v).toString("base64") : Buffer$C.isBuffer(t) ? t.toString("base64") : Buffer$C.from(t).toString("base64");
  }
  decode(t, v = "utf-8", w = !1) {
    if (Buffer$C.isBuffer(t))
      return t.toString(v);
    const T = Buffer$C.from(t, "base64").toString(v), x = this.encode(T, v) !== t;
    if (w && x)
      throw new Error("Cannot decode malformed value");
    return x ? null : T;
  }
  urlEncode(t, v) {
    return (typeof t == "string" ? this.encode(t, v) : this.encode(t)).replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "");
  }
  urlDecode(t, v = "utf-8", w = !1) {
    if (Buffer$C.isBuffer(t))
      return t.toString(v);
    const T = Buffer$C.from(t, "base64").toString(v), x = this.urlEncode(T, v) !== t;
    if (w && x)
      throw new Error("Cannot urlDecode malformed value");
    return x ? null : T;
  }
}
var secureJsonParse = { exports: {} };
secureJsonParse.exports;
const hasBuffer = typeof Buffer$C < "u", suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/, suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
function _parse(e, t, v) {
  v == null && t !== null && typeof t == "object" && (v = t, t = void 0), hasBuffer && Buffer$C.isBuffer(e) && (e = e.toString()), e && e.charCodeAt(0) === 65279 && (e = e.slice(1));
  const w = JSON.parse(e, t);
  if (w === null || typeof w != "object")
    return w;
  const T = v && v.protoAction || "error", x = v && v.constructorAction || "error";
  if (T === "ignore" && x === "ignore")
    return w;
  if (T !== "ignore" && x !== "ignore") {
    if (suspectProtoRx.test(e) === !1 && suspectConstructorRx.test(e) === !1)
      return w;
  } else if (T !== "ignore" && x === "ignore") {
    if (suspectProtoRx.test(e) === !1)
      return w;
  } else if (suspectConstructorRx.test(e) === !1)
    return w;
  return filter(w, { protoAction: T, constructorAction: x, safe: v && v.safe });
}
function filter(e, { protoAction: t = "error", constructorAction: v = "error", safe: w } = {}) {
  let T = [e];
  for (; T.length; ) {
    const x = T;
    T = [];
    for (const C of x) {
      if (t !== "ignore" && Object.prototype.hasOwnProperty.call(C, "__proto__")) {
        if (w === !0)
          return null;
        if (t === "error")
          throw new SyntaxError("Object contains forbidden prototype property");
        delete C.__proto__;
      }
      if (v !== "ignore" && Object.prototype.hasOwnProperty.call(C, "constructor") && Object.prototype.hasOwnProperty.call(C.constructor, "prototype")) {
        if (w === !0)
          return null;
        if (v === "error")
          throw new SyntaxError("Object contains forbidden prototype property");
        delete C.constructor;
      }
      for (const D in C) {
        const Y = C[D];
        Y && typeof Y == "object" && T.push(Y);
      }
    }
  }
  return e;
}
function parse$1(e, t, v) {
  const { stackTraceLimit: w } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse(e, t, v);
  } finally {
    Error.stackTraceLimit = w;
  }
}
function safeParse$1(e, t) {
  const { stackTraceLimit: v } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse(e, t, { safe: !0 });
  } catch {
    return;
  } finally {
    Error.stackTraceLimit = v;
  }
}
secureJsonParse.exports = parse$1;
secureJsonParse.exports.default = parse$1;
var parse_1 = secureJsonParse.exports.parse = parse$1;
secureJsonParse.exports.safeParse = safeParse$1;
secureJsonParse.exports.scan = filter;
secureJsonParse.exports;
var safeStableStringify = { exports: {} };
safeStableStringify.exports;
(function(e, t) {
  const { hasOwnProperty: v } = Object.prototype, w = rt();
  w.configure = rt, w.stringify = w, w.default = w, t.stringify = w, t.configure = rt, e.exports = w;
  const T = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
  function x(dr) {
    return dr.length < 5e3 && !T.test(dr) ? `"${dr}"` : JSON.stringify(dr);
  }
  function C(dr, _r) {
    if (dr.length > 200 || _r)
      return dr.sort(_r);
    for (let Bi = 1; Bi < dr.length; Bi++) {
      const qi = dr[Bi];
      let Wi = Bi;
      for (; Wi !== 0 && dr[Wi - 1] > qi; )
        dr[Wi] = dr[Wi - 1], Wi--;
      dr[Wi] = qi;
    }
    return dr;
  }
  const D = Object.getOwnPropertyDescriptor(
    Object.getPrototypeOf(
      Object.getPrototypeOf(
        new Int8Array()
      )
    ),
    Symbol.toStringTag
  ).get;
  function Y(dr) {
    return D.call(dr) !== void 0 && dr.length !== 0;
  }
  function L(dr, _r, Bi) {
    dr.length < Bi && (Bi = dr.length);
    const qi = _r === "," ? "" : " ";
    let Wi = `"0":${qi}${dr[0]}`;
    for (let Vi = 1; Vi < Bi; Vi++)
      Wi += `${_r}"${Vi}":${qi}${dr[Vi]}`;
    return Wi;
  }
  function q(dr) {
    if (v.call(dr, "circularValue")) {
      const _r = dr.circularValue;
      if (typeof _r == "string")
        return `"${_r}"`;
      if (_r == null)
        return _r;
      if (_r === Error || _r === TypeError)
        return {
          toString() {
            throw new TypeError("Converting circular structure to JSON");
          }
        };
      throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
    }
    return '"[Circular]"';
  }
  function N(dr) {
    let _r;
    if (v.call(dr, "deterministic") && (_r = dr.deterministic, typeof _r != "boolean" && typeof _r != "function"))
      throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
    return _r === void 0 ? !0 : _r;
  }
  function F(dr, _r) {
    let Bi;
    if (v.call(dr, _r) && (Bi = dr[_r], typeof Bi != "boolean"))
      throw new TypeError(`The "${_r}" argument must be of type boolean`);
    return Bi === void 0 ? !0 : Bi;
  }
  function ae(dr, _r) {
    let Bi;
    if (v.call(dr, _r)) {
      if (Bi = dr[_r], typeof Bi != "number")
        throw new TypeError(`The "${_r}" argument must be of type number`);
      if (!Number.isInteger(Bi))
        throw new TypeError(`The "${_r}" argument must be an integer`);
      if (Bi < 1)
        throw new RangeError(`The "${_r}" argument must be >= 1`);
    }
    return Bi === void 0 ? 1 / 0 : Bi;
  }
  function he(dr) {
    return dr === 1 ? "1 item" : `${dr} items`;
  }
  function tt(dr) {
    const _r = /* @__PURE__ */ new Set();
    for (const Bi of dr)
      (typeof Bi == "string" || typeof Bi == "number") && _r.add(String(Bi));
    return _r;
  }
  function br(dr) {
    if (v.call(dr, "strict")) {
      const _r = dr.strict;
      if (typeof _r != "boolean")
        throw new TypeError('The "strict" argument must be of type boolean');
      if (_r)
        return (Bi) => {
          let qi = `Object can not safely be stringified. Received type ${typeof Bi}`;
          throw typeof Bi != "function" && (qi += ` (${Bi.toString()})`), new Error(qi);
        };
    }
  }
  function rt(dr) {
    dr = { ...dr };
    const _r = br(dr);
    _r && (dr.bigint === void 0 && (dr.bigint = !1), "circularValue" in dr || (dr.circularValue = Error));
    const Bi = q(dr), qi = F(dr, "bigint"), Wi = N(dr), Vi = typeof Wi == "function" ? Wi : void 0, Ti = ae(dr, "maximumDepth"), Li = ae(dr, "maximumBreadth");
    function Hi(vr, Oi, Mi, ki, yr, xi) {
      let Si = Oi[vr];
      switch (typeof Si == "object" && Si !== null && typeof Si.toJSON == "function" && (Si = Si.toJSON(vr)), Si = ki.call(Oi, vr, Si), typeof Si) {
        case "string":
          return x(Si);
        case "object": {
          if (Si === null)
            return "null";
          if (Mi.indexOf(Si) !== -1)
            return Bi;
          let Ci = "", Ki = ",";
          const Yi = xi;
          if (Array.isArray(Si)) {
            if (Si.length === 0)
              return "[]";
            if (Ti < Mi.length + 1)
              return '"[Array]"';
            Mi.push(Si), yr !== "" && (xi += yr, Ci += `
${xi}`, Ki = `,
${xi}`);
            const to = Math.min(Si.length, Li);
            let zi = 0;
            for (; zi < to - 1; zi++) {
              const no = Hi(String(zi), Si, Mi, ki, yr, xi);
              Ci += no !== void 0 ? no : "null", Ci += Ki;
            }
            const Gi = Hi(String(zi), Si, Mi, ki, yr, xi);
            if (Ci += Gi !== void 0 ? Gi : "null", Si.length - 1 > Li) {
              const no = Si.length - Li - 1;
              Ci += `${Ki}"... ${he(no)} not stringified"`;
            }
            return yr !== "" && (Ci += `
${Yi}`), Mi.pop(), `[${Ci}]`;
          }
          let Qi = Object.keys(Si);
          const Zi = Qi.length;
          if (Zi === 0)
            return "{}";
          if (Ti < Mi.length + 1)
            return '"[Object]"';
          let Ni = "", Fi = "";
          yr !== "" && (xi += yr, Ki = `,
${xi}`, Ni = " ");
          const Xi = Math.min(Zi, Li);
          Wi && !Y(Si) && (Qi = C(Qi, Vi)), Mi.push(Si);
          for (let to = 0; to < Xi; to++) {
            const zi = Qi[to], Gi = Hi(zi, Si, Mi, ki, yr, xi);
            Gi !== void 0 && (Ci += `${Fi}${x(zi)}:${Ni}${Gi}`, Fi = Ki);
          }
          if (Zi > Li) {
            const to = Zi - Li;
            Ci += `${Fi}"...":${Ni}"${he(to)} not stringified"`, Fi = Ki;
          }
          return yr !== "" && Fi.length > 1 && (Ci = `
${xi}${Ci}
${Yi}`), Mi.pop(), `{${Ci}}`;
        }
        case "number":
          return isFinite(Si) ? String(Si) : _r ? _r(Si) : "null";
        case "boolean":
          return Si === !0 ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (qi)
            return String(Si);
        default:
          return _r ? _r(Si) : void 0;
      }
    }
    function pr(vr, Oi, Mi, ki, yr, xi) {
      switch (typeof Oi == "object" && Oi !== null && typeof Oi.toJSON == "function" && (Oi = Oi.toJSON(vr)), typeof Oi) {
        case "string":
          return x(Oi);
        case "object": {
          if (Oi === null)
            return "null";
          if (Mi.indexOf(Oi) !== -1)
            return Bi;
          const Si = xi;
          let Ci = "", Ki = ",";
          if (Array.isArray(Oi)) {
            if (Oi.length === 0)
              return "[]";
            if (Ti < Mi.length + 1)
              return '"[Array]"';
            Mi.push(Oi), yr !== "" && (xi += yr, Ci += `
${xi}`, Ki = `,
${xi}`);
            const Zi = Math.min(Oi.length, Li);
            let Ni = 0;
            for (; Ni < Zi - 1; Ni++) {
              const Xi = pr(String(Ni), Oi[Ni], Mi, ki, yr, xi);
              Ci += Xi !== void 0 ? Xi : "null", Ci += Ki;
            }
            const Fi = pr(String(Ni), Oi[Ni], Mi, ki, yr, xi);
            if (Ci += Fi !== void 0 ? Fi : "null", Oi.length - 1 > Li) {
              const Xi = Oi.length - Li - 1;
              Ci += `${Ki}"... ${he(Xi)} not stringified"`;
            }
            return yr !== "" && (Ci += `
${Si}`), Mi.pop(), `[${Ci}]`;
          }
          Mi.push(Oi);
          let Yi = "";
          yr !== "" && (xi += yr, Ki = `,
${xi}`, Yi = " ");
          let Qi = "";
          for (const Zi of ki) {
            const Ni = pr(Zi, Oi[Zi], Mi, ki, yr, xi);
            Ni !== void 0 && (Ci += `${Qi}${x(Zi)}:${Yi}${Ni}`, Qi = Ki);
          }
          return yr !== "" && Qi.length > 1 && (Ci = `
${xi}${Ci}
${Si}`), Mi.pop(), `{${Ci}}`;
        }
        case "number":
          return isFinite(Oi) ? String(Oi) : _r ? _r(Oi) : "null";
        case "boolean":
          return Oi === !0 ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (qi)
            return String(Oi);
        default:
          return _r ? _r(Oi) : void 0;
      }
    }
    function Di(vr, Oi, Mi, ki, yr) {
      switch (typeof Oi) {
        case "string":
          return x(Oi);
        case "object": {
          if (Oi === null)
            return "null";
          if (typeof Oi.toJSON == "function") {
            if (Oi = Oi.toJSON(vr), typeof Oi != "object")
              return Di(vr, Oi, Mi, ki, yr);
            if (Oi === null)
              return "null";
          }
          if (Mi.indexOf(Oi) !== -1)
            return Bi;
          const xi = yr;
          if (Array.isArray(Oi)) {
            if (Oi.length === 0)
              return "[]";
            if (Ti < Mi.length + 1)
              return '"[Array]"';
            Mi.push(Oi), yr += ki;
            let Ni = `
${yr}`;
            const Fi = `,
${yr}`, Xi = Math.min(Oi.length, Li);
            let to = 0;
            for (; to < Xi - 1; to++) {
              const Gi = Di(String(to), Oi[to], Mi, ki, yr);
              Ni += Gi !== void 0 ? Gi : "null", Ni += Fi;
            }
            const zi = Di(String(to), Oi[to], Mi, ki, yr);
            if (Ni += zi !== void 0 ? zi : "null", Oi.length - 1 > Li) {
              const Gi = Oi.length - Li - 1;
              Ni += `${Fi}"... ${he(Gi)} not stringified"`;
            }
            return Ni += `
${xi}`, Mi.pop(), `[${Ni}]`;
          }
          let Si = Object.keys(Oi);
          const Ci = Si.length;
          if (Ci === 0)
            return "{}";
          if (Ti < Mi.length + 1)
            return '"[Object]"';
          yr += ki;
          const Ki = `,
${yr}`;
          let Yi = "", Qi = "", Zi = Math.min(Ci, Li);
          Y(Oi) && (Yi += L(Oi, Ki, Li), Si = Si.slice(Oi.length), Zi -= Oi.length, Qi = Ki), Wi && (Si = C(Si, Vi)), Mi.push(Oi);
          for (let Ni = 0; Ni < Zi; Ni++) {
            const Fi = Si[Ni], Xi = Di(Fi, Oi[Fi], Mi, ki, yr);
            Xi !== void 0 && (Yi += `${Qi}${x(Fi)}: ${Xi}`, Qi = Ki);
          }
          if (Ci > Li) {
            const Ni = Ci - Li;
            Yi += `${Qi}"...": "${he(Ni)} not stringified"`, Qi = Ki;
          }
          return Qi !== "" && (Yi = `
${yr}${Yi}
${xi}`), Mi.pop(), `{${Yi}}`;
        }
        case "number":
          return isFinite(Oi) ? String(Oi) : _r ? _r(Oi) : "null";
        case "boolean":
          return Oi === !0 ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (qi)
            return String(Oi);
        default:
          return _r ? _r(Oi) : void 0;
      }
    }
    function z(vr, Oi, Mi) {
      switch (typeof Oi) {
        case "string":
          return x(Oi);
        case "object": {
          if (Oi === null)
            return "null";
          if (typeof Oi.toJSON == "function") {
            if (Oi = Oi.toJSON(vr), typeof Oi != "object")
              return z(vr, Oi, Mi);
            if (Oi === null)
              return "null";
          }
          if (Mi.indexOf(Oi) !== -1)
            return Bi;
          let ki = "";
          const yr = Oi.length !== void 0;
          if (yr && Array.isArray(Oi)) {
            if (Oi.length === 0)
              return "[]";
            if (Ti < Mi.length + 1)
              return '"[Array]"';
            Mi.push(Oi);
            const Yi = Math.min(Oi.length, Li);
            let Qi = 0;
            for (; Qi < Yi - 1; Qi++) {
              const Ni = z(String(Qi), Oi[Qi], Mi);
              ki += Ni !== void 0 ? Ni : "null", ki += ",";
            }
            const Zi = z(String(Qi), Oi[Qi], Mi);
            if (ki += Zi !== void 0 ? Zi : "null", Oi.length - 1 > Li) {
              const Ni = Oi.length - Li - 1;
              ki += `,"... ${he(Ni)} not stringified"`;
            }
            return Mi.pop(), `[${ki}]`;
          }
          let xi = Object.keys(Oi);
          const Si = xi.length;
          if (Si === 0)
            return "{}";
          if (Ti < Mi.length + 1)
            return '"[Object]"';
          let Ci = "", Ki = Math.min(Si, Li);
          yr && Y(Oi) && (ki += L(Oi, ",", Li), xi = xi.slice(Oi.length), Ki -= Oi.length, Ci = ","), Wi && (xi = C(xi, Vi)), Mi.push(Oi);
          for (let Yi = 0; Yi < Ki; Yi++) {
            const Qi = xi[Yi], Zi = z(Qi, Oi[Qi], Mi);
            Zi !== void 0 && (ki += `${Ci}${x(Qi)}:${Zi}`, Ci = ",");
          }
          if (Si > Li) {
            const Yi = Si - Li;
            ki += `${Ci}"...":"${he(Yi)} not stringified"`;
          }
          return Mi.pop(), `{${ki}}`;
        }
        case "number":
          return isFinite(Oi) ? String(Oi) : _r ? _r(Oi) : "null";
        case "boolean":
          return Oi === !0 ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (qi)
            return String(Oi);
        default:
          return _r ? _r(Oi) : void 0;
      }
    }
    function gr(vr, Oi, Mi) {
      if (arguments.length > 1) {
        let ki = "";
        if (typeof Mi == "number" ? ki = " ".repeat(Math.min(Mi, 10)) : typeof Mi == "string" && (ki = Mi.slice(0, 10)), Oi != null) {
          if (typeof Oi == "function")
            return Hi("", { "": vr }, [], Oi, ki, "");
          if (Array.isArray(Oi))
            return pr("", vr, [], tt(Oi), ki, "");
        }
        if (ki.length !== 0)
          return Di("", vr, [], ki, "");
      }
      return z("", vr, []);
    }
    return gr;
  }
})(safeStableStringify, safeStableStringify.exports);
var safeStableStringifyExports = safeStableStringify.exports;
const cjsModule = /* @__PURE__ */ getDefaultExportFromCjs$1(safeStableStringifyExports), configure = cjsModule.configure;
var RGX = /^(-?(?:\d+)?\.?\d+) *(m(?:illiseconds?|s(?:ecs?)?))?(s(?:ec(?:onds?|s)?)?)?(m(?:in(?:utes?|s)?)?)?(h(?:ours?|rs?)?)?(d(?:ays?)?)?(w(?:eeks?|ks?)?)?(y(?:ears?|rs?)?)?$/, SEC = 1e3, MIN = SEC * 60, HOUR = MIN * 60, DAY = HOUR * 24, YEAR = DAY * 365.25;
function parse(e) {
  var t, v = e.toLowerCase().match(RGX);
  if (v != null && (t = parseFloat(v[1])))
    return v[3] != null ? t * SEC : v[4] != null ? t * MIN : v[5] != null ? t * HOUR : v[6] != null ? t * DAY : v[7] != null ? t * DAY * 7 : v[8] != null ? t * YEAR : t;
}
const textEncoder = new TextEncoder();
function toUint8Array(e) {
  if (typeof e == "string")
    return textEncoder.encode(e);
  if (typeof SharedArrayBuffer < "u" && e instanceof SharedArrayBuffer)
    return new Uint8Array(e);
  if (e instanceof ArrayBuffer)
    return new Uint8Array(e);
  if (Array.isArray(e))
    return Uint8Array.from(e);
  const t = typeof e[Symbol.toPrimitive] == "function" ? e[Symbol.toPrimitive]("string") : e.valueOf();
  return textEncoder.encode(String(t));
}
function safeEqual(e, t) {
  if (typeof e == "string" && typeof t == "string") {
    const x = textEncoder.encode(e), C = textEncoder.encode(t), D = x.length, Y = new Uint8Array(D);
    Y.set(x.subarray(0, D));
    const L = new Uint8Array(D);
    L.set(C.subarray(0, D));
    let q = 0;
    for (let N = 0; N < D; N++)
      q |= Y[N] ^ L[N];
    return q === 0 && C.length === D;
  }
  const v = toUint8Array(e), w = toUint8Array(t);
  if (v.length !== w.length)
    return !1;
  let T = 0;
  for (const [x, C] of v.entries())
    T |= C ^ w[x];
  return T === 0;
}
const base64 = new Base64(), getRandomString = (e) => {
  const t = (e + 1) * 6, v = cryptoBrowserifyExports.randomBytes(Math.ceil(t / 8));
  return Buffer$C.from(v.buffer).toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/\=/g, "").slice(0, e);
};
function safeParse(e, t) {
  return parse_1(e, t, {
    protoAction: "remove",
    constructorAction: "remove"
  });
}
const stringify = configure({
  bigint: !1,
  circularValue: void 0,
  deterministic: !1
});
function jsonStringifyReplacer(e) {
  return function(t, v) {
    const w = e ? e.call(this, t, v) : v;
    return typeof w == "bigint" ? w.toString() : w;
  };
}
function safeStringify(e, t, v) {
  return stringify(e, jsonStringifyReplacer(t), v);
}
const parseMs = (e) => {
  if (typeof e == "number")
    return e;
  const t = parse(e);
  if (t === void 0)
    throw new Error(`Invalid duration expression "${e}"`);
  return t;
}, json = {
  safeParse,
  safeStringify
};
var Ir, Hr, Kr;
class MessageBuilder {
  constructor() {
    ir(this, Ir);
  }
  /**
   * Builds a message by encoding expiry date and purpose inside it.
   */
  build(t, v, w) {
    const T = Dr(this, Ir, Hr).call(this, v);
    return json.safeStringify({ message: t, purpose: w, expiryDate: T });
  }
  /**
   * Verifies the message for expiry and purpose.
   */
  verify(t, v) {
    const w = json.safeParse(t);
    return typeof w != "object" || !w || !w.message || w.purpose !== v || Dr(this, Ir, Kr).call(this, w) ? null : w.message;
  }
}
Ir = /* @__PURE__ */ new WeakSet(), Hr = function(e) {
  if (!e)
    return;
  const t = parseMs(e);
  return new Date(Date.now() + t);
}, /**
* Returns a boolean telling, if message has been expired or not
*/
Kr = function(e) {
  if (!e.expiryDate)
    return !1;
  const t = new Date(e.expiryDate);
  return Number.isNaN(t.getTime()) || t < /* @__PURE__ */ new Date();
};
var Cr;
class Hmac {
  constructor(t) {
    ir(this, Cr), Br(this, Cr, t);
  }
  /**
   * Generate the hmac
   */
  generate(t) {
    return base64.urlEncode(cryptoBrowserifyExports.createHmac("sha256", Uint8Array.from(tr(this, Cr))).update(t).digest());
  }
  /**
   * Compare raw value against an existing hmac
   */
  compare(t, v) {
    return safeEqual(this.generate(t), v);
  }
}
Cr = /* @__PURE__ */ new WeakMap();
var Ar, Tr;
class MessageVerifier {
  constructor(t) {
    ir(this, Ar), ir(this, Tr, "."), Br(this, Ar, cryptoBrowserifyExports.createHash("sha256").update(t).digest());
  }
  /**
   * Sign a given piece of value using the app secret. A wide range of
   * data types are supported. See [@nhtio/serialization](https://serialization.nht.io/quickstart.html#supported-data-types) for more information
   * on the supported data types.
   *
   * You can optionally define a purpose for which the value was signed and
   * mentioning a different purpose/no purpose during unsign will fail.
   */
  sign(t, v, w) {
    if (t == null)
      throw new I(`Cannot sign "${t}" value`);
    if (!kr$1(t))
      throw new O(t);
    const T = base64.urlEncode(new MessageBuilder().build(t, v, w));
    return `${T}${tr(this, Tr)}${new Hmac(tr(this, Ar)).generate(T)}`;
  }
  /**
   * Unsign a previously signed value with an optional purpose
   */
  unsign(t, v) {
    if (typeof t != "string")
      return null;
    const [w, T] = t.split(tr(this, Tr));
    if (!w || !T)
      return null;
    const x = base64.urlDecode(w, void 0, !1);
    return x && new Hmac(tr(this, Ar)).compare(w, T) ? new MessageBuilder().verify(x, v) : null;
  }
  /**
   * Checks if the value can be encoded
   */
  encodable(t) {
    return kr$1(t);
  }
  /**
   * Checks if the value can be encoded
   */
  static encodable(t) {
    return kr$1(t);
  }
}
Ar = /* @__PURE__ */ new WeakMap(), Tr = /* @__PURE__ */ new WeakMap();
var Rr, nr, Mr, kr, Gr;
const Lr = class Qa {
  constructor(t) {
    ir(this, kr), ir(this, Rr), ir(this, nr), ir(this, Mr, "."), qr(this, "verifier"), qr(this, "base64", base64);
    const v = t.secret && typeof t.secret == "object" && "release" in t.secret ? t.secret.release() : t.secret;
    Br(this, Rr, { algorithm: "aes-256-cbc", ...t }), Dr(this, kr, Gr).call(this, v), Br(this, nr, cryptoBrowserifyExports.createHash("sha256").update(v).digest()), this.verifier = new MessageVerifier(v);
  }
  /**
   * The algorithm in use
   */
  get algorithm() {
    return tr(this, Rr).algorithm;
  }
  /**
   * Encrypt a given piece of value using the app secret. A wide range of
   * data types are supported. See [@nhtio/serialization](https://serialization.nht.io/quickstart.html#supported-data-types) for more information
   * on the supported data types.
   *
   * You can optionally define a purpose for which the value was encrypted and
   * mentioning a different purpose/no purpose during decrypt will fail.
   * @param payload - The value to encrypt
   * @param expiresIn - The time to live for the value. It can be a number or a string
   * @param purpose - The purpose for which the value was encrypted
   */
  encrypt(t, v, w) {
    t = Buffer$C.from(ji(t)).toString("base64");
    const T = getRandomString(16), x = cryptoBrowserifyExports.createCipheriv(this.algorithm, Uint8Array.from(tr(this, nr)), T), C = new MessageBuilder().build(t, v, w), D = Buffer$C.concat([
      Uint8Array.from(x.update(C, "utf-8")),
      Uint8Array.from(x.final())
    ]), Y = `${this.base64.urlEncode(D)}${tr(this, Mr)}${this.base64.urlEncode(
      T
    )}`;
    return `${Y}${tr(this, Mr)}${new Hmac(tr(this, nr)).generate(Y)}`;
  }
  /**
   * Decrypt value and verify it against a purpose
   */
  decrypt(t, v) {
    if (typeof t != "string")
      return null;
    const [w, T, x] = t.split(tr(this, Mr));
    if (!w || !T || !x)
      return null;
    const C = this.base64.urlDecode(w, "base64");
    if (!C)
      return null;
    const D = this.base64.urlDecode(T);
    if (!D || !new Hmac(tr(this, nr)).compare(
      `${w}${tr(this, Mr)}${T}`,
      x
    ))
      return null;
    try {
      const Y = cryptoBrowserifyExports.createDecipheriv(this.algorithm, Uint8Array.from(tr(this, nr)), D), L = Y.update(C, "base64", "utf8") + Y.final("utf8"), q = new MessageBuilder().verify(L, v);
      if (!q || typeof q != "string")
        return null;
      const N = Uint8Array.from(Buffer$C.from(q, "base64"));
      return Ii(N);
    } catch {
      return null;
    }
  }
  /**
   * Create a children instance with different secret key
   */
  child(t) {
    return new Qa({ ...tr(this, Rr), ...t });
  }
  /**
   * Checks if the value can be encoded
   */
  encodable(t) {
    return kr$1(t);
  }
  /**
   * Checks if the value can be encoded
   */
  static encodable(t) {
    return kr$1(t);
  }
};
Rr = /* @__PURE__ */ new WeakMap(), nr = /* @__PURE__ */ new WeakMap(), Mr = /* @__PURE__ */ new WeakMap(), kr = /* @__PURE__ */ new WeakSet(), /**
* Validates the app secret
*/
Gr = function(e) {
  if (typeof e != "string")
    throw new A();
  if (e.length < 16)
    throw new k();
};
let Encryption = Lr;
const REDACTED = "[redacted]";
var Pr, ar;
const Fr = class eu {
  constructor(t, v) {
    ir(this, Pr), ir(this, ar), Br(this, Pr, t), Br(this, ar, v || REDACTED);
  }
  toJSON() {
    return tr(this, ar);
  }
  valueOf() {
    return tr(this, ar);
  }
  toLocaleString() {
    return tr(this, ar);
  }
  toString() {
    return tr(this, ar);
  }
  /**
   * Returns the original value
   */
  release() {
    return tr(this, Pr);
  }
  /**
   * Transform the original value and create a new
   * secret from it.
   */
  map(t) {
    return new eu(t(tr(this, Pr)));
  }
};
Pr = /* @__PURE__ */ new WeakMap(), ar = /* @__PURE__ */ new WeakMap();
let Secret = Fr;
const getEncryption = (e) => {
  const t = getGlobal();
  if (typeof t[FOR_ENCRYPTION] < "u" && t[FOR_ENCRYPTION] instanceof Encryption)
    return t[FOR_ENCRYPTION];
  if (typeof e == "string" || e instanceof Secret)
    return t[FOR_ENCRYPTION] = new Encryption({
      secret: e
    }), t[FOR_ENCRYPTION];
  throw new MissingEncryptionKey();
}, setPSK = (e) => {
  const t = getGlobal();
  if (!(typeof t[FOR_ENCRYPTION] < "u" && t[FOR_ENCRYPTION] instanceof Encryption) && (typeof e == "string" || e instanceof Secret)) {
    t[FOR_ENCRYPTION] = new Encryption({
      secret: e
    });
    return;
  }
}, logger = getLogger();
var Oa, na, Ba, fa, ua, ca, oa, aa, ta, ia, la, Ia, Co, za, Ga, Va, Ka, Pa, tu, qa, ru, Za;
const ra = class ra extends TypedEventEmitter {
  /** @private */
  constructor(v) {
    const w = getGlobal(), T = getEncryption(v);
    if (typeof w[FOR_SWARM] < "u" && w[FOR_SWARM] instanceof ra)
      throw new AlreadyInitializedInContextError();
    if (typeof navigator > "u" || !("serviceWorker" in navigator))
      throw new UnsupportedEnvironmentError();
    super();
    Xo(this, Co);
    Xo(this, Oa);
    Xo(this, na);
    Xo(this, Ba);
    Xo(this, fa);
    Xo(this, ua);
    Xo(this, ca);
    Xo(this, oa);
    Xo(this, aa);
    Xo(this, ta);
    Xo(this, ia);
    Xo(this, la);
    Xo(this, Ia);
    w[FOR_SWARM] = this, Jo(this, aa, T), Jo(this, Oa, makeRandomId(8)), Jo(this, na, new TypedEventEmitter()), Jo(this, Ba, /* @__PURE__ */ new Map()), Jo(this, fa, /* @__PURE__ */ new Map()), Jo(this, ua, /* @__PURE__ */ new Map()), Jo(this, ca, /* @__PURE__ */ new Map()), Jo(this, oa, /* @__PURE__ */ new Map()), Jo(this, Ia, 1e3), logger.debug(`Swarm instance initialized with ID "${fo(this, Oa)}"`), Jo(this, la, !1), Jo(this, ta, new BroadcastChannel$1("nhtio-swarm", {
      webWorkerSupport: !0,
      idb: {
        onclose: () => {
          logger.WARNING("Swarm channel closed, reinitializing..."), fo(this, ta).close(), Oo(this, Co, za).call(this, !0);
        }
      }
    })), Jo(this, ia, createLeaderElection(fo(this, ta))), Oo(this, Co, Ka).call(this), Oo(this, Co, Ga).call(this), logger.debug("Swarm instance is ready"), Oo(this, Co, ru).call(this), isTabEnvironment() && w.addEventListener("beforeunload", () => {
      Oo(this, Co, qa).call(this, ra.INTERNAL_OBITUARY, fo(this, Oa));
    });
  }
  /**
   * The ID of the current instance.
   */
  get id() {
    return fo(this, Oa);
  }
  /**
   * Whether this instance is the leader or not.
   */
  get leader() {
    return fo(this, la);
  }
  /**
   * Emit an event to all connected peers.
   * @param event - The name of the event to emit.
   * @param args - The arguments to pass to the event listeners.
   * @typeParam E - The name of the event to emit.
   */
  emit(v, ...w) {
    const T = {
      id: makeRandomId(16),
      event: v,
      args: w,
      needsAck: !1,
      isAck: !1
    }, x = fo(this, aa).encrypt(T);
    return fo(this, ta).postMessage(x).catch((C) => {
      logger.error("Got error while sending message", C);
    }), super.emit(v, ...w), this;
  }
  /**
   * Subscribe to the leadership change event.
   * @param cb - The callback function to be called when the leadership status changes.
   */
  onLeadershipChange(v) {
    return fo(this, na).on("leadership", v), this;
  }
  /**
   * Remove the leadership change event listener.
   * @param cb - The callback function to be removed from the leadership change event.
   */
  offLeadershipChange(v) {
    return fo(this, na).off("leadership", v), this;
  }
  /**
   * Subscribe to the next occurance of a leadership change event.
   * @param cb - The callback function to be called when the leadership status changes.
   */
  onceLeadershipChange(v) {
    return fo(this, na).once("leadership", v), this;
  }
  /**
   * Collect responses from all peers for a specific event.
   * @param event The name of the event to collect responses for.
   * @param args The arguments which will be passed to the event handler.
   * @returns A promise that resolves with an array of responses from all peers.
   * @typeParam R - The type of the response.
   * @typeParam E - The name of the event to collect responses for.
   */
  collect(v, ...w) {
    const T = makeRandomId(16), x = fo(this, ca).get(v), C = { responses: [], timer: null, resolve: (L) => {
    } }, D = new Promise((L) => {
      C.resolve = L, C.timer = setTimeout(() => {
        fo(this, ua).delete(T), L(C.responses);
      }, fo(this, Ia));
    });
    fo(this, ua).set(T, C), x && Promise.resolve(x(...w)).then((L) => {
      C.responses.push(L), Oo(this, Co, Za).call(this, T);
    });
    const Y = { id: T, event: v, args: w, needsCollect: !0 };
    return fo(this, ta).postMessage(fo(this, aa).encrypt(Y)).catch((L) => logger.error(L)), D;
  }
  /**
   * Register a handler for a specific event which will respond to incoming messages which require a general response
   * @param event The name of the event to listen for.
   * @param handler The function to call when the event is emitted.
   * @typeParam E - The name of the event to listen for.
   */
  onCollect(v, w) {
    return fo(this, ca).set(v, w), this;
  }
  /**
   * De-register a handler for a specific event which will respond to incoming messages which require a general response
   * @param event The name of the event to listen for.
   * @param handler The function to call when the event is emitted.
   * @typeParam E - The name of the event to listen for.
   */
  offCollect(v) {
    return fo(this, ca).delete(v), this;
  }
  /**
   * Request feedback from the leader for a specific event.
   * @param event The name of the event to request feedback for.
   * @param args The arguments to pass to the event handler.
   * @returns A promise that resolves with the response from the event handler.
   * @typeParam R - The type of the response.
   * @typeParam E - The name of the event to request feedback for.
   */
  request(v, ...w) {
    const T = makeRandomId(16), x = {
      id: T,
      event: v,
      args: w,
      needsAck: !0
    }, C = fo(this, aa).encrypt(x);
    return fo(this, ta).postMessage(C).catch((D) => {
      logger.error("Error sending request:", D);
    }), new Promise((D, Y) => {
      const L = setTimeout(() => {
        fo(this, fa).delete(T), Y(new RequestTimeoutError(v));
      }, fo(this, Ia));
      fo(this, fa).set(T, { resolve: D, reject: Y, timer: L });
    });
  }
  /**
   * Register a handler for a specific event which will respond to incoming messages which require a response from the leader
   * @param event The name of the event to listen for.
   * @param handler The function to call when the event is emitted.
   * @typeParam E - The name of the event to listen for.
   */
  onRequest(v, w) {
    return fo(this, Ba).set(v, w), this;
  }
  /**
   * De-register a handler for a specific event which will respond to incoming messages which require a response from the leader
   * @param event The name of the event to listen for.
   * @param handler The function to call when the event is emitted.
   * @typeParam E - The name of the event to listen for.
   */
  offRequest(v) {
    return fo(this, Ba).delete(v), this;
  }
  /**
   * Set the timeout for waiting for a response from `request()` or `collect()`.
   * @param timeout The timeout in milliseconds to wait for a response.
   * @returns The current instance of the Swarm class for the current context.
   */
  setAwaitResponseTimeout(v) {
    return Jo(this, Ia, v), this;
  }
  /**
   * Retreive the current instance of the Swarm class for the current context.
   * @typeParam Events - The map of events and their arguments that can be emitted and listened to.
   * @returns The current instance of the Swarm class for the current context.
   */
  static instance(v) {
    const w = getGlobal();
    return typeof w[FOR_SWARM] < "u" && w[FOR_SWARM] instanceof ra ? w[FOR_SWARM] : new ra(v);
  }
};
Oa = new WeakMap(), na = new WeakMap(), Ba = new WeakMap(), fa = new WeakMap(), ua = new WeakMap(), ca = new WeakMap(), oa = new WeakMap(), aa = new WeakMap(), ta = new WeakMap(), ia = new WeakMap(), la = new WeakMap(), Ia = new WeakMap(), Co = new WeakSet(), za = function(v = !1) {
  fo(this, ta) && !v || (Jo(this, ta, new BroadcastChannel$1("nhtio-swarm", {
    webWorkerSupport: !0,
    idb: {
      onclose: () => {
        fo(this, ta).close(), Oo(this, Co, za).call(this, !0);
      }
    }
  })), Jo(this, ia, createLeaderElection(fo(this, ta))), Oo(this, Co, Ga).call(this));
}, Ga = function() {
  logger.debug("Hooking swarm channel events"), fo(this, ta).onmessage = (v) => Oo(this, Co, tu).call(this, v), logger.debug("Swarm channel events hooked");
}, Va = function(v) {
  fo(this, la) !== v && (Jo(this, la, v), fo(this, na).emit("leadership", v), logger.debug(`Swarm instance is now ${v ? "the" : "not the"} leader`));
}, Ka = function() {
  new Promise(async (v) => {
    await fo(this, ia).hasLeader() || (logger.debug("No leader found, trying to elect one"), await fo(this, ia).awaitLeadership(), logger.debug("Leader elected"), Oo(this, Co, Va).call(this, fo(this, ia).isLeader)), v(void 0);
  }).catch((v) => {
    logger.error("Got error while checking for leader", v);
  }).finally(() => {
    setTimeout(() => Oo(this, Co, Ka).call(this), 500);
  });
}, Pa = function(v) {
  fo(this, ta).postMessage(
    fo(this, aa).encrypt({
      id: makeRandomId(16),
      ...v
    })
  ).catch((w) => logger.error(w));
}, tu = function(v) {
  const w = fo(this, aa).decrypt(v);
  if (typeof w != "object" || w === null || typeof w.event != "string" && typeof w.event != "number" || !Array.isArray(w.args))
    return;
  const {
    id: T,
    event: x,
    args: C,
    needsAck: D,
    isAck: Y,
    needsCollect: L,
    isCollectResponse: q,
    replyTo: N,
    result: F,
    error: ae
  } = w;
  if (x === ra.INTERNAL_HEARTBEAT) {
    const [he] = C, tt = !fo(this, oa).has(he);
    fo(this, oa).set(he, Date.now()), fo(this, na).emit(tt ? "peerJoined" : "peerHeartbeat", he);
    return;
  }
  if (x === ra.INTERNAL_OBITUARY) {
    const [he] = C;
    fo(this, oa).delete(he) && fo(this, na).emit("peerLeft", he);
    return;
  }
  if (Y && N) {
    const he = fo(this, fa).get(N);
    he && (clearTimeout(he.timer), fo(this, fa).delete(N), typeof ae == "string" ? he.reject(new Error(String(ae))) : he.resolve(F));
    return;
  }
  if (D) {
    fo(this, ia).hasLeader().then(async (he) => {
      if (he || (await fo(this, ia).awaitLeadership(), Oo(this, Co, Va).call(this, fo(this, ia).isLeader)), fo(this, la)) {
        const tt = fo(this, Ba).get(x);
        tt && Promise.resolve(tt(...C)).then((br) => {
          Oo(this, Co, Pa).call(this, {
            event: x,
            args: [],
            isAck: !0,
            replyTo: T,
            result: br
          });
        }).catch((br) => {
          Oo(this, Co, Pa).call(this, {
            event: x,
            args: [],
            isAck: !0,
            replyTo: T,
            error: br.message
          });
        });
      }
    });
    return;
  }
  if (q && N) {
    const he = fo(this, ua).get(N);
    he && (he.responses.push(F), Oo(this, Co, Za).call(this, N));
    return;
  }
  if (L) {
    const he = fo(this, ca).get(x);
    he && Promise.resolve(he(...C)).then((tt) => {
      Oo(this, Co, Pa).call(this, {
        event: x,
        args: [],
        isCollectResponse: !0,
        replyTo: T,
        result: tt
      });
    }).catch((tt) => {
      Oo(this, Co, Pa).call(this, {
        event: x,
        args: [],
        isCollectResponse: !0,
        replyTo: T,
        error: tt.message
      });
    });
    return;
  }
  Ja(ra.prototype, this, "emit").call(this, x, ...C);
}, qa = function(v, ...w) {
  const T = { id: makeRandomId(16), event: v, args: w };
  fo(this, ta).postMessage(fo(this, aa).encrypt(T)).catch((x) => logger.error(x));
}, ru = function() {
  Oo(this, Co, qa).call(this, ra.INTERNAL_HEARTBEAT, this.id), setInterval(() => {
    Oo(this, Co, qa).call(this, ra.INTERNAL_HEARTBEAT, this.id);
  }, 2e3), setInterval(() => {
    const v = Date.now();
    for (const [w, T] of fo(this, oa))
      v - T > 6e3 && (fo(this, oa).delete(w), fo(this, na).emit("peerLeft", w));
  }, 2e3);
}, Za = function(v) {
  const w = fo(this, ua).get(v);
  if (!w) return;
  const T = fo(this, oa).size + 1;
  w.responses.length >= T && (clearTimeout(w.timer), setTimeout(() => {
    fo(this, ua).delete(v) && w.resolve(w.responses);
  }, 100));
}, Ta(ra, "INTERNAL_HEARTBEAT", "__swarm_heartbeat"), Ta(ra, "INTERNAL_OBITUARY", "__swarm_obituary");
let Swarm = ra;
const version = "1.20250425.0";
export {
  Secret,
  Swarm,
  vu as errors,
  setLogLevel,
  setPSK,
  gu as types,
  version
};
//# sourceMappingURL=index.mjs.map
