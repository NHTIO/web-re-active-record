{"version":3,"file":"sort_imports_by_type_and_size.mjs","sources":["../../src/rules/sort_imports_by_type_and_size.ts"],"sourcesContent":["/**\n * @module @nhtio/eslint-config/rules/sort_imports_by_type_and_size\n */\n\nimport { createRule } from './common'\n\nimport type { TSESTree } from '@typescript-eslint/utils'\n\nconst sortImportsByTypeAndSizeRule = createRule({\n  name: 'sortImportsByTypeAndSize',\n  meta: {\n    type: 'layout',\n    docs: {\n      description:\n        'Group imports: nonâ€‘type imports first, then type-only; each group sorted by declaration length.',\n    },\n    fixable: 'code',\n    schema: [],\n    messages: {\n      wrongOrder:\n        'Imports should be grouped: non-type first, then type-only; each group sorted by length.',\n    },\n  },\n  create(context) {\n    const sourceCode = context.sourceCode\n    let importDecls: TSESTree.ImportDeclaration[] = []\n\n    return {\n      'Program'(node: TSESTree.Program) {\n        importDecls = node.body.filter(\n          (n): n is TSESTree.ImportDeclaration => n.type === 'ImportDeclaration'\n        )\n      },\n      'Program:exit'() {\n        if (importDecls.length < 2) return\n\n        const meta = importDecls.map((decl) => {\n          const text = sourceCode.getText(decl)\n          return {\n            decl,\n            text,\n            isTypeOnly: decl.importKind === 'type',\n            len: text.length,\n          }\n        })\n\n        const sorted = [\n          ...meta.filter((m) => !m.isTypeOnly).sort((a, b) => a.len - b.len),\n          ...meta.filter((m) => m.isTypeOnly).sort((a, b) => a.len - b.len),\n        ]\n\n        for (const [i, element] of meta.entries()) {\n          if (element.decl !== sorted[i].decl) {\n            context.report({\n              node: element.decl,\n              messageId: 'wrongOrder',\n              fix(fixer) {\n                const allText = sorted.map((m) => m.text).join('\\n')\n                const first = importDecls[0]\n                const last = importDecls[importDecls.length - 1]\n                return fixer.replaceTextRange([first.range![0], last.range![1]], allText)\n              },\n            })\n            break\n          }\n        }\n      },\n    }\n  },\n  defaultOptions: [],\n})\nexport default sortImportsByTypeAndSizeRule\n"],"names":["sortImportsByTypeAndSizeRule","createRule","context","sourceCode","importDecls","node","meta","decl","text","sorted","m","a","b","i","element","fixer","allText","first","last"],"mappings":";AAQA,MAAMA,IAA+BC,EAAW;AAAA,EAC9C,MAAM;AAAA,EACN,MAAM;AAAA,IACJ,MAAM;AAAA,IACN,MAAM;AAAA,MACJ,aACE;AAAA,IACJ;AAAA,IACA,SAAS;AAAA,IACT,QAAQ,CAAC;AAAA,IACT,UAAU;AAAA,MACR,YACE;AAAA,IACJ;AAAA,EACF;AAAA,EACA,OAAOC,GAAS;AACd,UAAMC,IAAaD,EAAQ;AAC3B,QAAIE,IAA4C,CAAA;AAEzC,WAAA;AAAA,MACL,QAAUC,GAAwB;AAChC,QAAAD,IAAcC,EAAK,KAAK;AAAA,UACtB,CAAC,MAAuC,EAAE,SAAS;AAAA,QAAA;AAAA,MAEvD;AAAA,MACA,iBAAiB;AACX,YAAAD,EAAY,SAAS,EAAG;AAE5B,cAAME,IAAOF,EAAY,IAAI,CAACG,MAAS;AAC/B,gBAAAC,IAAOL,EAAW,QAAQI,CAAI;AAC7B,iBAAA;AAAA,YACL,MAAAA;AAAA,YACA,MAAAC;AAAA,YACA,YAAYD,EAAK,eAAe;AAAA,YAChC,KAAKC,EAAK;AAAA,UAAA;AAAA,QACZ,CACD,GAEKC,IAAS;AAAA,UACb,GAAGH,EAAK,OAAO,CAACI,MAAM,CAACA,EAAE,UAAU,EAAE,KAAK,CAACC,GAAGC,MAAMD,EAAE,MAAMC,EAAE,GAAG;AAAA,UACjE,GAAGN,EAAK,OAAO,CAACI,MAAMA,EAAE,UAAU,EAAE,KAAK,CAACC,GAAGC,MAAMD,EAAE,MAAMC,EAAE,GAAG;AAAA,QAAA;AAGlE,mBAAW,CAACC,GAAGC,CAAO,KAAKR,EAAK;AAC9B,cAAIQ,EAAQ,SAASL,EAAOI,CAAC,EAAE,MAAM;AACnC,YAAAX,EAAQ,OAAO;AAAA,cACb,MAAMY,EAAQ;AAAA,cACd,WAAW;AAAA,cACX,IAAIC,GAAO;AACH,sBAAAC,IAAUP,EAAO,IAAI,CAACC,MAAMA,EAAE,IAAI,EAAE,KAAK;AAAA,CAAI,GAC7CO,IAAQb,EAAY,CAAC,GACrBc,IAAOd,EAAYA,EAAY,SAAS,CAAC;AAC/C,uBAAOW,EAAM,iBAAiB,CAACE,EAAM,MAAO,CAAC,GAAGC,EAAK,MAAO,CAAC,CAAC,GAAGF,CAAO;AAAA,cAC1E;AAAA,YAAA,CACD;AACD;AAAA,UACF;AAAA,MAEJ;AAAA,IAAA;AAAA,EAEJ;AAAA,EACA,gBAAgB,CAAC;AACnB,CAAC;"}