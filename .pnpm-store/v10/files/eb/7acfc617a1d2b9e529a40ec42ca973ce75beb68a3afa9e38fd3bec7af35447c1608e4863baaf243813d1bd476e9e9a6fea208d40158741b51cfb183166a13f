"use strict";var et=b=>{throw TypeError(b)};var Le=(b,p,$)=>p.has(b)||et("Cannot "+$);var me=(b,p,$)=>(Le(b,p,"read from private field"),$?$.call(b):p.get(b)),Ne=(b,p,$)=>p.has(b)?et("Cannot add the same private member more than once"):p instanceof WeakSet?p.add(b):p.set(b,$),tt=(b,p,$,A)=>(Le(b,p,"write to private field"),A?A.call(b,$):p.set(b,$),$),G=(b,p,$)=>(Le(b,p,"access private method"),$);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const re=require("./errors.cjs"),J=require("luxon"),At=-1,Se=0,fe=1,_e=2,Me=3,Ue=4,qe=5,ze=6,Ot=7,jt=8,rt=typeof self=="object"?self:globalThis,gr=(b,p)=>{const $=(x,w)=>(b.set(w,x),x),A=x=>{if(b.has(x))return b.get(x);const[w,m]=p[x];switch(w){case Se:case At:return $(m,x);case fe:{const a=$([],x);for(const h of m)a.push(A(h));return a}case _e:{const a=$({},x);for(const[h,y]of m)a[A(h)]=A(y);return a}case Me:return $(new Date(m),x);case Ue:{const{source:a,flags:h}=m;return $(new RegExp(a,h),x)}case qe:{const a=$(new Map,x);for(const[h,y]of m)a.set(A(h),A(y));return a}case ze:{const a=$(new Set,x);for(const h of m)a.add(A(h));return a}case Ot:{const{name:a,message:h}=m;return $(new rt[a](h),x)}case jt:return $(BigInt(m),x);case"BigInt":return $(Object(BigInt(m)),x);case"ArrayBuffer":return $(new Uint8Array(m).buffer,m);case"DataView":{const{buffer:a}=new Uint8Array(m);return $(new DataView(a),m)}}return $(new rt[w](m),x)};return A},yr=b=>gr(new Map,b)(0),ne="",{toString:br}={},{keys:vr}=Object,ce=b=>{const p=typeof b;if(p!=="object"||!b)return[Se,p];const $=br.call(b).slice(8,-1);switch($){case"Array":return[fe,ne];case"Object":return[_e,ne];case"Date":return[Me,ne];case"RegExp":return[Ue,ne];case"Map":return[qe,ne];case"Set":return[ze,ne];case"DataView":return[fe,$]}return $.includes("Array")?[fe,$]:$.includes("Error")?[Ot,$]:[_e,$]},de=([b,p])=>b===Se&&(p==="function"||p==="symbol"),_r=(b,p,$,A)=>{const x=(m,a)=>{const h=A.push(m)-1;return $.set(a,h),h},w=m=>{if($.has(m))return $.get(m);let[a,h]=ce(m);switch(a){case Se:{let c=m;switch(h){case"bigint":a=jt,c=m.toString();break;case"function":case"symbol":if(b)throw new TypeError("unable to serialize "+h);c=null;break;case"undefined":return x([At],m)}return x([a,c],m)}case fe:{if(h){let i=m;return h==="DataView"?i=new Uint8Array(m.buffer):h==="ArrayBuffer"&&(i=new Uint8Array(m)),x([h,[...i]],m)}const c=[],e=x([a,c],m);for(const i of m)c.push(w(i));return e}case _e:{if(h)switch(h){case"BigInt":return x([h,m.toString()],m);case"Boolean":case"Number":case"String":return x([h,m.valueOf()],m)}if(p&&"toJSON"in m)return w(m.toJSON());const c=[],e=x([a,c],m);for(const i of vr(m))(b||!de(ce(m[i])))&&c.push([w(i),w(m[i])]);return e}case Me:return x([a,m.toISOString()],m);case Ue:{const{source:c,flags:e}=m;return x([a,{source:c,flags:e}],m)}case qe:{const c=[],e=x([a,c],m);for(const[i,n]of m)(b||!(de(ce(i))||de(ce(n))))&&c.push([w(i),w(n)]);return e}case ze:{const c=[],e=x([a,c],m);for(const i of m)(b||!de(ce(i)))&&c.push(w(i));return e}}const{message:y}=m;return x([a,{name:h,message:y}],m)};return w},$r=(b,{json:p,lossy:$}={})=>{const A=[];return _r(!(p||$),!!p,new Map,A)(b),A},W=b=>{const p=$r(b),$=JSON.stringify(p);return Uint8Array.from($,A=>A.charCodeAt(0))},H=b=>{const p=Array.from(b).map($=>String.fromCharCode($)).join("");try{const $=JSON.parse(p);return yr($)}catch($){throw new re.E_VALUE_UNPARSEABLE($ instanceof Error?$:void 0)}};function wr(b){return b&&b.__esModule&&Object.prototype.hasOwnProperty.call(b,"default")?b.default:b}var $e={exports:{}};$e.exports;(function(b,p){(function($,A){b.exports=A()})(self,()=>{return $={7629:(x,w,m)=>{const a=m(375),h=m(8571),y=m(9474),c=m(1687),e=m(8652),i=m(8160),n=m(3292),r=m(6354),t=m(8901),l=m(9708),s=m(6914),o=m(2294),u=m(6133),d=m(1152),v=m(8863),R=m(2036),E={Base:class{constructor(f){this.type=f,this.$_root=null,this._definition={},this._reset()}_reset(){this._ids=new o.Ids,this._preferences=null,this._refs=new u.Manager,this._cache=null,this._valids=null,this._invalids=null,this._flags={},this._rules=[],this._singleRules=new Map,this.$_terms={},this.$_temp={ruleset:null,whens:{}}}describe(){return a(typeof l.describe=="function","Manifest functionality disabled"),l.describe(this)}allow(...f){return i.verifyFlat(f,"allow"),this._values(f,"_valids")}alter(f){a(f&&typeof f=="object"&&!Array.isArray(f),"Invalid targets argument"),a(!this._inRuleset(),"Cannot set alterations inside a ruleset");const g=this.clone();g.$_terms.alterations=g.$_terms.alterations||[];for(const _ in f){const S=f[_];a(typeof S=="function","Alteration adjuster for",_,"must be a function"),g.$_terms.alterations.push({target:_,adjuster:S})}return g.$_temp.ruleset=!1,g}artifact(f){return a(f!==void 0,"Artifact cannot be undefined"),a(!this._cache,"Cannot set an artifact with a rule cache"),this.$_setFlag("artifact",f)}cast(f){return a(f===!1||typeof f=="string","Invalid to value"),a(f===!1||this._definition.cast[f],"Type",this.type,"does not support casting to",f),this.$_setFlag("cast",f===!1?void 0:f)}default(f,g){return this._default("default",f,g)}description(f){return a(f&&typeof f=="string","Description must be a non-empty string"),this.$_setFlag("description",f)}empty(f){const g=this.clone();return f!==void 0&&(f=g.$_compile(f,{override:!1})),g.$_setFlag("empty",f,{clone:!1})}error(f){return a(f,"Missing error"),a(f instanceof Error||typeof f=="function","Must provide a valid Error object or a function"),this.$_setFlag("error",f)}example(f,g={}){return a(f!==void 0,"Missing example"),i.assertOptions(g,["override"]),this._inner("examples",f,{single:!0,override:g.override})}external(f,g){return typeof f=="object"&&(a(!g,"Cannot combine options with description"),g=f.description,f=f.method),a(typeof f=="function","Method must be a function"),a(g===void 0||g&&typeof g=="string","Description must be a non-empty string"),this._inner("externals",{method:f,description:g},{single:!0})}failover(f,g){return this._default("failover",f,g)}forbidden(){return this.presence("forbidden")}id(f){return f?(a(typeof f=="string","id must be a non-empty string"),a(/^[^\.]+$/.test(f),"id cannot contain period character"),this.$_setFlag("id",f)):this.$_setFlag("id",void 0)}invalid(...f){return this._values(f,"_invalids")}label(f){return a(f&&typeof f=="string","Label name must be a non-empty string"),this.$_setFlag("label",f)}meta(f){return a(f!==void 0,"Meta cannot be undefined"),this._inner("metas",f,{single:!0})}note(...f){a(f.length,"Missing notes");for(const g of f)a(g&&typeof g=="string","Notes must be non-empty strings");return this._inner("notes",f)}only(f=!0){return a(typeof f=="boolean","Invalid mode:",f),this.$_setFlag("only",f)}optional(){return this.presence("optional")}prefs(f){a(f,"Missing preferences"),a(f.context===void 0,"Cannot override context"),a(f.externals===void 0,"Cannot override externals"),a(f.warnings===void 0,"Cannot override warnings"),a(f.debug===void 0,"Cannot override debug"),i.checkPreferences(f);const g=this.clone();return g._preferences=i.preferences(g._preferences,f),g}presence(f){return a(["optional","required","forbidden"].includes(f),"Unknown presence mode",f),this.$_setFlag("presence",f)}raw(f=!0){return this.$_setFlag("result",f?"raw":void 0)}result(f){return a(["raw","strip"].includes(f),"Unknown result mode",f),this.$_setFlag("result",f)}required(){return this.presence("required")}strict(f){const g=this.clone(),_=f!==void 0&&!f;return g._preferences=i.preferences(g._preferences,{convert:_}),g}strip(f=!0){return this.$_setFlag("result",f?"strip":void 0)}tag(...f){a(f.length,"Missing tags");for(const g of f)a(g&&typeof g=="string","Tags must be non-empty strings");return this._inner("tags",f)}unit(f){return a(f&&typeof f=="string","Unit name must be a non-empty string"),this.$_setFlag("unit",f)}valid(...f){i.verifyFlat(f,"valid");const g=this.allow(...f);return g.$_setFlag("only",!!g._valids,{clone:!1}),g}when(f,g){const _=this.clone();_.$_terms.whens||(_.$_terms.whens=[]);const S=n.when(_,f,g);if(!["any","link"].includes(_.type)){const I=S.is?[S]:S.switch;for(const k of I)a(!k.then||k.then.type==="any"||k.then.type===_.type,"Cannot combine",_.type,"with",k.then&&k.then.type),a(!k.otherwise||k.otherwise.type==="any"||k.otherwise.type===_.type,"Cannot combine",_.type,"with",k.otherwise&&k.otherwise.type)}return _.$_terms.whens.push(S),_.$_mutateRebuild()}cache(f){a(!this._inRuleset(),"Cannot set caching inside a ruleset"),a(!this._cache,"Cannot override schema cache"),a(this._flags.artifact===void 0,"Cannot cache a rule with an artifact");const g=this.clone();return g._cache=f||e.provider.provision(),g.$_temp.ruleset=!1,g}clone(){const f=Object.create(Object.getPrototypeOf(this));return this._assign(f)}concat(f){a(i.isSchema(f),"Invalid schema object"),a(this.type==="any"||f.type==="any"||f.type===this.type,"Cannot merge type",this.type,"with another type:",f.type),a(!this._inRuleset(),"Cannot concatenate onto a schema with open ruleset"),a(!f._inRuleset(),"Cannot concatenate a schema with open ruleset");let g=this.clone();if(this.type==="any"&&f.type!=="any"){const _=f.clone();for(const S of Object.keys(g))S!=="type"&&(_[S]=g[S]);g=_}g._ids.concat(f._ids),g._refs.register(f,u.toSibling),g._preferences=g._preferences?i.preferences(g._preferences,f._preferences):f._preferences,g._valids=R.merge(g._valids,f._valids,f._invalids),g._invalids=R.merge(g._invalids,f._invalids,f._valids);for(const _ of f._singleRules.keys())g._singleRules.has(_)&&(g._rules=g._rules.filter(S=>S.keep||S.name!==_),g._singleRules.delete(_));for(const _ of f._rules)f._definition.rules[_.method].multi||g._singleRules.set(_.name,_),g._rules.push(_);if(g._flags.empty&&f._flags.empty){g._flags.empty=g._flags.empty.concat(f._flags.empty);const _=Object.assign({},f._flags);delete _.empty,c(g._flags,_)}else if(f._flags.empty){g._flags.empty=f._flags.empty;const _=Object.assign({},f._flags);delete _.empty,c(g._flags,_)}else c(g._flags,f._flags);for(const _ in f.$_terms){const S=f.$_terms[_];S?g.$_terms[_]?g.$_terms[_]=g.$_terms[_].concat(S):g.$_terms[_]=S.slice():g.$_terms[_]||(g.$_terms[_]=S)}return this.$_root._tracer&&this.$_root._tracer._combine(g,[this,f]),g.$_mutateRebuild()}extend(f){return a(!f.base,"Cannot extend type with another base"),t.type(this,f)}extract(f){return f=Array.isArray(f)?f:f.split("."),this._ids.reach(f)}fork(f,g){a(!this._inRuleset(),"Cannot fork inside a ruleset");let _=this;for(let S of[].concat(f))S=Array.isArray(S)?S:S.split("."),_=_._ids.fork(S,g,_);return _.$_temp.ruleset=!1,_}rule(f){const g=this._definition;i.assertOptions(f,Object.keys(g.modifiers)),a(this.$_temp.ruleset!==!1,"Cannot apply rules to empty ruleset or the last rule added does not support rule properties");const _=this.$_temp.ruleset===null?this._rules.length-1:this.$_temp.ruleset;a(_>=0&&_<this._rules.length,"Cannot apply rules to empty ruleset");const S=this.clone();for(let I=_;I<S._rules.length;++I){const k=S._rules[I],j=h(k);for(const O in f)g.modifiers[O](j,f[O]),a(j.name===k.name,"Cannot change rule name");S._rules[I]=j,S._singleRules.get(j.name)===k&&S._singleRules.set(j.name,j)}return S.$_temp.ruleset=!1,S.$_mutateRebuild()}get ruleset(){a(!this._inRuleset(),"Cannot start a new ruleset without closing the previous one");const f=this.clone();return f.$_temp.ruleset=f._rules.length,f}get $(){return this.ruleset}tailor(f){f=[].concat(f),a(!this._inRuleset(),"Cannot tailor inside a ruleset");let g=this;if(this.$_terms.alterations)for(const{target:_,adjuster:S}of this.$_terms.alterations)f.includes(_)&&(g=S(g),a(i.isSchema(g),"Alteration adjuster for",_,"failed to return a schema object"));return g=g.$_modify({each:_=>_.tailor(f),ref:!1}),g.$_temp.ruleset=!1,g.$_mutateRebuild()}tracer(){return d.location?d.location(this):this}validate(f,g){return v.entry(f,this,g)}validateAsync(f,g){return v.entryAsync(f,this,g)}$_addRule(f){typeof f=="string"&&(f={name:f}),a(f&&typeof f=="object","Invalid options"),a(f.name&&typeof f.name=="string","Invalid rule name");for(const k in f)a(k[0]!=="_","Cannot set private rule properties");const g=Object.assign({},f);g._resolve=[],g.method=g.method||g.name;const _=this._definition.rules[g.method],S=g.args;a(_,"Unknown rule",g.method);const I=this.clone();if(S){a(Object.keys(S).length===1||Object.keys(S).length===this._definition.rules[g.name].args.length,"Invalid rule definition for",this.type,g.name);for(const k in S){let j=S[k];if(_.argsByName){const O=_.argsByName.get(k);if(O.ref&&i.isResolvable(j))g._resolve.push(k),I.$_mutateRegister(j);else if(O.normalize&&(j=O.normalize(j),S[k]=j),O.assert){const L=i.validateArg(j,k,O);a(!L,L,"or reference")}}j!==void 0?S[k]=j:delete S[k]}}return _.multi||(I._ruleRemove(g.name,{clone:!1}),I._singleRules.set(g.name,g)),I.$_temp.ruleset===!1&&(I.$_temp.ruleset=null),_.priority?I._rules.unshift(g):I._rules.push(g),I}$_compile(f,g){return n.schema(this.$_root,f,g)}$_createError(f,g,_,S,I,k={}){const j=k.flags!==!1?this._flags:{},O=k.messages?s.merge(this._definition.messages,k.messages):this._definition.messages;return new r.Report(f,g,_,j,O,S,I)}$_getFlag(f){return this._flags[f]}$_getRule(f){return this._singleRules.get(f)}$_mapLabels(f){return f=Array.isArray(f)?f:f.split("."),this._ids.labels(f)}$_match(f,g,_,S){(_=Object.assign({},_)).abortEarly=!0,_._externals=!1,g.snapshot();const I=!v.validate(f,this,g,_,S).errors;return g.restore(),I}$_modify(f){return i.assertOptions(f,["each","once","ref","schema"]),o.schema(this,f)||this}$_mutateRebuild(){return a(!this._inRuleset(),"Cannot add this rule inside a ruleset"),this._refs.reset(),this._ids.reset(),this.$_modify({each:(f,{source:g,name:_,path:S,key:I})=>{const k=this._definition[g][_]&&this._definition[g][_].register;k!==!1&&this.$_mutateRegister(f,{family:k,key:I})}}),this._definition.rebuild&&this._definition.rebuild(this),this.$_temp.ruleset=!1,this}$_mutateRegister(f,{family:g,key:_}={}){this._refs.register(f,g),this._ids.register(f,{key:_})}$_property(f){return this._definition.properties[f]}$_reach(f){return this._ids.reach(f)}$_rootReferences(){return this._refs.roots()}$_setFlag(f,g,_={}){a(f[0]==="_"||!this._inRuleset(),"Cannot set flag inside a ruleset");const S=this._definition.flags[f]||{};if(y(g,S.default)&&(g=void 0),y(g,this._flags[f]))return this;const I=_.clone!==!1?this.clone():this;return g!==void 0?(I._flags[f]=g,I.$_mutateRegister(g)):delete I._flags[f],f[0]!=="_"&&(I.$_temp.ruleset=!1),I}$_parent(f,...g){return this[f][i.symbols.parent].call(this,...g)}$_validate(f,g,_){return v.validate(f,this,g,_)}_assign(f){f.type=this.type,f.$_root=this.$_root,f.$_temp=Object.assign({},this.$_temp),f.$_temp.whens={},f._ids=this._ids.clone(),f._preferences=this._preferences,f._valids=this._valids&&this._valids.clone(),f._invalids=this._invalids&&this._invalids.clone(),f._rules=this._rules.slice(),f._singleRules=h(this._singleRules,{shallow:!0}),f._refs=this._refs.clone(),f._flags=Object.assign({},this._flags),f._cache=null,f.$_terms={};for(const g in this.$_terms)f.$_terms[g]=this.$_terms[g]?this.$_terms[g].slice():null;f.$_super={};for(const g in this.$_super)f.$_super[g]=this._super[g].bind(f);return f}_bare(){const f=this.clone();f._reset();const g=f._definition.terms;for(const _ in g){const S=g[_];f.$_terms[_]=S.init}return f.$_mutateRebuild()}_default(f,g,_={}){return i.assertOptions(_,"literal"),a(g!==void 0,"Missing",f,"value"),a(typeof g=="function"||!_.literal,"Only function value supports literal option"),typeof g=="function"&&_.literal&&(g={[i.symbols.literal]:!0,literal:g}),this.$_setFlag(f,g)}_generate(f,g,_){if(!this.$_terms.whens)return{schema:this};const S=[],I=[];for(let O=0;O<this.$_terms.whens.length;++O){const L=this.$_terms.whens[O];if(L.concat){S.push(L.concat),I.push(`${O}.concat`);continue}const N=L.ref?L.ref.resolve(f,g,_):f,D=L.is?[L]:L.switch,C=I.length;for(let T=0;T<D.length;++T){const{is:P,then:F,otherwise:U}=D[T],z=`${O}${L.switch?"."+T:""}`;if(P.$_match(N,g.nest(P,`${z}.is`),_)){if(F){const q=g.localize([...g.path,`${z}.then`],g.ancestors,g.schemas),{schema:K,id:le}=F._generate(f,q,_);S.push(K),I.push(`${z}.then${le?`(${le})`:""}`);break}}else if(U){const q=g.localize([...g.path,`${z}.otherwise`],g.ancestors,g.schemas),{schema:K,id:le}=U._generate(f,q,_);S.push(K),I.push(`${z}.otherwise${le?`(${le})`:""}`);break}}if(L.break&&I.length>C)break}const k=I.join(", ");if(g.mainstay.tracer.debug(g,"rule","when",k),!k)return{schema:this};if(!g.mainstay.tracer.active&&this.$_temp.whens[k])return{schema:this.$_temp.whens[k],id:k};let j=this;this._definition.generate&&(j=this._definition.generate(this,f,g,_));for(const O of S)j=j.concat(O);return this.$_root._tracer&&this.$_root._tracer._combine(j,[this,...S]),this.$_temp.whens[k]=j,{schema:j,id:k}}_inner(f,g,_={}){a(!this._inRuleset(),`Cannot set ${f} inside a ruleset`);const S=this.clone();return S.$_terms[f]&&!_.override||(S.$_terms[f]=[]),_.single?S.$_terms[f].push(g):S.$_terms[f].push(...g),S.$_temp.ruleset=!1,S}_inRuleset(){return this.$_temp.ruleset!==null&&this.$_temp.ruleset!==!1}_ruleRemove(f,g={}){if(!this._singleRules.has(f))return this;const _=g.clone!==!1?this.clone():this;_._singleRules.delete(f);const S=[];for(let I=0;I<_._rules.length;++I){const k=_._rules[I];k.name!==f||k.keep?S.push(k):_._inRuleset()&&I<_.$_temp.ruleset&&--_.$_temp.ruleset}return _._rules=S,_}_values(f,g){i.verifyFlat(f,g.slice(1,-1));const _=this.clone(),S=f[0]===i.symbols.override;if(S&&(f=f.slice(1)),!_[g]&&f.length?_[g]=new R:S&&(_[g]=f.length?new R:null,_.$_mutateRebuild()),!_[g])return _;S&&_[g].override();for(const I of f){a(I!==void 0,"Cannot call allow/valid/invalid with undefined"),a(I!==i.symbols.override,"Override must be the first value");const k=g==="_invalids"?"_valids":"_invalids";_[k]&&(_[k].remove(I),_[k].length||(a(g==="_valids"||!_._flags.only,"Setting invalid value",I,"leaves schema rejecting all values due to previous valid rule"),_[k]=null)),_[g].add(I,_._refs)}return _}}};E.Base.prototype[i.symbols.any]={version:i.version,compile:n.compile,root:"$_root"},E.Base.prototype.isImmutable=!0,E.Base.prototype.deny=E.Base.prototype.invalid,E.Base.prototype.disallow=E.Base.prototype.invalid,E.Base.prototype.equal=E.Base.prototype.valid,E.Base.prototype.exist=E.Base.prototype.required,E.Base.prototype.not=E.Base.prototype.invalid,E.Base.prototype.options=E.Base.prototype.prefs,E.Base.prototype.preferences=E.Base.prototype.prefs,x.exports=new E.Base},8652:(x,w,m)=>{const a=m(375),h=m(8571),y=m(8160),c={max:1e3,supported:new Set(["undefined","boolean","number","string"])};w.provider={provision:e=>new c.Cache(e)},c.Cache=class{constructor(e={}){y.assertOptions(e,["max"]),a(e.max===void 0||e.max&&e.max>0&&isFinite(e.max),"Invalid max cache size"),this._max=e.max||c.max,this._map=new Map,this._list=new c.List}get length(){return this._map.size}set(e,i){if(e!==null&&!c.supported.has(typeof e))return;let n=this._map.get(e);if(n)return n.value=i,void this._list.first(n);n=this._list.unshift({key:e,value:i}),this._map.set(e,n),this._compact()}get(e){const i=this._map.get(e);if(i)return this._list.first(i),h(i.value)}_compact(){if(this._map.size>this._max){const e=this._list.pop();this._map.delete(e.key)}}},c.List=class{constructor(){this.tail=null,this.head=null}unshift(e){return e.next=null,e.prev=this.head,this.head&&(this.head.next=e),this.head=e,this.tail||(this.tail=e),e}first(e){e!==this.head&&(this._remove(e),this.unshift(e))}pop(){return this._remove(this.tail)}_remove(e){const{next:i,prev:n}=e;return i.prev=n,n&&(n.next=i),e===this.tail&&(this.tail=i),e.prev=null,e.next=null,e}}},8160:(x,w,m)=>{const a=m(375),h=m(7916),y=m(5934);let c,e;const i={isoDate:/^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/};w.version=y.version,w.defaults={abortEarly:!0,allowUnknown:!1,artifacts:!1,cache:!0,context:null,convert:!0,dateFormat:"iso",errors:{escapeHtml:!1,label:"path",language:null,render:!0,stack:!1,wrap:{label:'"',array:"[]"}},externals:!0,messages:{},nonEnumerables:!1,noDefaults:!1,presence:"optional",skipFunctions:!1,stripUnknown:!1,warnings:!1},w.symbols={any:Symbol.for("@hapi/joi/schema"),arraySingle:Symbol("arraySingle"),deepDefault:Symbol("deepDefault"),errors:Symbol("errors"),literal:Symbol("literal"),override:Symbol("override"),parent:Symbol("parent"),prefs:Symbol("prefs"),ref:Symbol("ref"),template:Symbol("template"),values:Symbol("values")},w.assertOptions=function(n,r,t="Options"){a(n&&typeof n=="object"&&!Array.isArray(n),"Options must be of type object");const l=Object.keys(n).filter(s=>!r.includes(s));a(l.length===0,`${t} contain unknown keys: ${l}`)},w.checkPreferences=function(n){e=e||m(3378);const r=e.preferences.validate(n);if(r.error)throw new h([r.error.details[0].message])},w.compare=function(n,r,t){switch(t){case"=":return n===r;case">":return n>r;case"<":return n<r;case">=":return n>=r;case"<=":return n<=r}},w.default=function(n,r){return n===void 0?r:n},w.isIsoDate=function(n){return i.isoDate.test(n)},w.isNumber=function(n){return typeof n=="number"&&!isNaN(n)},w.isResolvable=function(n){return!!n&&(n[w.symbols.ref]||n[w.symbols.template])},w.isSchema=function(n,r={}){const t=n&&n[w.symbols.any];return!!t&&(a(r.legacy||t.version===w.version,"Cannot mix different versions of joi schemas"),!0)},w.isValues=function(n){return n[w.symbols.values]},w.limit=function(n){return Number.isSafeInteger(n)&&n>=0},w.preferences=function(n,r){c=c||m(6914),n=n||{},r=r||{};const t=Object.assign({},n,r);return r.errors&&n.errors&&(t.errors=Object.assign({},n.errors,r.errors),t.errors.wrap=Object.assign({},n.errors.wrap,r.errors.wrap)),r.messages&&(t.messages=c.compile(r.messages,n.messages)),delete t[w.symbols.prefs],t},w.tryWithPath=function(n,r,t={}){try{return n()}catch(l){throw l.path!==void 0?l.path=r+"."+l.path:l.path=r,t.append&&(l.message=`${l.message} (${l.path})`),l}},w.validateArg=function(n,r,{assert:t,message:l}){if(w.isSchema(t)){const s=t.validate(n);return s.error?s.error.message:void 0}if(!t(n))return r?`${r} ${l}`:l},w.verifyFlat=function(n,r){for(const t of n)a(!Array.isArray(t),"Method no longer accepts array arguments:",r)}},3292:(x,w,m)=>{const a=m(375),h=m(8160),y=m(6133),c={};w.schema=function(e,i,n={}){h.assertOptions(n,["appendPath","override"]);try{return c.schema(e,i,n)}catch(r){throw n.appendPath&&r.path!==void 0&&(r.message=`${r.message} (${r.path})`),r}},c.schema=function(e,i,n){a(i!==void 0,"Invalid undefined schema"),Array.isArray(i)&&(a(i.length,"Invalid empty array schema"),i.length===1&&(i=i[0]));const r=(t,...l)=>n.override!==!1?t.valid(e.override,...l):t.valid(...l);if(c.simple(i))return r(e,i);if(typeof i=="function")return e.custom(i);if(a(typeof i=="object","Invalid schema content:",typeof i),h.isResolvable(i))return r(e,i);if(h.isSchema(i))return i;if(Array.isArray(i)){for(const t of i)if(!c.simple(t))return e.alternatives().try(...i);return r(e,...i)}return i instanceof RegExp?e.string().regex(i):i instanceof Date?r(e.date(),i):(a(Object.getPrototypeOf(i)===Object.getPrototypeOf({}),"Schema can only contain plain objects"),e.object().keys(i))},w.ref=function(e,i){return y.isRef(e)?e:y.create(e,i)},w.compile=function(e,i,n={}){h.assertOptions(n,["legacy"]);const r=i&&i[h.symbols.any];if(r)return a(n.legacy||r.version===h.version,"Cannot mix different versions of joi schemas:",r.version,h.version),i;if(typeof i!="object"||!n.legacy)return w.schema(e,i,{appendPath:!0});const t=c.walk(i);return t?t.compile(t.root,i):w.schema(e,i,{appendPath:!0})},c.walk=function(e){if(typeof e!="object")return null;if(Array.isArray(e)){for(const n of e){const r=c.walk(n);if(r)return r}return null}const i=e[h.symbols.any];if(i)return{root:e[i.root],compile:i.compile};a(Object.getPrototypeOf(e)===Object.getPrototypeOf({}),"Schema can only contain plain objects");for(const n in e){const r=c.walk(e[n]);if(r)return r}return null},c.simple=function(e){return e===null||["boolean","string","number"].includes(typeof e)},w.when=function(e,i,n){if(n===void 0&&(a(i&&typeof i=="object","Missing options"),n=i,i=y.create(".")),Array.isArray(n)&&(n={switch:n}),h.assertOptions(n,["is","not","then","otherwise","switch","break"]),h.isSchema(i))return a(n.is===void 0,'"is" can not be used with a schema condition'),a(n.not===void 0,'"not" can not be used with a schema condition'),a(n.switch===void 0,'"switch" can not be used with a schema condition'),c.condition(e,{is:i,then:n.then,otherwise:n.otherwise,break:n.break});if(a(y.isRef(i)||typeof i=="string","Invalid condition:",i),a(n.not===void 0||n.is===void 0,'Cannot combine "is" with "not"'),n.switch===void 0){let t=n;n.not!==void 0&&(t={is:n.not,then:n.otherwise,otherwise:n.then,break:n.break});let l=t.is!==void 0?e.$_compile(t.is):e.$_root.invalid(null,!1,0,"").required();return a(t.then!==void 0||t.otherwise!==void 0,'options must have at least one of "then", "otherwise", or "switch"'),a(t.break===void 0||t.then===void 0||t.otherwise===void 0,"Cannot specify then, otherwise, and break all together"),n.is===void 0||y.isRef(n.is)||h.isSchema(n.is)||(l=l.required()),c.condition(e,{ref:w.ref(i),is:l,then:t.then,otherwise:t.otherwise,break:t.break})}a(Array.isArray(n.switch),'"switch" must be an array'),a(n.is===void 0,'Cannot combine "switch" with "is"'),a(n.not===void 0,'Cannot combine "switch" with "not"'),a(n.then===void 0,'Cannot combine "switch" with "then"');const r={ref:w.ref(i),switch:[],break:n.break};for(let t=0;t<n.switch.length;++t){const l=n.switch[t],s=t===n.switch.length-1;h.assertOptions(l,s?["is","then","otherwise"]:["is","then"]),a(l.is!==void 0,'Switch statement missing "is"'),a(l.then!==void 0,'Switch statement missing "then"');const o={is:e.$_compile(l.is),then:e.$_compile(l.then)};if(y.isRef(l.is)||h.isSchema(l.is)||(o.is=o.is.required()),s){a(n.otherwise===void 0||l.otherwise===void 0,'Cannot specify "otherwise" inside and outside a "switch"');const u=n.otherwise!==void 0?n.otherwise:l.otherwise;u!==void 0&&(a(r.break===void 0,"Cannot specify both otherwise and break"),o.otherwise=e.$_compile(u))}r.switch.push(o)}return r},c.condition=function(e,i){for(const n of["then","otherwise"])i[n]===void 0?delete i[n]:i[n]=e.$_compile(i[n]);return i}},6354:(x,w,m)=>{const a=m(5688),h=m(8160),y=m(3328);w.Report=class{constructor(c,e,i,n,r,t,l){if(this.code=c,this.flags=n,this.messages=r,this.path=t.path,this.prefs=l,this.state=t,this.value=e,this.message=null,this.template=null,this.local=i||{},this.local.label=w.label(this.flags,this.state,this.prefs,this.messages),this.value===void 0||this.local.hasOwnProperty("value")||(this.local.value=this.value),this.path.length){const s=this.path[this.path.length-1];typeof s!="object"&&(this.local.key=s)}}_setTemplate(c){if(this.template=c,!this.flags.label&&this.path.length===0){const e=this._template(this.template,"root");e&&(this.local.label=e)}}toString(){if(this.message)return this.message;const c=this.code;if(!this.prefs.errors.render)return this.code;const e=this._template(this.template)||this._template(this.prefs.messages)||this._template(this.messages);return e===void 0?`Error code "${c}" is not defined, your custom type is missing the correct messages definition`:(this.message=e.render(this.value,this.state,this.prefs,this.local,{errors:this.prefs.errors,messages:[this.prefs.messages,this.messages]}),this.prefs.errors.label||(this.message=this.message.replace(/^"" /,"").trim()),this.message)}_template(c,e){return w.template(this.value,c,e||this.code,this.state,this.prefs)}},w.path=function(c){let e="";for(const i of c)typeof i!="object"&&(typeof i=="string"?(e&&(e+="."),e+=i):e+=`[${i}]`);return e},w.template=function(c,e,i,n,r){if(!e)return;if(y.isTemplate(e))return i!=="root"?e:null;let t=r.errors.language;if(h.isResolvable(t)&&(t=t.resolve(c,n,r)),t&&e[t]){if(e[t][i]!==void 0)return e[t][i];if(e[t]["*"]!==void 0)return e[t]["*"]}return e[i]?e[i]:e["*"]},w.label=function(c,e,i,n){if(!i.errors.label)return"";if(c.label)return c.label;let r=e.path;return i.errors.label==="key"&&e.path.length>1&&(r=e.path.slice(-1)),w.path(r)||w.template(null,i.messages,"root",e,i)||n&&w.template(null,n,"root",e,i)||"value"},w.process=function(c,e,i){if(!c)return null;const{override:n,message:r,details:t}=w.details(c);if(n)return n;if(i.errors.stack)return new w.ValidationError(r,t,e);const l=Error.stackTraceLimit;Error.stackTraceLimit=0;const s=new w.ValidationError(r,t,e);return Error.stackTraceLimit=l,s},w.details=function(c,e={}){let i=[];const n=[];for(const r of c){if(r instanceof Error){if(e.override!==!1)return{override:r};const l=r.toString();i.push(l),n.push({message:l,type:"override",context:{error:r}});continue}const t=r.toString();i.push(t),n.push({message:t,path:r.path.filter(l=>typeof l!="object"),type:r.code,context:r.local})}return i.length>1&&(i=[...new Set(i)]),{message:i.join(". "),details:n}},w.ValidationError=class extends Error{constructor(c,e,i){super(c),this._original=i,this.details=e}static isError(c){return c instanceof w.ValidationError}},w.ValidationError.prototype.isJoi=!0,w.ValidationError.prototype.name="ValidationError",w.ValidationError.prototype.annotate=a.error},8901:(x,w,m)=>{const a=m(375),h=m(8571),y=m(8160),c=m(6914),e={};w.type=function(i,n){const r=Object.getPrototypeOf(i),t=h(r),l=i._assign(Object.create(t)),s=Object.assign({},n);delete s.base,t._definition=s;const o=r._definition||{};s.messages=c.merge(o.messages,s.messages),s.properties=Object.assign({},o.properties,s.properties),l.type=s.type,s.flags=Object.assign({},o.flags,s.flags);const u=Object.assign({},o.terms);if(s.terms)for(const E in s.terms){const f=s.terms[E];a(l.$_terms[E]===void 0,"Invalid term override for",s.type,E),l.$_terms[E]=f.init,u[E]=f}s.terms=u,s.args||(s.args=o.args),s.prepare=e.prepare(s.prepare,o.prepare),s.coerce&&(typeof s.coerce=="function"&&(s.coerce={method:s.coerce}),s.coerce.from&&!Array.isArray(s.coerce.from)&&(s.coerce={method:s.coerce.method,from:[].concat(s.coerce.from)})),s.coerce=e.coerce(s.coerce,o.coerce),s.validate=e.validate(s.validate,o.validate);const d=Object.assign({},o.rules);if(s.rules)for(const E in s.rules){const f=s.rules[E];a(typeof f=="object","Invalid rule definition for",s.type,E);let g=f.method;if(g===void 0&&(g=function(){return this.$_addRule(E)}),g&&(a(!t[E],"Rule conflict in",s.type,E),t[E]=g),a(!d[E],"Rule conflict in",s.type,E),d[E]=f,f.alias){const _=[].concat(f.alias);for(const S of _)t[S]=f.method}f.args&&(f.argsByName=new Map,f.args=f.args.map(_=>(typeof _=="string"&&(_={name:_}),a(!f.argsByName.has(_.name),"Duplicated argument name",_.name),y.isSchema(_.assert)&&(_.assert=_.assert.strict().label(_.name)),f.argsByName.set(_.name,_),_)))}s.rules=d;const v=Object.assign({},o.modifiers);if(s.modifiers)for(const E in s.modifiers){a(!t[E],"Rule conflict in",s.type,E);const f=s.modifiers[E];a(typeof f=="function","Invalid modifier definition for",s.type,E);const g=function(_){return this.rule({[E]:_})};t[E]=g,v[E]=f}if(s.modifiers=v,s.overrides){t._super=r,l.$_super={};for(const E in s.overrides)a(r[E],"Cannot override missing",E),s.overrides[E][y.symbols.parent]=r[E],l.$_super[E]=r[E].bind(l);Object.assign(t,s.overrides)}s.cast=Object.assign({},o.cast,s.cast);const R=Object.assign({},o.manifest,s.manifest);return R.build=e.build(s.manifest&&s.manifest.build,o.manifest&&o.manifest.build),s.manifest=R,s.rebuild=e.rebuild(s.rebuild,o.rebuild),l},e.build=function(i,n){return i&&n?function(r,t){return n(i(r,t),t)}:i||n},e.coerce=function(i,n){return i&&n?{from:i.from&&n.from?[...new Set([...i.from,...n.from])]:null,method(r,t){let l;if((!n.from||n.from.includes(typeof r))&&(l=n.method(r,t),l)){if(l.errors||l.value===void 0)return l;r=l.value}if(!i.from||i.from.includes(typeof r)){const s=i.method(r,t);if(s)return s}return l}}:i||n},e.prepare=function(i,n){return i&&n?function(r,t){const l=i(r,t);if(l){if(l.errors||l.value===void 0)return l;r=l.value}return n(r,t)||l}:i||n},e.rebuild=function(i,n){return i&&n?function(r){n(r),i(r)}:i||n},e.validate=function(i,n){return i&&n?function(r,t){const l=n(r,t);if(l){if(l.errors&&(!Array.isArray(l.errors)||l.errors.length))return l;r=l.value}return i(r,t)||l}:i||n}},5107:(x,w,m)=>{const a=m(375),h=m(8571),y=m(8652),c=m(8160),e=m(3292),i=m(6354),n=m(8901),r=m(9708),t=m(6133),l=m(3328),s=m(1152);let o;const u={types:{alternatives:m(4946),any:m(8068),array:m(546),boolean:m(4937),date:m(7500),function:m(390),link:m(8785),number:m(3832),object:m(8966),string:m(7417),symbol:m(8826)},aliases:{alt:"alternatives",bool:"boolean",func:"function"},root:function(){const d={_types:new Set(Object.keys(u.types))};for(const v of d._types)d[v]=function(...R){return a(!R.length||["alternatives","link","object"].includes(v),"The",v,"type does not allow arguments"),u.generate(this,u.types[v],R)};for(const v of["allow","custom","disallow","equal","exist","forbidden","invalid","not","only","optional","options","prefs","preferences","required","strip","valid","when"])d[v]=function(...R){return this.any()[v](...R)};Object.assign(d,u.methods);for(const v in u.aliases){const R=u.aliases[v];d[v]=d[R]}return d.x=d.expression,s.setup&&s.setup(d),d}};u.methods={ValidationError:i.ValidationError,version:c.version,cache:y.provider,assert(d,v,...R){u.assert(d,v,!0,R)},attempt:(d,v,...R)=>u.assert(d,v,!1,R),build(d){return a(typeof r.build=="function","Manifest functionality disabled"),r.build(this,d)},checkPreferences(d){c.checkPreferences(d)},compile(d,v){return e.compile(this,d,v)},defaults(d){a(typeof d=="function","modifier must be a function");const v=Object.assign({},this);for(const R of v._types){const E=d(v[R]());a(c.isSchema(E),"modifier must return a valid schema object"),v[R]=function(...f){return u.generate(this,E,f)}}return v},expression:(...d)=>new l(...d),extend(...d){c.verifyFlat(d,"extend"),o=o||m(3378),a(d.length,"You need to provide at least one extension"),this.assert(d,o.extensions);const v=Object.assign({},this);v._types=new Set(v._types);for(let R of d){typeof R=="function"&&(R=R(v)),this.assert(R,o.extension);const E=u.expandExtension(R,v);for(const f of E){a(v[f.type]===void 0||v._types.has(f.type),"Cannot override name",f.type);const g=f.base||this.any(),_=n.type(g,f);v._types.add(f.type),v[f.type]=function(...S){return u.generate(this,_,S)}}}return v},isError:i.ValidationError.isError,isExpression:l.isTemplate,isRef:t.isRef,isSchema:c.isSchema,in:(...d)=>t.in(...d),override:c.symbols.override,ref:(...d)=>t.create(...d),types(){const d={};for(const v of this._types)d[v]=this[v]();for(const v in u.aliases)d[v]=this[v]();return d}},u.assert=function(d,v,R,E){const f=E[0]instanceof Error||typeof E[0]=="string"?E[0]:null,g=f!==null?E[1]:E[0],_=v.validate(d,c.preferences({errors:{stack:!0}},g||{}));let S=_.error;if(!S)return _.value;if(f instanceof Error)throw f;const I=R&&typeof S.annotate=="function"?S.annotate():S.message;throw S instanceof i.ValidationError==0&&(S=h(S)),S.message=f?`${f} ${I}`:I,S},u.generate=function(d,v,R){return a(d,"Must be invoked on a Joi instance."),v.$_root=d,v._definition.args&&R.length?v._definition.args(v,...R):v},u.expandExtension=function(d,v){if(typeof d.type=="string")return[d];const R=[];for(const E of v._types)if(d.type.test(E)){const f=Object.assign({},d);f.type=E,f.base=v[E](),R.push(f)}return R},x.exports=u.root()},6914:(x,w,m)=>{const a=m(375),h=m(8571),y=m(3328);w.compile=function(c,e){if(typeof c=="string")return a(!e,"Cannot set single message string"),new y(c);if(y.isTemplate(c))return a(!e,"Cannot set single message template"),c;a(typeof c=="object"&&!Array.isArray(c),"Invalid message options"),e=e?h(e):{};for(let i in c){const n=c[i];if(i==="root"||y.isTemplate(n)){e[i]=n;continue}if(typeof n=="string"){e[i]=new y(n);continue}a(typeof n=="object"&&!Array.isArray(n),"Invalid message for",i);const r=i;for(i in e[r]=e[r]||{},n){const t=n[i];i==="root"||y.isTemplate(t)?e[r][i]=t:(a(typeof t=="string","Invalid message for",i,"in",r),e[r][i]=new y(t))}}return e},w.decompile=function(c){const e={};for(let i in c){const n=c[i];if(i==="root"){e.root=n;continue}if(y.isTemplate(n)){e[i]=n.describe({compact:!0});continue}const r=i;for(i in e[r]={},n){const t=n[i];i!=="root"?e[r][i]=t.describe({compact:!0}):e[r].root=t}}return e},w.merge=function(c,e){if(!c)return w.compile(e);if(!e)return c;if(typeof e=="string")return new y(e);if(y.isTemplate(e))return e;const i=h(c);for(let n in e){const r=e[n];if(n==="root"||y.isTemplate(r)){i[n]=r;continue}if(typeof r=="string"){i[n]=new y(r);continue}a(typeof r=="object"&&!Array.isArray(r),"Invalid message for",n);const t=n;for(n in i[t]=i[t]||{},r){const l=r[n];n==="root"||y.isTemplate(l)?i[t][n]=l:(a(typeof l=="string","Invalid message for",n,"in",t),i[t][n]=new y(l))}}return i}},2294:(x,w,m)=>{const a=m(375),h=m(8160),y=m(6133),c={};w.Ids=c.Ids=class{constructor(){this._byId=new Map,this._byKey=new Map,this._schemaChain=!1}clone(){const e=new c.Ids;return e._byId=new Map(this._byId),e._byKey=new Map(this._byKey),e._schemaChain=this._schemaChain,e}concat(e){e._schemaChain&&(this._schemaChain=!0);for(const[i,n]of e._byId.entries())a(!this._byKey.has(i),"Schema id conflicts with existing key:",i),this._byId.set(i,n);for(const[i,n]of e._byKey.entries())a(!this._byId.has(i),"Schema key conflicts with existing id:",i),this._byKey.set(i,n)}fork(e,i,n){const r=this._collect(e);r.push({schema:n});const t=r.shift();let l={id:t.id,schema:i(t.schema)};a(h.isSchema(l.schema),"adjuster function failed to return a joi schema type");for(const s of r)l={id:s.id,schema:c.fork(s.schema,l.id,l.schema)};return l.schema}labels(e,i=[]){const n=e[0],r=this._get(n);if(!r)return[...i,...e].join(".");const t=e.slice(1);return i=[...i,r.schema._flags.label||n],t.length?r.schema._ids.labels(t,i):i.join(".")}reach(e,i=[]){const n=e[0],r=this._get(n);a(r,"Schema does not contain path",[...i,...e].join("."));const t=e.slice(1);return t.length?r.schema._ids.reach(t,[...i,n]):r.schema}register(e,{key:i}={}){if(!e||!h.isSchema(e))return;(e.$_property("schemaChain")||e._ids._schemaChain)&&(this._schemaChain=!0);const n=e._flags.id;if(n){const r=this._byId.get(n);a(!r||r.schema===e,"Cannot add different schemas with the same id:",n),a(!this._byKey.has(n),"Schema id conflicts with existing key:",n),this._byId.set(n,{schema:e,id:n})}i&&(a(!this._byKey.has(i),"Schema already contains key:",i),a(!this._byId.has(i),"Schema key conflicts with existing id:",i),this._byKey.set(i,{schema:e,id:i}))}reset(){this._byId=new Map,this._byKey=new Map,this._schemaChain=!1}_collect(e,i=[],n=[]){const r=e[0],t=this._get(r);a(t,"Schema does not contain path",[...i,...e].join(".")),n=[t,...n];const l=e.slice(1);return l.length?t.schema._ids._collect(l,[...i,r],n):n}_get(e){return this._byId.get(e)||this._byKey.get(e)}},c.fork=function(e,i,n){const r=w.schema(e,{each:(t,{key:l})=>{if(i===(t._flags.id||l))return n},ref:!1});return r?r.$_mutateRebuild():e},w.schema=function(e,i){let n;for(const r in e._flags){if(r[0]==="_")continue;const t=c.scan(e._flags[r],{source:"flags",name:r},i);t!==void 0&&(n=n||e.clone(),n._flags[r]=t)}for(let r=0;r<e._rules.length;++r){const t=e._rules[r],l=c.scan(t.args,{source:"rules",name:t.name},i);if(l!==void 0){n=n||e.clone();const s=Object.assign({},t);s.args=l,n._rules[r]=s,n._singleRules.get(t.name)===t&&n._singleRules.set(t.name,s)}}for(const r in e.$_terms){if(r[0]==="_")continue;const t=c.scan(e.$_terms[r],{source:"terms",name:r},i);t!==void 0&&(n=n||e.clone(),n.$_terms[r]=t)}return n},c.scan=function(e,i,n,r,t){const l=r||[];if(e===null||typeof e!="object")return;let s;if(Array.isArray(e)){for(let o=0;o<e.length;++o){const u=i.source==="terms"&&i.name==="keys"&&e[o].key,d=c.scan(e[o],i,n,[o,...l],u);d!==void 0&&(s=s||e.slice(),s[o]=d)}return s}if(n.schema!==!1&&h.isSchema(e)||n.ref!==!1&&y.isRef(e)){const o=n.each(e,{...i,path:l,key:t});return o===e?void 0:o}for(const o in e){if(o[0]==="_")continue;const u=c.scan(e[o],i,n,[o,...l],t);u!==void 0&&(s=s||Object.assign({},e),s[o]=u)}return s}},6133:(x,w,m)=>{const a=m(375),h=m(8571),y=m(9621),c=m(8160);let e;const i={symbol:Symbol("ref"),defaults:{adjust:null,in:!1,iterables:null,map:null,separator:".",type:"value"}};w.create=function(n,r={}){a(typeof n=="string","Invalid reference key:",n),c.assertOptions(r,["adjust","ancestor","in","iterables","map","prefix","render","separator"]),a(!r.prefix||typeof r.prefix=="object","options.prefix must be of type object");const t=Object.assign({},i.defaults,r);delete t.prefix;const l=t.separator,s=i.context(n,l,r.prefix);if(t.type=s.type,n=s.key,t.type==="value")if(s.root&&(a(!l||n[0]!==l,"Cannot specify relative path with root prefix"),t.ancestor="root",n||(n=null)),l&&l===n)n=null,t.ancestor=0;else if(t.ancestor!==void 0)a(!l||!n||n[0]!==l,"Cannot combine prefix with ancestor option");else{const[o,u]=i.ancestor(n,l);u&&(n=n.slice(u))===""&&(n=null),t.ancestor=o}return t.path=l?n===null?[]:n.split(l):[n],new i.Ref(t)},w.in=function(n,r={}){return w.create(n,{...r,in:!0})},w.isRef=function(n){return!!n&&!!n[c.symbols.ref]},i.Ref=class{constructor(n){a(typeof n=="object","Invalid reference construction"),c.assertOptions(n,["adjust","ancestor","in","iterables","map","path","render","separator","type","depth","key","root","display"]),a([!1,void 0].includes(n.separator)||typeof n.separator=="string"&&n.separator.length===1,"Invalid separator"),a(!n.adjust||typeof n.adjust=="function","options.adjust must be a function"),a(!n.map||Array.isArray(n.map),"options.map must be an array"),a(!n.map||!n.adjust,"Cannot set both map and adjust options"),Object.assign(this,i.defaults,n),a(this.type==="value"||this.ancestor===void 0,"Non-value references cannot reference ancestors"),Array.isArray(this.map)&&(this.map=new Map(this.map)),this.depth=this.path.length,this.key=this.path.length?this.path.join(this.separator):null,this.root=this.path[0],this.updateDisplay()}resolve(n,r,t,l,s={}){return a(!this.in||s.in,"Invalid in() reference usage"),this.type==="global"?this._resolve(t.context,r,s):this.type==="local"?this._resolve(l,r,s):this.ancestor?this.ancestor==="root"?this._resolve(r.ancestors[r.ancestors.length-1],r,s):(a(this.ancestor<=r.ancestors.length,"Invalid reference exceeds the schema root:",this.display),this._resolve(r.ancestors[this.ancestor-1],r,s)):this._resolve(n,r,s)}_resolve(n,r,t){let l;if(this.type==="value"&&r.mainstay.shadow&&t.shadow!==!1&&(l=r.mainstay.shadow.get(this.absolute(r))),l===void 0&&(l=y(n,this.path,{iterables:this.iterables,functions:!0})),this.adjust&&(l=this.adjust(l)),this.map){const s=this.map.get(l);s!==void 0&&(l=s)}return r.mainstay&&r.mainstay.tracer.resolve(r,this,l),l}toString(){return this.display}absolute(n){return[...n.path.slice(0,-this.ancestor),...this.path]}clone(){return new i.Ref(this)}describe(){const n={path:this.path};this.type!=="value"&&(n.type=this.type),this.separator!=="."&&(n.separator=this.separator),this.type==="value"&&this.ancestor!==1&&(n.ancestor=this.ancestor),this.map&&(n.map=[...this.map]);for(const r of["adjust","iterables","render"])this[r]!==null&&this[r]!==void 0&&(n[r]=this[r]);return this.in!==!1&&(n.in=!0),{ref:n}}updateDisplay(){const n=this.key!==null?this.key:"";if(this.type!=="value")return void(this.display=`ref:${this.type}:${n}`);if(!this.separator)return void(this.display=`ref:${n}`);if(!this.ancestor)return void(this.display=`ref:${this.separator}${n}`);if(this.ancestor==="root")return void(this.display=`ref:root:${n}`);if(this.ancestor===1)return void(this.display=`ref:${n||".."}`);const r=new Array(this.ancestor+1).fill(this.separator).join("");this.display=`ref:${r}${n||""}`}},i.Ref.prototype[c.symbols.ref]=!0,w.build=function(n){return(n=Object.assign({},i.defaults,n)).type==="value"&&n.ancestor===void 0&&(n.ancestor=1),new i.Ref(n)},i.context=function(n,r,t={}){if(n=n.trim(),t){const l=t.global===void 0?"$":t.global;if(l!==r&&n.startsWith(l))return{key:n.slice(l.length),type:"global"};const s=t.local===void 0?"#":t.local;if(s!==r&&n.startsWith(s))return{key:n.slice(s.length),type:"local"};const o=t.root===void 0?"/":t.root;if(o!==r&&n.startsWith(o))return{key:n.slice(o.length),type:"value",root:!0}}return{key:n,type:"value"}},i.ancestor=function(n,r){if(!r)return[1,0];if(n[0]!==r)return[1,0];if(n[1]!==r)return[0,1];let t=2;for(;n[t]===r;)++t;return[t-1,t]},w.toSibling=0,w.toParent=1,w.Manager=class{constructor(){this.refs=[]}register(n,r){if(n)if(r=r===void 0?w.toParent:r,Array.isArray(n))for(const t of n)this.register(t,r);else if(c.isSchema(n))for(const t of n._refs.refs)t.ancestor-r>=0&&this.refs.push({ancestor:t.ancestor-r,root:t.root});else w.isRef(n)&&n.type==="value"&&n.ancestor-r>=0&&this.refs.push({ancestor:n.ancestor-r,root:n.root}),e=e||m(3328),e.isTemplate(n)&&this.register(n.refs(),r)}get length(){return this.refs.length}clone(){const n=new w.Manager;return n.refs=h(this.refs),n}reset(){this.refs=[]}roots(){return this.refs.filter(n=>!n.ancestor).map(n=>n.root)}}},3378:(x,w,m)=>{const a=m(5107),h={};h.wrap=a.string().min(1).max(2).allow(!1),w.preferences=a.object({allowUnknown:a.boolean(),abortEarly:a.boolean(),artifacts:a.boolean(),cache:a.boolean(),context:a.object(),convert:a.boolean(),dateFormat:a.valid("date","iso","string","time","utc"),debug:a.boolean(),errors:{escapeHtml:a.boolean(),label:a.valid("path","key",!1),language:[a.string(),a.object().ref()],render:a.boolean(),stack:a.boolean(),wrap:{label:h.wrap,array:h.wrap,string:h.wrap}},externals:a.boolean(),messages:a.object(),noDefaults:a.boolean(),nonEnumerables:a.boolean(),presence:a.valid("required","optional","forbidden"),skipFunctions:a.boolean(),stripUnknown:a.object({arrays:a.boolean(),objects:a.boolean()}).or("arrays","objects").allow(!0,!1),warnings:a.boolean()}).strict(),h.nameRx=/^[a-zA-Z0-9]\w*$/,h.rule=a.object({alias:a.array().items(a.string().pattern(h.nameRx)).single(),args:a.array().items(a.string(),a.object({name:a.string().pattern(h.nameRx).required(),ref:a.boolean(),assert:a.alternatives([a.function(),a.object().schema()]).conditional("ref",{is:!0,then:a.required()}),normalize:a.function(),message:a.string().when("assert",{is:a.function(),then:a.required()})})),convert:a.boolean(),manifest:a.boolean(),method:a.function().allow(!1),multi:a.boolean(),validate:a.function()}),w.extension=a.object({type:a.alternatives([a.string(),a.object().regex()]).required(),args:a.function(),cast:a.object().pattern(h.nameRx,a.object({from:a.function().maxArity(1).required(),to:a.function().minArity(1).maxArity(2).required()})),base:a.object().schema().when("type",{is:a.object().regex(),then:a.forbidden()}),coerce:[a.function().maxArity(3),a.object({method:a.function().maxArity(3).required(),from:a.array().items(a.string()).single()})],flags:a.object().pattern(h.nameRx,a.object({setter:a.string(),default:a.any()})),manifest:{build:a.function().arity(2)},messages:[a.object(),a.string()],modifiers:a.object().pattern(h.nameRx,a.function().minArity(1).maxArity(2)),overrides:a.object().pattern(h.nameRx,a.function()),prepare:a.function().maxArity(3),rebuild:a.function().arity(1),rules:a.object().pattern(h.nameRx,h.rule),terms:a.object().pattern(h.nameRx,a.object({init:a.array().allow(null).required(),manifest:a.object().pattern(/.+/,[a.valid("schema","single"),a.object({mapped:a.object({from:a.string().required(),to:a.string().required()}).required()})])})),validate:a.function().maxArity(3)}).strict(),w.extensions=a.array().items(a.object(),a.function().arity(1)).strict(),h.desc={buffer:a.object({buffer:a.string()}),func:a.object({function:a.function().required(),options:{literal:!0}}),override:a.object({override:!0}),ref:a.object({ref:a.object({type:a.valid("value","global","local"),path:a.array().required(),separator:a.string().length(1).allow(!1),ancestor:a.number().min(0).integer().allow("root"),map:a.array().items(a.array().length(2)).min(1),adjust:a.function(),iterables:a.boolean(),in:a.boolean(),render:a.boolean()}).required()}),regex:a.object({regex:a.string().min(3)}),special:a.object({special:a.valid("deep").required()}),template:a.object({template:a.string().required(),options:a.object()}),value:a.object({value:a.alternatives([a.object(),a.array()]).required()})},h.desc.entity=a.alternatives([a.array().items(a.link("...")),a.boolean(),a.function(),a.number(),a.string(),h.desc.buffer,h.desc.func,h.desc.ref,h.desc.regex,h.desc.special,h.desc.template,h.desc.value,a.link("/")]),h.desc.values=a.array().items(null,a.boolean(),a.function(),a.number().allow(1/0,-1/0),a.string().allow(""),a.symbol(),h.desc.buffer,h.desc.func,h.desc.override,h.desc.ref,h.desc.regex,h.desc.template,h.desc.value),h.desc.messages=a.object().pattern(/.+/,[a.string(),h.desc.template,a.object().pattern(/.+/,[a.string(),h.desc.template])]),w.description=a.object({type:a.string().required(),flags:a.object({cast:a.string(),default:a.any(),description:a.string(),empty:a.link("/"),failover:h.desc.entity,id:a.string(),label:a.string(),only:!0,presence:["optional","required","forbidden"],result:["raw","strip"],strip:a.boolean(),unit:a.string()}).unknown(),preferences:{allowUnknown:a.boolean(),abortEarly:a.boolean(),artifacts:a.boolean(),cache:a.boolean(),convert:a.boolean(),dateFormat:["date","iso","string","time","utc"],errors:{escapeHtml:a.boolean(),label:["path","key"],language:[a.string(),h.desc.ref],wrap:{label:h.wrap,array:h.wrap}},externals:a.boolean(),messages:h.desc.messages,noDefaults:a.boolean(),nonEnumerables:a.boolean(),presence:["required","optional","forbidden"],skipFunctions:a.boolean(),stripUnknown:a.object({arrays:a.boolean(),objects:a.boolean()}).or("arrays","objects").allow(!0,!1),warnings:a.boolean()},allow:h.desc.values,invalid:h.desc.values,rules:a.array().min(1).items({name:a.string().required(),args:a.object().min(1),keep:a.boolean(),message:[a.string(),h.desc.messages],warn:a.boolean()}),keys:a.object().pattern(/.*/,a.link("/")),link:h.desc.ref}).pattern(/^[a-z]\w*$/,a.any())},493:(x,w,m)=>{const a=m(8571),h=m(9621),y=m(8160),c={value:Symbol("value")};x.exports=c.State=class{constructor(e,i,n){this.path=e,this.ancestors=i,this.mainstay=n.mainstay,this.schemas=n.schemas,this.debug=null}localize(e,i=null,n=null){const r=new c.State(e,i,this);return n&&r.schemas&&(r.schemas=[c.schemas(n),...r.schemas]),r}nest(e,i){const n=new c.State(this.path,this.ancestors,this);return n.schemas=n.schemas&&[c.schemas(e),...n.schemas],n.debug=i,n}shadow(e,i){this.mainstay.shadow=this.mainstay.shadow||new c.Shadow,this.mainstay.shadow.set(this.path,e,i)}snapshot(){this.mainstay.shadow&&(this._snapshot=a(this.mainstay.shadow.node(this.path))),this.mainstay.snapshot()}restore(){this.mainstay.shadow&&(this.mainstay.shadow.override(this.path,this._snapshot),this._snapshot=void 0),this.mainstay.restore()}commit(){this.mainstay.shadow&&(this.mainstay.shadow.override(this.path,this._snapshot),this._snapshot=void 0),this.mainstay.commit()}},c.schemas=function(e){return y.isSchema(e)?{schema:e}:e},c.Shadow=class{constructor(){this._values=null}set(e,i,n){if(!e.length||n==="strip"&&typeof e[e.length-1]=="number")return;this._values=this._values||new Map;let r=this._values;for(let t=0;t<e.length;++t){const l=e[t];let s=r.get(l);s||(s=new Map,r.set(l,s)),r=s}r[c.value]=i}get(e){const i=this.node(e);if(i)return i[c.value]}node(e){if(this._values)return h(this._values,e,{iterables:!0})}override(e,i){if(!this._values)return;const n=e.slice(0,-1),r=e[e.length-1],t=h(this._values,n,{iterables:!0});i?t.set(r,i):t&&t.delete(r)}}},3328:(x,w,m)=>{const a=m(375),h=m(8571),y=m(5277),c=m(1447),e=m(8160),i=m(6354),n=m(6133),r={symbol:Symbol("template"),opens:new Array(1e3).join("\0"),closes:new Array(1e3).join(""),dateFormat:{date:Date.prototype.toDateString,iso:Date.prototype.toISOString,string:Date.prototype.toString,time:Date.prototype.toTimeString,utc:Date.prototype.toUTCString}};x.exports=r.Template=class{constructor(t,l){if(a(typeof t=="string","Template source must be a string"),a(!t.includes("\0")&&!t.includes(""),"Template source cannot contain reserved control characters"),this.source=t,this.rendered=t,this._template=null,l){const{functions:s,...o}=l;this._settings=Object.keys(o).length?h(o):void 0,this._functions=s,this._functions&&(a(Object.keys(this._functions).every(u=>typeof u=="string"),"Functions keys must be strings"),a(Object.values(this._functions).every(u=>typeof u=="function"),"Functions values must be functions"))}else this._settings=void 0,this._functions=void 0;this._parse()}_parse(){if(!this.source.includes("{"))return;const t=r.encode(this.source),l=r.split(t);let s=!1;const o=[],u=l.shift();u&&o.push(u);for(const d of l){const v=d[0]!=="{",R=v?"}":"}}",E=d.indexOf(R);if(E===-1||d[1]==="{"){o.push(`{${r.decode(d)}`);continue}let f=d.slice(v?0:1,E);const g=f[0]===":";g&&(f=f.slice(1));const _=this._ref(r.decode(f),{raw:v,wrapped:g});o.push(_),typeof _!="string"&&(s=!0);const S=d.slice(E+R.length);S&&o.push(r.decode(S))}s?this._template=o:this.rendered=o.join("")}static date(t,l){return r.dateFormat[l.dateFormat].call(t)}describe(t={}){if(!this._settings&&t.compact)return this.source;const l={template:this.source};return this._settings&&(l.options=this._settings),this._functions&&(l.functions=this._functions),l}static build(t){return new r.Template(t.template,t.options||t.functions?{...t.options,functions:t.functions}:void 0)}isDynamic(){return!!this._template}static isTemplate(t){return!!t&&!!t[e.symbols.template]}refs(){if(!this._template)return;const t=[];for(const l of this._template)typeof l!="string"&&t.push(...l.refs);return t}resolve(t,l,s,o){return this._template&&this._template.length===1?this._part(this._template[0],t,l,s,o,{}):this.render(t,l,s,o)}_part(t,...l){return t.ref?t.ref.resolve(...l):t.formula.evaluate(l)}render(t,l,s,o,u={}){if(!this.isDynamic())return this.rendered;const d=[];for(const v of this._template)if(typeof v=="string")d.push(v);else{const R=this._part(v,t,l,s,o,u),E=r.stringify(R,t,l,s,o,u);if(E!==void 0){const f=v.raw||(u.errors&&u.errors.escapeHtml)===!1?E:y(E);d.push(r.wrap(f,v.wrapped&&s.errors.wrap.label))}}return d.join("")}_ref(t,{raw:l,wrapped:s}){const o=[],u=v=>{const R=n.create(v,this._settings);return o.push(R),E=>{const f=R.resolve(...E);return f!==void 0?f:null}};try{const v=this._functions?{...r.functions,...this._functions}:r.functions;var d=new c.Parser(t,{reference:u,functions:v,constants:r.constants})}catch(v){throw v.message=`Invalid template variable "${t}" fails due to: ${v.message}`,v}if(d.single){if(d.single.type==="reference"){const v=o[0];return{ref:v,raw:l,refs:o,wrapped:s||v.type==="local"&&v.key==="label"}}return r.stringify(d.single.value)}return{formula:d,raw:l,refs:o}}toString(){return this.source}},r.Template.prototype[e.symbols.template]=!0,r.Template.prototype.isImmutable=!0,r.encode=function(t){return t.replace(/\\(\{+)/g,(l,s)=>r.opens.slice(0,s.length)).replace(/\\(\}+)/g,(l,s)=>r.closes.slice(0,s.length))},r.decode=function(t){return t.replace(/\u0000/g,"{").replace(/\u0001/g,"}")},r.split=function(t){const l=[];let s="";for(let o=0;o<t.length;++o){const u=t[o];if(u==="{"){let d="";for(;o+1<t.length&&t[o+1]==="{";)d+="{",++o;l.push(s),s=d}else s+=u}return l.push(s),l},r.wrap=function(t,l){return l?l.length===1?`${l}${t}${l}`:`${l[0]}${t}${l[1]}`:t},r.stringify=function(t,l,s,o,u,d={}){const v=typeof t,R=o&&o.errors&&o.errors.wrap||{};let E=!1;if(n.isRef(t)&&t.render&&(E=t.in,t=t.resolve(l,s,o,u,{in:t.in,...d})),t===null)return"null";if(v==="string")return r.wrap(t,d.arrayItems&&R.string);if(v==="number"||v==="function"||v==="symbol")return t.toString();if(v!=="object")return JSON.stringify(t);if(t instanceof Date)return r.Template.date(t,o);if(t instanceof Map){const g=[];for(const[_,S]of t.entries())g.push(`${_.toString()} -> ${S.toString()}`);t=g}if(!Array.isArray(t))return t.toString();const f=[];for(const g of t)f.push(r.stringify(g,l,s,o,u,{arrayItems:!0,...d}));return r.wrap(f.join(", "),!E&&R.array)},r.constants={true:!0,false:!1,null:null,second:1e3,minute:6e4,hour:36e5,day:864e5},r.functions={if:(t,l,s)=>t?l:s,length:t=>typeof t=="string"?t.length:t&&typeof t=="object"?Array.isArray(t)?t.length:Object.keys(t).length:null,msg(t){const[l,s,o,u,d]=this,v=d.messages;if(!v)return"";const R=i.template(l,v[0],t,s,o)||i.template(l,v[1],t,s,o);return R?R.render(l,s,o,u,d):""},number:t=>typeof t=="number"?t:typeof t=="string"?parseFloat(t):typeof t=="boolean"?t?1:0:t instanceof Date?t.getTime():null}},4946:(x,w,m)=>{const a=m(375),h=m(1687),y=m(8068),c=m(8160),e=m(3292),i=m(6354),n=m(6133),r={};x.exports=y.extend({type:"alternatives",flags:{match:{default:"any"}},terms:{matches:{init:[],register:n.toSibling}},args:(t,...l)=>l.length===1&&Array.isArray(l[0])?t.try(...l[0]):t.try(...l),validate(t,l){const{schema:s,error:o,state:u,prefs:d}=l;if(s._flags.match){const R=[],E=[];for(let g=0;g<s.$_terms.matches.length;++g){const _=s.$_terms.matches[g],S=u.nest(_.schema,`match.${g}`);S.snapshot();const I=_.schema.$_validate(t,S,d);I.errors?(E.push(I.errors),S.restore()):(R.push(I.value),S.commit())}if(R.length===0)return{errors:o("alternatives.any",{details:E.map(g=>i.details(g,{override:!1}))})};if(s._flags.match==="one")return R.length===1?{value:R[0]}:{errors:o("alternatives.one")};if(R.length!==s.$_terms.matches.length)return{errors:o("alternatives.all",{details:E.map(g=>i.details(g,{override:!1}))})};const f=g=>g.$_terms.matches.some(_=>_.schema.type==="object"||_.schema.type==="alternatives"&&f(_.schema));return f(s)?{value:R.reduce((g,_)=>h(g,_,{mergeArrays:!1}))}:{value:R[R.length-1]}}const v=[];for(let R=0;R<s.$_terms.matches.length;++R){const E=s.$_terms.matches[R];if(E.schema){const _=u.nest(E.schema,`match.${R}`);_.snapshot();const S=E.schema.$_validate(t,_,d);if(!S.errors)return _.commit(),S;_.restore(),v.push({schema:E.schema,reports:S.errors});continue}const f=E.ref?E.ref.resolve(t,u,d):t,g=E.is?[E]:E.switch;for(let _=0;_<g.length;++_){const S=g[_],{is:I,then:k,otherwise:j}=S,O=`match.${R}${E.switch?"."+_:""}`;if(I.$_match(f,u.nest(I,`${O}.is`),d)){if(k)return k.$_validate(t,u.nest(k,`${O}.then`),d)}else if(j)return j.$_validate(t,u.nest(j,`${O}.otherwise`),d)}}return r.errors(v,l)},rules:{conditional:{method(t,l){a(!this._flags._endedSwitch,"Unreachable condition"),a(!this._flags.match,"Cannot combine match mode",this._flags.match,"with conditional rule"),a(l.break===void 0,"Cannot use break option with alternatives conditional");const s=this.clone(),o=e.when(s,t,l),u=o.is?[o]:o.switch;for(const d of u)if(d.then&&d.otherwise){s.$_setFlag("_endedSwitch",!0,{clone:!1});break}return s.$_terms.matches.push(o),s.$_mutateRebuild()}},match:{method(t){if(a(["any","one","all"].includes(t),"Invalid alternatives match mode",t),t!=="any")for(const l of this.$_terms.matches)a(l.schema,"Cannot combine match mode",t,"with conditional rules");return this.$_setFlag("match",t)}},try:{method(...t){a(t.length,"Missing alternative schemas"),c.verifyFlat(t,"try"),a(!this._flags._endedSwitch,"Unreachable condition");const l=this.clone();for(const s of t)l.$_terms.matches.push({schema:l.$_compile(s)});return l.$_mutateRebuild()}}},overrides:{label(t){return this.$_parent("label",t).$_modify({each:(l,s)=>s.path[0]!=="is"&&typeof l._flags.label!="string"?l.label(t):void 0,ref:!1})}},rebuild(t){t.$_modify({each:l=>{c.isSchema(l)&&l.type==="array"&&t.$_setFlag("_arrayItems",!0,{clone:!1})}})},manifest:{build(t,l){if(l.matches)for(const s of l.matches){const{schema:o,ref:u,is:d,not:v,then:R,otherwise:E}=s;t=o?t.try(o):u?t.conditional(u,{is:d,then:R,not:v,otherwise:E,switch:s.switch}):t.conditional(d,{then:R,otherwise:E})}return t}},messages:{"alternatives.all":"{{#label}} does not match all of the required types","alternatives.any":"{{#label}} does not match any of the allowed types","alternatives.match":"{{#label}} does not match any of the allowed types","alternatives.one":"{{#label}} matches more than one allowed type","alternatives.types":"{{#label}} must be one of {{#types}}"}}),r.errors=function(t,{error:l,state:s}){if(!t.length)return{errors:l("alternatives.any")};if(t.length===1)return{errors:t[0].reports};const o=new Set,u=[];for(const{reports:d,schema:v}of t){if(d.length>1)return r.unmatched(t,l);const R=d[0];if(R instanceof i.Report==0)return r.unmatched(t,l);if(R.state.path.length!==s.path.length){u.push({type:v.type,report:R});continue}if(R.code==="any.only"){for(const g of R.local.valids)o.add(g);continue}const[E,f]=R.code.split(".");f!=="base"?u.push({type:v.type,report:R}):R.code==="object.base"?o.add(R.local.type):o.add(E)}return u.length?u.length===1?{errors:u[0].report}:r.unmatched(t,l):{errors:l("alternatives.types",{types:[...o]})}},r.unmatched=function(t,l){const s=[];for(const o of t)s.push(...o.reports);return{errors:l("alternatives.match",i.details(s,{override:!1}))}}},8068:(x,w,m)=>{const a=m(375),h=m(7629),y=m(8160),c=m(6914);x.exports=h.extend({type:"any",flags:{only:{default:!1}},terms:{alterations:{init:null},examples:{init:null},externals:{init:null},metas:{init:[]},notes:{init:[]},shared:{init:null},tags:{init:[]},whens:{init:null}},rules:{custom:{method(e,i){return a(typeof e=="function","Method must be a function"),a(i===void 0||i&&typeof i=="string","Description must be a non-empty string"),this.$_addRule({name:"custom",args:{method:e,description:i}})},validate(e,i,{method:n}){try{return n(e,i)}catch(r){return i.error("any.custom",{error:r})}},args:["method","description"],multi:!0},messages:{method(e){return this.prefs({messages:e})}},shared:{method(e){a(y.isSchema(e)&&e._flags.id,"Schema must be a schema with an id");const i=this.clone();return i.$_terms.shared=i.$_terms.shared||[],i.$_terms.shared.push(e),i.$_mutateRegister(e),i}},warning:{method(e,i){return a(e&&typeof e=="string","Invalid warning code"),this.$_addRule({name:"warning",args:{code:e,local:i},warn:!0})},validate:(e,i,{code:n,local:r})=>i.error(n,r),args:["code","local"],multi:!0}},modifiers:{keep(e,i=!0){e.keep=i},message(e,i){e.message=c.compile(i)},warn(e,i=!0){e.warn=i}},manifest:{build(e,i){for(const n in i){const r=i[n];if(["examples","externals","metas","notes","tags"].includes(n))for(const t of r)e=e[n.slice(0,-1)](t);else if(n!=="alterations")if(n!=="whens"){if(n==="shared")for(const t of r)e=e.shared(t)}else for(const t of r){const{ref:l,is:s,not:o,then:u,otherwise:d,concat:v}=t;e=v?e.concat(v):l?e.when(l,{is:s,not:o,then:u,otherwise:d,switch:t.switch,break:t.break}):e.when(s,{then:u,otherwise:d,break:t.break})}else{const t={};for(const{target:l,adjuster:s}of r)t[l]=s;e=e.alter(t)}}return e}},messages:{"any.custom":"{{#label}} failed custom validation because {{#error.message}}","any.default":"{{#label}} threw an error when running default method","any.failover":"{{#label}} threw an error when running failover method","any.invalid":"{{#label}} contains an invalid value","any.only":'{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',"any.ref":"{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}","any.required":"{{#label}} is required","any.unknown":"{{#label}} is not allowed"}})},546:(x,w,m)=>{const a=m(375),h=m(9474),y=m(9621),c=m(8068),e=m(8160),i=m(3292),n={};x.exports=c.extend({type:"array",flags:{single:{default:!1},sparse:{default:!1}},terms:{items:{init:[],manifest:"schema"},ordered:{init:[],manifest:"schema"},_exclusions:{init:[]},_inclusions:{init:[]},_requireds:{init:[]}},coerce:{from:"object",method(r,{schema:t,state:l,prefs:s}){if(!Array.isArray(r))return;const o=t.$_getRule("sort");return o?n.sort(t,r,o.args.options,l,s):void 0}},validate(r,{schema:t,error:l}){if(!Array.isArray(r)){if(t._flags.single){const s=[r];return s[e.symbols.arraySingle]=!0,{value:s}}return{errors:l("array.base")}}if(t.$_getRule("items")||t.$_terms.externals)return{value:r.slice()}},rules:{has:{method(r){r=this.$_compile(r,{appendPath:!0});const t=this.$_addRule({name:"has",args:{schema:r}});return t.$_mutateRegister(r),t},validate(r,{state:t,prefs:l,error:s},{schema:o}){const u=[r,...t.ancestors];for(let v=0;v<r.length;++v){const R=t.localize([...t.path,v],u,o);if(o.$_match(r[v],R,l))return r}const d=o._flags.label;return d?s("array.hasKnown",{patternLabel:d}):s("array.hasUnknown",null)},multi:!0},items:{method(...r){e.verifyFlat(r,"items");const t=this.$_addRule("items");for(let l=0;l<r.length;++l){const s=e.tryWithPath(()=>this.$_compile(r[l]),l,{append:!0});t.$_terms.items.push(s)}return t.$_mutateRebuild()},validate(r,{schema:t,error:l,state:s,prefs:o,errorsArray:u}){const d=t.$_terms._requireds.slice(),v=t.$_terms.ordered.slice(),R=[...t.$_terms._inclusions,...d],E=!r[e.symbols.arraySingle];delete r[e.symbols.arraySingle];const f=u();let g=r.length;for(let _=0;_<g;++_){const S=r[_];let I=!1,k=!1;const j=E?_:new Number(_),O=[...s.path,j];if(!t._flags.sparse&&S===void 0){if(f.push(l("array.sparse",{key:j,path:O,pos:_,value:void 0},s.localize(O))),o.abortEarly)return f;v.shift();continue}const L=[r,...s.ancestors];for(const T of t.$_terms._exclusions)if(T.$_match(S,s.localize(O,L,T),o,{presence:"ignore"})){if(f.push(l("array.excludes",{pos:_,value:S},s.localize(O))),o.abortEarly)return f;I=!0,v.shift();break}if(I)continue;if(t.$_terms.ordered.length){if(v.length){const T=v.shift(),P=T.$_validate(S,s.localize(O,L,T),o);if(P.errors){if(f.push(...P.errors),o.abortEarly)return f}else if(T._flags.result==="strip")n.fastSplice(r,_),--_,--g;else{if(!t._flags.sparse&&P.value===void 0){if(f.push(l("array.sparse",{key:j,path:O,pos:_,value:void 0},s.localize(O))),o.abortEarly)return f;continue}r[_]=P.value}continue}if(!t.$_terms.items.length){if(f.push(l("array.orderedLength",{pos:_,limit:t.$_terms.ordered.length})),o.abortEarly)return f;break}}const N=[];let D=d.length;for(let T=0;T<D;++T){const P=s.localize(O,L,d[T]);P.snapshot();const F=d[T].$_validate(S,P,o);if(N[T]=F,!F.errors){if(P.commit(),r[_]=F.value,k=!0,n.fastSplice(d,T),--T,--D,!t._flags.sparse&&F.value===void 0&&(f.push(l("array.sparse",{key:j,path:O,pos:_,value:void 0},s.localize(O))),o.abortEarly))return f;break}P.restore()}if(k)continue;const C=o.stripUnknown&&!!o.stripUnknown.arrays||!1;D=R.length;for(const T of R){let P;const F=d.indexOf(T);if(F!==-1)P=N[F];else{const U=s.localize(O,L,T);if(U.snapshot(),P=T.$_validate(S,U,o),!P.errors){U.commit(),T._flags.result==="strip"?(n.fastSplice(r,_),--_,--g):t._flags.sparse||P.value!==void 0?r[_]=P.value:(f.push(l("array.sparse",{key:j,path:O,pos:_,value:void 0},s.localize(O))),I=!0),k=!0;break}U.restore()}if(D===1){if(C){n.fastSplice(r,_),--_,--g,k=!0;break}if(f.push(...P.errors),o.abortEarly)return f;I=!0;break}}if(!I&&(t.$_terms._inclusions.length||t.$_terms._requireds.length)&&!k){if(C){n.fastSplice(r,_),--_,--g;continue}if(f.push(l("array.includes",{pos:_,value:S},s.localize(O))),o.abortEarly)return f}}return d.length&&n.fillMissedErrors(t,f,d,r,s,o),v.length&&(n.fillOrderedErrors(t,f,v,r,s,o),f.length||n.fillDefault(v,r,s,o)),f.length?f:r},priority:!0,manifest:!1},length:{method(r){return this.$_addRule({name:"length",args:{limit:r},operator:"="})},validate:(r,t,{limit:l},{name:s,operator:o,args:u})=>e.compare(r.length,l,o)?r:t.error("array."+s,{limit:u.limit,value:r}),args:[{name:"limit",ref:!0,assert:e.limit,message:"must be a positive integer"}]},max:{method(r){return this.$_addRule({name:"max",method:"length",args:{limit:r},operator:"<="})}},min:{method(r){return this.$_addRule({name:"min",method:"length",args:{limit:r},operator:">="})}},ordered:{method(...r){e.verifyFlat(r,"ordered");const t=this.$_addRule("items");for(let l=0;l<r.length;++l){const s=e.tryWithPath(()=>this.$_compile(r[l]),l,{append:!0});n.validateSingle(s,t),t.$_mutateRegister(s),t.$_terms.ordered.push(s)}return t.$_mutateRebuild()}},single:{method(r){const t=r===void 0||!!r;return a(!t||!this._flags._arrayItems,"Cannot specify single rule when array has array items"),this.$_setFlag("single",t)}},sort:{method(r={}){e.assertOptions(r,["by","order"]);const t={order:r.order||"ascending"};return r.by&&(t.by=i.ref(r.by,{ancestor:0}),a(!t.by.ancestor,"Cannot sort by ancestor")),this.$_addRule({name:"sort",args:{options:t}})},validate(r,{error:t,state:l,prefs:s,schema:o},{options:u}){const{value:d,errors:v}=n.sort(o,r,u,l,s);if(v)return v;for(let R=0;R<r.length;++R)if(r[R]!==d[R])return t("array.sort",{order:u.order,by:u.by?u.by.key:"value"});return r},convert:!0},sparse:{method(r){const t=r===void 0||!!r;return this._flags.sparse===t?this:(t?this.clone():this.$_addRule("items")).$_setFlag("sparse",t,{clone:!1})}},unique:{method(r,t={}){a(!r||typeof r=="function"||typeof r=="string","comparator must be a function or a string"),e.assertOptions(t,["ignoreUndefined","separator"]);const l={name:"unique",args:{options:t,comparator:r}};if(r)if(typeof r=="string"){const s=e.default(t.separator,".");l.path=s?r.split(s):[r]}else l.comparator=r;return this.$_addRule(l)},validate(r,{state:t,error:l,schema:s},{comparator:o,options:u},{comparator:d,path:v}){const R={string:Object.create(null),number:Object.create(null),undefined:Object.create(null),boolean:Object.create(null),bigint:Object.create(null),object:new Map,function:new Map,custom:new Map},E=d||h,f=u.ignoreUndefined;for(let g=0;g<r.length;++g){const _=v?y(r[g],v):r[g],S=d?R.custom:R[typeof _];if(a(S,"Failed to find unique map container for type",typeof _),S instanceof Map){const I=S.entries();let k;for(;!(k=I.next()).done;)if(E(k.value[0],_)){const j=t.localize([...t.path,g],[r,...t.ancestors]),O={pos:g,value:r[g],dupePos:k.value[1],dupeValue:r[k.value[1]]};return v&&(O.path=o),l("array.unique",O,j)}S.set(_,g)}else{if((!f||_!==void 0)&&S[_]!==void 0){const I={pos:g,value:r[g],dupePos:S[_],dupeValue:r[S[_]]};return v&&(I.path=o),l("array.unique",I,t.localize([...t.path,g],[r,...t.ancestors]))}S[_]=g}}return r},args:["comparator","options"],multi:!0}},cast:{set:{from:Array.isArray,to:(r,t)=>new Set(r)}},rebuild(r){r.$_terms._inclusions=[],r.$_terms._exclusions=[],r.$_terms._requireds=[];for(const t of r.$_terms.items)n.validateSingle(t,r),t._flags.presence==="required"?r.$_terms._requireds.push(t):t._flags.presence==="forbidden"?r.$_terms._exclusions.push(t):r.$_terms._inclusions.push(t);for(const t of r.$_terms.ordered)n.validateSingle(t,r)},manifest:{build:(r,t)=>(t.items&&(r=r.items(...t.items)),t.ordered&&(r=r.ordered(...t.ordered)),r)},messages:{"array.base":"{{#label}} must be an array","array.excludes":"{{#label}} contains an excluded value","array.hasKnown":"{{#label}} does not contain at least one required match for type {:#patternLabel}","array.hasUnknown":"{{#label}} does not contain at least one required match","array.includes":"{{#label}} does not match any of the allowed types","array.includesRequiredBoth":"{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)","array.includesRequiredKnowns":"{{#label}} does not contain {{#knownMisses}}","array.includesRequiredUnknowns":"{{#label}} does not contain {{#unknownMisses}} required value(s)","array.length":"{{#label}} must contain {{#limit}} items","array.max":"{{#label}} must contain less than or equal to {{#limit}} items","array.min":"{{#label}} must contain at least {{#limit}} items","array.orderedLength":"{{#label}} must contain at most {{#limit}} items","array.sort":"{{#label}} must be sorted in {#order} order by {{#by}}","array.sort.mismatching":"{{#label}} cannot be sorted due to mismatching types","array.sort.unsupported":"{{#label}} cannot be sorted due to unsupported type {#type}","array.sparse":"{{#label}} must not be a sparse array item","array.unique":"{{#label}} contains a duplicate value"}}),n.fillMissedErrors=function(r,t,l,s,o,u){const d=[];let v=0;for(const R of l){const E=R._flags.label;E?d.push(E):++v}d.length?v?t.push(r.$_createError("array.includesRequiredBoth",s,{knownMisses:d,unknownMisses:v},o,u)):t.push(r.$_createError("array.includesRequiredKnowns",s,{knownMisses:d},o,u)):t.push(r.$_createError("array.includesRequiredUnknowns",s,{unknownMisses:v},o,u))},n.fillOrderedErrors=function(r,t,l,s,o,u){const d=[];for(const v of l)v._flags.presence==="required"&&d.push(v);d.length&&n.fillMissedErrors(r,t,d,s,o,u)},n.fillDefault=function(r,t,l,s){const o=[];let u=!0;for(let d=r.length-1;d>=0;--d){const v=r[d],R=[t,...l.ancestors],E=v.$_validate(void 0,l.localize(l.path,R,v),s).value;if(u){if(E===void 0)continue;u=!1}o.unshift(E)}o.length&&t.push(...o)},n.fastSplice=function(r,t){let l=t;for(;l<r.length;)r[l++]=r[l];--r.length},n.validateSingle=function(r,t){(r.type==="array"||r._flags._arrayItems)&&(a(!t._flags.single,"Cannot specify array item with single rule enabled"),t.$_setFlag("_arrayItems",!0,{clone:!1}))},n.sort=function(r,t,l,s,o){const u=l.order==="ascending"?1:-1,d=-1*u,v=u,R=(E,f)=>{let g=n.compare(E,f,d,v);if(g!==null||(l.by&&(E=l.by.resolve(E,s,o),f=l.by.resolve(f,s,o)),g=n.compare(E,f,d,v),g!==null))return g;const _=typeof E;if(_!==typeof f)throw r.$_createError("array.sort.mismatching",t,null,s,o);if(_!=="number"&&_!=="string")throw r.$_createError("array.sort.unsupported",t,{type:_},s,o);return _==="number"?(E-f)*u:E<f?d:v};try{return{value:t.slice().sort(R)}}catch(E){return{errors:E}}},n.compare=function(r,t,l,s){return r===t?0:r===void 0?1:t===void 0?-1:r===null?s:t===null?l:null}},4937:(x,w,m)=>{const a=m(375),h=m(8068),y=m(8160),c=m(2036),e={isBool:function(i){return typeof i=="boolean"}};x.exports=h.extend({type:"boolean",flags:{sensitive:{default:!1}},terms:{falsy:{init:null,manifest:"values"},truthy:{init:null,manifest:"values"}},coerce(i,{schema:n}){if(typeof i!="boolean"){if(typeof i=="string"){const r=n._flags.sensitive?i:i.toLowerCase();i=r==="true"||r!=="false"&&i}return typeof i!="boolean"&&(i=n.$_terms.truthy&&n.$_terms.truthy.has(i,null,null,!n._flags.sensitive)||(!n.$_terms.falsy||!n.$_terms.falsy.has(i,null,null,!n._flags.sensitive))&&i),{value:i}}},validate(i,{error:n}){if(typeof i!="boolean")return{value:i,errors:n("boolean.base")}},rules:{truthy:{method(...i){y.verifyFlat(i,"truthy");const n=this.clone();n.$_terms.truthy=n.$_terms.truthy||new c;for(let r=0;r<i.length;++r){const t=i[r];a(t!==void 0,"Cannot call truthy with undefined"),n.$_terms.truthy.add(t)}return n}},falsy:{method(...i){y.verifyFlat(i,"falsy");const n=this.clone();n.$_terms.falsy=n.$_terms.falsy||new c;for(let r=0;r<i.length;++r){const t=i[r];a(t!==void 0,"Cannot call falsy with undefined"),n.$_terms.falsy.add(t)}return n}},sensitive:{method(i=!0){return this.$_setFlag("sensitive",i)}}},cast:{number:{from:e.isBool,to:(i,n)=>i?1:0},string:{from:e.isBool,to:(i,n)=>i?"true":"false"}},manifest:{build:(i,n)=>(n.truthy&&(i=i.truthy(...n.truthy)),n.falsy&&(i=i.falsy(...n.falsy)),i)},messages:{"boolean.base":"{{#label}} must be a boolean"}})},7500:(x,w,m)=>{const a=m(375),h=m(8068),y=m(8160),c=m(3328),e={isDate:function(i){return i instanceof Date}};x.exports=h.extend({type:"date",coerce:{from:["number","string"],method:(i,{schema:n})=>({value:e.parse(i,n._flags.format)||i})},validate(i,{schema:n,error:r,prefs:t}){if(i instanceof Date&&!isNaN(i.getTime()))return;const l=n._flags.format;return t.convert&&l&&typeof i=="string"?{value:i,errors:r("date.format",{format:l})}:{value:i,errors:r("date.base")}},rules:{compare:{method:!1,validate(i,n,{date:r},{name:t,operator:l,args:s}){const o=r==="now"?Date.now():r.getTime();return y.compare(i.getTime(),o,l)?i:n.error("date."+t,{limit:s.date,value:i})},args:[{name:"date",ref:!0,normalize:i=>i==="now"?i:e.parse(i),assert:i=>i!==null,message:"must have a valid date format"}]},format:{method(i){return a(["iso","javascript","unix"].includes(i),"Unknown date format",i),this.$_setFlag("format",i)}},greater:{method(i){return this.$_addRule({name:"greater",method:"compare",args:{date:i},operator:">"})}},iso:{method(){return this.format("iso")}},less:{method(i){return this.$_addRule({name:"less",method:"compare",args:{date:i},operator:"<"})}},max:{method(i){return this.$_addRule({name:"max",method:"compare",args:{date:i},operator:"<="})}},min:{method(i){return this.$_addRule({name:"min",method:"compare",args:{date:i},operator:">="})}},timestamp:{method(i="javascript"){return a(["javascript","unix"].includes(i),'"type" must be one of "javascript, unix"'),this.format(i)}}},cast:{number:{from:e.isDate,to:(i,n)=>i.getTime()},string:{from:e.isDate,to:(i,{prefs:n})=>c.date(i,n)}},messages:{"date.base":"{{#label}} must be a valid date","date.format":'{{#label}} must be in {msg("date.format." + #format) || #format} format',"date.greater":"{{#label}} must be greater than {{:#limit}}","date.less":"{{#label}} must be less than {{:#limit}}","date.max":"{{#label}} must be less than or equal to {{:#limit}}","date.min":"{{#label}} must be greater than or equal to {{:#limit}}","date.format.iso":"ISO 8601 date","date.format.javascript":"timestamp or number of milliseconds","date.format.unix":"timestamp or number of seconds"}}),e.parse=function(i,n){if(i instanceof Date)return i;if(typeof i!="string"&&(isNaN(i)||!isFinite(i))||/^\s*$/.test(i))return null;if(n==="iso")return y.isIsoDate(i)?e.date(i.toString()):null;const r=i;if(typeof i=="string"&&/^[+-]?\d+(\.\d+)?$/.test(i)&&(i=parseFloat(i)),n){if(n==="javascript")return e.date(1*i);if(n==="unix")return e.date(1e3*i);if(typeof r=="string")return null}return e.date(i)},e.date=function(i){const n=new Date(i);return isNaN(n.getTime())?null:n}},390:(x,w,m)=>{const a=m(375),h=m(7824);x.exports=h.extend({type:"function",properties:{typeof:"function"},rules:{arity:{method(y){return a(Number.isSafeInteger(y)&&y>=0,"n must be a positive integer"),this.$_addRule({name:"arity",args:{n:y}})},validate:(y,c,{n:e})=>y.length===e?y:c.error("function.arity",{n:e})},class:{method(){return this.$_addRule("class")},validate:(y,c)=>/^\s*class\s/.test(y.toString())?y:c.error("function.class",{value:y})},minArity:{method(y){return a(Number.isSafeInteger(y)&&y>0,"n must be a strict positive integer"),this.$_addRule({name:"minArity",args:{n:y}})},validate:(y,c,{n:e})=>y.length>=e?y:c.error("function.minArity",{n:e})},maxArity:{method(y){return a(Number.isSafeInteger(y)&&y>=0,"n must be a positive integer"),this.$_addRule({name:"maxArity",args:{n:y}})},validate:(y,c,{n:e})=>y.length<=e?y:c.error("function.maxArity",{n:e})}},messages:{"function.arity":"{{#label}} must have an arity of {{#n}}","function.class":"{{#label}} must be a class","function.maxArity":"{{#label}} must have an arity lesser or equal to {{#n}}","function.minArity":"{{#label}} must have an arity greater or equal to {{#n}}"}})},7824:(x,w,m)=>{const a=m(978),h=m(375),y=m(8571),c=m(3652),e=m(8068),i=m(8160),n=m(3292),r=m(6354),t=m(6133),l=m(3328),s={renameDefaults:{alias:!1,multiple:!1,override:!1}};x.exports=e.extend({type:"_keys",properties:{typeof:"object"},flags:{unknown:{default:void 0}},terms:{dependencies:{init:null},keys:{init:null,manifest:{mapped:{from:"schema",to:"key"}}},patterns:{init:null},renames:{init:null}},args:(o,u)=>o.keys(u),validate(o,{schema:u,error:d,state:v,prefs:R}){if(!o||typeof o!==u.$_property("typeof")||Array.isArray(o))return{value:o,errors:d("object.base",{type:u.$_property("typeof")})};if(!(u.$_terms.renames||u.$_terms.dependencies||u.$_terms.keys||u.$_terms.patterns||u.$_terms.externals))return;o=s.clone(o,R);const E=[];if(u.$_terms.renames&&!s.rename(u,o,v,R,E))return{value:o,errors:E};if(!u.$_terms.keys&&!u.$_terms.patterns&&!u.$_terms.dependencies)return{value:o,errors:E};const f=new Set(Object.keys(o));if(u.$_terms.keys){const g=[o,...v.ancestors];for(const _ of u.$_terms.keys){const S=_.key,I=o[S];f.delete(S);const k=v.localize([...v.path,S],g,_),j=_.schema.$_validate(I,k,R);if(j.errors){if(R.abortEarly)return{value:o,errors:j.errors};j.value!==void 0&&(o[S]=j.value),E.push(...j.errors)}else _.schema._flags.result==="strip"||j.value===void 0&&I!==void 0?delete o[S]:j.value!==void 0&&(o[S]=j.value)}}if(f.size||u._flags._hasPatternMatch){const g=s.unknown(u,o,f,E,v,R);if(g)return g}if(u.$_terms.dependencies)for(const g of u.$_terms.dependencies){if(g.key!==null&&s.isPresent(g.options)(g.key.resolve(o,v,R,null,{shadow:!1}))===!1)continue;const _=s.dependencies[g.rel](u,g,o,v,R);if(_){const S=u.$_createError(_.code,o,_.context,v,R);if(R.abortEarly)return{value:o,errors:S};E.push(S)}}return{value:o,errors:E}},rules:{and:{method(...o){return i.verifyFlat(o,"and"),s.dependency(this,"and",null,o)}},append:{method(o){return o==null||Object.keys(o).length===0?this:this.keys(o)}},assert:{method(o,u,d){l.isTemplate(o)||(o=n.ref(o)),h(d===void 0||typeof d=="string","Message must be a string"),u=this.$_compile(u,{appendPath:!0});const v=this.$_addRule({name:"assert",args:{subject:o,schema:u,message:d}});return v.$_mutateRegister(o),v.$_mutateRegister(u),v},validate(o,{error:u,prefs:d,state:v},{subject:R,schema:E,message:f}){const g=R.resolve(o,v,d),_=t.isRef(R)?R.absolute(v):[];return E.$_match(g,v.localize(_,[o,...v.ancestors],E),d)?o:u("object.assert",{subject:R,message:f})},args:["subject","schema","message"],multi:!0},instance:{method(o,u){return h(typeof o=="function","constructor must be a function"),u=u||o.name,this.$_addRule({name:"instance",args:{constructor:o,name:u}})},validate:(o,u,{constructor:d,name:v})=>o instanceof d?o:u.error("object.instance",{type:v,value:o}),args:["constructor","name"]},keys:{method(o){h(o===void 0||typeof o=="object","Object schema must be a valid object"),h(!i.isSchema(o),"Object schema cannot be a joi schema");const u=this.clone();if(o)if(Object.keys(o).length){u.$_terms.keys=u.$_terms.keys?u.$_terms.keys.filter(d=>!o.hasOwnProperty(d.key)):new s.Keys;for(const d in o)i.tryWithPath(()=>u.$_terms.keys.push({key:d,schema:this.$_compile(o[d])}),d)}else u.$_terms.keys=new s.Keys;else u.$_terms.keys=null;return u.$_mutateRebuild()}},length:{method(o){return this.$_addRule({name:"length",args:{limit:o},operator:"="})},validate:(o,u,{limit:d},{name:v,operator:R,args:E})=>i.compare(Object.keys(o).length,d,R)?o:u.error("object."+v,{limit:E.limit,value:o}),args:[{name:"limit",ref:!0,assert:i.limit,message:"must be a positive integer"}]},max:{method(o){return this.$_addRule({name:"max",method:"length",args:{limit:o},operator:"<="})}},min:{method(o){return this.$_addRule({name:"min",method:"length",args:{limit:o},operator:">="})}},nand:{method(...o){return i.verifyFlat(o,"nand"),s.dependency(this,"nand",null,o)}},or:{method(...o){return i.verifyFlat(o,"or"),s.dependency(this,"or",null,o)}},oxor:{method(...o){return s.dependency(this,"oxor",null,o)}},pattern:{method(o,u,d={}){const v=o instanceof RegExp;v||(o=this.$_compile(o,{appendPath:!0})),h(u!==void 0,"Invalid rule"),i.assertOptions(d,["fallthrough","matches"]),v&&h(!o.flags.includes("g")&&!o.flags.includes("y"),"pattern should not use global or sticky mode"),u=this.$_compile(u,{appendPath:!0});const R=this.clone();R.$_terms.patterns=R.$_terms.patterns||[];const E={[v?"regex":"schema"]:o,rule:u};return d.matches&&(E.matches=this.$_compile(d.matches),E.matches.type!=="array"&&(E.matches=E.matches.$_root.array().items(E.matches)),R.$_mutateRegister(E.matches),R.$_setFlag("_hasPatternMatch",!0,{clone:!1})),d.fallthrough&&(E.fallthrough=!0),R.$_terms.patterns.push(E),R.$_mutateRegister(u),R}},ref:{method(){return this.$_addRule("ref")},validate:(o,u)=>t.isRef(o)?o:u.error("object.refType",{value:o})},regex:{method(){return this.$_addRule("regex")},validate:(o,u)=>o instanceof RegExp?o:u.error("object.regex",{value:o})},rename:{method(o,u,d={}){h(typeof o=="string"||o instanceof RegExp,"Rename missing the from argument"),h(typeof u=="string"||u instanceof l,"Invalid rename to argument"),h(u!==o,"Cannot rename key to same name:",o),i.assertOptions(d,["alias","ignoreUndefined","override","multiple"]);const v=this.clone();v.$_terms.renames=v.$_terms.renames||[];for(const R of v.$_terms.renames)h(R.from!==o,"Cannot rename the same key multiple times");return u instanceof l&&v.$_mutateRegister(u),v.$_terms.renames.push({from:o,to:u,options:a(s.renameDefaults,d)}),v}},schema:{method(o="any"){return this.$_addRule({name:"schema",args:{type:o}})},validate:(o,u,{type:d})=>!i.isSchema(o)||d!=="any"&&o.type!==d?u.error("object.schema",{type:d}):o},unknown:{method(o){return this.$_setFlag("unknown",o!==!1)}},with:{method(o,u,d={}){return s.dependency(this,"with",o,u,d)}},without:{method(o,u,d={}){return s.dependency(this,"without",o,u,d)}},xor:{method(...o){return i.verifyFlat(o,"xor"),s.dependency(this,"xor",null,o)}}},overrides:{default(o,u){return o===void 0&&(o=i.symbols.deepDefault),this.$_parent("default",o,u)}},rebuild(o){if(o.$_terms.keys){const u=new c.Sorter;for(const d of o.$_terms.keys)i.tryWithPath(()=>u.add(d,{after:d.schema.$_rootReferences(),group:d.key}),d.key);o.$_terms.keys=new s.Keys(...u.nodes)}},manifest:{build(o,u){if(u.keys&&(o=o.keys(u.keys)),u.dependencies)for(const{rel:d,key:v=null,peers:R,options:E}of u.dependencies)o=s.dependency(o,d,v,R,E);if(u.patterns)for(const{regex:d,schema:v,rule:R,fallthrough:E,matches:f}of u.patterns)o=o.pattern(d||v,R,{fallthrough:E,matches:f});if(u.renames)for(const{from:d,to:v,options:R}of u.renames)o=o.rename(d,v,R);return o}},messages:{"object.and":"{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}","object.assert":'{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',"object.base":"{{#label}} must be of type {{#type}}","object.instance":"{{#label}} must be an instance of {{:#type}}","object.length":'{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',"object.max":'{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',"object.min":'{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',"object.missing":"{{#label}} must contain at least one of {{#peersWithLabels}}","object.nand":"{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}","object.oxor":"{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}","object.pattern.match":"{{#label}} keys failed to match pattern requirements","object.refType":"{{#label}} must be a Joi reference","object.regex":"{{#label}} must be a RegExp object","object.rename.multiple":"{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}","object.rename.override":"{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists","object.schema":"{{#label}} must be a Joi schema of {{#type}} type","object.unknown":"{{#label}} is not allowed","object.with":"{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}","object.without":"{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}","object.xor":"{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}"}}),s.clone=function(o,u){if(typeof o=="object"){if(u.nonEnumerables)return y(o,{shallow:!0});const v=Object.create(Object.getPrototypeOf(o));return Object.assign(v,o),v}const d=function(...v){return o.apply(this,v)};return d.prototype=y(o.prototype),Object.defineProperty(d,"name",{value:o.name,writable:!1}),Object.defineProperty(d,"length",{value:o.length,writable:!1}),Object.assign(d,o),d},s.dependency=function(o,u,d,v,R){h(d===null||typeof d=="string",u,"key must be a strings"),R||(R=v.length>1&&typeof v[v.length-1]=="object"?v.pop():{}),i.assertOptions(R,["separator","isPresent"]),v=[].concat(v);const E=i.default(R.separator,"."),f=[];for(const _ of v)h(typeof _=="string",u,"peers must be strings"),f.push(n.ref(_,{separator:E,ancestor:0,prefix:!1}));d!==null&&(d=n.ref(d,{separator:E,ancestor:0,prefix:!1}));const g=o.clone();return g.$_terms.dependencies=g.$_terms.dependencies||[],g.$_terms.dependencies.push(new s.Dependency(u,d,f,v,R)),g},s.dependencies={and(o,u,d,v,R){const E=[],f=[],g=u.peers.length,_=s.isPresent(u.options);for(const S of u.peers)_(S.resolve(d,v,R,null,{shadow:!1}))===!1?E.push(S.key):f.push(S.key);if(E.length!==g&&f.length!==g)return{code:"object.and",context:{present:f,presentWithLabels:s.keysToLabels(o,f),missing:E,missingWithLabels:s.keysToLabels(o,E)}}},nand(o,u,d,v,R){const E=[],f=s.isPresent(u.options);for(const S of u.peers)f(S.resolve(d,v,R,null,{shadow:!1}))&&E.push(S.key);if(E.length!==u.peers.length)return;const g=u.paths[0],_=u.paths.slice(1);return{code:"object.nand",context:{main:g,mainWithLabel:s.keysToLabels(o,g),peers:_,peersWithLabels:s.keysToLabels(o,_)}}},or(o,u,d,v,R){const E=s.isPresent(u.options);for(const f of u.peers)if(E(f.resolve(d,v,R,null,{shadow:!1})))return;return{code:"object.missing",context:{peers:u.paths,peersWithLabels:s.keysToLabels(o,u.paths)}}},oxor(o,u,d,v,R){const E=[],f=s.isPresent(u.options);for(const _ of u.peers)f(_.resolve(d,v,R,null,{shadow:!1}))&&E.push(_.key);if(!E.length||E.length===1)return;const g={peers:u.paths,peersWithLabels:s.keysToLabels(o,u.paths)};return g.present=E,g.presentWithLabels=s.keysToLabels(o,E),{code:"object.oxor",context:g}},with(o,u,d,v,R){const E=s.isPresent(u.options);for(const f of u.peers)if(E(f.resolve(d,v,R,null,{shadow:!1}))===!1)return{code:"object.with",context:{main:u.key.key,mainWithLabel:s.keysToLabels(o,u.key.key),peer:f.key,peerWithLabel:s.keysToLabels(o,f.key)}}},without(o,u,d,v,R){const E=s.isPresent(u.options);for(const f of u.peers)if(E(f.resolve(d,v,R,null,{shadow:!1})))return{code:"object.without",context:{main:u.key.key,mainWithLabel:s.keysToLabels(o,u.key.key),peer:f.key,peerWithLabel:s.keysToLabels(o,f.key)}}},xor(o,u,d,v,R){const E=[],f=s.isPresent(u.options);for(const _ of u.peers)f(_.resolve(d,v,R,null,{shadow:!1}))&&E.push(_.key);if(E.length===1)return;const g={peers:u.paths,peersWithLabels:s.keysToLabels(o,u.paths)};return E.length===0?{code:"object.missing",context:g}:(g.present=E,g.presentWithLabels=s.keysToLabels(o,E),{code:"object.xor",context:g})}},s.keysToLabels=function(o,u){return Array.isArray(u)?u.map(d=>o.$_mapLabels(d)):o.$_mapLabels(u)},s.isPresent=function(o){return typeof o.isPresent=="function"?o.isPresent:u=>u!==void 0},s.rename=function(o,u,d,v,R){const E={};for(const f of o.$_terms.renames){const g=[],_=typeof f.from!="string";if(_)for(const S in u){if(u[S]===void 0&&f.options.ignoreUndefined||S===f.to)continue;const I=f.from.exec(S);I&&g.push({from:S,to:f.to,match:I})}else!Object.prototype.hasOwnProperty.call(u,f.from)||u[f.from]===void 0&&f.options.ignoreUndefined||g.push(f);for(const S of g){const I=S.from;let k=S.to;if(k instanceof l&&(k=k.render(u,d,v,S.match)),I!==k){if(!f.options.multiple&&E[k]&&(R.push(o.$_createError("object.rename.multiple",u,{from:I,to:k,pattern:_},d,v)),v.abortEarly)||Object.prototype.hasOwnProperty.call(u,k)&&!f.options.override&&!E[k]&&(R.push(o.$_createError("object.rename.override",u,{from:I,to:k,pattern:_},d,v)),v.abortEarly))return!1;u[I]===void 0?delete u[k]:u[k]=u[I],E[k]=!0,f.options.alias||delete u[I]}}}return!0},s.unknown=function(o,u,d,v,R,E){if(o.$_terms.patterns){let f=!1;const g=o.$_terms.patterns.map(S=>{if(S.matches)return f=!0,[]}),_=[u,...R.ancestors];for(const S of d){const I=u[S],k=[...R.path,S];for(let j=0;j<o.$_terms.patterns.length;++j){const O=o.$_terms.patterns[j];if(O.regex){const D=O.regex.test(S);if(R.mainstay.tracer.debug(R,"rule",`pattern.${j}`,D?"pass":"error"),!D)continue}else if(!O.schema.$_match(S,R.nest(O.schema,`pattern.${j}`),E))continue;d.delete(S);const L=R.localize(k,_,{schema:O.rule,key:S}),N=O.rule.$_validate(I,L,E);if(N.errors){if(E.abortEarly)return{value:u,errors:N.errors};v.push(...N.errors)}if(O.matches&&g[j].push(S),u[S]=N.value,!O.fallthrough)break}}if(f)for(let S=0;S<g.length;++S){const I=g[S];if(!I)continue;const k=o.$_terms.patterns[S].matches,j=R.localize(R.path,_,k),O=k.$_validate(I,j,E);if(O.errors){const L=r.details(O.errors,{override:!1});L.matches=I;const N=o.$_createError("object.pattern.match",u,L,R,E);if(E.abortEarly)return{value:u,errors:N};v.push(N)}}}if(d.size&&(o.$_terms.keys||o.$_terms.patterns)){if(E.stripUnknown&&o._flags.unknown===void 0||E.skipFunctions){const f=!(!E.stripUnknown||E.stripUnknown!==!0&&!E.stripUnknown.objects);for(const g of d)f?(delete u[g],d.delete(g)):typeof u[g]=="function"&&d.delete(g)}if(!i.default(o._flags.unknown,E.allowUnknown))for(const f of d){const g=R.localize([...R.path,f],[]),_=o.$_createError("object.unknown",u[f],{child:f},g,E,{flags:!1});if(E.abortEarly)return{value:u,errors:_};v.push(_)}}},s.Dependency=class{constructor(o,u,d,v,R){this.rel=o,this.key=u,this.peers=d,this.paths=v,this.options=R}describe(){const o={rel:this.rel,peers:this.paths};return this.key!==null&&(o.key=this.key.key),this.peers[0].separator!=="."&&(o.options={...o.options,separator:this.peers[0].separator}),this.options.isPresent&&(o.options={...o.options,isPresent:this.options.isPresent}),o}},s.Keys=class extends Array{concat(o){const u=this.slice(),d=new Map;for(let v=0;v<u.length;++v)d.set(u[v].key,v);for(const v of o){const R=v.key,E=d.get(R);E!==void 0?u[E]={key:R,schema:u[E].schema.concat(v.schema)}:u.push(v)}return u}}},8785:(x,w,m)=>{const a=m(375),h=m(8068),y=m(8160),c=m(3292),e=m(6354),i={};x.exports=h.extend({type:"link",properties:{schemaChain:!0},terms:{link:{init:null,manifest:"single",register:!1}},args:(n,r)=>n.ref(r),validate(n,{schema:r,state:t,prefs:l}){a(r.$_terms.link,"Uninitialized link schema");const s=i.generate(r,n,t,l),o=r.$_terms.link[0].ref;return s.$_validate(n,t.nest(s,`link:${o.display}:${s.type}`),l)},generate:(n,r,t,l)=>i.generate(n,r,t,l),rules:{ref:{method(n){a(!this.$_terms.link,"Cannot reinitialize schema"),n=c.ref(n),a(n.type==="value"||n.type==="local","Invalid reference type:",n.type),a(n.type==="local"||n.ancestor==="root"||n.ancestor>0,"Link cannot reference itself");const r=this.clone();return r.$_terms.link=[{ref:n}],r}},relative:{method(n=!0){return this.$_setFlag("relative",n)}}},overrides:{concat(n){a(this.$_terms.link,"Uninitialized link schema"),a(y.isSchema(n),"Invalid schema object"),a(n.type!=="link","Cannot merge type link with another link");const r=this.clone();return r.$_terms.whens||(r.$_terms.whens=[]),r.$_terms.whens.push({concat:n}),r.$_mutateRebuild()}},manifest:{build:(n,r)=>(a(r.link,"Invalid link description missing link"),n.ref(r.link))}}),i.generate=function(n,r,t,l){let s=t.mainstay.links.get(n);if(s)return s._generate(r,t,l).schema;const o=n.$_terms.link[0].ref,{perspective:u,path:d}=i.perspective(o,t);i.assert(u,"which is outside of schema boundaries",o,n,t,l);try{s=d.length?u.$_reach(d):u}catch{i.assert(!1,"to non-existing schema",o,n,t,l)}return i.assert(s.type!=="link","which is another link",o,n,t,l),n._flags.relative||t.mainstay.links.set(n,s),s._generate(r,t,l).schema},i.perspective=function(n,r){if(n.type==="local"){for(const{schema:t,key:l}of r.schemas){if((t._flags.id||l)===n.path[0])return{perspective:t,path:n.path.slice(1)};if(t.$_terms.shared){for(const s of t.$_terms.shared)if(s._flags.id===n.path[0])return{perspective:s,path:n.path.slice(1)}}}return{perspective:null,path:null}}return n.ancestor==="root"?{perspective:r.schemas[r.schemas.length-1].schema,path:n.path}:{perspective:r.schemas[n.ancestor]&&r.schemas[n.ancestor].schema,path:n.path}},i.assert=function(n,r,t,l,s,o){n||a(!1,`"${e.label(l._flags,s,o)}" contains link reference "${t.display}" ${r}`)}},3832:(x,w,m)=>{const a=m(375),h=m(8068),y=m(8160),c={numberRx:/^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,precisionRx:/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,exponentialPartRegex:/[eE][+-]?\d+$/,leadingSignAndZerosRegex:/^[+-]?(0*)?/,dotRegex:/\./,trailingZerosRegex:/0+$/,decimalPlaces(e){const i=e.toString(),n=i.indexOf("."),r=i.indexOf("e");return(n<0?0:(r<0?i.length:r)-n-1)+(r<0?0:Math.max(0,-parseInt(i.slice(r+1))))}};x.exports=h.extend({type:"number",flags:{unsafe:{default:!1}},coerce:{from:"string",method(e,{schema:i,error:n}){if(!e.match(c.numberRx))return;e=e.trim();const r={value:parseFloat(e)};if(r.value===0&&(r.value=0),!i._flags.unsafe)if(e.match(/e/i)){if(c.extractSignificantDigits(e)!==c.extractSignificantDigits(String(r.value)))return r.errors=n("number.unsafe"),r}else{const t=r.value.toString();if(t.match(/e/i))return r;if(t!==c.normalizeDecimal(e))return r.errors=n("number.unsafe"),r}return r}},validate(e,{schema:i,error:n,prefs:r}){if(e===1/0||e===-1/0)return{value:e,errors:n("number.infinity")};if(!y.isNumber(e))return{value:e,errors:n("number.base")};const t={value:e};if(r.convert){const l=i.$_getRule("precision");if(l){const s=Math.pow(10,l.args.limit);t.value=Math.round(t.value*s)/s}}return t.value===0&&(t.value=0),!i._flags.unsafe&&(e>Number.MAX_SAFE_INTEGER||e<Number.MIN_SAFE_INTEGER)&&(t.errors=n("number.unsafe")),t},rules:{compare:{method:!1,validate:(e,i,{limit:n},{name:r,operator:t,args:l})=>y.compare(e,n,t)?e:i.error("number."+r,{limit:l.limit,value:e}),args:[{name:"limit",ref:!0,assert:y.isNumber,message:"must be a number"}]},greater:{method(e){return this.$_addRule({name:"greater",method:"compare",args:{limit:e},operator:">"})}},integer:{method(){return this.$_addRule("integer")},validate:(e,i)=>Math.trunc(e)-e==0?e:i.error("number.integer")},less:{method(e){return this.$_addRule({name:"less",method:"compare",args:{limit:e},operator:"<"})}},max:{method(e){return this.$_addRule({name:"max",method:"compare",args:{limit:e},operator:"<="})}},min:{method(e){return this.$_addRule({name:"min",method:"compare",args:{limit:e},operator:">="})}},multiple:{method(e){const i=typeof e=="number"?c.decimalPlaces(e):null,n=Math.pow(10,i);return this.$_addRule({name:"multiple",args:{base:e,baseDecimalPlace:i,pfactor:n}})},validate:(e,i,{base:n,baseDecimalPlace:r,pfactor:t},l)=>c.decimalPlaces(e)>r?i.error("number.multiple",{multiple:l.args.base,value:e}):Math.round(t*e)%Math.round(t*n)==0?e:i.error("number.multiple",{multiple:l.args.base,value:e}),args:[{name:"base",ref:!0,assert:e=>typeof e=="number"&&isFinite(e)&&e>0,message:"must be a positive number"},"baseDecimalPlace","pfactor"],multi:!0},negative:{method(){return this.sign("negative")}},port:{method(){return this.$_addRule("port")},validate:(e,i)=>Number.isSafeInteger(e)&&e>=0&&e<=65535?e:i.error("number.port")},positive:{method(){return this.sign("positive")}},precision:{method(e){return a(Number.isSafeInteger(e),"limit must be an integer"),this.$_addRule({name:"precision",args:{limit:e}})},validate(e,i,{limit:n}){const r=e.toString().match(c.precisionRx);return Math.max((r[1]?r[1].length:0)-(r[2]?parseInt(r[2],10):0),0)<=n?e:i.error("number.precision",{limit:n,value:e})},convert:!0},sign:{method(e){return a(["negative","positive"].includes(e),"Invalid sign",e),this.$_addRule({name:"sign",args:{sign:e}})},validate:(e,i,{sign:n})=>n==="negative"&&e<0||n==="positive"&&e>0?e:i.error(`number.${n}`)},unsafe:{method(e=!0){return a(typeof e=="boolean","enabled must be a boolean"),this.$_setFlag("unsafe",e)}}},cast:{string:{from:e=>typeof e=="number",to:(e,i)=>e.toString()}},messages:{"number.base":"{{#label}} must be a number","number.greater":"{{#label}} must be greater than {{#limit}}","number.infinity":"{{#label}} cannot be infinity","number.integer":"{{#label}} must be an integer","number.less":"{{#label}} must be less than {{#limit}}","number.max":"{{#label}} must be less than or equal to {{#limit}}","number.min":"{{#label}} must be greater than or equal to {{#limit}}","number.multiple":"{{#label}} must be a multiple of {{#multiple}}","number.negative":"{{#label}} must be a negative number","number.port":"{{#label}} must be a valid port","number.positive":"{{#label}} must be a positive number","number.precision":"{{#label}} must have no more than {{#limit}} decimal places","number.unsafe":"{{#label}} must be a safe number"}}),c.extractSignificantDigits=function(e){return e.replace(c.exponentialPartRegex,"").replace(c.dotRegex,"").replace(c.trailingZerosRegex,"").replace(c.leadingSignAndZerosRegex,"")},c.normalizeDecimal=function(e){return(e=e.replace(/^\+/,"").replace(/\.0*$/,"").replace(/^(-?)\.([^\.]*)$/,"$10.$2").replace(/^(-?)0+([0-9])/,"$1$2")).includes(".")&&e.endsWith("0")&&(e=e.replace(/0+$/,"")),e==="-0"?"0":e}},8966:(x,w,m)=>{const a=m(7824);x.exports=a.extend({type:"object",cast:{map:{from:h=>h&&typeof h=="object",to:(h,y)=>new Map(Object.entries(h))}}})},7417:(x,w,m)=>{const a=m(375),h=m(5380),y=m(1745),c=m(9959),e=m(6064),i=m(9926),n=m(5752),r=m(8068),t=m(8160),l={tlds:i instanceof Set&&{tlds:{allow:i,deny:null}},base64Regex:{true:{true:/^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,false:/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/},false:{true:/^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,false:/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/}},dataUriRegex:/^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,hexRegex:{withPrefix:/^0x[0-9a-f]+$/i,withOptionalPrefix:/^(?:0x)?[0-9a-f]+$/i,withoutPrefix:/^[0-9a-f]+$/i},ipRegex:c.regex({cidr:"forbidden"}).regex,isoDurationRegex:/^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,guidBrackets:{"{":"}","[":"]","(":")","":""},guidVersions:{uuidv1:"1",uuidv2:"2",uuidv3:"3",uuidv4:"4",uuidv5:"5",uuidv6:"6",uuidv7:"7",uuidv8:"8"},guidSeparators:new Set([void 0,!0,!1,"-",":"]),normalizationForms:["NFC","NFD","NFKC","NFKD"]};x.exports=r.extend({type:"string",flags:{insensitive:{default:!1},truncate:{default:!1}},terms:{replacements:{init:null}},coerce:{from:"string",method(s,{schema:o,state:u,prefs:d}){const v=o.$_getRule("normalize");v&&(s=s.normalize(v.args.form));const R=o.$_getRule("case");R&&(s=R.args.direction==="upper"?s.toLocaleUpperCase():s.toLocaleLowerCase());const E=o.$_getRule("trim");if(E&&E.args.enabled&&(s=s.trim()),o.$_terms.replacements)for(const g of o.$_terms.replacements)s=s.replace(g.pattern,g.replacement);const f=o.$_getRule("hex");if(f&&f.args.options.byteAligned&&s.length%2!=0&&(s=`0${s}`),o.$_getRule("isoDate")){const g=l.isoDate(s);g&&(s=g)}if(o._flags.truncate){const g=o.$_getRule("max");if(g){let _=g.args.limit;if(t.isResolvable(_)&&(_=_.resolve(s,u,d),!t.limit(_)))return{value:s,errors:o.$_createError("any.ref",_,{ref:g.args.limit,arg:"limit",reason:"must be a positive integer"},u,d)};s=s.slice(0,_)}}return{value:s}}},validate(s,{schema:o,error:u}){if(typeof s!="string")return{value:s,errors:u("string.base")};if(s===""){const d=o.$_getRule("min");return d&&d.args.limit===0?void 0:{value:s,errors:u("string.empty")}}},rules:{alphanum:{method(){return this.$_addRule("alphanum")},validate:(s,o)=>/^[a-zA-Z0-9]+$/.test(s)?s:o.error("string.alphanum")},base64:{method(s={}){return t.assertOptions(s,["paddingRequired","urlSafe"]),s={urlSafe:!1,paddingRequired:!0,...s},a(typeof s.paddingRequired=="boolean","paddingRequired must be boolean"),a(typeof s.urlSafe=="boolean","urlSafe must be boolean"),this.$_addRule({name:"base64",args:{options:s}})},validate:(s,o,{options:u})=>l.base64Regex[u.paddingRequired][u.urlSafe].test(s)?s:o.error("string.base64")},case:{method(s){return a(["lower","upper"].includes(s),"Invalid case:",s),this.$_addRule({name:"case",args:{direction:s}})},validate:(s,o,{direction:u})=>u==="lower"&&s===s.toLocaleLowerCase()||u==="upper"&&s===s.toLocaleUpperCase()?s:o.error(`string.${u}case`),convert:!0},creditCard:{method(){return this.$_addRule("creditCard")},validate(s,o){let u=s.length,d=0,v=1;for(;u--;){const R=s.charAt(u)*v;d+=R-9*(R>9),v^=3}return d>0&&d%10==0?s:o.error("string.creditCard")}},dataUri:{method(s={}){return t.assertOptions(s,["paddingRequired"]),s={paddingRequired:!0,...s},a(typeof s.paddingRequired=="boolean","paddingRequired must be boolean"),this.$_addRule({name:"dataUri",args:{options:s}})},validate(s,o,{options:u}){const d=s.match(l.dataUriRegex);return d&&(!d[2]||d[2]!=="base64"||l.base64Regex[u.paddingRequired].false.test(d[3]))?s:o.error("string.dataUri")}},domain:{method(s){s&&t.assertOptions(s,["allowFullyQualified","allowUnicode","maxDomainSegments","minDomainSegments","tlds"]);const o=l.addressOptions(s);return this.$_addRule({name:"domain",args:{options:s},address:o})},validate:(s,o,u,{address:d})=>h.isValid(s,d)?s:o.error("string.domain")},email:{method(s={}){t.assertOptions(s,["allowFullyQualified","allowUnicode","ignoreLength","maxDomainSegments","minDomainSegments","multiple","separator","tlds"]),a(s.multiple===void 0||typeof s.multiple=="boolean","multiple option must be an boolean");const o=l.addressOptions(s),u=new RegExp(`\\s*[${s.separator?e(s.separator):","}]\\s*`);return this.$_addRule({name:"email",args:{options:s},regex:u,address:o})},validate(s,o,{options:u},{regex:d,address:v}){const R=u.multiple?s.split(d):[s],E=[];for(const f of R)y.isValid(f,v)||E.push(f);return E.length?o.error("string.email",{value:s,invalids:E}):s}},guid:{alias:"uuid",method(s={}){t.assertOptions(s,["version","separator"]);let o="";if(s.version){const v=[].concat(s.version);a(v.length>=1,"version must have at least 1 valid version specified");const R=new Set;for(let E=0;E<v.length;++E){const f=v[E];a(typeof f=="string","version at position "+E+" must be a string");const g=l.guidVersions[f.toLowerCase()];a(g,"version at position "+E+" must be one of "+Object.keys(l.guidVersions).join(", ")),a(!R.has(g),"version at position "+E+" must not be a duplicate"),o+=g,R.add(g)}}a(l.guidSeparators.has(s.separator),'separator must be one of true, false, "-", or ":"');const u=s.separator===void 0?"[:-]?":s.separator===!0?"[:-]":s.separator===!1?"[]?":`\\${s.separator}`,d=new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}(${u})[0-9A-F]{4}\\2?[${o||"0-9A-F"}][0-9A-F]{3}\\2?[${o?"89AB":"0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`,"i");return this.$_addRule({name:"guid",args:{options:s},regex:d})},validate(s,o,u,{regex:d}){const v=d.exec(s);return v?l.guidBrackets[v[1]]!==v[v.length-1]?o.error("string.guid"):s:o.error("string.guid")}},hex:{method(s={}){return t.assertOptions(s,["byteAligned","prefix"]),s={byteAligned:!1,prefix:!1,...s},a(typeof s.byteAligned=="boolean","byteAligned must be boolean"),a(typeof s.prefix=="boolean"||s.prefix==="optional",'prefix must be boolean or "optional"'),this.$_addRule({name:"hex",args:{options:s}})},validate:(s,o,{options:u})=>(u.prefix==="optional"?l.hexRegex.withOptionalPrefix:u.prefix===!0?l.hexRegex.withPrefix:l.hexRegex.withoutPrefix).test(s)?u.byteAligned&&s.length%2!=0?o.error("string.hexAlign"):s:o.error("string.hex")},hostname:{method(){return this.$_addRule("hostname")},validate:(s,o)=>h.isValid(s,{minDomainSegments:1})||l.ipRegex.test(s)?s:o.error("string.hostname")},insensitive:{method(){return this.$_setFlag("insensitive",!0)}},ip:{method(s={}){t.assertOptions(s,["cidr","version"]);const{cidr:o,versions:u,regex:d}=c.regex(s),v=s.version?u:void 0;return this.$_addRule({name:"ip",args:{options:{cidr:o,version:v}},regex:d})},validate:(s,o,{options:u},{regex:d})=>d.test(s)?s:u.version?o.error("string.ipVersion",{value:s,cidr:u.cidr,version:u.version}):o.error("string.ip",{value:s,cidr:u.cidr})},isoDate:{method(){return this.$_addRule("isoDate")},validate:(s,{error:o})=>l.isoDate(s)?s:o("string.isoDate")},isoDuration:{method(){return this.$_addRule("isoDuration")},validate:(s,o)=>l.isoDurationRegex.test(s)?s:o.error("string.isoDuration")},length:{method(s,o){return l.length(this,"length",s,"=",o)},validate(s,o,{limit:u,encoding:d},{name:v,operator:R,args:E}){const f=!d&&s.length;return t.compare(f,u,R)?s:o.error("string."+v,{limit:E.limit,value:s,encoding:d})},args:[{name:"limit",ref:!0,assert:t.limit,message:"must be a positive integer"},"encoding"]},lowercase:{method(){return this.case("lower")}},max:{method(s,o){return l.length(this,"max",s,"<=",o)},args:["limit","encoding"]},min:{method(s,o){return l.length(this,"min",s,">=",o)},args:["limit","encoding"]},normalize:{method(s="NFC"){return a(l.normalizationForms.includes(s),"normalization form must be one of "+l.normalizationForms.join(", ")),this.$_addRule({name:"normalize",args:{form:s}})},validate:(s,{error:o},{form:u})=>s===s.normalize(u)?s:o("string.normalize",{value:s,form:u}),convert:!0},pattern:{alias:"regex",method(s,o={}){a(s instanceof RegExp,"regex must be a RegExp"),a(!s.flags.includes("g")&&!s.flags.includes("y"),"regex should not use global or sticky mode"),typeof o=="string"&&(o={name:o}),t.assertOptions(o,["invert","name"]);const u=["string.pattern",o.invert?".invert":"",o.name?".name":".base"].join("");return this.$_addRule({name:"pattern",args:{regex:s,options:o},errorCode:u})},validate:(s,o,{regex:u,options:d},{errorCode:v})=>u.test(s)^d.invert?s:o.error(v,{name:d.name,regex:u,value:s}),args:["regex","options"],multi:!0},replace:{method(s,o){typeof s=="string"&&(s=new RegExp(e(s),"g")),a(s instanceof RegExp,"pattern must be a RegExp"),a(typeof o=="string","replacement must be a String");const u=this.clone();return u.$_terms.replacements||(u.$_terms.replacements=[]),u.$_terms.replacements.push({pattern:s,replacement:o}),u}},token:{method(){return this.$_addRule("token")},validate:(s,o)=>/^\w+$/.test(s)?s:o.error("string.token")},trim:{method(s=!0){return a(typeof s=="boolean","enabled must be a boolean"),this.$_addRule({name:"trim",args:{enabled:s}})},validate:(s,o,{enabled:u})=>u&&s!==s.trim()?o.error("string.trim"):s,convert:!0},truncate:{method(s=!0){return a(typeof s=="boolean","enabled must be a boolean"),this.$_setFlag("truncate",s)}},uppercase:{method(){return this.case("upper")}},uri:{method(s={}){t.assertOptions(s,["allowRelative","allowQuerySquareBrackets","domain","relativeOnly","scheme","encodeUri"]),s.domain&&t.assertOptions(s.domain,["allowFullyQualified","allowUnicode","maxDomainSegments","minDomainSegments","tlds"]);const{regex:o,scheme:u}=n.regex(s),d=s.domain?l.addressOptions(s.domain):null;return this.$_addRule({name:"uri",args:{options:s},regex:o,domain:d,scheme:u})},validate(s,o,{options:u},{regex:d,domain:v,scheme:R}){if(["http:/","https:/"].includes(s))return o.error("string.uri");let E=d.exec(s);if(!E&&o.prefs.convert&&u.encodeUri){const f=encodeURI(s);E=d.exec(f),E&&(s=f)}if(E){const f=E[1]||E[2];return!v||u.allowRelative&&!f||h.isValid(f,v)?s:o.error("string.domain",{value:f})}return u.relativeOnly?o.error("string.uriRelativeOnly"):u.scheme?o.error("string.uriCustomScheme",{scheme:R,value:s}):o.error("string.uri")}}},manifest:{build(s,o){if(o.replacements)for(const{pattern:u,replacement:d}of o.replacements)s=s.replace(u,d);return s}},messages:{"string.alphanum":"{{#label}} must only contain alpha-numeric characters","string.base":"{{#label}} must be a string","string.base64":"{{#label}} must be a valid base64 string","string.creditCard":"{{#label}} must be a credit card","string.dataUri":"{{#label}} must be a valid dataUri string","string.domain":"{{#label}} must contain a valid domain name","string.email":"{{#label}} must be a valid email","string.empty":"{{#label}} is not allowed to be empty","string.guid":"{{#label}} must be a valid GUID","string.hex":"{{#label}} must only contain hexadecimal characters","string.hexAlign":"{{#label}} hex decoded representation must be byte aligned","string.hostname":"{{#label}} must be a valid hostname","string.ip":"{{#label}} must be a valid ip address with a {{#cidr}} CIDR","string.ipVersion":"{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR","string.isoDate":"{{#label}} must be in iso format","string.isoDuration":"{{#label}} must be a valid ISO 8601 duration","string.length":"{{#label}} length must be {{#limit}} characters long","string.lowercase":"{{#label}} must only contain lowercase characters","string.max":"{{#label}} length must be less than or equal to {{#limit}} characters long","string.min":"{{#label}} length must be at least {{#limit}} characters long","string.normalize":"{{#label}} must be unicode normalized in the {{#form}} form","string.token":"{{#label}} must only contain alpha-numeric and underscore characters","string.pattern.base":"{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}","string.pattern.name":"{{#label}} with value {:[.]} fails to match the {{#name}} pattern","string.pattern.invert.base":"{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}","string.pattern.invert.name":"{{#label}} with value {:[.]} matches the inverted {{#name}} pattern","string.trim":"{{#label}} must not have leading or trailing whitespace","string.uri":"{{#label}} must be a valid uri","string.uriCustomScheme":"{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern","string.uriRelativeOnly":"{{#label}} must be a valid relative uri","string.uppercase":"{{#label}} must only contain uppercase characters"}}),l.addressOptions=function(s){if(!s)return l.tlds||s;if(a(s.minDomainSegments===void 0||Number.isSafeInteger(s.minDomainSegments)&&s.minDomainSegments>0,"minDomainSegments must be a positive integer"),a(s.maxDomainSegments===void 0||Number.isSafeInteger(s.maxDomainSegments)&&s.maxDomainSegments>0,"maxDomainSegments must be a positive integer"),s.tlds===!1)return s;if(s.tlds===!0||s.tlds===void 0)return a(l.tlds,"Built-in TLD list disabled"),Object.assign({},s,l.tlds);a(typeof s.tlds=="object","tlds must be true, false, or an object");const o=s.tlds.deny;if(o)return Array.isArray(o)&&(s=Object.assign({},s,{tlds:{deny:new Set(o)}})),a(s.tlds.deny instanceof Set,"tlds.deny must be an array, Set, or boolean"),a(!s.tlds.allow,"Cannot specify both tlds.allow and tlds.deny lists"),l.validateTlds(s.tlds.deny,"tlds.deny"),s;const u=s.tlds.allow;return u?u===!0?(a(l.tlds,"Built-in TLD list disabled"),Object.assign({},s,l.tlds)):(Array.isArray(u)&&(s=Object.assign({},s,{tlds:{allow:new Set(u)}})),a(s.tlds.allow instanceof Set,"tlds.allow must be an array, Set, or boolean"),l.validateTlds(s.tlds.allow,"tlds.allow"),s):s},l.validateTlds=function(s,o){for(const u of s)a(h.isValid(u,{minDomainSegments:1,maxDomainSegments:1}),`${o} must contain valid top level domain names`)},l.isoDate=function(s){if(!t.isIsoDate(s))return null;/.*T.*[+-]\d\d$/.test(s)&&(s+="00");const o=new Date(s);return isNaN(o.getTime())?null:o.toISOString()},l.length=function(s,o,u,d,v){return a(!v||!1,"Invalid encoding:",v),s.$_addRule({name:o,method:"length",args:{limit:u,encoding:v},operator:d})}},8826:(x,w,m)=>{const a=m(375),h=m(8068),y={};y.Map=class extends Map{slice(){return new y.Map(this)}},x.exports=h.extend({type:"symbol",terms:{map:{init:new y.Map}},coerce:{method(c,{schema:e,error:i}){const n=e.$_terms.map.get(c);return n&&(c=n),e._flags.only&&typeof c!="symbol"?{value:c,errors:i("symbol.map",{map:e.$_terms.map})}:{value:c}}},validate(c,{error:e}){if(typeof c!="symbol")return{value:c,errors:e("symbol.base")}},rules:{map:{method(c){c&&!c[Symbol.iterator]&&typeof c=="object"&&(c=Object.entries(c)),a(c&&c[Symbol.iterator],"Iterable must be an iterable or object");const e=this.clone(),i=[];for(const n of c){a(n&&n[Symbol.iterator],"Entry must be an iterable");const[r,t]=n;a(typeof r!="object"&&typeof r!="function"&&typeof r!="symbol","Key must not be of type object, function, or Symbol"),a(typeof t=="symbol","Value must be a Symbol"),e.$_terms.map.set(r,t),i.push(t)}return e.valid(...i)}}},manifest:{build:(c,e)=>(e.map&&(c=c.map(e.map)),c)},messages:{"symbol.base":"{{#label}} must be a symbol","symbol.map":"{{#label}} must be one of {{#map}}"}})},8863:(x,w,m)=>{const a=m(375),h=m(8571),y=m(738),c=m(9621),e=m(8160),i=m(6354),n=m(493),r={result:Symbol("result")};w.entry=function(t,l,s){let o=e.defaults;s&&(a(s.warnings===void 0,"Cannot override warnings preference in synchronous validation"),a(s.artifacts===void 0,"Cannot override artifacts preference in synchronous validation"),o=e.preferences(e.defaults,s));const u=r.entry(t,l,o);a(!u.mainstay.externals.length,"Schema with external rules must use validateAsync()");const d={value:u.value};return u.error&&(d.error=u.error),u.mainstay.warnings.length&&(d.warning=i.details(u.mainstay.warnings)),u.mainstay.debug&&(d.debug=u.mainstay.debug),u.mainstay.artifacts&&(d.artifacts=u.mainstay.artifacts),d},w.entryAsync=async function(t,l,s){let o=e.defaults;s&&(o=e.preferences(e.defaults,s));const u=r.entry(t,l,o),d=u.mainstay;if(u.error)throw d.debug&&(u.error.debug=d.debug),u.error;if(d.externals.length){let R=u.value;const E=[];for(const f of d.externals){const g=f.state.path,_=f.schema.type==="link"?d.links.get(f.schema):null;let S,I,k=R;const j=g.length?[R]:[],O=g.length?c(t,g):t;if(g.length){S=g[g.length-1];let L=R;for(const N of g.slice(0,-1))L=L[N],j.unshift(L);I=j[0],k=I[S]}try{const L=(D,C)=>(_||f.schema).$_createError(D,k,C,f.state,o),N=await f.method(k,{schema:f.schema,linked:_,state:f.state,prefs:s,original:O,error:L,errorsArray:r.errorsArray,warn:(D,C)=>d.warnings.push((_||f.schema).$_createError(D,k,C,f.state,o)),message:(D,C)=>(_||f.schema).$_createError("external",k,C,f.state,o,{messages:D})});if(N===void 0||N===k)continue;if(N instanceof i.Report){if(d.tracer.log(f.schema,f.state,"rule","external","error"),E.push(N),o.abortEarly)break;continue}if(Array.isArray(N)&&N[e.symbols.errors]){if(d.tracer.log(f.schema,f.state,"rule","external","error"),E.push(...N),o.abortEarly)break;continue}I?(d.tracer.value(f.state,"rule",k,N,"external"),I[S]=N):(d.tracer.value(f.state,"rule",R,N,"external"),R=N)}catch(L){throw o.errors.label&&(L.message+=` (${f.label})`),L}}if(u.value=R,E.length)throw u.error=i.process(E,t,o),d.debug&&(u.error.debug=d.debug),u.error}if(!o.warnings&&!o.debug&&!o.artifacts)return u.value;const v={value:u.value};return d.warnings.length&&(v.warning=i.details(d.warnings)),d.debug&&(v.debug=d.debug),d.artifacts&&(v.artifacts=d.artifacts),v},r.Mainstay=class{constructor(t,l,s){this.externals=[],this.warnings=[],this.tracer=t,this.debug=l,this.links=s,this.shadow=null,this.artifacts=null,this._snapshots=[]}snapshot(){this._snapshots.push({externals:this.externals.slice(),warnings:this.warnings.slice()})}restore(){const t=this._snapshots.pop();this.externals=t.externals,this.warnings=t.warnings}commit(){this._snapshots.pop()}},r.entry=function(t,l,s){const{tracer:o,cleanup:u}=r.tracer(l,s),d=s.debug?[]:null,v=l._ids._schemaChain?new Map:null,R=new r.Mainstay(o,d,v),E=l._ids._schemaChain?[{schema:l}]:null,f=new n([],[],{mainstay:R,schemas:E}),g=w.validate(t,l,f,s);u&&l.$_root.untrace();const _=i.process(g.errors,t,s);return{value:g.value,error:_,mainstay:R}},r.tracer=function(t,l){return t.$_root._tracer?{tracer:t.$_root._tracer._register(t)}:l.debug?(a(t.$_root.trace,"Debug mode not supported"),{tracer:t.$_root.trace()._register(t),cleanup:!0}):{tracer:r.ignore}},w.validate=function(t,l,s,o,u={}){if(l.$_terms.whens&&(l=l._generate(t,s,o).schema),l._preferences&&(o=r.prefs(l,o)),l._cache&&o.cache){const _=l._cache.get(t);if(s.mainstay.tracer.debug(s,"validate","cached",!!_),_)return _}const d=(_,S,I)=>l.$_createError(_,t,S,I||s,o),v={original:t,prefs:o,schema:l,state:s,error:d,errorsArray:r.errorsArray,warn:(_,S,I)=>s.mainstay.warnings.push(d(_,S,I)),message:(_,S)=>l.$_createError("custom",t,S,s,o,{messages:_})};s.mainstay.tracer.entry(l,s);const R=l._definition;if(R.prepare&&t!==void 0&&o.convert){const _=R.prepare(t,v);if(_){if(s.mainstay.tracer.value(s,"prepare",t,_.value),_.errors)return r.finalize(_.value,[].concat(_.errors),v);t=_.value}}if(R.coerce&&t!==void 0&&o.convert&&(!R.coerce.from||R.coerce.from.includes(typeof t))){const _=R.coerce.method(t,v);if(_){if(s.mainstay.tracer.value(s,"coerced",t,_.value),_.errors)return r.finalize(_.value,[].concat(_.errors),v);t=_.value}}const E=l._flags.empty;E&&E.$_match(r.trim(t,l),s.nest(E),e.defaults)&&(s.mainstay.tracer.value(s,"empty",t,void 0),t=void 0);const f=u.presence||l._flags.presence||(l._flags._endedSwitch?null:o.presence);if(t===void 0){if(f==="forbidden")return r.finalize(t,null,v);if(f==="required")return r.finalize(t,[l.$_createError("any.required",t,null,s,o)],v);if(f==="optional"){if(l._flags.default!==e.symbols.deepDefault)return r.finalize(t,null,v);s.mainstay.tracer.value(s,"default",t,{}),t={}}}else if(f==="forbidden")return r.finalize(t,[l.$_createError("any.unknown",t,null,s,o)],v);const g=[];if(l._valids){const _=l._valids.get(t,s,o,l._flags.insensitive);if(_)return o.convert&&(s.mainstay.tracer.value(s,"valids",t,_.value),t=_.value),s.mainstay.tracer.filter(l,s,"valid",_),r.finalize(t,null,v);if(l._flags.only){const S=l.$_createError("any.only",t,{valids:l._valids.values({display:!0})},s,o);if(o.abortEarly)return r.finalize(t,[S],v);g.push(S)}}if(l._invalids){const _=l._invalids.get(t,s,o,l._flags.insensitive);if(_){s.mainstay.tracer.filter(l,s,"invalid",_);const S=l.$_createError("any.invalid",t,{invalids:l._invalids.values({display:!0})},s,o);if(o.abortEarly)return r.finalize(t,[S],v);g.push(S)}}if(R.validate){const _=R.validate(t,v);if(_&&(s.mainstay.tracer.value(s,"base",t,_.value),t=_.value,_.errors)){if(!Array.isArray(_.errors))return g.push(_.errors),r.finalize(t,g,v);if(_.errors.length)return g.push(..._.errors),r.finalize(t,g,v)}}return l._rules.length?r.rules(t,g,v):r.finalize(t,g,v)},r.rules=function(t,l,s){const{schema:o,state:u,prefs:d}=s;for(const v of o._rules){const R=o._definition.rules[v.method];if(R.convert&&d.convert){u.mainstay.tracer.log(o,u,"rule",v.name,"full");continue}let E,f=v.args;if(v._resolve.length){f=Object.assign({},f);for(const _ of v._resolve){const S=R.argsByName.get(_),I=f[_].resolve(t,u,d),k=S.normalize?S.normalize(I):I,j=e.validateArg(k,null,S);if(j){E=o.$_createError("any.ref",I,{arg:_,ref:f[_],reason:j},u,d);break}f[_]=k}}E=E||R.validate(t,s,f,v);const g=r.rule(E,v);if(g.errors){if(u.mainstay.tracer.log(o,u,"rule",v.name,"error"),v.warn){u.mainstay.warnings.push(...g.errors);continue}if(d.abortEarly)return r.finalize(t,g.errors,s);l.push(...g.errors)}else u.mainstay.tracer.log(o,u,"rule",v.name,"pass"),u.mainstay.tracer.value(u,"rule",t,g.value,v.name),t=g.value}return r.finalize(t,l,s)},r.rule=function(t,l){return t instanceof i.Report?(r.error(t,l),{errors:[t],value:null}):Array.isArray(t)&&t[e.symbols.errors]?(t.forEach(s=>r.error(s,l)),{errors:t,value:null}):{errors:null,value:t}},r.error=function(t,l){return l.message&&t._setTemplate(l.message),t},r.finalize=function(t,l,s){l=l||[];const{schema:o,state:u,prefs:d}=s;if(l.length){const R=r.default("failover",void 0,l,s);R!==void 0&&(u.mainstay.tracer.value(u,"failover",t,R),t=R,l=[])}if(l.length&&o._flags.error)if(typeof o._flags.error=="function"){l=o._flags.error(l),Array.isArray(l)||(l=[l]);for(const R of l)a(R instanceof Error||R instanceof i.Report,"error() must return an Error object")}else l=[o._flags.error];if(t===void 0){const R=r.default("default",t,l,s);u.mainstay.tracer.value(u,"default",t,R),t=R}if(o._flags.cast&&t!==void 0){const R=o._definition.cast[o._flags.cast];if(R.from(t)){const E=R.to(t,s);u.mainstay.tracer.value(u,"cast",t,E,o._flags.cast),t=E}}if(o.$_terms.externals&&d.externals&&d._externals!==!1)for(const{method:R}of o.$_terms.externals)u.mainstay.externals.push({method:R,schema:o,state:u,label:i.label(o._flags,u,d)});const v={value:t,errors:l.length?l:null};return o._flags.result&&(v.value=o._flags.result==="strip"?void 0:s.original,u.mainstay.tracer.value(u,o._flags.result,t,v.value),u.shadow(t,o._flags.result)),o._cache&&d.cache!==!1&&!o._refs.length&&o._cache.set(s.original,v),t===void 0||v.errors||o._flags.artifact===void 0||(u.mainstay.artifacts=u.mainstay.artifacts||new Map,u.mainstay.artifacts.has(o._flags.artifact)||u.mainstay.artifacts.set(o._flags.artifact,[]),u.mainstay.artifacts.get(o._flags.artifact).push(u.path)),v},r.prefs=function(t,l){const s=l===e.defaults;return s&&t._preferences[e.symbols.prefs]?t._preferences[e.symbols.prefs]:(l=e.preferences(l,t._preferences),s&&(t._preferences[e.symbols.prefs]=l),l)},r.default=function(t,l,s,o){const{schema:u,state:d,prefs:v}=o,R=u._flags[t];if(v.noDefaults||R===void 0)return l;if(d.mainstay.tracer.log(u,d,"rule",t,"full"),!R)return R;if(typeof R=="function"){const E=R.length?[h(d.ancestors[0]),o]:[];try{return R(...E)}catch(f){return void s.push(u.$_createError(`any.${t}`,null,{error:f},d,v))}}return typeof R!="object"?R:R[e.symbols.literal]?R.literal:e.isResolvable(R)?R.resolve(l,d,v):h(R)},r.trim=function(t,l){if(typeof t!="string")return t;const s=l.$_getRule("trim");return s&&s.args.enabled?t.trim():t},r.ignore={active:!1,debug:y,entry:y,filter:y,log:y,resolve:y,value:y},r.errorsArray=function(){const t=[];return t[e.symbols.errors]=!0,t}},2036:(x,w,m)=>{const a=m(375),h=m(9474),y=m(8160),c={};x.exports=c.Values=class{constructor(e,i){this._values=new Set(e),this._refs=new Set(i),this._lowercase=c.lowercases(e),this._override=!1}get length(){return this._values.size+this._refs.size}add(e,i){y.isResolvable(e)?this._refs.has(e)||(this._refs.add(e),i&&i.register(e)):this.has(e,null,null,!1)||(this._values.add(e),typeof e=="string"&&this._lowercase.set(e.toLowerCase(),e))}static merge(e,i,n){if(e=e||new c.Values,i){if(i._override)return i.clone();for(const r of[...i._values,...i._refs])e.add(r)}if(n)for(const r of[...n._values,...n._refs])e.remove(r);return e.length?e:null}remove(e){y.isResolvable(e)?this._refs.delete(e):(this._values.delete(e),typeof e=="string"&&this._lowercase.delete(e.toLowerCase()))}has(e,i,n,r){return!!this.get(e,i,n,r)}get(e,i,n,r){if(!this.length)return!1;if(this._values.has(e))return{value:e};if(typeof e=="string"&&e&&r){const t=this._lowercase.get(e.toLowerCase());if(t)return{value:t}}if(!this._refs.size&&typeof e!="object")return!1;if(typeof e=="object"){for(const t of this._values)if(h(t,e))return{value:t}}if(i)for(const t of this._refs){const l=t.resolve(e,i,n,null,{in:!0});if(l===void 0)continue;const s=t.in&&typeof l=="object"?Array.isArray(l)?l:Object.keys(l):[l];for(const o of s)if(typeof o==typeof e){if(r&&e&&typeof e=="string"){if(o.toLowerCase()===e.toLowerCase())return{value:o,ref:t}}else if(h(o,e))return{value:o,ref:t}}}return!1}override(){this._override=!0}values(e){if(e&&e.display){const i=[];for(const n of[...this._values,...this._refs])n!==void 0&&i.push(n);return i}return Array.from([...this._values,...this._refs])}clone(){const e=new c.Values(this._values,this._refs);return e._override=this._override,e}concat(e){a(!e._override,"Cannot concat override set of values");const i=new c.Values([...this._values,...e._values],[...this._refs,...e._refs]);return i._override=this._override,i}describe(){const e=[];this._override&&e.push({override:!0});for(const i of this._values.values())e.push(i&&typeof i=="object"?{value:i}:i);for(const i of this._refs.values())e.push(i.describe());return e}},c.Values.prototype[y.symbols.values]=!0,c.Values.prototype.slice=c.Values.prototype.clone,c.lowercases=function(e){const i=new Map;if(e)for(const n of e)typeof n=="string"&&i.set(n.toLowerCase(),n);return i}},978:(x,w,m)=>{const a=m(375),h=m(8571),y=m(1687),c=m(9621),e={};x.exports=function(i,n,r={}){if(a(i&&typeof i=="object","Invalid defaults value: must be an object"),a(!n||n===!0||typeof n=="object","Invalid source value: must be true, falsy or an object"),a(typeof r=="object","Invalid options: must be an object"),!n)return null;if(r.shallow)return e.applyToDefaultsWithShallow(i,n,r);const t=h(i);if(n===!0)return t;const l=r.nullOverride!==void 0&&r.nullOverride;return y(t,n,{nullOverride:l,mergeArrays:!1})},e.applyToDefaultsWithShallow=function(i,n,r){const t=r.shallow;a(Array.isArray(t),"Invalid keys");const l=new Map,s=n===!0?null:new Set;for(let d of t){d=Array.isArray(d)?d:d.split(".");const v=c(i,d);v&&typeof v=="object"?l.set(v,s&&c(n,d)||v):s&&s.add(d)}const o=h(i,{},l);if(!s)return o;for(const d of s)e.reachCopy(o,n,d);const u=r.nullOverride!==void 0&&r.nullOverride;return y(o,n,{nullOverride:u,mergeArrays:!1})},e.reachCopy=function(i,n,r){for(const s of r){if(!(s in n))return;const o=n[s];if(typeof o!="object"||o===null)return;n=o}const t=n;let l=i;for(let s=0;s<r.length-1;++s){const o=r[s];typeof l[o]!="object"&&(l[o]={}),l=l[o]}l[r[r.length-1]]=t}},375:(x,w,m)=>{const a=m(7916);x.exports=function(h,...y){if(!h)throw y.length===1&&y[0]instanceof Error?y[0]:new a(y)}},8571:(x,w,m)=>{const a=m(9621),h=m(4277),y=m(7043),c={needsProtoHack:new Set([h.set,h.map,h.weakSet,h.weakMap])};x.exports=c.clone=function(e,i={},n=null){if(typeof e!="object"||e===null)return e;let r=c.clone,t=n;if(i.shallow){if(i.shallow!==!0)return c.cloneWithShallow(e,i);r=u=>u}else if(t){const u=t.get(e);if(u)return u}else t=new Map;const l=h.getInternalProto(e);if(l===h.buffer)return!1;if(l===h.date)return new Date(e.getTime());if(l===h.regex)return new RegExp(e);const s=c.base(e,l,i);if(s===e)return e;if(t&&t.set(e,s),l===h.set)for(const u of e)s.add(r(u,i,t));else if(l===h.map)for(const[u,d]of e)s.set(u,r(d,i,t));const o=y.keys(e,i);for(const u of o){if(u==="__proto__")continue;if(l===h.array&&u==="length"){s.length=e.length;continue}const d=Object.getOwnPropertyDescriptor(e,u);d?d.get||d.set?Object.defineProperty(s,u,d):d.enumerable?s[u]=r(e[u],i,t):Object.defineProperty(s,u,{enumerable:!1,writable:!0,configurable:!0,value:r(e[u],i,t)}):Object.defineProperty(s,u,{enumerable:!0,writable:!0,configurable:!0,value:r(e[u],i,t)})}return s},c.cloneWithShallow=function(e,i){const n=i.shallow;(i=Object.assign({},i)).shallow=!1;const r=new Map;for(const t of n){const l=a(e,t);typeof l!="object"&&typeof l!="function"||r.set(l,l)}return c.clone(e,i,r)},c.base=function(e,i,n){if(n.prototype===!1)return c.needsProtoHack.has(i)?new i.constructor:i===h.array?[]:{};const r=Object.getPrototypeOf(e);if(r&&r.isImmutable)return e;if(i===h.array){const t=[];return r!==i&&Object.setPrototypeOf(t,r),t}if(c.needsProtoHack.has(i)){const t=new r.constructor;return r!==i&&Object.setPrototypeOf(t,r),t}return Object.create(r)}},9474:(x,w,m)=>{const a=m(4277),h={mismatched:null};x.exports=function(y,c,e){return e=Object.assign({prototype:!0},e),!!h.isDeepEqual(y,c,e,[])},h.isDeepEqual=function(y,c,e,i){if(y===c)return y!==0||1/y==1/c;const n=typeof y;if(n!==typeof c||y===null||c===null)return!1;if(n==="function"){if(!e.deepFunction||y.toString()!==c.toString())return!1}else if(n!=="object")return y!=y&&c!=c;const r=h.getSharedType(y,c,!!e.prototype);switch(r){case a.buffer:return!1;case a.promise:return y===c;case a.regex:return y.toString()===c.toString();case h.mismatched:return!1}for(let t=i.length-1;t>=0;--t)if(i[t].isSame(y,c))return!0;i.push(new h.SeenEntry(y,c));try{return!!h.isDeepEqualObj(r,y,c,e,i)}finally{i.pop()}},h.getSharedType=function(y,c,e){if(e)return Object.getPrototypeOf(y)!==Object.getPrototypeOf(c)?h.mismatched:a.getInternalProto(y);const i=a.getInternalProto(y);return i!==a.getInternalProto(c)?h.mismatched:i},h.valueOf=function(y){const c=y.valueOf;if(c===void 0)return y;try{return c.call(y)}catch(e){return e}},h.hasOwnEnumerableProperty=function(y,c){return Object.prototype.propertyIsEnumerable.call(y,c)},h.isSetSimpleEqual=function(y,c){for(const e of Set.prototype.values.call(y))if(!Set.prototype.has.call(c,e))return!1;return!0},h.isDeepEqualObj=function(y,c,e,i,n){const{isDeepEqual:r,valueOf:t,hasOwnEnumerableProperty:l}=h,{keys:s,getOwnPropertySymbols:o}=Object;if(y===a.array){if(!i.part){if(c.length!==e.length)return!1;for(let E=0;E<c.length;++E)if(!r(c[E],e[E],i,n))return!1;return!0}for(const E of c)for(const f of e)if(r(E,f,i,n))return!0}else if(y===a.set){if(c.size!==e.size)return!1;if(!h.isSetSimpleEqual(c,e)){const E=new Set(Set.prototype.values.call(e));for(const f of Set.prototype.values.call(c)){if(E.delete(f))continue;let g=!1;for(const _ of E)if(r(f,_,i,n)){E.delete(_),g=!0;break}if(!g)return!1}}}else if(y===a.map){if(c.size!==e.size)return!1;for(const[E,f]of Map.prototype.entries.call(c))if(f===void 0&&!Map.prototype.has.call(e,E)||!r(f,Map.prototype.get.call(e,E),i,n))return!1}else if(y===a.error&&(c.name!==e.name||c.message!==e.message))return!1;const u=t(c),d=t(e);if((c!==u||e!==d)&&!r(u,d,i,n))return!1;const v=s(c);if(!i.part&&v.length!==s(e).length&&!i.skip)return!1;let R=0;for(const E of v)if(i.skip&&i.skip.includes(E))e[E]===void 0&&++R;else if(!l(e,E)||!r(c[E],e[E],i,n))return!1;if(!i.part&&v.length-R!==s(e).length)return!1;if(i.symbols!==!1){const E=o(c),f=new Set(o(e));for(const g of E){if(!i.skip||!i.skip.includes(g)){if(l(c,g)){if(!l(e,g)||!r(c[g],e[g],i,n))return!1}else if(l(e,g))return!1}f.delete(g)}for(const g of f)if(l(e,g))return!1}return!0},h.SeenEntry=class{constructor(y,c){this.obj=y,this.ref=c}isSame(y,c){return this.obj===y&&this.ref===c}}},7916:(x,w,m)=>{const a=m(8761);x.exports=class extends Error{constructor(h){super(h.filter(y=>y!=="").map(y=>typeof y=="string"?y:y instanceof Error?y.message:a(y)).join(" ")||"Unknown error"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,w.assert)}}},5277:x=>{const w={};x.exports=function(m){if(!m)return"";let a="";for(let h=0;h<m.length;++h){const y=m.charCodeAt(h);w.isSafe(y)?a+=m[h]:a+=w.escapeHtmlChar(y)}return a},w.escapeHtmlChar=function(m){return w.namedHtml.get(m)||(m>=256?"&#"+m+";":`&#x${m.toString(16).padStart(2,"0")};`)},w.isSafe=function(m){return w.safeCharCodes.has(m)},w.namedHtml=new Map([[38,"&amp;"],[60,"&lt;"],[62,"&gt;"],[34,"&quot;"],[160,"&nbsp;"],[162,"&cent;"],[163,"&pound;"],[164,"&curren;"],[169,"&copy;"],[174,"&reg;"]]),w.safeCharCodes=function(){const m=new Set;for(let a=32;a<123;++a)(a>=97||a>=65&&a<=90||a>=48&&a<=57||a===32||a===46||a===44||a===45||a===58||a===95)&&m.add(a);return m}()},6064:x=>{x.exports=function(w){return w.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g,"\\$&")}},738:x=>{x.exports=function(){}},1687:(x,w,m)=>{const a=m(375),h=m(8571),y=m(7043),c={};x.exports=c.merge=function(e,i,n){if(a(e&&typeof e=="object","Invalid target value: must be an object"),a(i==null||typeof i=="object","Invalid source value: must be null, undefined, or an object"),!i)return e;if(n=Object.assign({nullOverride:!0,mergeArrays:!0},n),Array.isArray(i)){a(Array.isArray(e),"Cannot merge array onto an object"),n.mergeArrays||(e.length=0);for(let t=0;t<i.length;++t)e.push(h(i[t],{symbols:n.symbols}));return e}const r=y.keys(i,n);for(let t=0;t<r.length;++t){const l=r[t];if(l==="__proto__"||!Object.prototype.propertyIsEnumerable.call(i,l))continue;const s=i[l];if(s&&typeof s=="object"){if(e[l]===s)continue;!e[l]||typeof e[l]!="object"||Array.isArray(e[l])!==Array.isArray(s)||s instanceof Date||s instanceof RegExp?e[l]=h(s,{symbols:n.symbols}):c.merge(e[l],s,n)}else(s!=null||n.nullOverride)&&(e[l]=s)}return e}},9621:(x,w,m)=>{const a=m(375),h={};x.exports=function(y,c,e){if(c===!1||c==null)return y;typeof(e=e||{})=="string"&&(e={separator:e});const i=Array.isArray(c);a(!i||!e.separator,"Separator option is not valid for array-based chain");const n=i?c:c.split(e.separator||".");let r=y;for(let t=0;t<n.length;++t){let l=n[t];const s=e.iterables&&h.iterables(r);if(Array.isArray(r)||s==="set"){const o=Number(l);Number.isInteger(o)&&(l=o<0?r.length+o:o)}if(!r||typeof r=="function"&&e.functions===!1||!s&&r[l]===void 0){a(!e.strict||t+1===n.length,"Missing segment",l,"in reach path ",c),a(typeof r=="object"||e.functions===!0||typeof r!="function","Invalid segment",l,"in reach path ",c),r=e.default;break}r=s?s==="set"?[...r][l]:r.get(l):r[l]}return r},h.iterables=function(y){return y instanceof Set?"set":y instanceof Map?"map":void 0}},8761:x=>{x.exports=function(...w){try{return JSON.stringify(...w)}catch(m){return"[Cannot display object: "+m.message+"]"}}},4277:(x,w)=>{const m={};w=x.exports={array:Array.prototype,buffer:!1,date:Date.prototype,error:Error.prototype,generic:Object.prototype,map:Map.prototype,promise:Promise.prototype,regex:RegExp.prototype,set:Set.prototype,weakMap:WeakMap.prototype,weakSet:WeakSet.prototype},m.typeMap=new Map([["[object Error]",w.error],["[object Map]",w.map],["[object Promise]",w.promise],["[object Set]",w.set],["[object WeakMap]",w.weakMap],["[object WeakSet]",w.weakSet]]),w.getInternalProto=function(a){if(Array.isArray(a))return w.array;if(a instanceof Date)return w.date;if(a instanceof RegExp)return w.regex;if(a instanceof Error)return w.error;const h=Object.prototype.toString.call(a);return m.typeMap.get(h)||w.generic}},7043:(x,w)=>{w.keys=function(m,a={}){return a.symbols!==!1?Reflect.ownKeys(m):Object.getOwnPropertyNames(m)}},3652:(x,w,m)=>{const a=m(375),h={};w.Sorter=class{constructor(){this._items=[],this.nodes=[]}add(y,c){const e=[].concat((c=c||{}).before||[]),i=[].concat(c.after||[]),n=c.group||"?",r=c.sort||0;a(!e.includes(n),`Item cannot come before itself: ${n}`),a(!e.includes("?"),"Item cannot come before unassociated items"),a(!i.includes(n),`Item cannot come after itself: ${n}`),a(!i.includes("?"),"Item cannot come after unassociated items"),Array.isArray(y)||(y=[y]);for(const t of y){const l={seq:this._items.length,sort:r,before:e,after:i,group:n,node:t};this._items.push(l)}if(!c.manual){const t=this._sort();a(t,"item",n!=="?"?`added into group ${n}`:"","created a dependencies error")}return this.nodes}merge(y){Array.isArray(y)||(y=[y]);for(const e of y)if(e)for(const i of e._items)this._items.push(Object.assign({},i));this._items.sort(h.mergeSort);for(let e=0;e<this._items.length;++e)this._items[e].seq=e;const c=this._sort();return a(c,"merge created a dependencies error"),this.nodes}sort(){const y=this._sort();return a(y,"sort created a dependencies error"),this.nodes}_sort(){const y={},c=Object.create(null),e=Object.create(null);for(const l of this._items){const s=l.seq,o=l.group;e[o]=e[o]||[],e[o].push(s),y[s]=l.before;for(const u of l.after)c[u]=c[u]||[],c[u].push(s)}for(const l in y){const s=[];for(const o in y[l]){const u=y[l][o];e[u]=e[u]||[],s.push(...e[u])}y[l]=s}for(const l in c)if(e[l])for(const s of e[l])y[s].push(...c[l]);const i={};for(const l in y){const s=y[l];for(const o of s)i[o]=i[o]||[],i[o].push(l)}const n={},r=[];for(let l=0;l<this._items.length;++l){let s=l;if(i[l]){s=null;for(let o=0;o<this._items.length;++o){if(n[o]===!0)continue;i[o]||(i[o]=[]);const u=i[o].length;let d=0;for(let v=0;v<u;++v)n[i[o][v]]&&++d;if(d===u){s=o;break}}}s!==null&&(n[s]=!0,r.push(s))}if(r.length!==this._items.length)return!1;const t={};for(const l of this._items)t[l.seq]=l;this._items=[],this.nodes=[];for(const l of r){const s=t[l];this.nodes.push(s.node),this._items.push(s)}return!0}},h.mergeSort=(y,c)=>y.sort===c.sort?0:y.sort<c.sort?-1:1},5380:(x,w,m)=>{const a=m(443),h=m(2178),y={minDomainSegments:2,nonAsciiRx:/[^\x00-\x7f]/,domainControlRx:/[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/,tldSegmentRx:/^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,domainSegmentRx:/^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,URL:a.URL||URL};w.analyze=function(c,e={}){if(!c)return h.code("DOMAIN_NON_EMPTY_STRING");if(typeof c!="string")throw new Error("Invalid input: domain must be a string");if(c.length>256)return h.code("DOMAIN_TOO_LONG");if(y.nonAsciiRx.test(c)){if(e.allowUnicode===!1)return h.code("DOMAIN_INVALID_UNICODE_CHARS");c=c.normalize("NFC")}if(y.domainControlRx.test(c))return h.code("DOMAIN_INVALID_CHARS");c=y.punycode(c),e.allowFullyQualified&&c[c.length-1]==="."&&(c=c.slice(0,-1));const i=e.minDomainSegments||y.minDomainSegments,n=c.split(".");if(n.length<i)return h.code("DOMAIN_SEGMENTS_COUNT");if(e.maxDomainSegments&&n.length>e.maxDomainSegments)return h.code("DOMAIN_SEGMENTS_COUNT_MAX");const r=e.tlds;if(r){const t=n[n.length-1].toLowerCase();if(r.deny&&r.deny.has(t)||r.allow&&!r.allow.has(t))return h.code("DOMAIN_FORBIDDEN_TLDS")}for(let t=0;t<n.length;++t){const l=n[t];if(!l.length)return h.code("DOMAIN_EMPTY_SEGMENT");if(l.length>63)return h.code("DOMAIN_LONG_SEGMENT");if(t<n.length-1){if(!y.domainSegmentRx.test(l))return h.code("DOMAIN_INVALID_CHARS")}else if(!y.tldSegmentRx.test(l))return h.code("DOMAIN_INVALID_TLDS_CHARS")}return null},w.isValid=function(c,e){return!w.analyze(c,e)},y.punycode=function(c){c.includes("%")&&(c=c.replace(/%/g,"%25"));try{return new y.URL(`http://${c}`).host}catch{return c}}},1745:(x,w,m)=>{const a=m(9848),h=m(5380),y=m(2178),c={nonAsciiRx:/[^\x00-\x7f]/,encoder:new(a.TextEncoder||TextEncoder)};w.analyze=function(e,i){return c.email(e,i)},w.isValid=function(e,i){return!c.email(e,i)},c.email=function(e,i={}){if(typeof e!="string")throw new Error("Invalid input: email must be a string");if(!e)return y.code("EMPTY_STRING");const n=!c.nonAsciiRx.test(e);if(!n){if(i.allowUnicode===!1)return y.code("FORBIDDEN_UNICODE");e=e.normalize("NFC")}const r=e.split("@");if(r.length!==2)return r.length>2?y.code("MULTIPLE_AT_CHAR"):y.code("MISSING_AT_CHAR");const[t,l]=r;if(!t)return y.code("EMPTY_LOCAL");if(!i.ignoreLength){if(e.length>254)return y.code("ADDRESS_TOO_LONG");if(c.encoder.encode(t).length>64)return y.code("LOCAL_TOO_LONG")}return c.local(t,n)||h.analyze(l,i)},c.local=function(e,i){const n=e.split(".");for(const r of n){if(!r.length)return y.code("EMPTY_LOCAL_SEGMENT");if(i){if(!c.atextRx.test(r))return y.code("INVALID_LOCAL_CHARS")}else for(const t of r){if(c.atextRx.test(t))continue;const l=c.binary(t);if(!c.atomRx.test(l))return y.code("INVALID_LOCAL_CHARS")}}},c.binary=function(e){return Array.from(c.encoder.encode(e)).map(i=>String.fromCharCode(i)).join("")},c.atextRx=/^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/,c.atomRx=new RegExp(["(?:[\\xc2-\\xdf][\\x80-\\xbf])","(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})","(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"].join("|"))},2178:(x,w)=>{w.codes={EMPTY_STRING:"Address must be a non-empty string",FORBIDDEN_UNICODE:"Address contains forbidden Unicode characters",MULTIPLE_AT_CHAR:"Address cannot contain more than one @ character",MISSING_AT_CHAR:"Address must contain one @ character",EMPTY_LOCAL:"Address local part cannot be empty",ADDRESS_TOO_LONG:"Address too long",LOCAL_TOO_LONG:"Address local part too long",EMPTY_LOCAL_SEGMENT:"Address local part contains empty dot-separated segment",INVALID_LOCAL_CHARS:"Address local part contains invalid character",DOMAIN_NON_EMPTY_STRING:"Domain must be a non-empty string",DOMAIN_TOO_LONG:"Domain too long",DOMAIN_INVALID_UNICODE_CHARS:"Domain contains forbidden Unicode characters",DOMAIN_INVALID_CHARS:"Domain contains invalid character",DOMAIN_INVALID_TLDS_CHARS:"Domain contains invalid tld character",DOMAIN_SEGMENTS_COUNT:"Domain lacks the minimum required number of segments",DOMAIN_SEGMENTS_COUNT_MAX:"Domain contains too many segments",DOMAIN_FORBIDDEN_TLDS:"Domain uses forbidden TLD",DOMAIN_EMPTY_SEGMENT:"Domain contains empty dot-separated segment",DOMAIN_LONG_SEGMENT:"Domain contains dot-separated segment that is too long"},w.code=function(m){return{code:m,error:w.codes[m]}}},9959:(x,w,m)=>{const a=m(375),h=m(5752);w.regex=function(y={}){a(y.cidr===void 0||typeof y.cidr=="string","options.cidr must be a string");const c=y.cidr?y.cidr.toLowerCase():"optional";a(["required","optional","forbidden"].includes(c),"options.cidr must be one of required, optional, forbidden"),a(y.version===void 0||typeof y.version=="string"||Array.isArray(y.version),"options.version must be a string or an array of string");let e=y.version||["ipv4","ipv6","ipvfuture"];Array.isArray(e)||(e=[e]),a(e.length>=1,"options.version must have at least 1 version specified");for(let r=0;r<e.length;++r)a(typeof e[r]=="string","options.version must only contain strings"),e[r]=e[r].toLowerCase(),a(["ipv4","ipv6","ipvfuture"].includes(e[r]),"options.version contains unknown version "+e[r]+" - must be one of ipv4, ipv6, ipvfuture");e=Array.from(new Set(e));const i=`(?:${e.map(r=>{if(c==="forbidden")return h.ip[r];const t=`\\/${r==="ipv4"?h.ip.v4Cidr:h.ip.v6Cidr}`;return c==="required"?`${h.ip[r]}${t}`:`${h.ip[r]}(?:${t})?`}).join("|")})`,n=new RegExp(`^${i}$`);return{cidr:c,versions:e,regex:n,raw:i}}},5752:(x,w,m)=>{const a=m(375),h=m(6064),y={generate:function(){const c={},e="\\dA-Fa-f",i="["+e+"]",n="\\w-\\.~",r="!\\$&'\\(\\)\\*\\+,;=",t="%"+e,l=n+t+r+":@",s="["+l+"]",o="(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";c.ipv4address="(?:"+o+"\\.){3}"+o;const u=i+"{1,4}",d="(?:"+u+":"+u+"|"+c.ipv4address+")",v="(?:"+u+":){6}"+d,R="::(?:"+u+":){5}"+d,E="(?:"+u+")?::(?:"+u+":){4}"+d,f="(?:(?:"+u+":){0,1}"+u+")?::(?:"+u+":){3}"+d,g="(?:(?:"+u+":){0,2}"+u+")?::(?:"+u+":){2}"+d,_="(?:(?:"+u+":){0,3}"+u+")?::"+u+":"+d,S="(?:(?:"+u+":){0,4}"+u+")?::"+d,I="(?:(?:"+u+":){0,5}"+u+")?::"+u,k="(?:(?:"+u+":){0,6}"+u+")?::";c.ipv4Cidr="(?:\\d|[1-2]\\d|3[0-2])",c.ipv6Cidr="(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])",c.ipv6address="(?:"+v+"|"+R+"|"+E+"|"+f+"|"+g+"|"+_+"|"+S+"|"+I+"|"+k+")",c.ipvFuture="v"+i+"+\\.["+n+r+":]+",c.scheme="[a-zA-Z][a-zA-Z\\d+-\\.]*",c.schemeRegex=new RegExp(c.scheme);const j="["+n+t+r+":]*",O="["+n+t+r+"]{1,255}",L="(?:\\[(?:"+c.ipv6address+"|"+c.ipvFuture+")\\]|"+c.ipv4address+"|"+O+")",N="(?:"+j+"@)?"+L+"(?::\\d*)?",D="(?:"+j+"@)?("+L+")(?::\\d*)?",C=s+"*",T=s+"+",P="(?:\\/"+C+")*",F="\\/(?:"+T+P+")?",U=T+P,z="["+n+t+r+"@]+"+P,q="(?:\\/\\/\\/"+C+P+")";return c.hierPart="(?:(?:\\/\\/"+N+P+")|"+F+"|"+U+"|"+q+")",c.hierPartCapture="(?:(?:\\/\\/"+D+P+")|"+F+"|"+U+")",c.relativeRef="(?:(?:\\/\\/"+N+P+")|"+F+"|"+z+"|)",c.relativeRefCapture="(?:(?:\\/\\/"+D+P+")|"+F+"|"+z+"|)",c.query="["+l+"\\/\\?]*(?=#|$)",c.queryWithSquareBrackets="["+l+"\\[\\]\\/\\?]*(?=#|$)",c.fragment="["+l+"\\/\\?]*",c}};y.rfc3986=y.generate(),w.ip={v4Cidr:y.rfc3986.ipv4Cidr,v6Cidr:y.rfc3986.ipv6Cidr,ipv4:y.rfc3986.ipv4address,ipv6:y.rfc3986.ipv6address,ipvfuture:y.rfc3986.ipvFuture},y.createRegex=function(c){const e=y.rfc3986,i="(?:\\?"+(c.allowQuerySquareBrackets?e.queryWithSquareBrackets:e.query)+")?(?:#"+e.fragment+")?",n=c.domain?e.relativeRefCapture:e.relativeRef;if(c.relativeOnly)return y.wrap(n+i);let r="";if(c.scheme){a(c.scheme instanceof RegExp||typeof c.scheme=="string"||Array.isArray(c.scheme),"scheme must be a RegExp, String, or Array");const s=[].concat(c.scheme);a(s.length>=1,"scheme must have at least 1 scheme specified");const o=[];for(let u=0;u<s.length;++u){const d=s[u];a(d instanceof RegExp||typeof d=="string","scheme at position "+u+" must be a RegExp or String"),d instanceof RegExp?o.push(d.source.toString()):(a(e.schemeRegex.test(d),"scheme at position "+u+" must be a valid scheme"),o.push(h(d)))}r=o.join("|")}const t="(?:"+(r?"(?:"+r+")":e.scheme)+":"+(c.domain?e.hierPartCapture:e.hierPart)+")",l=c.allowRelative?"(?:"+t+"|"+n+")":t;return y.wrap(l+i,r)},y.wrap=function(c,e){return{raw:c=`(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${c}`,regex:new RegExp(`^${c}$`),scheme:e}},y.uriRegex=y.createRegex({}),w.regex=function(c={}){return c.scheme||c.allowRelative||c.relativeOnly||c.allowQuerySquareBrackets||c.domain?y.createRegex(c):y.uriRegex}},1447:(x,w)=>{const m={operators:["!","^","*","/","%","+","-","<","<=",">",">=","==","!=","&&","||","??"],operatorCharacters:["!","^","*","/","%","+","-","<","=",">","&","|","?"],operatorsOrder:[["^"],["*","/","%"],["+","-"],["<","<=",">",">="],["==","!="],["&&"],["||","??"]],operatorsPrefix:["!","n"],literals:{'"':'"',"`":"`","'":"'","[":"]"},numberRx:/^(?:[0-9]*(\.[0-9]*)?){1}$/,tokenRx:/^[\w\$\#\.\@\:\{\}]+$/,symbol:Symbol("formula"),settings:Symbol("settings")};w.Parser=class{constructor(a,h={}){if(!h[m.settings]&&h.constants)for(const y in h.constants){const c=h.constants[y];if(c!==null&&!["boolean","number","string"].includes(typeof c))throw new Error(`Formula constant ${y} contains invalid ${typeof c} value type`)}this.settings=h[m.settings]?h:Object.assign({[m.settings]:!0,constants:{},functions:{}},h),this.single=null,this._parts=null,this._parse(a)}_parse(a){let h=[],y="",c=0,e=!1;const i=r=>{if(c)throw new Error("Formula missing closing parenthesis");const t=h.length?h[h.length-1]:null;if(e||y||r){if(t&&t.type==="reference"&&r===")")return t.type="function",t.value=this._subFormula(y,t.value),void(y="");if(r===")"){const l=new w.Parser(y,this.settings);h.push({type:"segment",value:l})}else if(e){if(e==="]")return h.push({type:"reference",value:y}),void(y="");h.push({type:"literal",value:y})}else if(m.operatorCharacters.includes(y))t&&t.type==="operator"&&m.operators.includes(t.value+y)?t.value+=y:h.push({type:"operator",value:y});else if(y.match(m.numberRx))h.push({type:"constant",value:parseFloat(y)});else if(this.settings.constants[y]!==void 0)h.push({type:"constant",value:this.settings.constants[y]});else{if(!y.match(m.tokenRx))throw new Error(`Formula contains invalid token: ${y}`);h.push({type:"reference",value:y})}y=""}};for(const r of a)e?r===e?(i(),e=!1):y+=r:c?r==="("?(y+=r,++c):r===")"?(--c,c?y+=r:i(r)):y+=r:r in m.literals?e=m.literals[r]:r==="("?(i(),++c):m.operatorCharacters.includes(r)?(i(),y=r,i()):r!==" "?y+=r:i();i(),h=h.map((r,t)=>r.type!=="operator"||r.value!=="-"||t&&h[t-1].type!=="operator"?r:{type:"operator",value:"n"});let n=!1;for(const r of h){if(r.type==="operator"){if(m.operatorsPrefix.includes(r.value))continue;if(!n)throw new Error("Formula contains an operator in invalid position");if(!m.operators.includes(r.value))throw new Error(`Formula contains an unknown operator ${r.value}`)}else if(n)throw new Error("Formula missing expected operator");n=!n}if(!n)throw new Error("Formula contains invalid trailing operator");h.length===1&&["reference","literal","constant"].includes(h[0].type)&&(this.single={type:h[0].type==="reference"?"reference":"value",value:h[0].value}),this._parts=h.map(r=>{if(r.type==="operator")return m.operatorsPrefix.includes(r.value)?r:r.value;if(r.type!=="reference")return r.value;if(this.settings.tokenRx&&!this.settings.tokenRx.test(r.value))throw new Error(`Formula contains invalid reference ${r.value}`);return this.settings.reference?this.settings.reference(r.value):m.reference(r.value)})}_subFormula(a,h){const y=this.settings.functions[h];if(typeof y!="function")throw new Error(`Formula contains unknown function ${h}`);let c=[];if(a){let e="",i=0,n=!1;const r=()=>{if(!e)throw new Error(`Formula contains function ${h} with invalid arguments ${a}`);c.push(e),e=""};for(let t=0;t<a.length;++t){const l=a[t];n?(e+=l,l===n&&(n=!1)):l in m.literals&&!i?(e+=l,n=m.literals[l]):l!==","||i?(e+=l,l==="("?++i:l===")"&&--i):r()}r()}return c=c.map(e=>new w.Parser(e,this.settings)),function(e){const i=[];for(const n of c)i.push(n.evaluate(e));return y.call(e,...i)}}evaluate(a){const h=this._parts.slice();for(let y=h.length-2;y>=0;--y){const c=h[y];if(c&&c.type==="operator"){const e=h[y+1];h.splice(y+1,1);const i=m.evaluate(e,a);h[y]=m.single(c.value,i)}}return m.operatorsOrder.forEach(y=>{for(let c=1;c<h.length-1;)if(y.includes(h[c])){const e=h[c],i=m.evaluate(h[c-1],a),n=m.evaluate(h[c+1],a);h.splice(c,2);const r=m.calculate(e,i,n);h[c-1]=r===0?0:r}else c+=2}),m.evaluate(h[0],a)}},w.Parser.prototype[m.symbol]=!0,m.reference=function(a){return function(h){return h&&h[a]!==void 0?h[a]:null}},m.evaluate=function(a,h){return a===null?null:typeof a=="function"?a(h):a[m.symbol]?a.evaluate(h):a},m.single=function(a,h){if(a==="!")return!h;const y=-h;return y===0?0:y},m.calculate=function(a,h,y){if(a==="??")return m.exists(h)?h:y;if(typeof h=="string"||typeof y=="string"){if(a==="+")return(h=m.exists(h)?h:"")+(m.exists(y)?y:"")}else switch(a){case"^":return Math.pow(h,y);case"*":return h*y;case"/":return h/y;case"%":return h%y;case"+":return h+y;case"-":return h-y}switch(a){case"<":return h<y;case"<=":return h<=y;case">":return h>y;case">=":return h>=y;case"==":return h===y;case"!=":return h!==y;case"&&":return h&&y;case"||":return h||y}return null},m.exists=function(a){return a!=null}},9926:()=>{},5688:()=>{},9708:()=>{},1152:()=>{},443:()=>{},9848:()=>{},5934:x=>{x.exports=JSON.parse('{"version":"17.13.3"}')}},A={},function x(w){var m=A[w];if(m!==void 0)return m.exports;var a=A[w]={exports:{}};return $[w](a,a.exports,x),a.exports}(5107);var $,A})})($e,$e.exports);var It=$e.exports;const M=wr(It),Ve=b=>typeof b!="object"||b===null||!("isLuxonDateTime"in b)?!1:b.isLuxonDateTime===!0,Ge=b=>typeof b!="object"||b===null||!("isLuxonDuration"in b)?!1:b.isLuxonDuration===!0,Be=b=>typeof b!="object"||b===null||!("isLuxonInterval"in b)?!1:b.isLuxonInterval===!0,Er=(b,p)=>{switch(p){case"DateTime":return Ve(b);case"Duration":return Ge(b);case"Interval":return Be(b)}return typeof b=="object"&&b!==null?b.constructor.name===p:!1},kt=b=>!!b&&b.constructor===Object,Lt=b=>typeof b=="string"||typeof b=="number"||typeof b=="boolean"||typeof b=="bigint"||typeof b>"u",Rr=["Error"],Nt=M.string().allow("").required(),Tt=M.number().required(),Dt=M.boolean().required(),Ct=M.any().custom((b,p)=>typeof b=="bigint"?b:p.error("any.invalid")).required(),Pt=M.any().valid(null).required(),Ft=M.any().custom((b,p)=>typeof b>"u"?b:p.error("any.invalid")),Mt=M.alternatives().try(Nt,Tt,Dt,Ct,Pt,Ft),Ut=M.any().custom((b,p)=>b instanceof Int8Array?b:p.error("any.invalid")),qt=M.any().custom((b,p)=>b instanceof Uint8Array?b:p.error("any.invalid")),zt=M.any().custom((b,p)=>b instanceof Uint8ClampedArray?b:p.error("any.invalid")),Vt=M.any().custom((b,p)=>b instanceof Int16Array?b:p.error("any.invalid")),Gt=M.any().custom((b,p)=>b instanceof Uint16Array?b:p.error("any.invalid")),Bt=M.any().custom((b,p)=>b instanceof Int32Array?b:p.error("any.invalid")),Wt=M.any().custom((b,p)=>b instanceof Uint32Array?b:p.error("any.invalid")),Ht=M.any().custom((b,p)=>b instanceof Float32Array?b:p.error("any.invalid")),Xt=M.any().custom((b,p)=>b instanceof Float64Array?b:p.error("any.invalid")),Zt=M.any().custom((b,p)=>b instanceof BigInt64Array?b:p.error("any.invalid")),Yt=M.any().custom((b,p)=>b instanceof BigUint64Array?b:p.error("any.invalid")),Kt=M.alternatives().try(Ut,qt,zt,Vt,Gt,Bt,Wt,Ht,Xt,Zt,Yt),Jt=M.any().custom((b,p)=>b instanceof Date?b:p.error("any.invalid")),Qt=M.any().custom((b,p)=>b instanceof RegExp?b:p.error("any.invalid")),er=M.any().custom((b,p)=>b instanceof ArrayBuffer?b:p.error("any.invalid")),tr=M.any().custom((b,p)=>b instanceof DataView?b:p.error("any.invalid")),rr=M.any().custom((b,p)=>{if(b instanceof Error){const $=b.constructor.name;if(Rr.includes($))return b}return p.error("any.invalid")}),sr=M.alternatives().try(Jt,Qt,er,tr,rr),nr=M.any().custom((b,p)=>Ve(b)?b:p.error("any.invalid")),ir=M.any().custom((b,p)=>Ge(b)?b:p.error("any.invalid")),ar=M.any().custom((b,p)=>Be(b)?b:p.error("any.invalid")),or=M.alternatives().try(nr,ir,ar),te=M.alternatives().try(Mt,Kt,sr,or,M.array().items(M.link("#serializable")),M.any().custom((b,p)=>{if(b instanceof Map){for(const[$,A]of b.entries())if(te.validate($).error||te.validate(A).error)return p.error("any.invalid");return b}return p.error("any.invalid")}),M.any().custom((b,p)=>{if(b instanceof Set){for(const $ of b.values())if(te.validate($).error)return p.error("any.invalid");return b}return p.error("any.invalid")}),M.any().custom((b,p)=>{if(Object.getPrototypeOf(b)!==Object.prototype)return p.error("any.invalid");const $=Object.getOwnPropertyDescriptors(b);for(const A in $){const x=$[A];if(x.get||x.set||x.enumerable===!1||te.validate(A).error||te.validate(x.value).error)return p.error("any.invalid")}return b})).id("serializable"),lr=b=>{const{error:p}=te.validate(b);return!p},we=b=>{const{error:p}=te.validate(b,{abortEarly:!1});if(p)throw new re.E_PAYLOAD_UNSERIALIZABLE(p);return b},st=[{key:"polyfill:Error",test:b=>b instanceof Error,encode:b=>Uint8Array.from(W(b)),decode:b=>{const p=H(b);return typeof p.stack!="string"&&(Object.defineProperty(p,"stack",{value:"",writable:!0,enumerable:!1,configurable:!0}),p.stack=""),p}},{key:"luxon:DateTime",test:b=>Ve(b),encode:b=>{const p=b.toISO({extendedZone:!0});return Uint8Array.from(W(p))},decode:b=>{const p=H(b);return p?J.DateTime.fromISO(p,{setZone:!0}):J.DateTime.invalid("Previously serialized value is not valid")}},{key:"luxon:Duration",test:b=>Ge(b),encode:b=>{const p=b.toISO();return Uint8Array.from(W(p))},decode:b=>{const p=H(b);return p?J.Duration.fromISO(p):J.Duration.invalid("Previously serialized value is not valid")}},{key:"luxon:Interval",test:b=>Be(b),encode:b=>{const p=b.start?b.start.toISO({extendedZone:!0}):null,$=b.end?b.end.toISO({extendedZone:!0}):null;return Uint8Array.from(W([p,$]))},decode:b=>{const[p,$]=H(b);return!p||!$?J.Interval.invalid("Previously serialized value is not valid"):J.Interval.fromDateTimes(J.DateTime.fromISO(p,{setZone:!0}),J.DateTime.fromISO($,{setZone:!0}))}}],nt=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array],it=[Date,RegExp,ArrayBuffer,DataView,Error,EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError];var Ee={exports:{}};const xr="2.0.0",cr=256,Sr=Number.MAX_SAFE_INTEGER||9007199254740991,Ar=16,Or=cr-6,jr=["major","premajor","minor","preminor","patch","prepatch","prerelease"];var Ae={MAX_LENGTH:cr,MAX_SAFE_COMPONENT_LENGTH:Ar,MAX_SAFE_BUILD_LENGTH:Or,MAX_SAFE_INTEGER:Sr,RELEASE_TYPES:jr,SEMVER_SPEC_VERSION:xr,FLAG_INCLUDE_PRERELEASE:1,FLAG_LOOSE:2};const Ir=typeof process=="object"&&process.env&&process.env.NODE_DEBUG&&/\bsemver\b/i.test(process.env.NODE_DEBUG)?(...b)=>console.error("SEMVER",...b):()=>{};var Oe=Ir;Ee.exports;(function(b,p){const{MAX_SAFE_COMPONENT_LENGTH:$,MAX_SAFE_BUILD_LENGTH:A,MAX_LENGTH:x}=Ae,w=Oe;p=b.exports={};const m=p.re=[],a=p.safeRe=[],h=p.src=[],y=p.safeSrc=[],c=p.t={};let e=0;const i="[a-zA-Z0-9-]",n=[["\\s",1],["\\d",x],[i,A]],r=l=>{for(const[s,o]of n)l=l.split(`${s}*`).join(`${s}{0,${o}}`).split(`${s}+`).join(`${s}{1,${o}}`);return l},t=(l,s,o)=>{const u=r(s),d=e++;w(l,d,s),c[l]=d,h[d]=s,y[d]=u,m[d]=new RegExp(s,o?"g":void 0),a[d]=new RegExp(u,o?"g":void 0)};t("NUMERICIDENTIFIER","0|[1-9]\\d*"),t("NUMERICIDENTIFIERLOOSE","\\d+"),t("NONNUMERICIDENTIFIER",`\\d*[a-zA-Z-]${i}*`),t("MAINVERSION",`(${h[c.NUMERICIDENTIFIER]})\\.(${h[c.NUMERICIDENTIFIER]})\\.(${h[c.NUMERICIDENTIFIER]})`),t("MAINVERSIONLOOSE",`(${h[c.NUMERICIDENTIFIERLOOSE]})\\.(${h[c.NUMERICIDENTIFIERLOOSE]})\\.(${h[c.NUMERICIDENTIFIERLOOSE]})`),t("PRERELEASEIDENTIFIER",`(?:${h[c.NUMERICIDENTIFIER]}|${h[c.NONNUMERICIDENTIFIER]})`),t("PRERELEASEIDENTIFIERLOOSE",`(?:${h[c.NUMERICIDENTIFIERLOOSE]}|${h[c.NONNUMERICIDENTIFIER]})`),t("PRERELEASE",`(?:-(${h[c.PRERELEASEIDENTIFIER]}(?:\\.${h[c.PRERELEASEIDENTIFIER]})*))`),t("PRERELEASELOOSE",`(?:-?(${h[c.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${h[c.PRERELEASEIDENTIFIERLOOSE]})*))`),t("BUILDIDENTIFIER",`${i}+`),t("BUILD",`(?:\\+(${h[c.BUILDIDENTIFIER]}(?:\\.${h[c.BUILDIDENTIFIER]})*))`),t("FULLPLAIN",`v?${h[c.MAINVERSION]}${h[c.PRERELEASE]}?${h[c.BUILD]}?`),t("FULL",`^${h[c.FULLPLAIN]}$`),t("LOOSEPLAIN",`[v=\\s]*${h[c.MAINVERSIONLOOSE]}${h[c.PRERELEASELOOSE]}?${h[c.BUILD]}?`),t("LOOSE",`^${h[c.LOOSEPLAIN]}$`),t("GTLT","((?:<|>)?=?)"),t("XRANGEIDENTIFIERLOOSE",`${h[c.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),t("XRANGEIDENTIFIER",`${h[c.NUMERICIDENTIFIER]}|x|X|\\*`),t("XRANGEPLAIN",`[v=\\s]*(${h[c.XRANGEIDENTIFIER]})(?:\\.(${h[c.XRANGEIDENTIFIER]})(?:\\.(${h[c.XRANGEIDENTIFIER]})(?:${h[c.PRERELEASE]})?${h[c.BUILD]}?)?)?`),t("XRANGEPLAINLOOSE",`[v=\\s]*(${h[c.XRANGEIDENTIFIERLOOSE]})(?:\\.(${h[c.XRANGEIDENTIFIERLOOSE]})(?:\\.(${h[c.XRANGEIDENTIFIERLOOSE]})(?:${h[c.PRERELEASELOOSE]})?${h[c.BUILD]}?)?)?`),t("XRANGE",`^${h[c.GTLT]}\\s*${h[c.XRANGEPLAIN]}$`),t("XRANGELOOSE",`^${h[c.GTLT]}\\s*${h[c.XRANGEPLAINLOOSE]}$`),t("COERCEPLAIN",`(^|[^\\d])(\\d{1,${$}})(?:\\.(\\d{1,${$}}))?(?:\\.(\\d{1,${$}}))?`),t("COERCE",`${h[c.COERCEPLAIN]}(?:$|[^\\d])`),t("COERCEFULL",h[c.COERCEPLAIN]+`(?:${h[c.PRERELEASE]})?(?:${h[c.BUILD]})?(?:$|[^\\d])`),t("COERCERTL",h[c.COERCE],!0),t("COERCERTLFULL",h[c.COERCEFULL],!0),t("LONETILDE","(?:~>?)"),t("TILDETRIM",`(\\s*)${h[c.LONETILDE]}\\s+`,!0),p.tildeTrimReplace="$1~",t("TILDE",`^${h[c.LONETILDE]}${h[c.XRANGEPLAIN]}$`),t("TILDELOOSE",`^${h[c.LONETILDE]}${h[c.XRANGEPLAINLOOSE]}$`),t("LONECARET","(?:\\^)"),t("CARETTRIM",`(\\s*)${h[c.LONECARET]}\\s+`,!0),p.caretTrimReplace="$1^",t("CARET",`^${h[c.LONECARET]}${h[c.XRANGEPLAIN]}$`),t("CARETLOOSE",`^${h[c.LONECARET]}${h[c.XRANGEPLAINLOOSE]}$`),t("COMPARATORLOOSE",`^${h[c.GTLT]}\\s*(${h[c.LOOSEPLAIN]})$|^$`),t("COMPARATOR",`^${h[c.GTLT]}\\s*(${h[c.FULLPLAIN]})$|^$`),t("COMPARATORTRIM",`(\\s*)${h[c.GTLT]}\\s*(${h[c.LOOSEPLAIN]}|${h[c.XRANGEPLAIN]})`,!0),p.comparatorTrimReplace="$1$2$3",t("HYPHENRANGE",`^\\s*(${h[c.XRANGEPLAIN]})\\s+-\\s+(${h[c.XRANGEPLAIN]})\\s*$`),t("HYPHENRANGELOOSE",`^\\s*(${h[c.XRANGEPLAINLOOSE]})\\s+-\\s+(${h[c.XRANGEPLAINLOOSE]})\\s*$`),t("STAR","(<|>)?=?\\s*\\*"),t("GTE0","^\\s*>=\\s*0\\.0\\.0\\s*$"),t("GTE0PRE","^\\s*>=\\s*0\\.0\\.0-0\\s*$")})(Ee,Ee.exports);var he=Ee.exports;const kr=Object.freeze({loose:!0}),Lr=Object.freeze({}),Nr=b=>b?typeof b!="object"?kr:b:Lr;var We=Nr;const at=/^[0-9]+$/,ur=(b,p)=>{const $=at.test(b),A=at.test(p);return $&&A&&(b=+b,p=+p),b===p?0:$&&!A?-1:A&&!$?1:b<p?-1:1},Tr=(b,p)=>ur(p,b);var fr={compareIdentifiers:ur,rcompareIdentifiers:Tr};const pe=Oe,{MAX_LENGTH:ot,MAX_SAFE_INTEGER:ge}=Ae,{safeRe:lt,safeSrc:ct,t:ye}=he,Dr=We,{compareIdentifiers:ie}=fr;let Cr=class Y{constructor(p,$){if($=Dr($),p instanceof Y){if(p.loose===!!$.loose&&p.includePrerelease===!!$.includePrerelease)return p;p=p.version}else if(typeof p!="string")throw new TypeError(`Invalid version. Must be a string. Got type "${typeof p}".`);if(p.length>ot)throw new TypeError(`version is longer than ${ot} characters`);pe("SemVer",p,$),this.options=$,this.loose=!!$.loose,this.includePrerelease=!!$.includePrerelease;const A=p.trim().match($.loose?lt[ye.LOOSE]:lt[ye.FULL]);if(!A)throw new TypeError(`Invalid Version: ${p}`);if(this.raw=p,this.major=+A[1],this.minor=+A[2],this.patch=+A[3],this.major>ge||this.major<0)throw new TypeError("Invalid major version");if(this.minor>ge||this.minor<0)throw new TypeError("Invalid minor version");if(this.patch>ge||this.patch<0)throw new TypeError("Invalid patch version");A[4]?this.prerelease=A[4].split(".").map(x=>{if(/^[0-9]+$/.test(x)){const w=+x;if(w>=0&&w<ge)return w}return x}):this.prerelease=[],this.build=A[5]?A[5].split("."):[],this.format()}format(){return this.version=`${this.major}.${this.minor}.${this.patch}`,this.prerelease.length&&(this.version+=`-${this.prerelease.join(".")}`),this.version}toString(){return this.version}compare(p){if(pe("SemVer.compare",this.version,this.options,p),!(p instanceof Y)){if(typeof p=="string"&&p===this.version)return 0;p=new Y(p,this.options)}return p.version===this.version?0:this.compareMain(p)||this.comparePre(p)}compareMain(p){return p instanceof Y||(p=new Y(p,this.options)),ie(this.major,p.major)||ie(this.minor,p.minor)||ie(this.patch,p.patch)}comparePre(p){if(p instanceof Y||(p=new Y(p,this.options)),this.prerelease.length&&!p.prerelease.length)return-1;if(!this.prerelease.length&&p.prerelease.length)return 1;if(!this.prerelease.length&&!p.prerelease.length)return 0;let $=0;do{const A=this.prerelease[$],x=p.prerelease[$];if(pe("prerelease compare",$,A,x),A===void 0&&x===void 0)return 0;if(x===void 0)return 1;if(A===void 0)return-1;if(A===x)continue;return ie(A,x)}while(++$)}compareBuild(p){p instanceof Y||(p=new Y(p,this.options));let $=0;do{const A=this.build[$],x=p.build[$];if(pe("build compare",$,A,x),A===void 0&&x===void 0)return 0;if(x===void 0)return 1;if(A===void 0)return-1;if(A===x)continue;return ie(A,x)}while(++$)}inc(p,$,A){if(p.startsWith("pre")){if(!$&&A===!1)throw new Error("invalid increment argument: identifier is empty");if($){const x=new RegExp(`^${this.options.loose?ct[ye.PRERELEASELOOSE]:ct[ye.PRERELEASE]}$`),w=`-${$}`.match(x);if(!w||w[1]!==$)throw new Error(`invalid identifier: ${$}`)}}switch(p){case"premajor":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc("pre",$,A);break;case"preminor":this.prerelease.length=0,this.patch=0,this.minor++,this.inc("pre",$,A);break;case"prepatch":this.prerelease.length=0,this.inc("patch",$,A),this.inc("pre",$,A);break;case"prerelease":this.prerelease.length===0&&this.inc("patch",$,A),this.inc("pre",$,A);break;case"release":if(this.prerelease.length===0)throw new Error(`version ${this.raw} is not a prerelease`);this.prerelease.length=0;break;case"major":(this.minor!==0||this.patch!==0||this.prerelease.length===0)&&this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case"minor":(this.patch!==0||this.prerelease.length===0)&&this.minor++,this.patch=0,this.prerelease=[];break;case"patch":this.prerelease.length===0&&this.patch++,this.prerelease=[];break;case"pre":{const x=Number(A)?1:0;if(this.prerelease.length===0)this.prerelease=[x];else{let w=this.prerelease.length;for(;--w>=0;)typeof this.prerelease[w]=="number"&&(this.prerelease[w]++,w=-2);if(w===-1){if($===this.prerelease.join(".")&&A===!1)throw new Error("invalid increment argument: identifier already exists");this.prerelease.push(x)}}if($){let w=[$,x];A===!1&&(w=[$]),ie(this.prerelease[0],$)===0?isNaN(this.prerelease[1])&&(this.prerelease=w):this.prerelease=w}break}default:throw new Error(`invalid increment argument: ${p}`)}return this.raw=this.format(),this.build.length&&(this.raw+=`+${this.build.join(".")}`),this}};var B=Cr;const ut=B,Pr=(b,p,$=!1)=>{if(b instanceof ut)return b;try{return new ut(b,p)}catch(A){if(!$)return null;throw A}};var oe=Pr;const Fr=oe,Mr=(b,p)=>{const $=Fr(b,p);return $?$.version:null};var Ur=Mr;const qr=oe,zr=(b,p)=>{const $=qr(b.trim().replace(/^[=v]+/,""),p);return $?$.version:null};var Vr=zr;const ft=B,Gr=(b,p,$,A,x)=>{typeof $=="string"&&(x=A,A=$,$=void 0);try{return new ft(b instanceof ft?b.version:b,$).inc(p,A,x).version}catch{return null}};var Br=Gr;const ht=oe,Wr=(b,p)=>{const $=ht(b,null,!0),A=ht(p,null,!0),x=$.compare(A);if(x===0)return null;const w=x>0,m=w?$:A,a=w?A:$,h=!!m.prerelease.length;if(!!a.prerelease.length&&!h){if(!a.patch&&!a.minor)return"major";if(a.compareMain(m)===0)return a.minor&&!a.patch?"minor":"patch"}const c=h?"pre":"";return $.major!==A.major?c+"major":$.minor!==A.minor?c+"minor":$.patch!==A.patch?c+"patch":"prerelease"};var Hr=Wr;const Xr=B,Zr=(b,p)=>new Xr(b,p).major;var Yr=Zr;const Kr=B,Jr=(b,p)=>new Kr(b,p).minor;var Qr=Jr;const es=B,ts=(b,p)=>new es(b,p).patch;var rs=ts;const ss=oe,ns=(b,p)=>{const $=ss(b,p);return $&&$.prerelease.length?$.prerelease:null};var is=ns;const mt=B,as=(b,p,$)=>new mt(b,$).compare(new mt(p,$));var X=as;const os=X,ls=(b,p,$)=>os(p,b,$);var cs=ls;const us=X,fs=(b,p)=>us(b,p,!0);var hs=fs;const dt=B,ms=(b,p,$)=>{const A=new dt(b,$),x=new dt(p,$);return A.compare(x)||A.compareBuild(x)};var He=ms;const ds=He,ps=(b,p)=>b.sort(($,A)=>ds($,A,p));var gs=ps;const ys=He,bs=(b,p)=>b.sort(($,A)=>ys(A,$,p));var vs=bs;const _s=X,$s=(b,p,$)=>_s(b,p,$)>0;var je=$s;const ws=X,Es=(b,p,$)=>ws(b,p,$)<0;var Xe=Es;const Rs=X,xs=(b,p,$)=>Rs(b,p,$)===0;var hr=xs;const Ss=X,As=(b,p,$)=>Ss(b,p,$)!==0;var mr=As;const Os=X,js=(b,p,$)=>Os(b,p,$)>=0;var Ze=js;const Is=X,ks=(b,p,$)=>Is(b,p,$)<=0;var Ye=ks;const Ls=hr,Ns=mr,Ts=je,Ds=Ze,Cs=Xe,Ps=Ye,Fs=(b,p,$,A)=>{switch(p){case"===":return typeof b=="object"&&(b=b.version),typeof $=="object"&&($=$.version),b===$;case"!==":return typeof b=="object"&&(b=b.version),typeof $=="object"&&($=$.version),b!==$;case"":case"=":case"==":return Ls(b,$,A);case"!=":return Ns(b,$,A);case">":return Ts(b,$,A);case">=":return Ds(b,$,A);case"<":return Cs(b,$,A);case"<=":return Ps(b,$,A);default:throw new TypeError(`Invalid operator: ${p}`)}};var dr=Fs;const Ms=B,Us=oe,{safeRe:be,t:ve}=he,qs=(b,p)=>{if(b instanceof Ms)return b;if(typeof b=="number"&&(b=String(b)),typeof b!="string")return null;p=p||{};let $=null;if(!p.rtl)$=b.match(p.includePrerelease?be[ve.COERCEFULL]:be[ve.COERCE]);else{const h=p.includePrerelease?be[ve.COERCERTLFULL]:be[ve.COERCERTL];let y;for(;(y=h.exec(b))&&(!$||$.index+$[0].length!==b.length);)(!$||y.index+y[0].length!==$.index+$[0].length)&&($=y),h.lastIndex=y.index+y[1].length+y[2].length;h.lastIndex=-1}if($===null)return null;const A=$[2],x=$[3]||"0",w=$[4]||"0",m=p.includePrerelease&&$[5]?`-${$[5]}`:"",a=p.includePrerelease&&$[6]?`+${$[6]}`:"";return Us(`${A}.${x}.${w}${m}${a}`,p)};var zs=qs;class Vs{constructor(){this.max=1e3,this.map=new Map}get(p){const $=this.map.get(p);if($!==void 0)return this.map.delete(p),this.map.set(p,$),$}delete(p){return this.map.delete(p)}set(p,$){if(!this.delete(p)&&$!==void 0){if(this.map.size>=this.max){const x=this.map.keys().next().value;this.delete(x)}this.map.set(p,$)}return this}}var Gs=Vs,Te,pt;function Z(){if(pt)return Te;pt=1;const b=/\s+/g;class p{constructor(O,L){if(L=x(L),O instanceof p)return O.loose===!!L.loose&&O.includePrerelease===!!L.includePrerelease?O:new p(O.raw,L);if(O instanceof w)return this.raw=O.value,this.set=[[O]],this.formatted=void 0,this;if(this.options=L,this.loose=!!L.loose,this.includePrerelease=!!L.includePrerelease,this.raw=O.trim().replace(b," "),this.set=this.raw.split("||").map(N=>this.parseRange(N.trim())).filter(N=>N.length),!this.set.length)throw new TypeError(`Invalid SemVer Range: ${this.raw}`);if(this.set.length>1){const N=this.set[0];if(this.set=this.set.filter(D=>!t(D[0])),this.set.length===0)this.set=[N];else if(this.set.length>1){for(const D of this.set)if(D.length===1&&l(D[0])){this.set=[D];break}}}this.formatted=void 0}get range(){if(this.formatted===void 0){this.formatted="";for(let O=0;O<this.set.length;O++){O>0&&(this.formatted+="||");const L=this.set[O];for(let N=0;N<L.length;N++)N>0&&(this.formatted+=" "),this.formatted+=L[N].toString().trim()}}return this.formatted}format(){return this.range}toString(){return this.range}parseRange(O){const N=((this.options.includePrerelease&&n)|(this.options.loose&&r))+":"+O,D=A.get(N);if(D)return D;const C=this.options.loose,T=C?h[y.HYPHENRANGELOOSE]:h[y.HYPHENRANGE];O=O.replace(T,I(this.options.includePrerelease)),m("hyphen replace",O),O=O.replace(h[y.COMPARATORTRIM],c),m("comparator trim",O),O=O.replace(h[y.TILDETRIM],e),m("tilde trim",O),O=O.replace(h[y.CARETTRIM],i),m("caret trim",O);let P=O.split(" ").map(q=>o(q,this.options)).join(" ").split(/\s+/).map(q=>S(q,this.options));C&&(P=P.filter(q=>(m("loose invalid filter",q,this.options),!!q.match(h[y.COMPARATORLOOSE])))),m("range list",P);const F=new Map,U=P.map(q=>new w(q,this.options));for(const q of U){if(t(q))return[q];F.set(q.value,q)}F.size>1&&F.has("")&&F.delete("");const z=[...F.values()];return A.set(N,z),z}intersects(O,L){if(!(O instanceof p))throw new TypeError("a Range is required");return this.set.some(N=>s(N,L)&&O.set.some(D=>s(D,L)&&N.every(C=>D.every(T=>C.intersects(T,L)))))}test(O){if(!O)return!1;if(typeof O=="string")try{O=new a(O,this.options)}catch{return!1}for(let L=0;L<this.set.length;L++)if(k(this.set[L],O,this.options))return!0;return!1}}Te=p;const $=Gs,A=new $,x=We,w=Ie(),m=Oe,a=B,{safeRe:h,t:y,comparatorTrimReplace:c,tildeTrimReplace:e,caretTrimReplace:i}=he,{FLAG_INCLUDE_PRERELEASE:n,FLAG_LOOSE:r}=Ae,t=j=>j.value==="<0.0.0-0",l=j=>j.value==="",s=(j,O)=>{let L=!0;const N=j.slice();let D=N.pop();for(;L&&N.length;)L=N.every(C=>D.intersects(C,O)),D=N.pop();return L},o=(j,O)=>(m("comp",j,O),j=R(j,O),m("caret",j),j=d(j,O),m("tildes",j),j=f(j,O),m("xrange",j),j=_(j,O),m("stars",j),j),u=j=>!j||j.toLowerCase()==="x"||j==="*",d=(j,O)=>j.trim().split(/\s+/).map(L=>v(L,O)).join(" "),v=(j,O)=>{const L=O.loose?h[y.TILDELOOSE]:h[y.TILDE];return j.replace(L,(N,D,C,T,P)=>{m("tilde",j,N,D,C,T,P);let F;return u(D)?F="":u(C)?F=`>=${D}.0.0 <${+D+1}.0.0-0`:u(T)?F=`>=${D}.${C}.0 <${D}.${+C+1}.0-0`:P?(m("replaceTilde pr",P),F=`>=${D}.${C}.${T}-${P} <${D}.${+C+1}.0-0`):F=`>=${D}.${C}.${T} <${D}.${+C+1}.0-0`,m("tilde return",F),F})},R=(j,O)=>j.trim().split(/\s+/).map(L=>E(L,O)).join(" "),E=(j,O)=>{m("caret",j,O);const L=O.loose?h[y.CARETLOOSE]:h[y.CARET],N=O.includePrerelease?"-0":"";return j.replace(L,(D,C,T,P,F)=>{m("caret",j,D,C,T,P,F);let U;return u(C)?U="":u(T)?U=`>=${C}.0.0${N} <${+C+1}.0.0-0`:u(P)?C==="0"?U=`>=${C}.${T}.0${N} <${C}.${+T+1}.0-0`:U=`>=${C}.${T}.0${N} <${+C+1}.0.0-0`:F?(m("replaceCaret pr",F),C==="0"?T==="0"?U=`>=${C}.${T}.${P}-${F} <${C}.${T}.${+P+1}-0`:U=`>=${C}.${T}.${P}-${F} <${C}.${+T+1}.0-0`:U=`>=${C}.${T}.${P}-${F} <${+C+1}.0.0-0`):(m("no pr"),C==="0"?T==="0"?U=`>=${C}.${T}.${P}${N} <${C}.${T}.${+P+1}-0`:U=`>=${C}.${T}.${P}${N} <${C}.${+T+1}.0-0`:U=`>=${C}.${T}.${P} <${+C+1}.0.0-0`),m("caret return",U),U})},f=(j,O)=>(m("replaceXRanges",j,O),j.split(/\s+/).map(L=>g(L,O)).join(" ")),g=(j,O)=>{j=j.trim();const L=O.loose?h[y.XRANGELOOSE]:h[y.XRANGE];return j.replace(L,(N,D,C,T,P,F)=>{m("xRange",j,N,D,C,T,P,F);const U=u(C),z=U||u(T),q=z||u(P),K=q;return D==="="&&K&&(D=""),F=O.includePrerelease?"-0":"",U?D===">"||D==="<"?N="<0.0.0-0":N="*":D&&K?(z&&(T=0),P=0,D===">"?(D=">=",z?(C=+C+1,T=0,P=0):(T=+T+1,P=0)):D==="<="&&(D="<",z?C=+C+1:T=+T+1),D==="<"&&(F="-0"),N=`${D+C}.${T}.${P}${F}`):z?N=`>=${C}.0.0${F} <${+C+1}.0.0-0`:q&&(N=`>=${C}.${T}.0${F} <${C}.${+T+1}.0-0`),m("xRange return",N),N})},_=(j,O)=>(m("replaceStars",j,O),j.trim().replace(h[y.STAR],"")),S=(j,O)=>(m("replaceGTE0",j,O),j.trim().replace(h[O.includePrerelease?y.GTE0PRE:y.GTE0],"")),I=j=>(O,L,N,D,C,T,P,F,U,z,q,K)=>(u(N)?L="":u(D)?L=`>=${N}.0.0${j?"-0":""}`:u(C)?L=`>=${N}.${D}.0${j?"-0":""}`:T?L=`>=${L}`:L=`>=${L}${j?"-0":""}`,u(U)?F="":u(z)?F=`<${+U+1}.0.0-0`:u(q)?F=`<${U}.${+z+1}.0-0`:K?F=`<=${U}.${z}.${q}-${K}`:j?F=`<${U}.${z}.${+q+1}-0`:F=`<=${F}`,`${L} ${F}`.trim()),k=(j,O,L)=>{for(let N=0;N<j.length;N++)if(!j[N].test(O))return!1;if(O.prerelease.length&&!L.includePrerelease){for(let N=0;N<j.length;N++)if(m(j[N].semver),j[N].semver!==w.ANY&&j[N].semver.prerelease.length>0){const D=j[N].semver;if(D.major===O.major&&D.minor===O.minor&&D.patch===O.patch)return!0}return!1}return!0};return Te}var De,gt;function Ie(){if(gt)return De;gt=1;const b=Symbol("SemVer ANY");class p{static get ANY(){return b}constructor(c,e){if(e=$(e),c instanceof p){if(c.loose===!!e.loose)return c;c=c.value}c=c.trim().split(/\s+/).join(" "),m("comparator",c,e),this.options=e,this.loose=!!e.loose,this.parse(c),this.semver===b?this.value="":this.value=this.operator+this.semver.version,m("comp",this)}parse(c){const e=this.options.loose?A[x.COMPARATORLOOSE]:A[x.COMPARATOR],i=c.match(e);if(!i)throw new TypeError(`Invalid comparator: ${c}`);this.operator=i[1]!==void 0?i[1]:"",this.operator==="="&&(this.operator=""),i[2]?this.semver=new a(i[2],this.options.loose):this.semver=b}toString(){return this.value}test(c){if(m("Comparator.test",c,this.options.loose),this.semver===b||c===b)return!0;if(typeof c=="string")try{c=new a(c,this.options)}catch{return!1}return w(c,this.operator,this.semver,this.options)}intersects(c,e){if(!(c instanceof p))throw new TypeError("a Comparator is required");return this.operator===""?this.value===""?!0:new h(c.value,e).test(this.value):c.operator===""?c.value===""?!0:new h(this.value,e).test(c.semver):(e=$(e),e.includePrerelease&&(this.value==="<0.0.0-0"||c.value==="<0.0.0-0")||!e.includePrerelease&&(this.value.startsWith("<0.0.0")||c.value.startsWith("<0.0.0"))?!1:!!(this.operator.startsWith(">")&&c.operator.startsWith(">")||this.operator.startsWith("<")&&c.operator.startsWith("<")||this.semver.version===c.semver.version&&this.operator.includes("=")&&c.operator.includes("=")||w(this.semver,"<",c.semver,e)&&this.operator.startsWith(">")&&c.operator.startsWith("<")||w(this.semver,">",c.semver,e)&&this.operator.startsWith("<")&&c.operator.startsWith(">")))}}De=p;const $=We,{safeRe:A,t:x}=he,w=dr,m=Oe,a=B,h=Z();return De}const Bs=Z(),Ws=(b,p,$)=>{try{p=new Bs(p,$)}catch{return!1}return p.test(b)};var ke=Ws;const Hs=Z(),Xs=(b,p)=>new Hs(b,p).set.map($=>$.map(A=>A.value).join(" ").trim().split(" "));var Zs=Xs;const Ys=B,Ks=Z(),Js=(b,p,$)=>{let A=null,x=null,w=null;try{w=new Ks(p,$)}catch{return null}return b.forEach(m=>{w.test(m)&&(!A||x.compare(m)===-1)&&(A=m,x=new Ys(A,$))}),A};var Qs=Js;const en=B,tn=Z(),rn=(b,p,$)=>{let A=null,x=null,w=null;try{w=new tn(p,$)}catch{return null}return b.forEach(m=>{w.test(m)&&(!A||x.compare(m)===1)&&(A=m,x=new en(A,$))}),A};var sn=rn;const Ce=B,nn=Z(),yt=je,an=(b,p)=>{b=new nn(b,p);let $=new Ce("0.0.0");if(b.test($)||($=new Ce("0.0.0-0"),b.test($)))return $;$=null;for(let A=0;A<b.set.length;++A){const x=b.set[A];let w=null;x.forEach(m=>{const a=new Ce(m.semver.version);switch(m.operator){case">":a.prerelease.length===0?a.patch++:a.prerelease.push(0),a.raw=a.format();case"":case">=":(!w||yt(a,w))&&(w=a);break;case"<":case"<=":break;default:throw new Error(`Unexpected operation: ${m.operator}`)}}),w&&(!$||yt($,w))&&($=w)}return $&&b.test($)?$:null};var on=an;const ln=Z(),cn=(b,p)=>{try{return new ln(b,p).range||"*"}catch{return null}};var un=cn;const fn=B,pr=Ie(),{ANY:hn}=pr,mn=Z(),dn=ke,bt=je,vt=Xe,pn=Ye,gn=Ze,yn=(b,p,$,A)=>{b=new fn(b,A),p=new mn(p,A);let x,w,m,a,h;switch($){case">":x=bt,w=pn,m=vt,a=">",h=">=";break;case"<":x=vt,w=gn,m=bt,a="<",h="<=";break;default:throw new TypeError('Must provide a hilo val of "<" or ">"')}if(dn(b,p,A))return!1;for(let y=0;y<p.set.length;++y){const c=p.set[y];let e=null,i=null;if(c.forEach(n=>{n.semver===hn&&(n=new pr(">=0.0.0")),e=e||n,i=i||n,x(n.semver,e.semver,A)?e=n:m(n.semver,i.semver,A)&&(i=n)}),e.operator===a||e.operator===h||(!i.operator||i.operator===a)&&w(b,i.semver))return!1;if(i.operator===h&&m(b,i.semver))return!1}return!0};var Ke=yn;const bn=Ke,vn=(b,p,$)=>bn(b,p,">",$);var _n=vn;const $n=Ke,wn=(b,p,$)=>$n(b,p,"<",$);var En=wn;const _t=Z(),Rn=(b,p,$)=>(b=new _t(b,$),p=new _t(p,$),b.intersects(p,$));var xn=Rn;const Sn=ke,An=X;var On=(b,p,$)=>{const A=[];let x=null,w=null;const m=b.sort((c,e)=>An(c,e,$));for(const c of m)Sn(c,p,$)?(w=c,x||(x=c)):(w&&A.push([x,w]),w=null,x=null);x&&A.push([x,null]);const a=[];for(const[c,e]of A)c===e?a.push(c):!e&&c===m[0]?a.push("*"):e?c===m[0]?a.push(`<=${e}`):a.push(`${c} - ${e}`):a.push(`>=${c}`);const h=a.join(" || "),y=typeof p.raw=="string"?p.raw:String(p);return h.length<y.length?h:p};const $t=Z(),Je=Ie(),{ANY:Pe}=Je,ue=ke,Qe=X,jn=(b,p,$={})=>{if(b===p)return!0;b=new $t(b,$),p=new $t(p,$);let A=!1;e:for(const x of b.set){for(const w of p.set){const m=kn(x,w,$);if(A=A||m!==null,m)continue e}if(A)return!1}return!0},In=[new Je(">=0.0.0-0")],wt=[new Je(">=0.0.0")],kn=(b,p,$)=>{if(b===p)return!0;if(b.length===1&&b[0].semver===Pe){if(p.length===1&&p[0].semver===Pe)return!0;$.includePrerelease?b=In:b=wt}if(p.length===1&&p[0].semver===Pe){if($.includePrerelease)return!0;p=wt}const A=new Set;let x,w;for(const n of b)n.operator===">"||n.operator===">="?x=Et(x,n,$):n.operator==="<"||n.operator==="<="?w=Rt(w,n,$):A.add(n.semver);if(A.size>1)return null;let m;if(x&&w){if(m=Qe(x.semver,w.semver,$),m>0)return null;if(m===0&&(x.operator!==">="||w.operator!=="<="))return null}for(const n of A){if(x&&!ue(n,String(x),$)||w&&!ue(n,String(w),$))return null;for(const r of p)if(!ue(n,String(r),$))return!1;return!0}let a,h,y,c,e=w&&!$.includePrerelease&&w.semver.prerelease.length?w.semver:!1,i=x&&!$.includePrerelease&&x.semver.prerelease.length?x.semver:!1;e&&e.prerelease.length===1&&w.operator==="<"&&e.prerelease[0]===0&&(e=!1);for(const n of p){if(c=c||n.operator===">"||n.operator===">=",y=y||n.operator==="<"||n.operator==="<=",x){if(i&&n.semver.prerelease&&n.semver.prerelease.length&&n.semver.major===i.major&&n.semver.minor===i.minor&&n.semver.patch===i.patch&&(i=!1),n.operator===">"||n.operator===">="){if(a=Et(x,n,$),a===n&&a!==x)return!1}else if(x.operator===">="&&!ue(x.semver,String(n),$))return!1}if(w){if(e&&n.semver.prerelease&&n.semver.prerelease.length&&n.semver.major===e.major&&n.semver.minor===e.minor&&n.semver.patch===e.patch&&(e=!1),n.operator==="<"||n.operator==="<="){if(h=Rt(w,n,$),h===n&&h!==w)return!1}else if(w.operator==="<="&&!ue(w.semver,String(n),$))return!1}if(!n.operator&&(w||x)&&m!==0)return!1}return!(x&&y&&!w&&m!==0||w&&c&&!x&&m!==0||i||e)},Et=(b,p,$)=>{if(!b)return p;const A=Qe(b.semver,p.semver,$);return A>0?b:A<0||p.operator===">"&&b.operator===">="?p:b},Rt=(b,p,$)=>{if(!b)return p;const A=Qe(b.semver,p.semver,$);return A<0?b:A>0||p.operator==="<"&&b.operator==="<="?p:b};var Ln=jn;const Fe=he,xt=Ae,Nn=B,St=fr,Tn=oe,Dn=Ur,Cn=Vr,Pn=Br,Fn=Hr,Mn=Yr,Un=Qr,qn=rs,zn=is,Vn=X,Gn=cs,Bn=hs,Wn=He,Hn=gs,Xn=vs,Zn=je,Yn=Xe,Kn=hr,Jn=mr,Qn=Ze,ei=Ye,ti=dr,ri=zs,si=Ie(),ni=Z(),ii=ke,ai=Zs,oi=Qs,li=sn,ci=on,ui=un,fi=Ke,hi=_n,mi=En,di=xn,pi=On,gi=Ln;var yi={parse:Tn,valid:Dn,clean:Cn,inc:Pn,diff:Fn,major:Mn,minor:Un,patch:qn,prerelease:zn,compare:Vn,rcompare:Gn,compareLoose:Bn,compareBuild:Wn,sort:Hn,rsort:Xn,gt:Zn,lt:Yn,eq:Kn,neq:Jn,gte:Qn,lte:ei,cmp:ti,coerce:ri,Comparator:si,Range:ni,satisfies:ii,toComparators:ai,maxSatisfying:oi,minSatisfying:li,minVersion:ci,validRange:ui,outside:fi,gtr:hi,ltr:mi,intersects:di,simplifyRange:pi,subset:gi,SemVer:Nn,re:Fe.re,src:Fe.src,tokens:Fe.t,SEMVER_SPEC_VERSION:xt.SEMVER_SPEC_VERSION,RELEASE_TYPES:xt.RELEASE_TYPES,compareIdentifiers:St.compareIdentifiers,rcompareIdentifiers:St.rcompareIdentifiers};let ae;var se,V,Q,ee;const xe=class xe{constructor(){Ne(this,V);Ne(this,se);tt(this,se,new Map),st.forEach(p=>{if(p.key&&p.key.startsWith("js:"))throw new re.E_RULE_CONFLICT(p.key);me(this,se).set(p.key,p)})}encode(p){p=we(p);const $=G(this,V,Q).call(this,p);return W($)}decode(p){const $=H(p),A=G(this,V,ee).call(this,$);return we(A)}static encode(p){return ae||(ae=new xe),ae.encode(p)}static decode(p){return ae||(ae=new xe),ae.decode(p)}};se=new WeakMap,V=new WeakSet,Q=function(p){const $=st.find(A=>A.test(p));if($)return{key:$.key,value:$.encode(p),version:"1.20250425.1"};if(p instanceof Map){const A=new Map;return p.forEach((x,w)=>{const m=G(this,V,Q).call(this,w),a=G(this,V,Q).call(this,x);A.set(m,a)}),{key:"js:Map",value:Uint8Array.from(W(A)),version:"1.20250425.1"}}if(p instanceof Set){const A=new Set;return p.forEach(x=>{const w=G(this,V,Q).call(this,x);A.add(w)}),{key:"js:Set",value:Uint8Array.from(W(A)),version:"1.20250425.1"}}for(const A of nt)if(p instanceof A){const x=Array.from(p).map(w=>G(this,V,Q).call(this,w));return{key:`js:${A.name}`,value:Uint8Array.from(W(x)),version:"1.20250425.1"}}for(const A of it)if(p instanceof A)return{key:`js:${A.name}`,value:Uint8Array.from(W(p)),version:"1.20250425.1"};if(Array.isArray(p)){const A=p.map(x=>G(this,V,Q).call(this,x));return{key:"js:array",value:Uint8Array.from(W(A)),version:"1.20250425.1"}}if(kt(p)){const A={};return Object.entries(p).forEach(([x,w])=>{const m=G(this,V,Q).call(this,w);A[x]=m}),{key:"js:object",value:Uint8Array.from(W(A)),version:"1.20250425.1"}}if(p===null)return{key:"js:null",value:Uint8Array.from(W(p)),version:"1.20250425.1"};if(Lt(p))return{key:"js:primitive",value:Uint8Array.from(W(p)),version:"1.20250425.1"};throw new re.E_VALUE_UNSERIALIZABLE(p)},ee=function(p){const{key:$,value:A,version:x}=p;if(x!=="1.20250425.1"){if(yi.gt(x,"1.20250425.1"))throw new re.E_VALUE_FROM_FUTURE_VERSION(x);try{process.emitWarning(re.W_VALUE_FROM_PAST_VERSION(x))}catch{}}if($&&me(this,se).has($)){const w=me(this,se).get($);if(w)return w.decode(A)}if($==="js:Map"){const w=H(A),m=new Map;return w.forEach((a,h)=>{m.set(G(this,V,ee).call(this,h),G(this,V,ee).call(this,a))}),m}if($==="js:Set"){const w=H(A),m=new Set;return w.forEach(a=>{m.add(G(this,V,ee).call(this,a))}),m}for(const w of nt)if($===`js:${w.name}`){const m=H(A);return new w(m.map(a=>G(this,V,ee).call(this,a)))}for(const w of it)if($===`js:${w.name}`)return H(A);if($==="js:array")return H(A).map(m=>G(this,V,ee).call(this,m));if($==="js:object"){const w=H(A),m={};return Object.entries(w).forEach(([a,h])=>{m[a]=G(this,V,ee).call(this,h)}),m}if($==="js:null")return null;if($==="js:primitive")return H(A);throw new re.E_VALUE_UNDESERIALIZABLE(p)};let Re=xe;const bi=b=>Re.encode(b),vi=b=>Re.decode(b),_i="1.20250425.1",$i={stringSchema:Nt,numberSchema:Tt,booleanSchema:Dt,bigintSchema:Ct,nullSchema:Pt,undefinedSchema:Ft,primitiveSchema:Mt,int8ArraySchema:Ut,uint8ArraySchema:qt,uint8ClampedArraySchema:zt,int16ArraySchema:Vt,uint16ArraySchema:Gt,int32ArraySchema:Bt,uint32ArraySchema:Wt,float32ArraySchema:Ht,float64ArraySchema:Xt,bigInt64ArraySchema:Zt,bigUint64ArraySchema:Yt,typedArraySchema:Kt,dateSchema:Jt,regExpSchema:Qt,arrayBufferSchema:er,dataViewSchema:tr,errorSchema:rr,uniterableObjectSchema:sr,luxonDateTimeSchema:nr,luxonDurationSchema:ir,luxonIntervalSchema:ar,luxonSchema:or,serializableSchema:te,canSerialize:lr,confirm:we},wi=It.ValidationError;exports.ValidationError=wi;exports.canSerialize=lr;exports.confirm=we;exports.deserialize=vi;exports.isInstanceOf=Er;exports.isPlainObject=kt;exports.isPrimitive=Lt;exports.schema=$i;exports.serialize=bi;exports.version=_i;
//# sourceMappingURL=index.cjs.map
