import type { Encodeable } from '../types';
/**
 * Message verifier is similar to the encryption. However, the actual payload
 * is not encrypted and just base64 encoded. This is helpful when you are
 * not concerned about the confidentiality of the data, but just want to
 * make sure that is not tampered after encoding.
 */
export declare class MessageVerifier {
    #private;
    constructor(secret: string);
    /**
     * Sign a given piece of value using the app secret. A wide range of
     * data types are supported. See [@nhtio/serialization](https://serialization.nht.io/quickstart.html#supported-data-types) for more information
     * on the supported data types.
     *
     * You can optionally define a purpose for which the value was signed and
     * mentioning a different purpose/no purpose during unsign will fail.
     */
    sign(payload: Encodeable, expiresIn?: string | number, purpose?: string): string;
    /**
     * Unsign a previously signed value with an optional purpose
     */
    unsign<T extends Encodeable>(payload: string, purpose?: string): T | null;
    /**
     * Checks if the value can be encoded
     */
    encodable(value: unknown): boolean;
    /**
     * Checks if the value can be encoded
     */
    static encodable(value: unknown): boolean;
}
