{"version":3,"file":"sort_imports_by_type_and_size.cjs","sources":["../../src/rules/sort_imports_by_type_and_size.ts"],"sourcesContent":["/**\n * @module @nhtio/eslint-config/rules/sort_imports_by_type_and_size\n */\n\nimport { createRule } from './common'\n\nimport type { TSESTree } from '@typescript-eslint/utils'\n\nconst sortImportsByTypeAndSizeRule = createRule({\n  name: 'sortImportsByTypeAndSize',\n  meta: {\n    type: 'layout',\n    docs: {\n      description:\n        'Group imports: nonâ€‘type imports first, then type-only; each group sorted by declaration length.',\n    },\n    fixable: 'code',\n    schema: [],\n    messages: {\n      wrongOrder:\n        'Imports should be grouped: non-type first, then type-only; each group sorted by length.',\n    },\n  },\n  create(context) {\n    const sourceCode = context.sourceCode\n    let importDecls: TSESTree.ImportDeclaration[] = []\n\n    return {\n      'Program'(node: TSESTree.Program) {\n        importDecls = node.body.filter(\n          (n): n is TSESTree.ImportDeclaration => n.type === 'ImportDeclaration'\n        )\n      },\n      'Program:exit'() {\n        if (importDecls.length < 2) return\n\n        const meta = importDecls.map((decl) => {\n          const text = sourceCode.getText(decl)\n          return {\n            decl,\n            text,\n            isTypeOnly: decl.importKind === 'type',\n            len: text.length,\n          }\n        })\n\n        const sorted = [\n          ...meta.filter((m) => !m.isTypeOnly).sort((a, b) => a.len - b.len),\n          ...meta.filter((m) => m.isTypeOnly).sort((a, b) => a.len - b.len),\n        ]\n\n        for (const [i, element] of meta.entries()) {\n          if (element.decl !== sorted[i].decl) {\n            context.report({\n              node: element.decl,\n              messageId: 'wrongOrder',\n              fix(fixer) {\n                const allText = sorted.map((m) => m.text).join('\\n')\n                const first = importDecls[0]\n                const last = importDecls[importDecls.length - 1]\n                return fixer.replaceTextRange([first.range![0], last.range![1]], allText)\n              },\n            })\n            break\n          }\n        }\n      },\n    }\n  },\n  defaultOptions: [],\n})\nexport default sortImportsByTypeAndSizeRule\n"],"names":["sortImportsByTypeAndSizeRule","createRule","context","sourceCode","importDecls","node","meta","decl","text","sorted","m","a","b","i","element","fixer","allText","first","last"],"mappings":"qJAQMA,EAA+BC,EAAAA,WAAW,CAC9C,KAAM,2BACN,KAAM,CACJ,KAAM,SACN,KAAM,CACJ,YACE,iGACJ,EACA,QAAS,OACT,OAAQ,CAAC,EACT,SAAU,CACR,WACE,yFACJ,CACF,EACA,OAAOC,EAAS,CACd,MAAMC,EAAaD,EAAQ,WAC3B,IAAIE,EAA4C,CAAA,EAEzC,MAAA,CACL,QAAUC,EAAwB,CAChCD,EAAcC,EAAK,KAAK,OACrB,GAAuC,EAAE,OAAS,mBAAA,CAEvD,EACA,gBAAiB,CACX,GAAAD,EAAY,OAAS,EAAG,OAE5B,MAAME,EAAOF,EAAY,IAAKG,GAAS,CAC/B,MAAAC,EAAOL,EAAW,QAAQI,CAAI,EAC7B,MAAA,CACL,KAAAA,EACA,KAAAC,EACA,WAAYD,EAAK,aAAe,OAChC,IAAKC,EAAK,MAAA,CACZ,CACD,EAEKC,EAAS,CACb,GAAGH,EAAK,OAAQI,GAAM,CAACA,EAAE,UAAU,EAAE,KAAK,CAACC,EAAGC,IAAMD,EAAE,IAAMC,EAAE,GAAG,EACjE,GAAGN,EAAK,OAAQI,GAAMA,EAAE,UAAU,EAAE,KAAK,CAACC,EAAGC,IAAMD,EAAE,IAAMC,EAAE,GAAG,CAAA,EAGlE,SAAW,CAACC,EAAGC,CAAO,IAAKR,EAAK,UAC9B,GAAIQ,EAAQ,OAASL,EAAOI,CAAC,EAAE,KAAM,CACnCX,EAAQ,OAAO,CACb,KAAMY,EAAQ,KACd,UAAW,aACX,IAAIC,EAAO,CACH,MAAAC,EAAUP,EAAO,IAAKC,GAAMA,EAAE,IAAI,EAAE,KAAK;AAAA,CAAI,EAC7CO,EAAQb,EAAY,CAAC,EACrBc,EAAOd,EAAYA,EAAY,OAAS,CAAC,EAC/C,OAAOW,EAAM,iBAAiB,CAACE,EAAM,MAAO,CAAC,EAAGC,EAAK,MAAO,CAAC,CAAC,EAAGF,CAAO,CAC1E,CAAA,CACD,EACD,KACF,CAEJ,CAAA,CAEJ,EACA,eAAgB,CAAC,CACnB,CAAC"}